자료구조의 이해 1. 자료구조의 개념을 이해하고 설명할 수 있다. 수업목표   1주차  2. 자료구조에서 사용하는 개념들을 설명할 수 있다. 1교시 
① 자료구조의 개념 세부내용 
② sw코딩
③ 자료구조의 분류 1. 자료구조의 개념 ▶ 자료구조의 이해

1) 자료구조 ­ 자료구조는 계산에 쓰이는 여러 가지 자료들을 조직화, 구조화(organize)한 것이다.
2) 일상생활과 자료구조와의 비교 : 일상생활과 자료구조의 유사성 일상생활에서의 예 자료 구조 물건을 쌓아두는 것 스택 영화관 매표소의 줄 큐 할 일 리스트 리스트 영어사전 사전, 탐색구조 지도 그래프 조직도 트리 학습자님의   2. sw코딩 ▶ sw코딩은 무엇인가?
1) 대부분의 sw코딩은 자료(data)를 처리하며, 이 자료들은 자료구조(data structure)를 사용 하여 표현되고 저장된다.
2) sw코딩을 하는데 자료구조가 필요한 이유는? ­ 효율적으로 문제를 처리하기 위해서는 문제를 정의하고 분석하여 최적의 설계를 작성해야 함. ­ 자료구조의 개념과 활용능력이 필요함.  
3) sw코딩은 자료구조와 알고리즘으로 이루어짐.
4) 자료구조에서 취급하는 분야는 이론적인 측면, 효율적인 측면, 실제적인 측면에서 응용을 다룸. ­ 그래프이론,  집합이론,  조합적  분석의  이산수학과  확률이론을  기초로  이론적인 측면 알고리즘을 분석하여 검색, 정렬방법을 결정함. 효율적인 측면 ­ 공간복잡도, 시간복잡도 기초로 효율분석을 하여 최적의 상태를 결정함. ­ 자료를  문자열,  리스트, 트리,  그래프,  파일  구조로 표현하고 알고리즘 실제적인 측면 을 구현하고, sw코딩과 파일작성, 메모리관리, 운영체제 등에 적용함. 학습자님의   3. 자료구조의 분류 ▶ 자료형태에 따른 분류
1) 단순구조 ­ 자료값을  사용하기  위한  기본  형태로  코딩언어에서  제공하는  정수,  실수,  문자,  문자열  등 의 데이터타입
2) 비선형구조 ­ 계층구조나 망 구조를 갖는 트리, 그래프 등의 자료구조
3) 파일구조  ­ 레코드 집합인 파일에 대한 자료구조로 보조기억장치에 데이터가 실제로 저장되는 형태 ­ 순차파일, 색인파일, 직접파일 등이 있음.
4) 선형구조  ­ 자료들의 관계가 1:1 관계인 순차리스트, 연결리스트, 스택, 큐, 데크 등 ­ 자료의 논리적인 순서와 기억장소에 저장되는 물리적인 순서가 일치하 순차리스트 는 구조 ­ 기억장소에 저장되는 물리적인 순서와 관계없이 포인터를 이용하여 논리 연결리스트 적인 순서대로 연결하는 구조 스택, 큐, 데크 ­ 자료의 삽입이나 삭제 위치에 대한 제한조건이 있는 리스트 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.11~14 v C로 배우는 쉬운 자료구조, 이지영, 한빛아카데미, pp.23~26 학습자님의   자료의 표현 1 1. 컴퓨터 SW코딩 2진수 코드체계를 설명할 수 있다.  1주차  수업목표   2. 자료의 형태에 따른 자료표현 방법을 설명할 수 있다. 2교시 
① 컴퓨터의 자료표현  세부내용 
② 수치/진수 자료 표현 1. 컴퓨터의 자료표현  ▶ 컴퓨터에서의 자료표현

1) 컴퓨터에서의 자료표현 ­ 2진수 코드 : (1,0) (True/ex)alse), (on/off) ­ 최소단위 : 비트(bit) ­ 4비트그룹 : 니블(Nibble)  ­ 8비트그룹 : 바이트(Byte)
2) n비트로     2n개의 상태를 표시 ▶ 컴퓨터 내부에서 표현할 수 있는 자료의 종류 ­ 수치자료, 문자자료, 논리자료, 포인터자료, 문자열자료 ­ 1과 0의 조합인 2진수로 표현 학습자님의   2. 수치/진수 자료 표현 ▶ 10진수의 표현
1) 존(Zone)형식의 표현 ­ 10진수 한 자리를 표현하기 위해서 1바이트(8비트)를 사용하는 형식
① 존 영역  ­ 상위 4비트 ­ 1111로 표현
② 수치 영역  ­ 하위 4비트 ­ 표현하고자 하는 10진수 ­ 한 자리 값에 대한 2진수 값을 표시
③ 존 형식의 구조 

2) 수치 영역의 값 표현 ­ 최상위 비트 23=8 ­ 그 다음 비트 22=4 ­ 다음 비트 21=2 ­ 다음 비트 20=1 학습자님의  
3) 여러 자리의 10진수 표현방법
① 10진수의 자릿수만큼 존 형식을 연결하여 사용
② 마지막 자리의 존 영역에 부호를 표시 ­ 양수(+) : 1100       ­ 음수(
-) : 1101

4) 팩(Pack) 형식의 표현
① 존 영역은 항상 1111로 표시되어 메모리 낭비 제거
② 10진수 한 자리를 표현하기 위해서 존 영역 없이 4비트를 사용하는 형식
③ 최하위 4비트에 부호를 표시 ­ 양수(+) : 1100       ­ 음수(
-) : 1101      ▶ 2진수의 정수 표현

1) 2진수의 정수 표현
① 일정한 길이의 n비트로 표현, 부호와 절댓값 형식으로 표현
② 최상위 1비트 : 부호 표시 ­ 양수(+) : 0  ­ 음수(
-) : 1
③ 나머지 n
-1 비트 : 이진수 표시 학습자님의   v 1바이트를 사용하는 부호 절댓값 표현 예

2) 1의 보수(Complement) 형식
① 음수 표현에서 부호 비트를 사용하는 대신 1의 보수를 사용하는 방법 v 1바이트를 사용하는 부호 절댓값 표현 예 ­ n비트를 모두 1로 만든 이진수에서 변환하고자 하는 이진수를 뺌 ­ 예) 10진수 21을 1의 보수로 만듦(1바이트 사용) v 1바이트를 사용하는 1의 보수 표현의 예

3) 2의 보수(Complement) 형식 ­ 음수의 표현에서 부호 비트를 사용하는 대신 2의 보수를 사용하는 방법 v n비트의 2진수를 2의 보수로 만드는 방법 ­ 1의 보수에 1을 더함. ­ 예) 10진수 21을 2의 보수로 만들기(1바이트 사용) 학습자님의   v 1바이트를 사용하는 2진 보수 형식의 예  ▶ 2진수를 표현하는 세 가지 방법
1) 부호와 절댓값 형식 ­ MSB값을 바꿔 음수를 간단히 표현할 수 있음. ­ 가산기와 감산기가 모두 필요하므로 하드웨어 구성비용이 많이 듦. ­ +0(00000000)과 
-0(10000000)이 존재하므로 논리적으로 맞지 않음. ­ n비트로 ­(2n
-1
-1)~+(2n
-1
-1)의 범위를 표현할 수 있음.

2) 1의 보수 형식 ­ (A
-B)뺄셈을  (A+(B의  1의  보수))로  변환하여  계산할  수  있으므로,  가산기  회로로  감산을  수행할 수 있음. ­ +0(00000000)과 
-0(11111111)이 존재하므로 논리적으로 맞지 않음. ­ n비트로 ­(2n
-1
-1)~+(2n
-1
-1)의 범위를 표현할 수 있음.

3) 2의 보수 형식 ­ (A
-B)뺄셈을 (A+(B의 2의 보수))로 변환하여 계산할 수 있으므로 가산기 회로로 감산을 수 행할 수 있음. ­ 덧셈 연산에서 발생하는 오버플로 처리가 1의 보수 형식보다 간단함. ­ 컴퓨터 시스템에서 실제로 사용하는 형식임. ­ n비트로 비트로 ­2n
-1 ~+(2n
-1
-1)의 범위를 표현할 수 있음. 학습자님의   ▶ 2진수의 실수 표현

1) 2진수의 실수 표현 ­ 실수 : 정수부와 소수부 사이에 소수점이 있는 숫자 ­ 컴퓨터는 2진수만으로 실수 표현, 소수점을 직접 표현하지 못하고 정수부와 실수부의 위치 를 지정하여 실수를 표현함.
① 고정 소수점 표현 ­ 소수점이 항상 최상위 비트의 왼쪽 밖에 고정되어 있는 것으로 취급하는 방법 ­ 고정 소수점 표현의 00010101은 0.00010101의 실수 값을 의미
② 부동 소수점 형식의 표현 ­ 고정 소수점 형식에 비해서 표현 가능한 값의 범위가 넓음. ­ 실수를 구분하여 표현 ­ 부호, 지수부, 가수부 구분 ­ a는 4바이트(32비트) 단정도 방식, b는 8바이트(64비트) 배정도 방식 ­ 부호 : 양수 0, 음수 1 v C로 배우는 쉬운 자료구조, 이지영, 한빛아카데미, pp.27~35 학습자님의   자료의 표현 2 (문자/논리/포인터/문자열)

1. 컴퓨터 SW코딩의 문자자료/논리자료/포인터자료/문자열자료의  수업목표   표현을 설명할 수 있다. 1주차 
① 문자자료의 표현  3교시 
② 논리자료의 표현 세부내용 
③ 포인터자료의 표현 
④ 문자열자료의 표현 1. 문자자료의 표현  ▶ 문자자료의 표현 : 문자에 대한 2진수 코드를 정의하여 사용 ­ 문자에 대한 이진수 코드표 : BCD 코드, EBCDIC 코드, ASCII 코드, 유니 코드 ▶ BCD 코드 

1) BCD 코드 (Binary
-Coded Decimal)
① 6비트를 사용하여 문자표현
Ÿ 상위 2비트 : 존 비트
Ÿ 하위 4비트 : 2진수 비트
Ÿ 존 비트와 2진수 비트를 조합하여 10진수 0~9와 영어의 대/소문자 특수문자를 표현
② 존비트 01과 숫자비트 0001을 연결한 010001이 A에 대한 BCD 코드 학습자님의   ▶ EBCDIC 코드

1) EBCDIC 코드(Extended Binary
-Coded Decimal Interchange Code)
① 8비트를 사용하여 문자표현
Ÿ 상위 4비트 : 존 비트
Ÿ 하위 4비트 : 2진수 비트
Ÿ 존 비트와 2진수 비트를 조합하여 10진수 0~9와 영어의 대/소문자 특수문자를 표현
② EBCDIC 코드의 구성
③ EBCDIC 코드표 학습자님의   ▶ ASCII 코드

1) ASCII코드(American Standard Code for Information Interchange)
① 7비트를 사용하여 문자표현
Ÿ 상위 3비트 : 존 비트
Ÿ 하위 4비트 : 2진수 비트
Ÿ 존 비트와 2진수 비트를 조합하여 10진수 0~9와 영어 대문자/소문자, 특수문자를 표현
② ASCII 코드의 구성 
③ ASCII 코드표  학습자님의   ▶ 유니코드
① EBCDIC  코드나  ASCII  코드는  최대  8비트로  숫자,  몇  가지  특수문자,  알파벳  정의하므로  문자 코드 표에 정의되어 있지 않은 문자 표현 불가능 
Ÿ 이러한 문제를 해결하기 위해 세계 여러 나라의 언어를 통일된 방법으로 표현할 수 있 도록 정의한 국제 표준 코드(ISO/IEC 10646)
② 2바이트를 조합하여 하나의 글자를 표현하기 때문에 1바이트 코드로 표현할 수 없었던 다 양한 언어를 표현함.
③ 유니코드 표는 http://www.unicode.org/에서 확인 가능
④ 초기  IBM  컴퓨터  시스템에서는  BCD  코드를  사용하다가  더  많은  문자  코드를  표현할  수  있는  EBCDIC코드로  대체,  그러다  미국  표준  코드인  ASCII  코드  일반화,  현재는  표현의  한계를 극복한 유니코드가 일반화
⑤ XML, Java, CORBA 3.0, WML 등 인터넷 기반 프로그램과 제품에 사용 2. 논리자료의 표현 ▶ 논리자료 ­ 논리자료 : 논리값을 표현하기 위한 자료 형식 ­ 논리값 : 참(True)와 거짓(ex)alse), 1과 0

1) 1바이트를 사용하여 논리자료를 표현하는 방법
① 방법 1
Ÿ 참   : 최하위 비트를 1로 표시      00000001
Ÿ 거짓 : 전체 비트를 0으로 표시     00000000
② 방법 2
Ÿ 참   : 전체 비트를 1로 표시     11111111
Ÿ 거짓 : 전체 비트를 0으로 표시     00000000
③ 방법 3
Ÿ 참   : 하나 이상의 비트를 1로 표시    00000001 or 00000100 …… 
Ÿ 거짓 : 전체 비트를 0으로 표시     00000000 3. 포인터자료의 표현 ▶ 포인터자료 ­ 메모리의 주소를 표현하기 위한 자료 형식 ­ 변수의 주소나 메모리의 특정 위치에 대한 주소를 저장하고 주소 연산하기 위해 사용 학습자님의   4. 문자열자료의 표현 ▶ 문자열(String)자료 ­ 여러 문자로 이루어진 문자의 그룹을 하나의 자료로 취급하여 메모리에 연속적으로 저장하 는 자료 형식

1) 하나의 문자열 자료에 포함된 부분문자열을 표현하는 방법
① 방법 1 : 부분 문자열 사이에 구분자를 사용하여 저장함.
② 방법 2 : 가장 긴 문자열의 길이에 맞춰 고정 길이로 저장함.
③ 방법 3 : 부분 문자열을 연속하여 저장하고 각 부분 문자열에 대한 포인터를 사용함. v {COMPUTER, DATA STRUCTURE, STRINT}을  방법 1, 방법 2, 방법 3으로 표시하면 다음과 같음.

2) 문자열표현 3가지 방법의 메모리 이용률과 부분 문자열 탐색시간 비교 비교항목 메모리 이용률 부분 문자열 탐색 시간 방법 구분자를  문자열 길이 + 구분자 길이  문자 비교 연산 시간  사용하는 방법 → 효율적 + 구분자 식별 시간 → 비효율적 고정 길이로  가장 긴 부분 문자열 길이  문자 비교 연산 시간 → 효율적 저장하는 방법 X 부문 문자열의 개수 → 비효율적 포인터를  문자열 길이 + 포인터 저장 공간 문자 비교 연산 시간 + 포인터  사용하는 방법 → 효율적 주소 연산 시간 → 효율적 v C로 배우는 쉬운 자료구조, 이지영, 한빛아카데미, pp.35~40 학습자님의   자료추상화와 알고리즘 수업목표   1. 자료추상화/구체화/알고리즘의 개념을 이해하고 설명할 수 있다. 2주차  1교시 
① 자료의 추상화 / 알고리즘 세부내용 
② 알고리즘의 이해
③ 알고리즘의 표현 방식 1. 자료의 추상화 / 알고리즘 ▶ 자료 추상 데이터 타입과 알고리즘

1) 자료의 추상화 ­ 어렵고 복잡한 문제를 단순화시켜 쉽게 문제해결을 하는 절차
2) 데이터 타입(data type) : 데이터의 집합과 연산의 집합 ­ 데이터 : 정수, 문자열, 실수, 여러 타입의 합 등 ­ 데이터의 집합 : 데이터의 집합과 데이터에 적용할 수 있는 연산의 집합 ▶ 추상화와 구체화 추상화 ­ “무엇(what)인가?”를 논리적으로 정의 구체화 ­ “어떻게(how)할 것인가?”를 실제적으로 정의 v 추상화 : 구체화  ▶ 추상 데이터 타입
1) 추상 데이터 타입(ADT : Abstract Data Type)
① 소프트웨어 개발과 유지보수에서 가장 중요한 이슈 ­ 어떻게 소프트웨어 시스템의 복잡성을 관리할 것인가”
Ÿ 이 문제의 해결을 위한 방법론과 언어들이 개발되었음.
Ÿ 여기서 주요 이슈가 “추상화”와 관련된 도구의 개발이었음.
② 데이터 타입을 추상적(수학적)으로 정의 학습자님의  
③ 데이터나  연산이  무엇(what)인가는  정의하지만,  이를  어떻게(how)  컴퓨터상에서  구현할  것인가는 정의하지 않음. ▶ 추상 데이터 타입의 정의

1) 추상 데이터 타입의 정의 ­ 추상 데이터 타입에 속하는 객체를 정의 객체 ­ 주로 집합의 개념을 사용하여 정의 ­ 이들 객체들 사이의 연산이 정의됨. 연산 ­ 연산은 추상 데이터 타입과 외부를 연결하는 인터페이스의 역할을 함.
2) 추상 데이터 타입의 구현 ­ 구현 세부 사항은 외부에 알리지 않고 외부와의 인터페이스만을 공개함.  ­ 정보은닉의 기본개념임. 학습자님의   ▶ 추상 데이터 타입과 오디오시스템 비교 추상 데이터 타입 VCR ­ 사용자는  추상데이터타입이  제공하는  연산 ­ 오디오시스템의  인터페이스가  제공하는  특 만 사용할 수 있음. 정한 작업만을 할 수 있음. ­ 사용자는  이러한  작업들을  이해해야  함.  ­ 사용자는  추상데이터타입을  어떻게  사용하 즉,  비디오를  시청하기  위해서는  어떻게  는지 알아야 함. 해야 하는지를 알아야 함. ­ 사용자는  추상데이터타입  내부의  데이터를  ­ 오디오시스템의 내부를 볼 수는 없음. 접근할 수 없음.  ­ 사용자는  어떻게  구현되었는지  몰라도  사 ­ 오디오시스템의  내부에서  무엇이  일어나고  용할 수 있음. 있는지 몰라도 이용할 수 있음. ­ 만약  다른  사람이  추상데이터타입의  구현 ­ 누군가가  오디오시스템의  내부의  기계장치 을  변경하더라도  인터페이스가  변경되지  를  교환한다고  하더라도  인터페이스만  바 않으면 사용할 수 있음. 꾸지 않는 한 그대로 사용이 가능함. ­ 추상데이터타입의 이론은 객체지향프로그램 언어의 탄생에 기여함. ­ C++, Java, Python ­ 클래스를 사용하여 추상 데이터 타입을 구현함. ­ 객체는 클래스의 멤버 변수로 구현, 연산은 클래스의 멤버 함수로 구현 2. 알고리즘의 이해 ▶ 알고리즘의 이해
1) 알고리즘 ­ 문제해결 방법을 추상화하여 단계적 절차를 논리적으로 기술해 놓은 명세서  
Ÿ 자료구조는 계산에 쓰이는 여러 가지 자료들을 조직화, 구조화(organize)한 것임.
Ÿ 알고리즘은 어떤 일을 하는 절차임. 자료구조와 알고리즘은 밀접한 관계가 있음.
Ÿ 프로그램은 자료구조와 알고리즘으로 이루어짐. 학습자님의  
① 예 : 숫자들의 집합에서 특정한 숫자를 찾는 문제 ­ 첫째는 숫자들을 어디에 저장해야 하느냐이다. ­ 자료구조는 배열이나 또는 트리, 연결리스트 중에서 선택해야 한다. ­ 자료구조로 배열을 선택, 알고리즘 결정해야 한다.
② 순차탐색과 이진탐색 중에서 하나를 선택(60을 찾는 수) ­ 순차탐색은 배열의 첫 번째 원소부터 차례대로 비교하는 것임. ­ 이진탐색은 중간위치의 숫자와 비교하여 작으면 앞쪽을 크면 뒤쪽을 탐색함. 자료구조로는 배열을 선택하고, 알고리즘으로는 이진 탐색을 선택함. ▶ 알고리즘의 조건 입력 ­ 알고리즘 수행에 필요한 자료가 외부로부터 입력되어야 함. 출력 ­ 알고리즘 수행 후 하나 이상의 결과를 출력해야 함. ­ 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어들은 명확하게  명확성 표현되어야 함. 유한성 ­ 알고리즘은 수행 뒤에 반드시 종료되어야 함. 효과성 ­ 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 함. ­ 예) 요리 재료의 레시피와 요리법은 SW코딩의 알고리즘과 유사함. ▶ 알고리즘 표현 방법의 종류 v 알고리즘 표현 방법의 종류
① 자연어를 이용한 서술적 표현 방법 : 자연어로 표현, 표현에 한계가 있음
② 순서도를 이용한 도식화 표현 방법 : 명령의 흐름을 쉽게 파악할 수 있지만 복잡한 알 고리즘 표현에 한계가 있음.
③ 프로그래밍 언어를 이용한 구체화 방법 : 특정 프로그램 언어로 표현하는 방법
④ 가상코드를 이용한 추상화 방법 : 프로그래밍 언어로 표현방법의 단점을 보완 학습자님의   ▶ 자연어를 이용한 알고리즘 ­ 인간이 읽기 쉬움. ­ 자연어 단어의 정확한 정의가 없으면 의미 전달이 모호해짐.

1) (예) 배열에서 최대값 찾기 알고리즘  ▶ 순서도를 이용한 도식화 ­ 직관적이고 이해가 쉬움. ­ 복잡한 알고리즘의 경우 이해가 어려움. ▶ 가상코드를 이용한 추상화 ­ 가상코드,  즉  알고리즘  기술언어(ADL,  Algorithm  Description  Language)로  프로그래밍  언어의 일반적인 형태와 유사하게 알고리즘을 기술 ­ 특정 프로그래밍 언어가 아니므로 직접 실행은 불가능 ­ 일반적인 프로그래밍 언어의 형태이므로 특정 프로그래밍 언어로의 변환 용이   학습자님의   ▶ C로 표현된 알고리즘 ­ 가장 정확한 알고리즘 기술 가능 ­ 실제 구현 시 구체적인 사항들이 알고리즘의 핵심적인 내용의 이해 방해 3. 알고리즘의 표현 방식 ▶ 조건문 ­ 조건에 따라 실행할 명령문이 겨정되는 선택적 제어구조를 만듦.
1) if문의 형식과 제어 흐름 학습자님의   ▶ 중첩 조건문
1) 중첩 if문의 형식과 제어 흐름 
2) 중첩 if문의 사용 예 : 평균점수로 등급 계산하기 학습자님의   ▶ Case 문 ­ 조건식들 중에서 해당하는 조건을 찾아서 명령문을 수행 ­ 중첩 if 문으로 표현 가능
1) 형식과 제어 흐름 
2) Case문 예 : 평균점수로 등급 계산하기 학습자님의   ▶ 반복문 ­ 일정한 명령을 반복 수행하는 루프(loop) 형태의 제어구조
1) for문 : 형식과 제어흐름
2) While
-do 문 : 형식과 제어흐름 

3) Do
-while 문 : 형식과 제어흐름  학습자님의  

4) 함수문 : 처리작업 별로 모듈화하여 만든 서브프로그램 ­ 형식과 예 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.17~20 v C로 배우는 쉬운 자료구조, 이지영, 한빛아카데미, pp.44~50 학습자님의   알고리즘 선택기준과 성능분석
1) 알고리즘의  선택과  성능측정방법  및  복잡도  분석  방법을  이해 수업목표   하고 설명할 수 있다. 2주차 
① 알고리즘 성능분석 기준과 기법 2교시 
② 수행시간 측정방법 세부내용 
③ 알고리즘의 복잡도 분석
④ 시간 복잡도 함수
⑤ 빅오(O) 표기법 1. 알고리즘 성능분석 기준과 기법 ▶ 알고리즘 성능분석 기준 ­ 정확성, 명확성, 수행량, 메모리사용량, 최적성 등이 있음. 정확성 ­ 정확한 자료 입력 시 유한한 시간 내에 정확한 결과가 출력됨. 명확성 ­ 알고리즘이 이해하기 쉽고 명확하게 작성되었는가. 수행량 ­ 일반적인 연산 제외, 알고리즘 특성 나타내는 중요 연산 모두 분석 메모리 사용량 ­ 최적성 ­ 가장 좋은 알고리즘은 조건에 맞는 ‘최적의 알고리즘’임. ▶ 알고리즘 성능분석 기법

1) 필요성 ­ 최근 프로그램 규모가 대규모화되어 데이터 처리량이 많아지고 있음.  ­ 알고리즘간의 효율성 차이는 입력자료 양이 적은 경우는 무시되지만, 자료의 양이 많아지면  그 차이는 큼.
2) 공간 복잡도 ­ 알고리즘을 프로그램으로 실행하여 완료하기까지 필요한 총 저장 공간 양 ­ 공간복잡도 = 고정 공간 + 가변 공간
3) 시간 복잡도  ­ 알고리즘을 프로그램으로 실행하여 완료하기까지의 총 소요 시간 ­ 시간복잡도 = 컴파일시간 + 실행시간
Ÿ 컴파일시간 : 프로그램마다 고정적인 시간 소요
Ÿ 실행시간 : 컴퓨터의 성능에 따라 달라질 수 있으므로 실제 실행 시간보다는 명령문의  실행 빈도수에 따라 계산 학습자님의   ­ 실행 빈도수의 계산
Ÿ 지정문,  조건문,  반복문  내의  제어문과  반환문은  실행시간  차이가  거의  없으므로  하나 의 단위시간을 갖는 기본 명령문으로 취급 ­ 예) 피보나치 수열 알고리즘의 빈도수 구하기 ­ 시간복잡도 n<0, n=0, n=1의 경우에 대한 실행 빈도수

4) 입력자료 개수에 따른 알고리즘 실행시간 예  입력 자료의 개수 프로그램 A : n2 프로그램 B : 2n n = 6 36초 64초 n = 100 10,000초 2100초 ~ = 4*1022년 ­ n=6 미만의 경우 프로그램 A와 B의 실행속도 차이는 2배 이내임. ­ n=100의 경우 두 프로그램의 실행 속도 차이는 매우 큼. ­ 사용자는 실행속도가 빠른 프로그램을 선호함. ­ 개발자는 하드웨어에 관계없이 소프트웨어적으로 최선의 효율적인 소프트웨어를 개발함. ­ 효율적  알고리즘은  시작하여  결과가  나오기까지  실행시간이  짧으면서  메모리  자원사용이  적어야 함.  ­ 메모리 공간보다 실행시간이 효율적인 알고리즘이 기준임. 학습자님의   2. 수행시간 측정방법 ▶ 수행시간 측정방법
1) 수행시간 측정방법 ­ 두 개의 알고리즘의 실제 수행 시간을 측정하는 것 ­ 실제로 구현하는 것이 필요하고, 동일한 하드웨어에서 실행해야 함. ­ 알고리즘을 구현하여 실행시간을 측정하는 방법은 정확하고 확실한 방법임.
2) 실제 측정 방법 clock 함수 사용 => clock_t_clock(void)
3) 실행시간 측정하는 프로그램 3. 알고리즘의 복잡도 분석 ▶ 알고리즘의 복잡도 분석 ­ 직접 구현하지 않고서도 수행시간을 분석하는 것 ­ 알고리즘이 수행하는 연산의 횟수를 측정하여 비교 ­ 일반적으로 연산의 횟수는 n의 함수
Ÿ 시간복잡도 분석 : 수행 시간 분석
Ÿ 공간복잡도 분석 : 수행 시 필요로 하는 메모리 공간 분석 학습자님의   4. 시간 복잡도 함수 ▶ 시간 복잡도 함수

1) 시간 복잡도 함수 ­ 시간복잡도는 알고리즘을 이루고 있는 연산들이 몇 번이나 수행되는지를 숫자로 표시함. ­ 산술연산, 대입연산, 비교연산, 이동연산의 기본적인 연산 : 수행시간이 입력의 크기에 따라  변하면 안 됨. → 기본적인 연산만 비교 ­ 알고리즘이 수행하는 연산의 개수를 계산하여 두 개의 알고리즘을 비교할 수 있음. ­ 연산의 수행횟수는 고정된 숫자가 아니라 입력의 개수 n에 대한 함수임.  → 시간복잡도 함수라고 하고, T(n)이라고 표기함.
2) 복잡도 분석의 예 
① 예) n을 n번 더하는 문제 ­ 각 알고리즘이 수행하는 연산의 개수를 세어본다. 단, for 루프 제어 연산은 고려하지 않는다. ­ 알고리즘 A : 가장 쉬운 알고리즘 n*n ­ 알고리즘 B : 조금 어려운 알고리즘 : n을 n번 더하기 ­ 알고리즘 C : 가장 어려운 알고리즘 : 1을 n*n번 더하기
② 알고리즘의 비교 알고리즘 A 알고리즘 B 알고리즘 C 대입연산 1 n + 1 n*n + 1 덧셈연산 ■ n*n 곱셈연산 1 나눗셈연산 전체 연산 수 2 2n + 1 2n2 + 1
③ 연산 횟수를 그래프로 표현 ­ 입력의 개수에 따른 연산의 수 학습자님의   5. 빅오(O) 표기법 ▶ 빅오(O) 표기법

1) 빅오(O) 표기법 ­ 자료의  개수가  많은  경우에는  차수가  가장  큰  항이  가장  영향을  크게  미치고  다른  항들은  상대적으로 그 영향이 미미함. v 예) 시간복잡도 함수가 T(n)=n2+n+1 의 경우 
Ÿ n=1,000일 때, T(n)의 값은 1,001,001이고, 첫 번째 항 n2의 값이 전체의 약  99%인 1,000,000이고, 두 번째 항 n의 값이 전체의 약 0.1%인 1,000 ­ 일반적으로 시간복잡도 함수에서 영향을 크게 미치는 항만을 고려하면 충분함.    ­ 빅오표기법(O)은 연산의 횟수를 대략적(접근적)으로 표기한 것으로, 시간복잡도 함수에서 불 필요한 정보를 제거하고 알고리즘 분석을 쉽게 할 목적으로 시간복잡도를 표시하는 방법임. ­ 두  개의  함수 f(n)과  g(n)이  주어졌을  때,  모든  n>=n0에  대하여  |f(n)|  <= c|g(n)|을 만족 하는 2개의 상수 c와 n0가 존재하면 f(n) = 0(g(n))임.  ­ 함수의 상한을 나타내기 위한 표기법임.
Ÿ 최악의 경우에도 g(n)의 수행 시간 안에는 알고리즘 수행 완료 보장.
Ÿ 먼저 실행 빈도수를 구하여 실행 시간 함수를 찾고, 이 함수값에 가장 큰 영향을 주는  n에 대한 항을 한 개 선택하여 계수는 생략하고 O의 오른쪽 괄호 안에 표시함.
Ÿ 피보나치  수열에서  실행시간함수는  4n+2이고,  가장  영향이  큰  항은  4n인데  여기에서  계수 4를 생략하여 O(n)으로 표기함. v 예) n>=5이면  2n+1 < 10n 이므로 2n+1 = O(n)      학습자님의  

2) 빅오표기법의 실행시간 빠른 순서순 비교 ­ 주의점 : 상수항이나 계수가 굉장히 큰 경우는 실행시간에 영향을 미침.
① 예) 두 개의 알고리즘 A, B 
Ÿ A의 시간복잡도 = TA(n)= 100n+100  => O(n)
Ÿ B의 시간복잡도 = TB(n) = n2  => O(n2) ■ 알고리즘A 알고리즘 B 1 200 1 10 1100 100 20 2100 400 30 3100 900 40 4100 1600 50 5100 2500 60 6100 3600 ­ 표에서 보면 A가 더 효율적으로 되는 것은  70 7100 4900 80 8100 6400 n>100인 경우임. 90 9100 8100 ­ n이 작을 때에는 상수항이나  100 10100 10000 1100 110100 1210000 다른 항의 계수도 실행시간에 영향을 미침. 
② 알고리즘이 지수형이나 팩토리얼형의 시간복잡도를 가지면 사용할 수가 없음. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.20~30 v C로 배우는 쉬운 자료구조, 이지영, 한빛아카데미, pp.51~55 학습자님의   자료구조의 표기법

1. 자료구조의 상수 / 변수 / 함수 / 리스트 / 클래스 표기법을 설 수업목표   2주차  명하고 SW코딩에 사용할 수 있다. 3교시 
① 알고리즘 실행시간의 자료집합 평가기준 세부내용 
② 순차탐색
③ 자료구조 표기법 1. 알고리즘 실행시간의 자료집합 평가기준 ▶ 알고리즘 실행시간의 자료집합 평가기준

1) 최선, 평균, 최악의 경우 ­ 똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 실행시간을 보일 수 있음.
Ÿ 정렬  알고리즘에  거의  정렬이  되어  있는  자료  집합을  주면,  난수  값으로  주어지는  자 료 집합보다 훨씬 빨리 정렬될 수도 있음.
① 최선의 경우(best case) ­ 수행시간이 가장 빠른 경우  ­ 알고리즘의 의미가 없는 경우가 많음.
② 평균의 경우(average case)  ­ 수행시간이 평균적인 경우 ­ 방대한 데이터 수집 등 계산하기가 상당히 어려움.
③ 최악의 경우(worst case)  ­ 수행시간이 가장 늦은 경우, 가장 널리 사용됨.  ­ 계산하기 쉽고 응용에 따라서 중요한 의미를 가질 수도 있음. ­ 예)  비행기  관제업무  알고리즘은  입력  자료에  관계없이  정해진  시간  내에  반드시  계산을  끝내야 함. 게임, 로보틱스 등 학습자님의   2. 순차탐색 ▶ 순차탐색 ­ 정렬되지 않은 배열을 순차적으로 탐색하여 특정한 값을 찾는 알고리즘에서 최상, 최악, 평 균적인 경우의 시간복잡도 함수를 계산함. 이 경우 기본연산을 비교연산으로 가정함. v 순차탐색 알고리즘  ­ 찾고자 하는 숫자가  최선의 경우  맨 앞에 있는 경우 => O(1) ­ 찾고자 하는 숫자가  최악의 경우  맨 뒤에 있는 경우 => O(n) ­ 각  요소들이  균일하게  탐색된다고  가정하면  평균적인 경우 => (1+2+…+n)/n = (n+1)/2   => O(n) 3. 자료구조 표기법 ▶ 자료구조 표기법 프로그램 작성 시 변수, 상수, 함수의 이름을 짓는 것은 매우 신중해야 함.

1) 자료구조의 C언어 표현방법 : 이름 짓기
① 상수의 이름 ­ 상수는 전체를 대문자로 표기함. 학습자님의  
② 변수의 이름  ­ 소문자로 표기함. ­ 언더라인으로 단어와 단어를 분리함. ­ 약어는 가급적 제한함.  ­ 이름이 길어지는 경우에 약어를 사용함.
③ 함수의 이름  ­ 동사를 이용하여 함수가 하는 작업을 표기함. ­ 자료구조에서 자주 사용하는 이름은 동사가 아니어도 사용함. ­ 여러 개의 자료구조가 동시에 사용되는 경우는 list_add와 같이 이름 앞에 자료구조의 이름 을 붙여서 사용함.

2) typedef의 사용 ­ C언어에서 typedef는 사용자 정의 데이터 타입을 만드는데 유용하게 사용됨. ­ 사용자 정의 데이터 타입은 데이터 타입을 사용자가 직접 만드는 것 [ 형식 ] typedef <타입의 정의> <타입의 이름> ­ typedef의 사용 → 간결하고 정리된 코드를 작성할 수 있음. ­ 자료구조 안에서 타입이름 부여할 때 사용함.  ­ 자료구조 안의 노드의 구조에 타입 이름 부여할 때 사용함. ­ 이미 정의되어 있는 타입에 대하여 다른 타입을 부여할 때 사용함. ­ typedef는 변수를 정의하지 않음. v ListNode의  타입 이름을 갖는  사용자 정의  데이터 타입
3) 자료구조의 요소 ­ 대부분의 자료구조는 요소들의 집합으로 정의 ­ ‘리스트’ 자료구조에는 요소들이 순서를 가지고 포함 ­ 요소들은 정수, 문자열, 구조체일 수도 있음. ­ 모든 자료구조의 요소를 element로 표기함. ­ element는 상황에 맞게 정수, 문자열, 구조체 등으로 정의됨. 학습자님의   ▶ 자료구조에 관련된 데이터
1) 자료구조에 관련된 데이터 ­ 객체지향언어는 자료구조에 관련된 자료들과 연산들을 하나의 클래스로 표기함. ­ C언어는 자료구조에 관련된 자료들을 하나의 구조체에 넣고, 함수를 호출할 때에 구조체의  포인터를 전달함. ­ 구조체 그 자체를 전달하는 것이 아니라, 구조체의 포인터 전달은 구조체를 함수 내에서 변 경할 수 있음.
① 스택 연산 자료구조 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.30~36 학습자님의   순환 수업목표   1. 순환호출의 구조를 이해하고 설명할 수 있다. 3주차 
① 순환의 개념 1교시 
② 순환호출의 내부적인 구현  세부내용 
③ 순환 알고리즘 구조 
④ 순환과 반복 
⑤ 순환의 원리 1. 순환의 개념 ▶ 순환의 소개 ­ 순환(recursion)은  알고리즘이나 함수가 실행 중에 자기 자신을 호출하여 문제를 해결하는 기법
Ÿ [예] 팩토리얼 값 구하기, 피보나치 수열, 하노이 탑 등 ▶ 순환 : 순환적으로 정의된 문제나 자료구조를 다루는 프로그램에 적합함.

1) 팩토리얼 값 구하기    ­ n!를 정의하는데 n!를 (n
-1)!이 또 다시 사용됨. 이것을 순환적이라 함.
① 함수 factorial(n)
② C언어 함수로 만듦 => 순환적 팩토리얼 계산 프로그램 학습자님의  
③ factorial(5) 계산 순서  ­ n=1에서 1값이 n=2에 전달되어 2*1=2, 2값이 n=3에 전달되어 3*2=6, 6값이 n=4값에  전달되어 4*6=24, 24값이 n=5에 전달되어 5*24=120이 됨. factorial(5) = 5 * factorial(4) = 5 * 4 * factorial(3) = 5 * 4 * 3 * factorial(2)             = 5 * 4 * 3 * 2 * factorial(1) = 5 * 4 * 3 * 2 * 1 = 120 학습자님의  
④ printf문을 추가한 순환적 팩토리얼 함수 factorial(5)의 출력 결과는                   factorial(5)                   factorial(4)                   factorial(3)                   factorial(2)                   factorial(1) 2. 순환호출의 내부적인 구현 ▶ 순환호출의 내부적 구현

1) 순환호출의 내부적 구현 ­ 순환의 경우 시스템 내부에서는 어떤 일이 일어나는지 알아보자.
Ÿ 함수 호출의 과정에서자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일
Ÿ 복귀 주소가 스택에 저장됨.
Ÿ 호출되는 함수를 위한 매개변수(parameter)와 지역변수를 스택에서 할당 받음.
① 시스템 스택에서 처리 순서 학습자님의   3. 순환 알고리즘 구조 ▶ 순환 알고리즘의 구조

1) 순환 알고리즘의 구조 ­ 순환 알고리즘은 자기 자신은 순환적으로 호출하는 부분과 순환호출을 멈추는 부분으로 구 성됨. ­ 순환호출을 멈추는 부분이 없으면 무한 루프로 에러가 발생함. ­ 다음 함수에서 //부분이 없으면 무한 루프로 에러가 발생함. ­ 순환 호출 함수는 반드시 순환호출을 멈추는 문장이 포함되어야 함. 4. 순환과 반복 ▶ 순환과 반복
1) 순환과 반복 ­ 프로그램에서 되풀이하는 방법에는 순환(recursion)과 반복(iteration) 2가지가 있음.
Ÿ 순환은 순환호출을 이용함.
Ÿ 반복은 for나 while을 이용함.
Ÿ 대부분의 순환은 반복으로 바꾸어 작성할 수 있음. 학습자님의  
① 순환과 반복 ­ 순환적 문제에는 적합한 방법 순환 ­ 함수 호출의 오버헤드 발생으로 수행속도가 느림. ­ 수행속도가 빠름. 반복 ­ 순환적 문제에서는 프로그램이 아주 어려운 경우도 있음.
② 팩토리얼의 반복적인 구현
③ C언어 for반복구조 이용한 프로그램
④ 순환과 반복 어느 것이 바람직한가?  ­ 문제 정의 순환적인 것은 순환이 유리함. ­ 순환적 코드가 반복보다 더 이해하기 쉬움. ­ 프로그램의 가독성 증대, 코딩도 간단함. ­ 약점은 실행시간이 긺. ­ 어떤 경우는 순환이 아니면 프로그램 구현이 어려운 경우가 있음. 학습자님의   5. 순환의 원리 ▶ 순환의 원리

1) 순환의 원리 ­ 주어진  문제를  작은  동일한  문제로  분해하여  해결하는  방법을  분할정복(divide  and  conquer)라고 함. ­ 순환 호출이 일어날 때마다 문제의 크기는 줄어듦. 문제 해결이 점점 쉬어짐. ­ 팩토리얼 함수, 피보나치 수열, 이항 계수 계산, 이진트리 알고리즘.  ­ 이진탐색, 하노이 탑 문제들은 순환이 적합함.   ▶ 순환 알고리즘의 성능
1) 반복알고리즘의 시간복잡도  ­ for를 n번 반복 O(n)
2) 순환알고리즘의 시간복잡도 ­ 순환 호출 1번에 1번의 곱셈 수행, n번 발생 O(n)
3) 순환 알고리즘의 경우 ­ 기억 공간 더 필요 ­ 함수 파라미터 스택에 저장 공간 등 필요사전 작업 시간이 필요함.  v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.42~51 학습자님의   거듭제곱 값 계산 / 피보나치 수열의 계산
1. 순환의  대표적인  알고리즘인  거듭제곱  값  계산  /  피보나치  수 3주차  수업목표   열의 계산을 SW코딩으로 구현할 수 있다. 2교시 
① 거듭제곱 값 계산 세부내용 
② 피보나치 수열의 계산 1. 거듭제곱 값 계산 ▶ 거듭제곱 값 계산

1) 거듭제곱 값 계산 ­ 팩토리얼 계산 프로그램은 반복적인 방법이 순환적인 방법보다 속도가 빠름. ­ 거듭제곱 값 계산 프로그램은 순환적인 방법이 속도가 더 빠름. ­ 숫자 x의 n제곱 값을 구하는 문제 : xn
① 반복적인 거듭제곱 계산 프로그램 
② 순환적인 거듭제곱 계산 프로그램의 알고리즘 학습자님의   v xn=(x2)n/2의 공식을 사용
Ÿ n이 짝수이면 x2 먼저 계산 후 n/2를 제곱한다.
Ÿ n이 홀수이면 x2을 (n
-1)/2 제곱하고, 여기에 x를 곱한다.
Ÿ 위에서도 문제의 크기는 줄어들고 있다.
Ÿ n제곱 => n/2제곱 => n/4 => ..........
③ 거듭제곱을 구하는 순환호출의 예  ­ 210 계산의 경우, 순환 호출의 복귀하는 순서
Ÿ n이 짝수이면 x2 먼저 계산 후 n/2를 제곱한다.
Ÿ n이 홀수이면 x2을 (n
-1)/2제곱하고, 여기에 x를 곱한다.    학습자님의  
④ 순환적인 거듭제곱 계산 프로그램 

2) 어느 함수가 더 빠른가? ­ 순환적 함수가 더 빠름. ­ 순환 호출마다 문제의 크기는 약 절반으로 줄어듦.
Ÿ n=100의 경우, 100 => 50 => 25 => 12 => 6 => 3=> 1
Ÿ 2k의 경우, 2k => 2k
-1 => 2k
-2 => ……=> 21 => 20 ­ 순환호출은 1번의 곱셈과 1번의 나눗셈이 발생함. ­ 전체 연산 개수는 k=log n에 비례함. 2 ­ 시간복잡도는 O(log ■)임. 2
① 반복적인 기법 사용 ­ 한번 루프에 한 번의 곱셈 발생, 루프의 개수는 n개. ­ 시간복잡도는 O(n)임.
② 반복적인 방법과 순환적인 방법의 비교  ­ 2500을 1,000,000번 계산 시 반복적인 함수 slowPower 순환적인 함수 power 시간 복잡도 O(n) O(logn) 실제수행속도 7.17초 0.47초 2. 피보나치 수열의 계산 ▶ 피보나치 수열의 계산

1) 피보나치 수열의 계산 ­ 순환은 단순하게 작성 가능하여 가독성이 높아짐. ­ 똑같은 계산을 수차례 반복하면 단순한 경우라도 계산시간이 길어짐. ­ 피보나치 수열은 순환 호출 사용하면 비효율적임. 학습자님의  
2) 피보나치 수열
Ÿ 앞의 두 개의 숫자를 더해서 뒷자리 수를 만든다.
Ÿ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34,..........  
① 순환적인 피보나치 수열 계산 프로그램 
Ÿ 피보나치 수열은 순환 호출을 사용하면 비효율적임.
Ÿ 같은 항이 중복해서 계산됨. 이 현상은 n이 커질수록 심각해짐.
Ÿ fib(6) : fib()함수가 25번 호출  → 중간에 계산된 값을 기억하지 않고 다시 계산하기 때문임.
Ÿ 예로 n이 25이면 거의 25만 번의 호출이 필요, n이 30이면 300만 번의 호출이 필요함.
② 반복적인 피보나치 수열 계산 프로그램 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.52~56 학습자님의   하노이 탑 문제와 다중순환

1. 순환의 대표적인 알고리즘인 하노이 탑 문제와 다중순환을 SW 3주차  수업목표   코딩으로 구현할 수 있다. 3교시 
① 하노이 탑의 문제 세부내용 
② 다중순환 1. 하노이 탑의 문제 ▶ 하노이 탑의 문제

1) 하노이 탑의 문제 ­ 순환 호출을 가장 잘 사용하여 해결함. ­ 고대 인도 베나레스는 세계의 중심으로 매우 큰 사원임. ­ 높이 50m되는 다이아몬드 막대 3개가 있음. ­ 한 막대에 구멍이 뚫린 64장의 순금 원판이 아래에서부터 크기가 큰 것 순으로 놓였음. ­ 한 장씩만 움직여 다른 막대에 옮기기 ­ 작은 원판 위에 큰 원판을 올려놓으면 안 됨. ­ 원판의 이동횟수는 최소로 함.
2) 하노이탑(The Tower of Hanoi)를 해결하기 위하여 원판의 개수가 3개인 경우 이용
① 문제 : 막대 A에 있는 원판 n개를 막대 C로 옮기는 것이다. ▷ 다음의 조건은 필수이다.
Ÿ 한 번에 하나의 원판만 이동할 수 있다.
Ÿ 맨 위에 있는 원판만 이동할 수 있다.
Ÿ 크기가 작은 원판 위에 큰 원판이 쌓일 수 없다.
Ÿ 중간의 막대를 임시적으로 이용할 수 있으나 앞으로 조건들을 지켜야 한다. 학습자님의  
② n=3인 경우의 해답
③ 일반적인 경우의 하노이 탑 문제
Ÿ A에 n개의 원판이 놓여있다. 위에 있는 n
-1개의 원판을 B로 옮긴다.
Ÿ 제일 밑에 있는 원판을 C로 옮긴다. B에 있는 n
-1개 원판을 C로 옮긴다.
Ÿ 여기서 문제는 B에 있는 n
-1개의 원판을 어떻게 C로 옮기느냐이다. 학습자님의  
④ 남아 있는 문제 해결 알고리즘 
Ÿ 어떻게 n
-1개의 원판을 A에서 B로, 또 B에서 C로 이동하는가?
Ÿ 문제는 n개의 원판을 A에서 C로 이동하는 것이다.
Ÿ 함수의 파라미터를 n
-1로 바꾸어 순환 호출하면 된다.
Ÿ 위 
②는 1개의 원판을 옮기는 것으로 쉽게 해결한다. 
①, 
③은 n
-1개의 원판을 옮기는  것이다. 
①은  to를  사용하여  from에서  tmp로  ■
-1개  원판을  이동하는  문제이고, 
③은  from을 사용하여 tmp에서 to로 n
-1개의 원판을 이동하는 문제이다.
⑤ 순환 호출 사용하여 작성한 알고리즘 학습자님의  
⑥ 위 프로그램의 이동순서    
⑦ 반복적인 형태로 바꾸기 어려운 순환  ­ 팩토리얼에서 다음의 차이는 무엇인가? ❶ return n * factorial(n
-1); ❷ return factorial(n
-1) * n; v 꼬리순환(tail recursion)
Ÿ ❶처럼 순환 호출이 순환 함수의 맨 끝에서 이루어지는 형태
Ÿ 꼬리순환은 쉽게 반복적인 형태로 변환이 가능함. v 머리순환(head recursion)
Ÿ ❷의 경우는 반복적인 코드로 변환이 쉽지 않음.    2. 다중순환 ▶ 다중순환 ­ 한 번의 호출이 발생할 때마다 두 개 이상의 순환 호출이 이루어지는 경우
① 선형순환 : 팩토리얼, 거듭제곱
② 이진순환 : 피보나치, 하노이탑 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.57~62 학습자님의   배열의 개념, 1,2차원배열

1. 배열의  개념을  이해하고,  1,2차원  배열을  이용하여  SW코딩을  4주차  수업목표   한다. 1교시 
① 배열의 개념 세부내용 
② 1,2차원 배열 1. 배열의 개념 ▶ 배열(Array)의 개념 ­ 거의 모든 코딩언어에서 기본적으로 제공하고 있는 데이터 타입. ­ 배열은 데이터 타입의 기본임. 고급 자료구조에 사용됨. ­ 배열은 여러 개의 동일한 데이터 타입의 데이터를 한 번에 만듦.

1) 같은 형의 변수를 여러 개 만드는 경우에 사용 ­ int A0, A1, A2, A3, …, A9; ­ int A[10];   ­ 각각의 변수 사용은 서로 다른 이름을 사용하기 때문에 다른 연산이나 데이터 교환에서 처 리가 힘듦. ­ 배열은 인덱스 번호를 사용하므로 간단한 코드로 이용 가능함. ­ 반복 코드 등에서 배열을 사용하면 효율적인 코딩이 가능함.
2) 최대값을 구하는 프로그램의 예  ­ 배열이 없다면 어떻게 구현하는가?   학습자님의   ▶ 배열의 기본적 특징 ­ 배열은 <인덱스, 요소> 쌍의 집합임. ­ 인덱스에 해당 요소가 대응되는 자료구조임. ­ 배열은 인덱스로 해당 요소에 직접 접근함. ­ 배열은 추상 데이터 타입, 즉 배열이 없는 경우 구현해야 함. 2. 1, 2차원 배열 ▶ 1차원 배열
1) 간단한 정수 배열 ­ int A[6]
2) 배열의 인덱스는 0부터 시작함.   ­ 배열은 메모리에 연속된 위치에 저장됨.  ­ A[0]의 주소가 기준이 됨. 
① 다른 요소의 주소 배열의 요소 메모리 주소 A[0] 기본 주소 = base A[1] base + 1*sizeof(int) A[2] base + 2*sizeof(int) A[3] base + 3*sizeof(int) A[4] base + 4*sizeof(int) A[5] base + 5*sizeof(int) 학습자님의  

3) 메모리와 배열
4) 배열과 주소 ▶ 1차원 배열 : 코딩의 예
1) 메모리 할당크기 확인 코드 및 결과  학습자님의  
2) 학년별 학점 출력하기
3) 구구단 출력하기 학습자님의   ▶ 2차원 배열
1) 2차원 배열 ­ 1차원 배열이 여러 개 모여서 만들어짐. ­ 가로줄 : 행(row), 세로줄 : 열(column) ­ int A[3][4]; 로 선언 생성함. v 실제 메모리 안에서의 위치    
2) 2차원 배열의 초기화 방식 ­ 2차원 배열의 초기화 방식은 앞에서부터 초기화함. ­ int A[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10 11, 12}} v 함수의 매개 변수로서의 배열 예
Ÿ 함수  안에서  매개  변수로  배열을  받아서  배열 의 내용을 수정하면 원래의 배열이 수정됨.
Ÿ 배열의 이름은 포인터와 같음.  배열 이름에 기반주소가 입력됨.
Ÿ 배열 이름의 값을 변경할 수 없음.  따라서 배열 이름은 상수포인터 역할을 함. ▶ 3차원 배열 ­ 3차원 배열은 2차원 배열 형식에 차수만큼 [ ]를 추가함. ­ int i[2][3][4]; 로 선언 생성함. 학습자님의   v 3차원 배열 자료입력 방법과 구조 v 3차원 배열에 값 저장과 출력 프로그램 예  v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.68~71 v C로 배우는 쉬운 자료구조, 이지영, 한빛아카데미, pp.69~81 학습자님의   배열의 응용 : 다항식, 희소행렬 4주차  수업목표   1. 다항식과 희소행렬을 사용하여 SW코딩을 할 수 있다. 2교시 
① 배열의 다항식 세부내용 
② 배열의 희소행렬, 구조체 1. 배열의 다항식 ▶ 배열의 응용 : 다항식

1) 다항식의 일반적인 형태 p(x) = a xn + a xn
-1 + ...... + a x +a   ■ ■
-1 1 0

2) 프로그램에서 다항식을 처리하기 위한 자료구조가 필요함. ­ 어떤 자료구조를 사용해야 다항식의 덧셈, 뺄셈, 곱셈, 나눗셈 연산이 편리하고 효율적인가
3) 배열을 사용한 2가지 방법  ­ 다항식의 모든 항을 배열에 저장하는 방법 ­ 다항식의 0이 아닌 항만을 배열에 저장하는 방법 ▶ 모든 차수에 대한 계수값을 배열로 저장
1) 하나의 다항식을 하나의 배열로 표현함.  a = 10x5 + 6x + 3 장점 ­ 다항식의 각종 연산이 간단해짐. 단점 ­ 대부분의 항의 계수가 0이면 공간의 낭비가 심함. 학습자님의  
① 예 : 다항식의 덧셈 연산 #1  학습자님의   ▶ 다항식에서 0이 아닌 항만을 배열에 저장

1) (계수, 차수) 형식으로 배열에 저장 [예] 10x5+6x+3 → ((10,5), (6,1), (3,0))  
2) 하나의 배열로 여러 개의 다항식을 나타냄. 장점 ­ 메모리 공간을 효율적으로 이용함. ­ 다항식의 연산들이 복잡해짐.  단점 ­ 하나의 다항식이 시작과 끝나는 지점을 변수로 저장함. ­ 차수도 저장하므로 첫 방식보다 메모리가 더 필요한 경우도 있음.
3) term 안에 항의 총 개수가 MAX_TERMS를 넘지 않으면 많은 다항식을 저장함. 
4) avail 변수는 현재 비어 있는 요소의 인덱스를 가리킴.
① 예 : 다항식의 덧셈  A=8x3+7x+1, B=10x3+3x2+1, C=A+B A와 B의 각 항의 지수를 비교하여, 
Ÿ A와 B의 각 항의 지수를 비교하여,  지수가 같으면  두 식의 계수를 더하여 C로 옮기고,  지수가 다르면  두 식 중 지수가 큰 항을 C로 옮기고, 이 과정을 한 쪽의 다항식이  다 끝날 때까지 반복함. 학습자님의  
② 예 : 다항식의 덧셈 프로그램 #2  학습자님의   2. 배열의 희소행렬, 구조체 ▶ 배열의 응용 : 희소행렬

1) 행렬(matrix)는 자연과학에서 많은 문제를 해결하는데 자주 사용됨.
2) 배열을 이용하여 행렬을 표현하는 2가지 방법  ­ 2차원 배열을 이용하여 배열의 전체 요소를 저장하는 방법 ­  0이 아닌 요소들만 저장하는 방법
3) 희소행렬은 대부분의 항들이 0인 행렬  ▶ 2차원 배열을 이용하여 배열의 전체 요소를 저장하는 방법(전통적인 방법) 장점 ­ 행렬의 연산들을 간단하게 구현할 수 있음. 단점 ­ 대부분의 항들이 0인 희소행렬은 메모리 낭비가 심함.   
Ÿ 덧셈 연산의 경우는 배열의 크기가 같다면 각 항을 더하면 됨.
Ÿ 행렬의 크기를 비교해서 같은지를 확인함.
Ÿ 같으면 각 항을 더해서 합 행렬의 항에 입력함. 학습자님의   ­ 다음 희소 행렬 덧셈 프로그램에서 배열을 함수의 매개 변수로 전달하고, 그 결과도 매개변 수로 받음. ▶ 행렬의 0이 아닌 항만 저장하는 방법

1) 희소행렬의 경우는 메모리 공간이 절약됨.
2) 각종 행렬 연산들의 구현이 복잡해짐.
3) 하나의 요소와 여러 개의 구조체가 필요하므로 구조체 배열 선언해야 함. v SparseMatrix 
Ÿ 새로운 타입으로 선언, 하나의 희소행렬에 하나의 1차원 구조체 배열과 행의 개수, 열 의 개수 학습자님의  

4) 2차원 배열의 각 요소에 위에서 아래로, 왼쪽에서 오른쪽으로, 순차적 번호를 부여하여 이 들 번호가 일치하면 같은 위치의 요소로 판단함.
5) 덧셈 결과를 배열 C에 저장도 이 번호 순으로 함. 번호 계산식 index_number(row, col) = row * (열의 개수(cols)) + col ­ row, col는 각 데이터가 저장된 요소의 번호 ­ rows, cols는 2차원 배열의 행, 열의 개수
6) 인덱스변수가 배열 A, B의 각 요소를 가리키면서 각 요소의 인덱스 번호가 같으면 요소를  더함.
7) 인덱스 번호가 다르면 앞선 인덱스 번호의 요소를 C로 이동함.
8) 한 쪽의 배열이 끝나면 다른 남은 요소들을 전부 C로 이동함. v SparseMatrix 프로그램 예  학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.71~86 학습자님의   구조체, 포인터, 동적 메모리 할당
1. 구조체,  포인터,  동적메모리  할당을  이해하고  이를  사용하여  수업목표   4주차  SW코딩을 할 수 있다. 3교시 
① 구조체 세부내용 
② 포인터
③ 동적 메모리 할당 1. 구조체 ▶ 구조체(structure)

1) 구조체(structure) ­ 복잡한 객체는 같은 타입의 데이터로만 되어 있지 않다. ­ 배열이 같은 데이터타입의 모음이라면, 구조체는 다른 데이터타입의 모음임. ­ C언어에서 구조체는 struct로 표시함. ­ 구조체는 특정 자료구조와 관련된 데이터를 묶기 위하여 사용됨.
2) 구조체의 형식과 정의
3) 구조체의 선언과 구조체 변수의 생성 : 사람을 나타내는 구조체 ­ 문자 배열로 된 이름 ­ 나이를 나타내는 정수 값 ­ 키를 나타내는 실수 값 ­ 구조체 형식 정의 / 구조체 변수 선언 ­ 구조체 명(식별자) : person 학습자님의  
4) typedef를 이용한 구조체의 선언과 구조체 변수의 생성 
5) person은  구조체의  식별자임과  동시에  C에서  기본  데이터타입인  int,  float와  같은  새로 운 타입의 이름이 됨. 
6) 항목연산자(membership operator) ­ 구조체 변수명 바로 뒤에 ‘.’을 첨가 후 항목명을 부여하면  외부에서 항목을 접근할 수 있는 변수명이 됨. ▶ 구조체의 대입과 비교 연산
1) 하나의 구조체 변수의 내용을 다른구조체에 대입 가능함.
2) 대입이 불가능하면?
3) 구조체의 변수와 다른 구조체의 변수의 비교는 불가능함. 학습자님의  
4) 두 개의 구조체 변수 비교 프로그램의 예 ▶ 자체 참조 구조체 (self
-referential structure) ­ 구성 요소 중에 자기 자신을 가리키는 포인터가 한 개 이상 존재하는 구조체 ­ 연결리스트나 트리에 많이 나타남. ­ 항목의  개수를  미리  예측할  수  없는  경우  자체  참조  구조체를  정의해  놓고  동적으로  기억  장소를 할당 받아서 이들을 포인터로 연결 받아서 자료 구조를 구성함.
① ListNote 구조체에서 link 필드가 ListNode를 가리키므로 자체 참조 구조체임.        ▶ 구조체 배열 ­ 구조체를 요소로 하는 배열 생성도 가능함. ­ 구조체를 포함한 구조체도 선언 가능함.    
Ÿ Birthday라는 구조체을 선언하고,  구조체 Student에서  이 구조체를 포함한 후  구조체 student의 배열을 만듦.       학습자님의   2. 포인터 ▶ 포인터(pointer)

1) 포인터 개념 ­ 포인터 변수 : 다른 변수의 주소를 가지고 있는 변수 ­ 포인터는 다른 변수를 가리킴. 이를 화살표로 표시함. ­ 모든 변수는 주소를 가지고 있음. 바이트마다 순차적으로 주소를 가지고 있음.
Ÿ p는 a라는 변수를 가리키는 포인터 변수임.
Ÿ 포인터 변수를 사용하여 메모리의 내용 추출, 변경은 * 연산자를 사용함.
Ÿ *p와 변수a는 동일함.
Ÿ 값만 같은 것이 아니라, 동일한 객체를 가리키기 때문에 *p의 값을 변경하면 a의 값도  바뀜. ▶ 포인터와 관련된 연산자

1) 포인터의 주요 연산자 : &, * & ­ 변수로부터 변수의 주소를 추출해내는 연산자 * ­ 포인터가 가리키는 변수의 내용을 추출하는 연산자   학습자님의   ▶ 다양한 포인터 ▶ 포인터의 형변환
1) 포인터의 형변환 : 필요할 때마다 형 변환하는 것 ­ p를 정수 포인터로 변경하여 pi에 대입하는 경우 ▶ 함수의 매개변수로서의 포인터 ­ 포인터는 함수의 매개변수로 전달될 수 있음. ­ 특정 변수를 가리키는 포인터가 함수의 매개변수로 전달되면 포인터를 이용하여 함수 안에 서 변수의 값을 변경할 수 있음. 변경된 결과는 함수 호출자에게 영향을 미침.
1) 포인터 함수의 매개변수 사용 예  ▶ 배열과 포인터 ­ 배열의 이름 : 사실상의 포인터와 같은 역할 ­ 배열의 이름이 배열의 시작 부분을 가리키는 포인터임. ­ 컴파일러가 배열의 이름을  배열의 첫 번째 주소로 대치하기 때문임. 학습자님의   ▶ 구조체와 포인터
1) 구조체의 요소에 접근하는 연산자 “
->” ps 
-> i는 (*ps).i와 같음.  ps
-> i가 사용하기 쉬움.

2) 구조체 자체를 매개변수로 넘기는 경우, 매개변수가 크다면 문제가 심각함.
3) 구조체 포인터만 넘기면 주소만 함수에 전달됨.
4) 함수는 이 포인터를 이용하여 구조체의 내용을 변경할 수 있음. ▶ 포인터의 포인터 ­ 포인터도 변수이므로 포인터의 포인터도 선언이 가능함. ▶ 포인터의 연산 ­ 포인터에 대한 사칙연산은 포인터가 가리키는 객체단위로 계산함. 학습자님의   v 다음을 잘 구분하여 사용하자.  ▶ 포인터 사용 시 주의할 점
1) 포인터가 아무것도 가리키고 있지 않을 때는 NULL로 설정함.    
2) 초기화가 안 된 상태에서 사용금지     
3) 포인터 타입 간의 변환 시에는 명시적인 타입 변환을 사용함.     3. 동적 메모리 할당 ▶ 프로그램이 메모리 할당 받는 방법 ­ 프로그램이 메모리를 할당 받는 개념으로 정적과 동적 두 가지가 있음.
1) 정적 메모리 할당  ­ 메모리의 크기를 프로그램 시작 전에 결정된 경우 ­ 프로그램 수행 도중에 크기를 변경할 수 없음. ­ 처음에 결정된 크기보다 더 큰 입력이 들어오면 처리 불가이고,더 작은 입력이 들어오면 남 는 메모리가 발생하여 낭비가 됨.
① 변수, 배열의 선언     학습자님의  

2) 동적 메모리 할당  ­ 프로그램의 실행 도중에 메모리 할당 받는 방법 ­ 필요한 만큼만 할당을 받고 또 필요한 때에 사용하고 반납함. ­ 메모리를 효율적으로 사용 가능함.
① 전형적인 동적 메모리 할당 코드     ▶ 동적 메모리 할당 관련 라이브러리 함수 ▶ 동적 메모리 할당 관련 라이브러리 

1) void *malloc(int size) : size 바이트만큼의 메모리 블록을 할당함.
2) void free(void *ptr) ­ ptr이 가리키는 할당된 블록을 해제함. v malloc을 이용한 동적메모리 할당 예 학습자님의  
3) void *calloc(int num, int size) : 배열 형식의 메모리를 할당함.  ­ 배열 요소의 크기는 size바이트임.  ­ num이 개수. ­ 요소들은 0으로 초기화됨. ­ 반환값은 malloc함수와 동일함.
4) sizeof 연산자 ­ sizeof는 변수나 타입의 크기를 바이트단위의 숫자로 반환함. ­ sizeof 대상은 식별자 또는 데이터타입임. ­ size_t i = sizeof( int ); : i의 값은 4임. 즉 int 타입의 크기는 4바이트임.  
Ÿ size는 구조체의 크기임.
Ÿ char 변수 c의 크기는 1이고, int 변수 i는 4, 구조체는 5임.
Ÿ c++의 경우는 c의 크기 4, i의 크기 4, 구조체 8임. ­ sizeof 연산자 이용 배열의 크기 계산 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.82~98 v C로 배우는 쉬운 자료구조, 이지영,, pp.98~104 학습자님의   리스트의 소개

1. 리스트  타입과  배열  리스트를  이해하고,  이를  사용하여  SW코 5주차  수업목표   딩을 구현할 수 있다. 1교시 
① 리스트 추상데이터 타입 세부내용 
② 배열로 구현된 리스트 1. 리스트 추상데이터 타입 ▶ 리스트 추상데이터 타입

1) 리스트의 소개 ­ 리스트 또는 선형리스트(linear list)는 자료를 정리하는 방법 ­ 순서를 가진 항목들의 모음 ­ 집합은 항목들 간의 순서의 개념이 없음.
2) 표현 L = (item , item , item , .... , item ) 0 1 3 ■
-1

3) 리스트의 예 ­ 요일 : (일요일, 월요일, .... 토요일) ­ 한글자음 모음 : (ㄱ, ㄴ, ㄷ,.... ㅎ) ­ 핸드폰 문자메시지 리스트
4) 리스트의 연산 ­ 새로운 항목을 리스트의 마지막, 처음, 중간에 추가함. ­ 기존의 항목을 리스트의 임의의 위치에서 삭제함. ­ 모든 항목을 삭제함. ­ 기존의 항목을 대치함. ­ 리스트가 특정한 항목을 가지고 있는지를 살핌. ­ 리스트가 특정위치 항목을 반환함. ­ 리스트 안의 항목 계수를 셈. ­ 리스트가 비었는지, 꽉 찼는지를 체크함. ­ 리스트 안의 모든 항목을 표시함.
5) 리스트 ADT ­ 추상  데이터  타입(ADT)단계로  리스트가  무엇이냐(what)에  집중하고,  어떻게(how)  구현하 느냐는 다음 단계임. ­ 자료구조는 추상 데이터 타입을 특정 프로그래밍 언어로 구현하는 것 학습자님의  
6) 리스트를 추상 데이터 타입으로 정의
7) 리스트 ADT의 사용 예 
Ÿ add_last(list1, a)
Ÿ add_last(list1, b)
Ÿ add(list, 2, c)
Ÿ add(list1, 1, d)
Ÿ delete(list1, 2)
Ÿ replace(list1, 1, e)

8) 리스트 ADT 사용 예 학습자님의  
9) 리스트를 구현하는 방법
① 배열을 이용하는 방법 ­ 구현이 간단함. ­ 삽입, 삭제 시 오버헤드가 발생함. ­ 항목의 개수가 제한됨.
② 연결리스트를 이용하는 방법 ­ 구현이 복잡함. ­ 삽입, 삭제가 효율적임. ­ 크기가 제한되지 않음. 2. 배열로 구현된 리스트 ▶ 배열로 구현된 리스트

1) 1차원 배열에 항목들을 순서대로 저장 L =(A, B, C, D,, E) 
2) 삽입연산 : 삽입위치 다음의 항목들을 뒤로 이동하여야 함.
3) 삭제연산 : 삭제위치 다음의 항목들을 앞으로 이동하여야 함. 학습자님의   ▶ 배열을 이용한 리스트 프로그램
1) 배열을 이용한 리스트 프로그램 ­ 1차원 배열, 배열 이름은 list, 저장된 항목은 element 타입, 자료의 개수 length 변수 ­ arrayListType : list와 length를 합한 구조체 ­ 초기화 함수 init함수 : 리스트 초기화 함수 length를 0으로 만든다. ­ 빈 리스트 검사 is_empty 함수 : length값이 0이면 빈 리스트로 1을 반환, 아니면 0반환 ­ 가득  찼는지  검사  is_full  함수  구현  :  length값이  MAX_LIST_SIZE보다  크면  1반환,  아니 면 0반환 ­ display함수 : 배열의 요소를 한 줄에 하나씩 출력함.     학습자님의  
2) arrayListType의 삽입연산 ­ add함수는 먼저 배열이 포화 상태인지를 검사함. ­ 삽입 위치가 적합한 범위에 있는지를 검사함. ­ 삽입 위치 다음에 있는 자료들을 한 칸씩 뒤로 이동함.   
3) arrayListType의 삭제연산 ­ 삭제 위치를 검사함. ­ 삭제 위치부터 맨 뒤까지의 자료를 한 칸씩 앞으로 옮김.      v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.104~116 학습자님의   연결리스트
1. 연결리스트의  소개,  단순/원형/이중  연결리스트를  이해하고,  이 5주차  수업목표   를 설명할 수 있다. 2교시 
① 연결리스트의 소개 세부내용 
② 단순연결리스트 1. 연결리스트의 소개 ▶ 연결 리스트(linked list)의 소개

1) 연결리스트란 ­ 동적으로 크기가 변할 수 있고, 삭제나 삽입 시에 데이터 이동을 하지 않음. 데이터와 링크 로 구성되어 있으며 링크가 데이터들을 연결하는 역할을 함. ­ 연결된  표현은  리스트  구현에만  사용되는  것이  아니고  다른  동적  자료  구조  즉,  스텍,  큐,  트리, 그래프 등 구현에 사용함.   ­ 연결된  표현은 줄로  연결된  상자임.  이것은  데이터를  한군데  모아  두지  않음.  연결된  줄을  따라가면서 다음을 찾음. 이것을 연결리스트라 함. ­ 리스트의 항목들을 노드(node)에 분산 저장함. ­ 다음 항목을 가리키는 주소도 같이 저장함. ­ 노드(node) : <항목, 주소> 쌍 ­ 노드는 데이터 필드와 링크 필드로 구성됨. 데이터 필드 ­ 리스트의 원소, 즉 데이터 값을 저장하는 곳 링크 필드 ­ 다른 노드의 주소값을 저장하는 장소(포인터)     ­ 메모리 안에서의 노드의 물리적 순서가 리스트의 논리적 순서와 일치할 필요 없음.   학습자님의  
2) 연결리스트의 장단점 ­ 삽입, 삭제가 보다 용이함.  ­ 연속된 메모리 공간이 필요 없음. 장점 ­ 크기 제한이 없음. ­ 필요시마다 동적으로 공간 확보함. ­ 구현이 어려움. 단점 ­ 오류가 발생하기 쉬움.
① 삽입연산                                 
② 삭제연산

3) 연결리스트의 구조 ­ 노드 = 데이터 필드 + 링크 필드      ­ 데이터 필드 : 데이터 저장(정수, 구조체 등) ­ 링크 필드 : 다른 노드를 가리키는 포인터 저장, 이 포인터로 다음 노드로 감. ­ 헤드 포인터 : 첫 노드를 가리키는 변수 ­ 마지막 노드의 링크 필드 : NULL로 설정함. 더 이상의 연결노드가 없음. ­ 노드는 메모리 어디든지 위치함. ­ 노드 저장 위치 순서가 리스트상의 순서와 동일하지 않음. ­ 연속적인 기억공간이 없어도 데이터 저장이 가능함. ­ 사전에 기억공간을 확보할 필요가 없으며,  필요마다 노드를 동적으로 생성 연결함.      학습자님의  
3) 연결리스트의 종류 단순 연결리스트 ­ 하나의 방향으로만 연결 원형 연결리스트 ­ 맨 마지막 노드의 링크값이 첫 번째 노드를 가리킴. 이중 연결리스트 ­ 노드마다 링크필드가 2개가 있음. 양방향 링크 2. 단순연결리스트 ▶ 단순연결리스트 ­ 노드들이 하나의 링크필드를 가짐. ­ 이 링크필드로 다른 링크필드를 연결함. ­ 마지막 링크필드 값 : NULL      ▶ 삽입알고리즘
1) 중간 삽입의 경우 ­ before노드와 after노드 중간에 new노드 삽입 ­ new노드가 after노드를 가리킴. ­ before노드 링크필드에 있는 after노드 주소를 new노드 링크로 복사 ­ before노드의 링크가 new를 가리키게 함. 학습자님의   v 삽입알고리즘 설명
(1) 만약 연결리스트가 L이 공백상태이면 (2) 새로운 노드를 첫 번째 노드로 함. (3) 그렇지 않으면 new노드의 링크가 after를 가리키게 하고 (after노드의 주소가 before.link에 저장되어 있음)  (4) before노드의 링크가 new를 가리키게 함. ▶ 삭제알고리즘 ­ before노드 링크가 after노드를 가리키도록 변경함. ­ after노드의  주소가  remove노드의  링크에  있으므로  remove노드의  링크를  before노드의  링크로 복사함. v 알고리즘 설명 (1) 만약 연결리스트 L이 공백 상태가 아니면 (2) before노드의 링크가 after노드를 가리키게 함.  after노드의 주소가 remove노드의 링크에 저장되어 있음. (3) remove노드를 삭제함. 학습자님의   ▶ 단순연결리스트의 구현 ­ 노드는 C언어의 구조체로 정의함. ­ 구조체 안에 데이터 필드와 링크 필드가 존재함. 데이터 필드 ­ element타입의 데이터 저장 링크 필드 ­ 구조체를 가리키는 포인터   ­ 위는 노드가 생성되지 않았음. ­ 임시포인터  변수  p1을  만들고  malloc함수를  사용하여  노드  크기만큼  메모리  할당받음.    이 할당받은 메모리가 노드가 됨. ­ 위 코드 실행하면 아래 노드가 생성됨. 아직 빈 노드임.  ­ 노드에 데이터 저장, 링크필드를 NULL로 설정함. ­ 두 번째 노드 생성과 첫 번째 노드와의 연결 학습자님의   ▶ 삽입연산

1) 삽입연산 ­ 노드가 존재할 경우 중간에 노드를 삽입하는 경우 알고리즘 ­ 위 알고리즘을 C언어 함수로 만들어서 사용함. ­ 단순연결리스트는 첫 번째 노드를 가리키는 포인터만 알면 됨.  이 포인터를 헤드포인터 (head pointer)라 함.
2) 생성 방법
Ÿ ListNode *head;
Ÿ ListNode *list1, list2; ­ 삽입 위치 바로 앞 노드를 가리키는 포인터를 p ­ 삽입하고자 하는 노드를 가리키는 포인터를 new_node ­ 노드 삽입함수 insert_node함수, 이 함수는 3개의 인수를 받음.

3) 삽입알고리즘의 3가지 경우 ­ head가 NULL인 경우 : 공백 리스트에 삽입 ­ p가 NULL인 경우 : 리스트의 맨 처음에 삽입 ­ 일반적인 경우 : 리스트의 중간에 삽입
① head가 NULL인 경우 ­ head가 NULL이라면 현재 삽입하려는 노드가 첫 노드가 됨. ­ head의 값만 변경하면 됨. 학습자님의  
② p가 NULL인 경우 ­ 새로운 노드를 리스트의 맨 앞에 삽입함. ­ new_node의 link가 head와 같은 값을 가짐. ­ head가 new_node를 가리킴.
③ head와 p가 NULL이 아닌 경우  ­ 가장 일반적인 경우 ­ new_node의 link에 p
->link값을 복사한 다음 p
->link가 new_node를 가리킴.

4) 위 알고리즘을 순서대로 C언어로 구현 학습자님의   ▶ 삭제연산
1) 삭제연산 ­ 삭제연산 함수 remove_node 함수는 3개의 인수를 받음.
2) 삭제알고리즘의 2가지 경우
① p가 NULL인 경우  ­ 연결리스트의 첫 노드를 삭제함. ­ head포인터를 변경하고, remove노드의 메모리를 반환함.
② p가 NULL이 아닌 경우 ­ remove 앞 노드인 p링크가 remove 다음 노드를 가리킴. ­ remove 노드 메모리 반환함.

3) 삭제 알고리즘 함수 학습자님의   ▶ 방문연산 ­ 리스트 상의 노드를 순차적으로 방문하는 알고리즘 ­ 반복알고리즘과 순환기법 모두 사용 가능 ­ 노드의 링크값이 NULL이 아니면 계속 링크를 방문함. ­ 노드의 링크값이 NULL이면 연결리스트의 끝이므로 종료함. ­ 연결리스트의 기본 연산임.
① 반복연산 코드 
② 순환연산 코드 ­ 매개변수 p가 NULL이 아니면 p의 데이터 출력 ­ p
->link값을 매개변수로 하여 현재 함수를 순환호출 ­ 실행시간이 반복보다 더 걸림. ▶ 탐색연산 ­ 리스트 원소값 탐색 연산도 기본 ­ 포인터 p가 첫 노드를 가리킴. ­ 순서대로 노드를 탐색하며 노드의 데이터와 비교 ­ 링크값 NULL을 만나면 종료함. ­ 반환값은 탐색값을 가지고 있는 노드의 포인터임. 학습자님의   ▶ 합병연산 코드 ­ 두 개의 리스트 L1과 L2를 하나로 만드는 연산 ­ 첫 리스트의 끝으로 이동 ­ 마지막 노드의 링크를 두 번째 리스트의 첫 노드로 가리키도록 변경 ­ head1과 head2가 NULL인 경우를 처리 ▶ 역순 연산 코드 ­ 리스트를 역순으로 만드는 연산 ­ 세 개의 포인터 q, p, r포인터 사용하여 연결리스트 순회로 링크 방향 역순으로 변경 ­ 새로운 리스트를 만들지 않고 3개의 포인터로 연결리스트를 역순으로 변경
Ÿ p는 아직 처리되지 않은 노드  
Ÿ q는 현재 역순으로 만들 노드  
Ÿ r은 이미 역순으로 변경된 노드    
Ÿ r은 q, q는 p를 차례로 따라감.
① 역순 알고리즘 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.117~144 학습자님의   연결리스트의 응용

1. 연결리스트의 응용의 이해와 이를 이용한 구현을 설명할 수 있 5주차  수업목표   다. 3교시 
① 연결리스트의 응용, 연결리스트로 구현된 리스트 세부내용 
② 선형리스트의 응용 : 텍스트 에디터 1. 연결리스트의 응용, 연결리스트로 구현된 리스트 ▶ 원형연결리스트 ­ 마지막 노드의 링크가 첫 노드의 링크를 가리키는 리스트 ­ 마지막 노드의 링크 주소가 NULL이 아니고, 첫 노드의 주소가 됨. ­ 한 노드에서 다른 모든 노드로의 접근이 가능함.
① 노드의 삽입과 삭제가 단순연결리스트보다 용이함.
② 헤드포인터가 마지막  노드를 가리키도록 구성하면 리스트의 처음이나  마지막에 노드 삽입 하는 연산이 단순연결리스트보다 용이함.        ▶ 삽입함수 ­ 새로운 노드의 링크 node
->link가 첫 노드를 가리킴. ­ 마지막 노드의 링크가 node를 가리킴. 학습자님의   ­ 원형연결리스트 마지막에 노드 삽입은 head의 위치를 새로운 노드로 변경하면 됨. ▶ 이중연결리스트

1) 이중연결리스트 ­ 단순연결리스트의 문제점 : 선행노드 찾기가 어려움. ­ 삽입이나 삭제 시에는 반드시 선행노드가 필요함. v 이중연결리스트 
① 하나의 노드가 선행노드와 후속노드에 대한 두 개의 링크를 가지는 리스트
② 링크가 양방향이므로 양방향 검색이 가능함.
③ 단점은 공간을 많이 차지하고 코드가 복잡함.

2) 실제 사용되는 이중연결리스트의 형태    : 헤드노드 + 이중연결리스트 + 원형연결리스트   
① 헤드노드(head node) ­ 데이터를 가지지 않고 단지 삽입, 삭제 코드를 간단하게 할 목적으로 만들어진 노드 ­ 헤드 포인터와의 구별 ­ 공백상태에서는 헤드노드만 존재 ­ 임의의 노드 가리키는 포인터 p의 경우  p == p
->llink
->rlink == rlink
->llink   즉, 앞뒤로 똑같이 이동할 수 있음. 학습자님의  

3) 이중연결리스트의 노드 구조 : 구조체로 정의 ­ 각 노드의 왼쪽 링크필드는 선행노드를 지시하고 오른쪽 링크필드는 후속노드를 지시함.     ▶ 삽입연산 ­ 삽입할 노드의 링크필드 값을 먼저 변경함. ▶ 삭제연산 학습자님의   ▶ 연결리스트의 응용 : 다항식 ­ 배열을 이용하여 다항식 계산을 앞에서 표현했음. ­ 다항식의 덧셈, 뺄셈을 하는 프로그램 작성 ­ 하나의 다항식을 하나의 연결리스트로 표현함. A = 3x12+2x8+1 
2) 2개의 다항식을 더하는 덧셈 연산 A = 3x12+2x8+1, B = 8x12+3x10+10x6이면 A+B = 11x12
-3x10+2x8+10x6+1

3) 연결리스트의 응용 : 다항식
① p와 q가 가리키는 항들의 지수가 같으면 계수를 더함. 학습자님의  
② q가 가리키는 항의 지수가 높으면 그대로 C로 옮김.
③ p가 가리키는 항의 지수가 높으면 그대로 C로 옮김.
④ p나 q 중 하나가 NULL이 되면 남아 있는 항들을 전부 C로 가져옴. ▶ 연결리스트로 구현된 리스트

1) 연결리스트로 구현된 리스트 ­ 리스트 ADT의 연산 구현방법 : 배열 이용, 연결리스트 이용 ­ 리스트 ADT의 연산을 연결리스트를 이용하여 구현 ­ 리스트 ADT의 add, delete연산의 파라미터는 위치 ­ 연결리스트의 insert_node, remove_node의 파라미터는 노드 포인터 ­ 상황에 따라 연산을 적절하게 선택하여야 함.     학습자님의  
2) 리스트 ADT의 구현 
① 리스트 ADT의 구조체
② 연결리스트를 이용한 리스트 생성    LinkedListType list1;   
③ is_empty 연산의 구현 ­ 연결리스트를 사용한 리스트 ADT의 is_empty구현  
④ get_length 연산의 구현 ­ 연결리스트를 사용한 리스트 ADT의 get_length함수 구현
⑤ add연산의 구현 ­ 새로운 자료를 선형리스트에 추가하는 함수 ­ 동적메모리할당을 이용하여 노드를 생성함. ­ 노드 데이터필드에 자료를 복사하고 지정된 노드의 뒤에 삽입하면 됨. ­ 항목의 위치를 노드 포인터로 변환해 주는 get_node_at 함수 사용 ­ 매개변수 pos로 위치를 받아서 그 위치에 해당하는 주소를 반환함.      학습자님의   ­ 새로운 데이터를 임의의 위치에 삽입 ­ 항목의 위치를 노드 포인터로 변환해 주는 함수 get_node_at 필요
⑥ delete연산의 구현 ­ 공백이 아닌 리스트에서 pos위치의 자료를 삭제함. ­ get_node_at 함수 사용하여 (pos
-1) 위치에 해당하는 노드의 주소를 파악함. ­ (pos
-1) 위치의 노드주소를 반환하는 이유는 노드 삭제 시 그 노드의 선행노드가 필요하기  때문임.
⑦ get_entry연산의 구현 ­ 연결리스트를 사용한 리스트 ADT의 get_entry 구현 ­ get_entry연산은 위치 pos에 해당하는 데이터를 반환하는 연산 ­ 먼저  pos가  length보다  작은지를  확인하고  작으면  get_node_at  함수를  이용하여  위치에  해당하는 노드의 주소를 얻음. ­ 이 노드가 가지고 있는 데이터 값을 반환함.   학습자님의  
⑧ clear연산의 구현 ­ 모든 노드를 지우는 함수 ­ 리스트의 길이만큼 delete함수를 호출하면 됨.
⑨ display연산의 구현 ­ 연결리스트를 사용한 리스트 ADT의 display구현 ­ 리스트가 가지고 있는 데이터를 화면에 출력하는 함수 ­ 리스트의 head_pointer가 가리키는 노드부터 NULL까지 노드의 데이터 값을 출력함.
⑩ is_in_list 연산의 구현 ­ 데이터 필드가 item인 노드를 탐색하는 연산 ­ 헤드포인터부터 시작하여 NULL까지 while루프 수행함. ­ 헤드포인터는  변경하면  연결리스트가  상실되기  때문에헤드포인터는  직접  사용하지  않고  복 사하여 사용함. 학습자님의   ▶ 전체 프로그램 ­ 리스트 ADT연산을 이용하여 프로그램 작성 ­ add, add_last, add_first 함수 사용하여 리스트 노드 삽입함. ­ delete 함수 이용하여 특정 노드 삭제 연산 수행함. ­ 삽입, 삭제 연산 수행 후 그 결과를 화면에 출력함. ­ is_in_list 함수 이용하여 노드 탐색함. ­ get_entry 함수 이용하여 특정노드 값을 가져옴. ▶ 전체 프로그램 예 학습자님의   학습자님의   학습자님의   학습자님의   2. 선형리스트의 응용 : 텍스트 에디터 ▶ 선형리스트의 응용 : 텍스트 에디터 ­ 라인에디터(line editor)로 라인단위로 입력, 삭제함. ­ 이 에디터는 고정된 수의 명령어를 받아서 동작하며 커서는 사용하지 않음. ­ 현재 사용하고 있는 에디터와는 많은 차이가 있으나 에디터의 기본적인 아이디어를 창출함. ­ buffer라는 연결리스트를 사용하여 텍스트 저장함. ▶ 리스트 ADT를 이용한  라인에티터(라인에디터) 학습자님의   ▶ 리스트 ADT를 사용한 라인에디터 프로그램 학습자님의   학습자님의   학습자님의   학습자님의   학습자님의   학습자님의   ▶ 실행 결과 화면 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.105~166 학습자님의   스택 1

1. 스택의  개념,  추상자료형,  동작원리를  이해하고,  이를  SW코딩 6주차  수업목표   에 적용할 수 있다. 1교시 
① 스택추상 데이터 타입 세부내용 
② 배열로 구현한 스택 1. 스택추상데이터타입 ▶ 스택추상데이터타입

1) 스택추상데이터타입 ­ 스택(stack) : 쌓아놓은 더미를 의미함. ­ 스택은  먼저  들어온  것이  나중에  나감.  즉,  나중에  들어온  것이  먼저  나감.  이것을  후입선 출(LIex)O:Last
-in
-ex)irst
-Out)이라 함.   ­ 스택 상단(stack top) : 입출력이 이루어지는 부분  ­ 스택 하단(stack bottom) : 바닥 부분 ­ 요소(element) : 스택에 저장되는 데이터 ­ 공백 스택(empty stack) : 스택에 요소가 하나도 없음. 학습자님의  

2) 스택추상자료형 정의 ­ 스택의 상태변화를 주는 연산과 스택의 현재상태를 검사하는 연산으로 구성됨.
3) 스택의 연산 : 두 가지 기본연산이 있음. ­ 삽입연산 : push() : 스택에 데이터를 추가함. ­ 삭제연산 : pop() : 스택에서 데이터를 삭제함. ­ is_empty(s) : 스택이 공백상태인지 검사함. ­ is_full(s) : 스택에 포화상태인지 검사함. ­ create() : 스택을 생성함. ­ peek(s) : 요소를 스택에서 삭제하지 않고 보기만 하는 연산. pop은 요소를 스택에서 완전 히 삭제함.
4) 스택의 용도 ­ 입력과 역순의 출력이 필요한 경우 적합함.
Ÿ 에디터에서 되돌리기(undo) 기능
Ÿ 함수 호출에서 복귀주소를 기억할 때(순환)  

5) 스택을 구현하는 방법 2가지 ­ 배열을 이용하는 방법 : 간단하지만, 크기가 고정됨. ­ 연결리스트를 이용하는 방법 : 구현이 복잡하지만 크기는 필요에 따라 가변적임. 학습자님의   2. 배열로 구현한 스택 ▶ 배열로 구현한 스택
1) 배열로 구현한 스택 ­ int타입 1차원 배열 stack[MAX_STACK_SIZE] 필요함.이 배열에 스택의 요소 저장함. ­ top변수 : 스택에서 가장 최근에 입력된 자료 가리키는 변수 ­ stack[0] : 가장 먼저 들어온 요소 ­ stack[top] : 가장 최근에 들어온 요소   ­ 공백상태 : top
-1로 스택이 빈 경우

2) 스택 is_empty 연산 알고리즘 ­ 스택이 비어있는지를 검사함. ­ top을 
-1과 비교함. 배열의 시작은 0임.

3) 스택 is_full 연산 알고리즘 ­ 스택이 가득 차있는지를 검사함. ­ top을 (MAX_STACK_SIZE
-1)과 비교하여 같으면 포화상태임. 학습자님의  

4) 스택의 push 연산 알고리즘 ­ 스택에  요소  삽입  전에  포화상태를  검사함.  is_full()을  호출하여  검사함.  먼저  top값을  증 가하고 요소를 삽입함.
5) 스택의 pop 연산 알고리즘 ­ top이 가리키는 요소를 스택에서 꺼내어 외부로 전달함. ­ 먼저 요소 삭제전에 빈 스택인지를 검사함. ­ is_empty()를 호출하여 검사함. ­ 빈 스텍이면 오류 메시지 출력한다.  아니면 top이 가리키는 요소를 반환하고 top을 하나 감소함.  ▶ 스택을 C언어의 배열로 구현 v 스택을 C언어의 배열로 구현
Ÿ 전역변수로 구현하는 방법
Ÿ 구조체 배열로 구현하는 방법
Ÿ 관련된 데이터를 함수의 매개변수로 전달하는 방법

1) 전역변수로 구현하는 방법  ­ 배열이나 top변수를 함수의 매개변수로 전달하지 않음. ­ 전역변수 사용은 프로그램을 복잡하게 만들어 오류발생 가능성이 큼. 학습자님의  
2) 정수배열 스택 프로그램 학습자님의   학습자님의  
3) 구조체 배열 스택 프로그램 ­ 스택 요소가 정수나 문자가 아니고 복잡한 구조를 갖는 요소 ­ 학생의 학번, 이름, 주소 등 요소 ­ 스택의 요소를 구조체로 선언함. 학습자님의  
4) 관련된 데이터를 함수의 매개변수로 전달하는 방법 ­ 전체 프로그램에서 여러 개의 스택을 사용하기가 어려움. ­ top과 stack배열을 하나의 구조체를 결합해서 새로운 구조체 타입 선언함. ­ 이 구조체의 포인터를 각 함수의 매개변수로 전달함. ­ 전달된 구조체 포인터가 s인 경우, 기존 top을 s
->top으로 변경함. ­ stack배열도 s
->stack으로 변경 사용함. ­ StackType타입 구조체 생성 초기화에 init()함수 필요함. 학습자님의  

5) 일반적인 배열 스택 프로그램 학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.117~187 학습자님의   스택 2 1. 배열과 연결리스트의 2가지 구현방법을 이해하고, 이를  6주차  수업목표   SW코딩에 적용할 수 있다. 2교시  1. 연결리스트로 구현한 스택 세부내용  2. 괄호검사 프로그램  1. 연결리스트로 구현한 스택 ▶ 연결리스트로 구현한 스택
1) 연결리스트로 구현한 스택 ­ 연결된 스택(inked stack)이라고 함. ­ 외부에서는 다른 스택방법과 차이가 없음. ­ 외부 인터페이스는 동일하고, 내부 구현이 다름. ­ 장점 : 크기가 제한되지 않음. ­ 단점 : 구현이 복잡하고 삽입, 삭제 시간이 오래 걸림. ­ 연결리스트는 데이터필드와 링크필드(포인터)로 구분됨. ­ top은 정수가 아니고, 노드를 가리키는 포인터로 선언됨. ­ LinkedStackType 구조체 타입으로 정의
2) 연결리스트 스택에 삽입(push)연산 ­ 단순연결리스트의 맨 앞에 데이터를 삽입과 동일함.     학습자님의  
3) 연결리스트 스택에 삭제(pop) 연산 ­ top의 값을 top
->link로 바꾸고, 기존의 top이 가리키는 노드를 동적 메모리 해제함. ­ 연결리스트에서 공백상태는 top포인터가 NULL인 경우임. ­ 연결리스트에서 포화상태는 동적메모리 할당만 되면 노드를 생성할 수 있음.   학습자님의  

4) 연결된 스택 프로그램 예 학습자님의   학습자님의   2. 괄호검사 프로그램 ▶ 괄호검사 프로그램
1) 괄호검사 ­ 프로그램에서 여러 가지 타입의 괄호가 쌍으로 사용됨. ­ 대괄호 [], 중괄호 {}, 소괄호 () 등이 사용됨.
① 괄호 검사의 3가지 조건 ­ 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다. ­ 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다. ­ 괄호 사이에는 포함 관계만 존재한다.
② 잘못된 괄호 사용의 예  ▶ 괄호 검사 알고리즘 ­ 문자열의 괄호를 차례대로 조사하여 왼쪽 괄호를 만나면 스택에 삽입함. ­ 오른쪽 괄호를 만나면 스택에서 top괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지 검사함. ­ 스택이 비어 있는 경우는 조건1, 조건2 등을 위반이고, 괄호 짝이 맞지 않으면 조건 3 위반임. ­ 마지막 괄호까지  조사한 후 스택에 괄호가  남아 있으면, 조건1  위반으로  0(거짓) 반환,  아 니면 1(참) 반환함. 학습자님의   ▶ C언어 괄호검사 프로그램 학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.187~196 학습자님의   스택 3

1. 스택  응용프로그램을  제작할  수  있는  능력을  배양하고,  이를  6주차  수업목표   SW코딩에 적용할 수 있다. 3교시 
① 수식 계산 프로그램 세부내용 
② 미로탐색 프로그램  1. 수식 계산 프로그램 ▶ 수식의 계산

1) 수식의 표기방법 : 전위(prefix), 증위(infix), 후위(postfix) 중위 표기법 전위 표기법 후위 표기법 2+3*4 +2*34 234*+ a*b+5 +5*ab Ab*5+ (1+2)+7 +7+12 12+7+ ­ 중위표기법 : 연산자가 피연산자 사이에 있음. ­ 전위표기법 : 연산자가 피연산자 앞에 있음. ­ 후위표기법 : 연산자가 피연산자 뒤에 있음. ▶ 컴퓨터에서 수식의 계산 순서 ­ 중위표기식 → 후위표기식 → 계산 (2+3*4 → 234*+ → 14) ­ 모두 스택을 사용함. ▶ 수식의 계산
1) 후위표기법의 계산 ­ 수식을 왼쪽에서 오른쪽으로 스캔하여 피연산자이면 스택에 저장함. ­ 연산자이면 필요한 수만큼의 피연산자를 스택에서 꺼내 연산을 실행함. ­ 연산의 결과를 다시 스택에 저장함. (예) 82/3
-32*+ 학습자님의   ▶ 후위표기법 계산 알고리즘 ▶ 알고리즘을 C언어로 구현 학습자님의   학습자님의   ▶ 중위 표기 수식을 후위 표기 수식으로 변환

1) 중위표기법과 후위표기법의 공통점 ­ 피연산자들의 순서는 동일함.  ­ 연산자들의 순서만 다르다.(우선순위 순서)
Ÿ 연산자만 스택에 저장했다가 출력하면 된다.
Ÿ 2+3*7 
-> 234*+ ▶ 후위표기법 알고리즘 ­ 피연산자를 만나면 그대로 출력함. ­ 연산자를 만나면 스택에 저장했다가  스택보다 우선순위가 낮은 연산자가 나오면 출력함. ­ 왼쪽 괄호는 우선순위가 가장 낮은 연산자로 취급함. ­ 오른쪽 괄호가 나오면 스택에서 왼쪽 괄호 위에  쌓여있는 모든 연산자를 출력함.   학습자님의   ▶ 중위표기 수식을 후위표기 수식으로 변환하는 알고리즘 ▶ 중위표기 수식을 후위표기 수식으로 변환하는 프로그램 학습자님의   학습자님의   학습자님의   학습자님의   2. 미로탐색 프로그램 ▶ 미로탐색 문제 ­ 미로는 서로 연결된 여러 개의 작은 방 또는 칸으로 구성됨. ­ 미로 탐색의 기본적인 방법은 시행착오 방법임. ­ 탐색한 경로를 저장은 가장 최근에 방문한 경로를 쉽게 추출하는 방법을 사용함. ▶ 스택을 이용한 미로탐색 ­ 처음 스택은 공백상태임. ­ 현재 위치에서 위, 아래, 왼쪽, 오른쪽을 판단함. ­ 아직 방문전이고 갈 수 있는 위치는 스택에 삽입함. ­ 스텍에서 하나의 위치를 가져다가 그 위치를 현재 위치로 하여 갈 수 있는 곳을 탐색함. ­ 갈 수 있는 곳 모두를 스택에 저장함. ­ 위 순서를 반복하여 출구를 찾음. ▶ 미로의 배열 표현 ­ 배열의 값이 0이면 갈수 있는 길이다. ­ 배열의 값이 1이면 갈수 없는 길이다. ­ 출구는 x로 표시, 현재 위치는 m으로 표시함.    학습자님의   ▶ 미로탐색 프로그램 ­ 2차원 배열로 입력함. ­ 현재 위치는 (행, 열)의 좌표값으로 표시함. ­ (행, 열)좌표를 저장할 수 있는 구조체를 만듦. 학습자님의   학습자님의   학습자님의   ▶ 미로탐색 프로그램 : 실행결과화면 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.196~213 학습자님의   큐 (Queue) 1 수업목표   1. 큐의 개념, 추상데이터 타입을 이해하고, 이를 설명할 수 있다. 7주차 
① 큐의 추상데이터 타입 1교시 
② 추상 자료형 큐 연산 세부내용 
③ 큐의 삽입, 삭제 연산들
④ 배열로 구현된 큐 : 선형 큐 1. 큐의 추상데이터 타입 ▶ 큐의 추상데이터 타입 ­ 큐 : 먼저 들어온 데이터가 먼저 나가는 자료구조 ­ 선입선출(ex)Iex)O: ex)irst
-In ex)irst
-Out) : 예) 매표소의 대기열 ­ 큐는 뒤에서 새로운 데이터 추가되고 앞에서 삭제됨.
① 후단(rear) : 삽입이 발생하는 곳
② 전단(front) : 삭제가 발생하는 곳 2. 추상 자료형 큐 연산 ▶ 추상 자료형 큐 연산

1) 큐의 추상데이터 타입 ­ is_empty연산 : 큐가 공백이면 TRUE, 아니면 ex)ALSE 반환 ­ is_full연산 : 큐가 포화이면 TRUE, 아니면 ex)ALSE 반환 학습자님의   3. 큐의 삽입, 삭제 연산들 ▶ 큐의 삽입, 삭제 연산들
1) 가장 중요한 연산 : 삽입(enqueue), 삭제(dequeue)
Ÿ enqueue 연산은 큐의 요소를 추가하는 연산,  큐의 맨 뒤에 새로운 요소 추가
Ÿ dequeue 연산은 큐의 맨 앞에서 요소를 꺼내서  외부로 반환
Ÿ 삽입, 삭제가 큐의 양끝에서 발생
Ÿ rear변수 : 삽입과 관련된 변수 
Ÿ front변수 : 삭제와 관련된 변수

2) 사용 예 : 시뮬레이션 ­ 은행의 대기열 ­ 공항의 이륙하는 비행기 ­ 인터넷 전송 데이터 패킷 모델링 ­ 운영체제, 컴퓨터와 주변기기 사이 큐 존재 ­ 프린터 버퍼 ­ 키보드
3) 큐의 구현 방법 ­ 배열을 이용한 방법 ­ 연결리스트를 이용한 방법 학습자님의   4. 배열로 구현된 큐 : 선형 큐 ▶ 배열로 구현된 큐
1) 선형큐 : 1차원 배열을 사용하는 방법 ­ 정수 1차원 배열 정의 ­ 삽입, 삭제 변수 front, rear 생성
Ÿ front : 큐의 첫 요소
Ÿ rear : 큐의 마지막 요소
Ÿ front와 rear의 초기값은 ­1
Ÿ 데이터 삽입은 rear를 1 증가시키고  그 자리에 데이터 저장
Ÿ 데이터 삭제는 front를 1 증가시키고  가리키는 자리의 데이터 삭제

2) 선형큐의 문제점 ­ front와  rear의  값이  계속  증가만  하기  때문에  배열의  끝에  도달하면  배열의  앞이  비었어 도 사용하지 못함. ­ 주기적으로 모든 요소를 왼쪽으로 이동시켜야 함.     v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.217~222 학습자님의   큐 (Queue) 2
1. 배열과 연결리스트의 2가지 구현방법을 SW코딩에 적용하여 프 수업목표   7주차  로그램을 할 수 있다. 2교시 
① 배열로 구현된 큐 : 원형 큐 세부내용 
② 연결리스트로 구현된 큐
③ 연결된 큐(삽입, 삭제, 프로그램 등) 1. 배열로 구현된 큐 : 원형 큐 ▶ 원형 큐

1) 원형 큐  선형 큐의 문제를 해결 ­ 배열을 선형으로 보지 않고 원형으로 보면 해결 ­ front와 rear의 값이 배열의 끝에(MAX_QUEUE_SIZE
-1)  도달하면 다음에 증가되는 값은 0이 되면 원형큐가 됨. ­ 큐의 전단과 후단을 관리 : 2개의 변수 필요 ­ 원형큐에서는 front와 rear의 초기값이 ­1이 아니라 0이 됨. ­ front는 항상 큐의 첫 요소의 하나 앞을 가리킴. ­ rear는 마지막 요소를 가리킴.

2) 원형큐의 삽입 삭제 과정 ­ front, rear 초기값 0 ­ 삽입 시 rear가 먼저 증가하고, 증가한 위치에 데이터 삽입 ­ 삭제 시 front가 먼저 증가하고, 증가한 위치의 데이터 삭제    학습자님의  
3) 공백상태, 포화상태 공백상태 front == rear front가 rear보다 하나 앞에 있음. 포화상태 front % M == (rear+1 % M) ­ 원형큐는 항상 한 자리는 비워둠. 공백상태와 포화상태를 구분함.  학습자님의   ▶ 원형 큐의 삽입, 삭제 알고리즘 ­ 삽입, 삭제를 하기 전에 front와 rear를 원형으로 회전 ­ 회전 후 하나 증가, 증가된 위치의 테이터 삽입, 삭제함. ­ 나머지 연산자 mod 이용 인덱스를 원형으로 회전하여 구현 front <
- (front+1) mod MAX_QUEUE_SIZE; rear <
- (rear+1) mod MAX_QUEUE_SIZE;
Ÿ front와 rear 값은 (MAX_QUEUE_SIZE
-1)에서 1증가하면 0이 됨.
Ÿ 예 : MAX_QUEUE_SIZE = 5 정의, front, rear 값은 0, 1, 2, 3, 4, 0으로 변화 ▶ 원형 큐의 구현 ­ front는 첫 요소부터 시계 방향으로 하나 앞을 가리킴. ­ rear는 마지막 요소를 가리킨다.  삽입 시는 무조건 rear를 증가, 그 위치에 삽입  삭제 시에도 front를 무조건 증가, 그 위치 데이터 삭제 학습자님의   ▶ 원형 큐 프로그램 학습자님의   학습자님의   2. 연결리스트로 구현된 큐 ▶ 연결된 큐(linked queue) : 연결리스트로 구현된 큐 ­ 배열로 구현된 큐에 비해 크기가 제한되지 않는 장점 ­ 코드가 복잡하고 링크 필드로 메모리를 더 많이 사용 ­ front 포인터는 삭제와 관련되며 rear 포인터는 삽입과 관련 ­ front는 연결리스트의 맨 앞 요소 가리킴. ­ rear는 포인터는 맨 뒤 요소 가리킴. ­ 큐에 요소가 없는 경우는 front와 rear는 NULL    3. 연결된 큐(삽입, 삭제, 프로그램 등) ▶ 연결된 큐에서 삽입과 삭제

1) 삽입연산 ­ 동적 메모리 할당으로 새로운 노드를 생성하고 데이터를 저장하고 연결리스트의 끝에 새로 운 노드를 추가
① 연결된 큐가 공백상태일 때의 삽입연산 ­ 큐가 공백상태이면(즉 front와 rear가 모두 NULL이면)  front와 rear 모두 새로운 노드를 가리킴.
② 연결된 큐가 공백상태가 아닐 때의 삽입연산 ­ 큐가  기존  노드가  있는  경우라면  rear가  가리키는  노드의  링크필드가  새로운  노드를  가리 키고, rear가 이 새로운 노드를 가리키도록 변경함.  학습자님의  

2) 연결된 큐 삽입 연산
3) 삭제연산 ­ 연결리스트 처음에서 노드를 꺼내오면 됨. ­ 먼저 큐가 공백인지 검사함. ­ 공백상태이면 오류 발생 종료 ­ 공백상태가 아니면 front가 가리키는 노드를 temp로  ­ front는 front의 링크 값을 설정 ­ 이 결과 front는 전 노드의 다음 노드를 가리킴. ­ temp로 노드로부터 데이터를 가져오고 동적메모리 해제로 노드 삭제
① 공백상태가 아닌 연결된 큐에서의 삭제연산 
② 노드가 하나 있는 연결된 큐에서의 삭제연산  학습자님의  

4) 연결된 큐의 삭제연산 ▶ 연결된 큐 프로그램 ­ 공백상태 검사는 front나 rear가 NULL이면 공백상태임. ­ 포화상태는 없기에 (메모리 할당 과정에서 오류가 없으면) 포화상태 없음. ­ 포화 상태 검출 함수는 is_full 함수 고려하지 않음. 학습자님의   학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.105~166 v C로 배우는 쉬운 자료구조, 이지영, pp.98~104 학습자님의   큐 (Queue) 3
1. 덱의  개념을  이해하고,  큐를  SW코딩에  적용하여  프로그램을  수업목표   7주차  할 수 있다. 3교시 
① 덱의 소개 세부내용 
② 덱의 추상데이터 타입, 삽입, 삭제 연산 프로그램
③ 큐의 응용 : 버퍼, 시뮬레이션 1. 덱의 소개 ▶ 덱의 소개

1) 덱(deque) ­ double
-ended queue의 약자 ­ 큐의 전단과 후단에서 모두 삽입과 삭제가 가능한 큐

2) 덱의 구조 ­ 덱은 스택과 큐의 연산을 모두 가짐. ­ add_front, delete_front 연산은 스택의 push, pop연산과 같음. ­ add_rear, delete_front 연산은 큐의 enqueue, dequeue 연산과 같음.  추가로 덱은 get_front, get_rear, delete_rear가 있음. 2. 덱의 추상데이터 타입, 삽입, 삭제 연산 프로그램 ▶ 덱 추상데이터타입
1) 덱 추상데이터타입 ­ 덱의 삽입연산  push_front,  push_back ­ 덱의 삭제연산  pop_front,  pop_back 학습자님의   ▶ 덱에서의 연산 수행결과 ▶ 덱의 구현 ­ 덱은 이중 연결리스트로 구현함. ­ 전단, 후단 모두 삽입 삭제 발생으로 양방향 링크가 연결리스트의 첫 노드와 마지막 노드의  포인터를 동시에 필요
Ÿ head : 첫 노드를 가리키는 변수
Ÿ tail : 마지막 노드를 가리키는 변수
Ÿ DequeType : head, tail을 구조체로 묶어서 사용 학습자님의   ▶ 삽입연산

1) 삽입연산 ­ add_rear연산은 노드를 동적 생성하고 이 노드를 tail 포인터를 이용 덱에 연결     
2) 덱에서의 삽입연산 add_rear ­ create_node 함수 제작 사용 ­ 이 함수는 1 노드를 동적메모리 할당으로 생성 ­ 생성된 노드의 llink와 rlink값을 함수 매개변수 값으로 설정 ­ add_front 함수도 위와 같이 앞쪽 노드를 삽입 학습자님의  
3) 덱에서의 삽입연산 add_front ▶ 삭제연산
1) 삭제연산 ­ 덱의 삭제연산은 큐의 삭제연산과 비슷함. ­ delete_front 함수는 첫 노드 삭제의 경우  ­ 덱이 공백상태가 아니면 새로운 첫 노드의 llink 필드를 NULL로 결정 ­ 공백상태의 경우는 tail포인터도 NULL로 결정 ­ delete_rear함수도 위와 같이 노드 삭제 학습자님의  
2) 덱에서의 삭제연산 delete_front
3) 덱에서의 삭제연산 delete_rear ▶ 덱 전체 프로그램 ­ 덱에 데이터 삽입 삭제하는 완전한 프로그램임. ­ 덱을 사용하기 전에 초기화함. 학습자님의  
Ÿ 초기화 함수 : head, tail 포인터를 NULL로 설정함.
Ÿ is_empty함수 : head, tail 포인터가 NULL 검사 학습자님의   학습자님의   학습자님의   2. 큐의 응용 : 버퍼, 시뮬레이션 ▶ 큐의 응용 : 버퍼 ­ 큐는 서로 다른 속도로 실행되는 두 프로세스 간의 상호 작용을 조화시키는 버퍼 역할을 담
Ÿ CPU와 프린터 사이의 프린팅 버퍼, CPU와 키보드 사이의 키보드 버퍼 등
Ÿ 데이터를 생산하는 생산자 프로세스
Ÿ 데이터를 소비하는 소비자 프로세스
Ÿ 이 두 프로세스 사이에 큐로 구성되는 버퍼 존재 학습자님의   ▶ 큐의 응용 : 버퍼 ­ 생산자와 소비자가 동시에 프로세스 수행의 경우  ­ 공유되는 큐를 동시 접근 문제 발생 ­ 이 경우 큐를 사용하기 전 큐 사용을 알리는 락(lock)을 걺. ▶ 큐의 응용 : 시뮬레이션 ­ 큐잉 이론에 따라 시스템의 특성을 시뮬레이션하여 분석에 이용 ­ 큐잉 모델은 고객에 대한 서비스를 수행하는 서버와 서비스를 받는 고객으로 이루어짐. ­ 은행에서 고객이 들어와서 서비스를 받고 나가는 과정을 시뮬레이션
Ÿ 고객들이 기다리는 평균시간을 계산 학습자님의   ­ 시뮬레이션은 하나의 반복 루포 ­ 현재시각을 나타내는 clock이라는 변수를 하나 증가 ­ is_customer_arrived함수를 호출함.
Ÿ is_customer_arrived 함수는 랜덤 숫자를 생성하여 시뮬레이션 파라미터 변수인 arrival_prov와 비교하여 작으면 새로운 고객이 들어왔다고 판단함. ­ 고객의 아이디, 도착시간, 서비스 시간 등의 정보를 만들어 구조체에 복사하고 이 구조체를  파라미터로 하여 큐의 삽입 함수 enqueue()를 호출함. ­ 고객이 필요로 하는 서비스 시간은 역시 랜덤 숫자를 이용하여 생성 ­ 지금 서비스하고 있는 고객이 끝났는지를 검사 
Ÿ 만약 service_time이 0이 아니면 어떤 고객이 지금 서비스를 받고 있는 중임을 의미함. ­ clock이 하나 증가했으므로 service_time을 하나 감소시킴. ­ 만약  service_time이  0이면  현재  서비스  받는  고객이  없다는  것을  의미함.  따라서  큐에서  고객 구조체를 하나 꺼내어 서비스를 시작함. ▶ 은행 서비스 시뮬레이션 프로그램 학습자님의   학습자님의   학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.222~246 학습자님의   트리 1 9주차  수업목표  

1. 트리의 개념과 이진트리의 소개와 표현에 대하여 설명할 수 있다. 1교시 
① 트리의 개념, 용어들, 종류 세부내용 
② 이진트리의 개념, 성질, 분류, 표현 1. 트리의 개념 ▶ 트리의 개념 ­ 계층적인 자료를 표현하는 자료구조 ­ 리스트, 스택, 큐 등은 선형자료구조임. ­ 트리는 부모
-자식 관계의 노드들로 이루어짐. ­ 응용분야 : 전형적인 예 ⇛ 회사의 조직구조
① 컴퓨터 디스크의 디렉토리 구조 
② 인공지능에서의 결정 트리(decision tree)  학습자님의   ▶ 트리에서 나타나는 용어들 노드(node)  트리의 구성요소 A, B, C, D, E, ex), G, H, I, J 부모가 없는 노드  루트(root)  {A} 하나의 노드와 그 노드들의 자손들로 이루어진 트리 서브트리(subtree)  {B, E, ex), G} {C, H} {D, I, J} 간선(edge)  루트와 서브트리를 연결하는 선 ­ 자식, 부모, 형제, 조상, 자손노드는 인간관계와 동일함. 부모노드 A는 B, C, D의 부모노드 자식노드 B, C, D는 A의 자식노드 형제노드 B와 C와 D는 형제노드
Ÿ 단말노드(terminal node) : 자식이 없는 노드 (E,ex),G,H,I,J) 
Ÿ 비단말노드 : 적어도 하나의 자식을 가지는 노드(A,B,C,D)  
Ÿ 레벨(level) : 트리의 각층의 번호로 루트부터 1로 시작함.
Ÿ 높이(height) : 트리의 최대 레벨로 위 그림은 3임.
Ÿ 차수(degree) : 노드가 가지고 있는 자식 노드의 개수를 의미함.               A와 B 노드의 차수가 3으로 가장 크므로 전체 트리의 차수가 3임.
Ÿ 포리스트(forest) : 나무가 모이면 숲이 되듯이 트리의 집합을 말함. 학습자님의   ▶ 예제
Ÿ A : 루트노드
Ÿ B : D와 E의 부모노드
Ÿ C : B의 형제노드
Ÿ D와 E : B의 자식노드
Ÿ B의 차수 : 2
Ÿ 트리의 높이 : 4
Ÿ 트리의 차수 : 3 ▶ 트리의 종류

1) 일반트리  ­ 각 노드가 데이터를 저장하는 데이터필드와 자식노드를 가리키는 링크필드를 가지는 트리  ­ 자식노드의 개수에 따라서 링크 필드의 개수가 달라짐. ­ 일반트리는 노드의 개수가 고정되지 않음. (단점)
2) 이진트리  ­ 자식노드의 개수가 2인 트리 2. 이진트리의 개념, 성질, 분류, 표현 ▶ 이진트리 소개
1) 이진트리 (binary tree) : 모든 노드가 2개의 서브트리를 가지고 있는 트리 ­ 이진트리의 서브트리는 공집합일 수 있음. ­ 이진트리의 노드에는 최대 2개까지의 자식노드가 존재함. ­ 모든 노드의 차수가 2이하가 됨. ⇨ 구현하기가 편리함. ­ 이진트리에는 서브트리 간의 순서가 존재함. ­ 왼쪽 서브트리와 오른쪽 서브트리는 서로 구별됨. 학습자님의   ▶ 이진트리의 정의
1. 공집합이거나
2. 루트와 왼쪽 서브트리, 오른쪽 서브트리로 구성된 노드들의 유한집합 ­ 이진트리의 서브트리들은 모두 이진트리이어야 함. ▶ 이진트리의 검증 : 다음 트리가 이진트리인지를 확인하여 보자
Ÿ 아래부터 위로 확인하여 검증함.
Ÿ 먼저  SUB3을  확인하면  노드D만으로  이루어져  있음.  만약  노드D를  루트라고  보면,  SUB3의  서브트리는  공집합임.  정의 

1)에  의하여  공집합도  이진트리이므로  정의 
2)에  의하여 SUB3은 루트와 공집합 서브트리 2개를 가지는 이진트리임.
Ÿ SUB2도 SUB3과 같이 이진트리임.
Ÿ SUB1은 SUB1의 루트노드 B와 서브트리 SUB3과 공집합 서브트리를 가지므로 이진트 리임.
Ÿ 전체트리는 루트노드 A와 SUB1, SUB2의 두 개의 서브트리를 가짐.이 두 개의 서브트 리가 이진트리이므로 전체트리도 이진트리임. ▶ 이진트리와 일반트리의 차이점

1) 이진트리와 일반트리의 차이점 ­ 이진트리의 모든 노드는 차수가 2이하임. 즉 자식노드의 개수가 2이하임. 반면 일반트리는  자식노드의 개수에 제한이 없음. ­ 일반트리와는 달리 이진트리는 노드를 하나도 갖지 않을 수도 있음. ­ 서브트리 간에 순서가 존재한다는 점도 다른 점임. 따라서 왼쪽 서브트리와 오른쪽 서브트 리를 구별함.
① 이진트리 예로 수식을 표현하는 이진트리 (a+b) + (c/d)
Ÿ 각 연산자들은 하나 또는 2개의 피연산자를 가짐.
Ÿ 왼쪽 피연산자는 왼쪽 서브트리가 되고, 오른쪽 피연산 자는 오른쪽 서브트리가 됨. 
Ÿ 단말노드는 상수이거나 변수임.   학습자님의   ▶ 이진트리의 성질

1) 이진트리의 성질 ­ 이진트리는 노드의 개수가 n개이면 간선의 개수는 n
-1개임. ­ 이진트리에서 노드는 루트를 제외하고는 하나의 부모노드를 가짐. 부모와 자식 간에는 하나 의 간선만이 존재함.

2) 높이가 h인 이진트리의 경우 ­ 최소 h개의 노드를 가지며, 최대 2h ­1개의 노드를 가짐. 이유는 한 레벨에는 적어도 하나 의 노드가 존재해야 하므로, 따라서 높이가 h인 이진트리는 h개의 노드를 가짐. 그리고 하 나의 노드는 최대 2개의 자식을 가지므로 레벨 i의 최대 노드의 개수는 2i ­1임. 따라서 전  체 노드의 개수는    임.   ­ n개의  노드를  가지는  이진트리의  높이는  최대  n이거나  최소  [log (n+1)]임.  이유는  레벨  2 당 최소한 하나의 노드가 필요하므로 높이가 n을 초과하지 못함.  그리고 높이 h의 이진트리가 가질 수 있는 최대 노드 값은 2h
-1임.  따라서 ≤이 성립하고 양변에 log를 취하면 ≥ 임.  학습자님의   ▶ 이진트리의 분류
Ÿ 포화이진트리(full binary tree)
Ÿ 완전이진트리(complete binary tree)
Ÿ 기타이진트리

1) 포화이진트리 ­ 트리의 각 레벨에 노드가 꽉 차 있는 이진트리 ­ 높이가 k인 포화이진트리는 정확하게 2k
-1개의 노드를 가짐. ­ 노드의 개수의 계산은      전체 노드 개수 :      
① 포화이진트리에는 다음과 같이 각 노드에 번호를 붙일 수 있음. ­ 번호  부여방법은  레벨  단위로  왼쪽에서  오른쪽으로  번호를  붙임.  이것은  항상  일정하므로  루트의 오른쪽 자식노드의 번호는 항상 3임.
Ÿ 높이가 4인 노드의 개수  : 21
-1 + 22
-1 + 23
-1  + 24
-1 = 15 

2) 완전이진트리 ­ 높이가  k일  때  레벨  1부터  k
-1레벨까지는  노드가  모두  채워져  있고  마지막  레벨  k에서는  왼쪽부터 오른쪽으로 노드가 순서대로 채워져 있는 이진트리 ­ 포화이진트리와 노드번호가 일치함. ­ 마지막 레벨에서는 노드가 비어있어도 되지만, 중간 레벨에서는 비어서는 안 됨. 학습자님의   ▶ 이진트리의 표현
Ÿ 배열을 이용하는 방법
Ÿ 포인터를 이용하는 방법

1) 배열 표현법 ­ 포화이진트리나 완전이진트리의 경우 사용하는 방법 ­ 완전이진트리로  가정하고,  이진트리의  높이가  k  이면  최대  2k
-1개의  공간  연속적으로  할당 하고 완전이진트리의 번호대로 노드들을 저장함. ­ 예 : 노드들은 먼저 번호를 지정한 후, 이 번호에 따라서 배열에 저장함. ­ 노드 A는 번호가 1이므로 배열의 인덱스 1에 저장함. ­ 배열의 인덱스 0은 사용하지 않음. 이것이 더 편함. ­ 일반이진트리는 저장 공간의 낭비가 심해짐. [ 부모와 자식의 인덱스 관계 ]
Ÿ 배열표현법에서는 인덱스만 알면 부모와 자식을 쉽게 알 수 있음.
Ÿ 노드 i의 부모노드 인덱스 = i/2, 노드 B의 인덱스 2이고 부모노드 A 인덱스는 1
Ÿ 노드 i의 왼쪽자식노드 인덱스 = 2i,  
Ÿ 노드 i의 오른쪽 자식노드 인덱스 = 2i+1

2) 링크표현법  ­ 노드가 구조체로 표현되고, 하나의 노드가 데이터를 저장하는 필드와 왼쪽 자식노드와 오른 쪽 자식노드를 가리키는 2개의 포인터 필드를 가짐. 이 2개의 포인터를 이용하여 부모노드 와 자식노드를 연결함. 학습자님의   [ 링크의 구현 ]
Ÿ 노드는 구조체로 표현
Ÿ 링크는 포인터로 표현 [ 링크표현법으로 생성한 이진트리 프로그램 ] v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.251~264 학습자님의   트리 2

1. 이진트리의  순회, 연산,  스레드의  동작원리를  이해하고,  코딩에  수업목표   적용할 수 있다. 9주차 
① 이진트리 순회방법 : 전위 순회, 중위 순회, 후위 순회 2교시 
② 순회  프로그램,  수식트리  계산  프로그램,  디렉터리  용량  계산  세부내용  프로그램
③ 이진트리 연산방법, 노드의 개수, 높이구하기 알고리즘
④ 스레드 이진트리 순회 프로그램 1. 이진트리순회방법 : 전위 순회, 중위 순회, 후위 순회 ▶ 이진트리의 순회

1) 순회(traversal) ­ 링크표현법의 트리는 루트노드의 포인터만 알면 트리 안의 모든 노드에 접근 가능함. ­ 연결리스트와  매우  비슷하며,  연결리스트는  1차원적  연결이고,  링크표현법은  2차원적  연결  구조임. ­ 이진트리도 데이터 저장 방법인 자료구조임. ­ 데이터는 노드의 데이터필드를 이용하여 저장함. ­ 이진트리의  순회는  이진트리에  속하는  모든  노드를  한  번씩  방문하여  노드가  가지고  있는  데이터를 목적에 맞게 처리하는 것임. ­ 트리 사용 목적은 트리의 노드에 자료를 저장하고 필요에 따라서 이 자료를 처리하는 것임. ­ 이진트리의 순회는 중요한 연산임. ­ 순회의 방법은 여러 가지가 있음. ▶ 이진트리 순회방법 [ 3가지의 기본적인 순회방법 ]
Ÿ 루트와 왼쪽 서브트리, 오른쪽 서브트리 중에서 루트를 언제 방문하느냐에 구분함.
Ÿ 루트 방문을 V, 왼쪽 서브트리 방문을 L, 오른쪽 서브트리 방문을 R이라고 함. ­ preorder traversal : VLR 전위 순회 ­ 자식 노드보다 루트 노드를 먼저 방문함. ­ inorder traversal : LVR 중위 순회 ­ 왼쪽 자식, 루트, 오른쪽 자식 순으로 방문함. ­ preorder traversal : LRV 후위 순회 ­ 자식 노드보다 루트 노드를 먼저 방문함.       학습자님의   ▶ 전위순회

1) 전위순회 ­ 순환호출을 사용함. ­ 루트노드를 방문함. ­ 왼쪽 서브트리를 방문함. ­ 오른쪽 서브트리를 방문함.
2) 전위순회 알고리즘 
Ÿ 노드x가 NULL이면 더 이상 순환호출을 하지 않음.
Ÿ 아니면 x의 데이터를 출력함.
Ÿ x의 왼쪽 서브트리를 순환 호출하여 방문함.
Ÿ x의 오른쪽 서브트리를 순환 호출하여 방문함.

3) 전위순회 응용 : (예) 전위순회의 방문순서 학습자님의   ▶ 중위순회
1) 중위순회 ­ 왼쪽 서브트리를 방문함. ­ 루트노드를 방문함. ­ 오른쪽 서브트리를 방문함. ­ 순환 호출을 이용함.
2) 중위순회 알고리즘
Ÿ 노드x가 NULL이면 더 이상 순환호출을 하지 않음.
Ÿ x의 왼쪽 서브트리를 순환호출하여 방문함.
Ÿ x의 데이터를 출력함.
Ÿ x의 오른쪽 서브트리를 순환호출하여 방문함.  

3) 중위순회 응용 : (예) 수식트리 학습자님의   ▶ 후위순회
1) 후위순회 ­ 왼쪽 서브노트리를 방문함. ­ 오른쪽 서브트리를 방문함. ­ 루트노드를 방문함. ­ 순환호출을 이용함. 
2) 후위순회 알고리즘
Ÿ 노드x가 NULL이면 더 이상 순환호출을 하지 않음.
Ÿ x의 왼쪽 서브트리를 순환호출하여 방문함.
Ÿ x의 오른쪽 서브트리를 순한호출하여 방문함.
Ÿ x의 데이터를 출력함.

3) 후위순회 응용 : (예) 디렉토리 용량 계산 ▶ 전위, 중위, 후위 순회의 선택방법 ­ 순서가 중요하지 않고 노드를 전부 방문하면 되는 경우는 3가지 중 어느 방법을 선택해도 됨. ­ 자식노드를 처리하고 부모노드를 처리해야 하는 경우는 후위순회를 선택함. ­ 부모노드를 처리하고 자식노드를 처리해야 하는 경우는 전위순회를 선택함. ­ 디렉터리 용량 계산의 경우는 하위 디렉터리의 용량이 계산되어야 현재의 디렉터리 용량을  계산할 수 있기에 후위순회를 선택함. 학습자님의   ▶ 전위, 중위, 후위 순회 구현 ­ C언어 함수로 구현 ­ 트리가 링크표현법으로 표현되는 경우 함수의 매개변수는 루트를 가리키는 포인터임. ­ 왼쪽이나 오른쪽 서브트리를 방문하는 것은 전체 트리를 방문하는 것과 같음. ­ 서브트리 방문의 경우는 서브트리의 루트노드 포인터를 함수의 매개변수로 전달함.   2. 순회 프로그램, 수식트리 계산 프로그램, 디렉터리 용량 계산 프로그램 ▶ 순회프로그램
1) 순회프로그램 학습자님의  
2) 레벨순회 ­ 각 노드를 레벨 순으로 순회하는 방법 ­ 지금까지의 순회법은 스택을 사용하였음. ­ 레벨순회는 큐를 사용하는 순회법임.
Ÿ 먼저 큐에 있는 노드를 꺼내서 방문함.
Ÿ 그 노드의 자식노드를 큐에 삽입함.
Ÿ 큐에 노드가 없을 때까지 반복함.
Ÿ 그림에서 +노드가 큐에 입력된 상태로 순회 시작
Ÿ 큐에서 하나를 꺼내면 +가 나오고 노드+를 방문함.
Ÿ 노드+의 자식노드인 노드*와 노드/를 큐에 삽입함. 이를 계속 반복함.

3) 레벨순회 알고리즘 학습자님의   [ 알고리즘 설명 ]
Ÿ 큐를 초기화함. 트리 root가 NULL이면 종료함. 트리 root의 루트노드를 큐에 삽입함. 
Ÿ 큐가 공백 상태가 될 때까지 계속 다음을 반복함. 
Ÿ 큐에서 맨 처음에 있는 노드를 x로 가져옴. 
Ÿ x의  데이터  값을  출력하고  x의  왼쪽  자식이  NULL이  아니면  z에  삽입함.  x의  오른쪽  자식이 NULL이 아니면 큐에 삽입함. ▶ 수식트리 계산 프로그램

1) 이진트리 순회응용 : 수식트리
Ÿ 비단말노드 : 연산자(operator) ­ 산술식을 트리 형태로 표현한 것
Ÿ 단말노드 : 피연산자(operaand)
① 예) 수식 a+b a
-(b×c) (a<b) or (c<d) 전위 순회 +ab
-a×bc or<ab<cd 중위 순회 a+b a
-(b×c) (a<b) or (c<d) 후위 순회 ab+ aabc×
- ab<cd<or ­ 수식트리 계산은 후위순회를 사용함. ­ 수식트리의 루트는 연산자임. ­ 루트의 연산자의 피연산자인 서브트리들만 계산하면  전체 수식이 계산됨. ­ 각 서브트리도 마찬가지로 자식노드만 되면  루트에 저장된 연산자를 이용 계산함.

2) 수식트리 알고리즘 학습자님의   [ 알고리즘 설명 ]
Ÿ 만약 자식노드들이 없으면 데이터필드 값을 반환함.
Ÿ 왼쪽 서브트리에 대하여 evaluate를 순환호출함.
Ÿ 오른쪽 서브트리에 대하여 evaluate를 순환호출함.
Ÿ 데이터필드에서 연산자를 추출함.
Ÿ 추출된 연산자를 가지고 연산을 수행해서 결과 값을 반환함.

3) 수식트리 프로그램 ­ 트리의 데이터필드는 정수로 정의   여기에 피연산자인 숫자를 저장, 연산자인 경우는 연산자(‘+’, ‘
-’, ‘*’, ‘/’) 저장 학습자님의   ▶ 디렉터리 용량 계산 프로그램

1) 이진트리 순회응용 : 디렉터리 용량 계산 ­ 디렉터리 안에 다른 디렉터리가 2개를 초과하지 않는 조건 ­ 서브디렉터리의 용량을 모두 계산한 다음 루트 디렉터리의 용량 계산함. ­ 후위 순회를 사용하여 순환 호출되는 순회함수가 용량을 반환하도록 함.    학습자님의   3. 이진트리 연산방법, 노드의 개수, 높이구하기 알고리즘 ▶ 이진트리의 연산
1) 노드의 개수 ­ 탐색 트리 안의 노드의 개수를 계산함. ­ 각각의 서브트리를 순환호출한 다음 반환되는 값에 1을 더하여 반환함.
① 단말 노드 개수 구하기 ­ 트리안의 노드를 전체적으로 순회하면서 왼쪽 자식과 오른쪽 자식이 동시에 0이면 단말노드임.  1을 반환함. ­ 각 서브트리를 순환호출하여 반환된 값을 더하면 됨.
② 높이 구하기 ­ 서브트리에 대하여 순환호출하고 서브트리들의 반환값 중에서 최대값을 구하여 반환함. 학습자님의   4. 스레드 이진트리 순회 프로그램 ▶ 스레드 이진트리

1) 스레드 이진트리 ­ 이진트리의 NULL링크를 이용하여 순환호출 없이도 트리의 노드를 순회하는 방법 ­ 이진트리 노드에 많은 NULL링크가 존재함. ­ 트리의 노드개수 n이면, 총 링크의 개수는 2n임. 이 들 중 n
-1개의 링크들이 루트노드를 제외한 n
-1개의 다른 노드를 가리킴. ­ 2n개의 링크 중에서 n
-1은 NULL링크가 아니고,  나머지 n+1개의 링크는 NULL임.  ­ NULL링크에 중위순회 시에 후속노드인  중위후속자를 저장한 트리가 스레드 이진트리임. ­ 중위후속자만 저장한다고 가정함. [ 문제점 ]
Ÿ NULL링크에 자식노드의 포인터인지 스레드가 저장되었는지 구분이 불가함. ­ 단말노드와 비단말노드의 구별을 위하여 is_thread필드가 필요함.
① is_thread 구조 ­ is_thread가 TRUE이면 right는 중위후속자이고, ex)ALSE이면 오른쪽자식 노드포인터임.
② 중위후속자를 찾는 함수 작성 ­ 노드p의 중위후속자를 반환하는 함수 find_successor를 작성 ­ find_successor는 p의 is_thread가 THUE이면 바로 오른쪽 자식노드가 중위후속자이고, 오 른쪽 자식노드가 NULL이면 후속자가 없으므로 NULL을 반환함. ­ is_thread가 ex)ALSE이면 서브트리의 가장 왼쪽으로 가야 함. ­ 자식노드가 NULL이 될 때까지 왼쪽링크를 따라 이동함. 학습자님의  
③ 스레드 버전 중위순회 함수 thread_inorder 작성  ­ 중위순회는 가장 왼쪽 노드부터 시작하므로 왼쪽 자식이 NULL일 때까지 왼쪽 링크로 이동 ­ 데이터 출력하고 중위후속 찾는 함수 호출 ­ 후속자가 NULL이 아니면 계속 반복함. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.264~284 학습자님의   트리 3

1. 이진 탐색 트리의 동작원리와 효율성을 이해하며, 이를 SW 코 수업목표   9주차  딩에 적용하여 프로그램을 할 수 있다. 3교시 
① 이진 탐색 트리의 정의 세부내용 
② 알고리즘, 삽입 연산, 삭제 연산, 성능 분석
③ 이진 탐색 트리의 응용 : 영어 사전의 예 1. 이진 탐색 트리의 정의 ▶ 이진 탐색 트리의 정의

1) 이진 탐색 트리(binary search tree) ­ 이진트리 기반의 탐색을 위한 자료구조이다. ­ 컴퓨터 응용 프로그램에서 많이 사용되며, 가장 시간이 많이 걸리는 작업 중 하나임. ­ 탐색을 가능한 효율적으로 수행하는 것은 매우 중요함. ­ 탐색은 레코드의 집합에서 특정한 레코드를 찾아내는 작업임.
2) 탐색 관련 용어 ­ 레코드(record) ­ 필드(field) ­ 테이블(table) ­ 키(key) ­ 주요 키(primary key)
3) 이진 탐색 트리의 정의 ­ 모든 노드의 키는 유일함. ­ 왼쪽 서브트리의 키들은 루트의 키보다 작음. ­ 오른쪽 서브트리의 키들은 루트의 키보다 큼. ­ 왼쪽과 오른쪽 서브트리도 이진 탐색 트리임. 2. 탐색 연산, 삽입 연산, 삭제 연산, 성능 분석 ▶ 탐색 연산
1) 탐색작업을 효율적으로 하기 위한 자료구조 ­ key(왼쪽 서브트리) <= key(루트노드) <= key(오른쪽 서브트리) ­ 이진탐색을 중위순회하면 오름차순으로 정렬된 값을 얻음. 학습자님의  
2) 이진 탐색 트리에서의 탐색 연산 ­ 이진 탐색 트리에서 특정 키 값을 가진 노드를 찾기 위해서는 주어진 탐색 키 값과 현재의  루트노드의 키 값을 비교해야 함. [ 비교 결과 다음 3가지로 분류됨. ]
Ÿ 비교한 결과가 같으면 탐색이 성공으로 종료함.
Ÿ 주어진  키  값이  루트노드의  키값보다  작으면  탐색은  이  루트노드의  왼쪽  자식을  기준 으로 다시 시작함.
Ÿ 주어진  키  값이  루트노드의  키값보다  크면  탐색은  이  루트노드의  오른쪽  지식을  기준 으로 다시 시작함. ⇨ 루트노드보다 작으면 왼쪽 서브트리로, 루트노드보다 크면 오른쪽 서브트리로 감.
① 12를 탐색하는 순서

3) 이진탐색트리 탐색 알고리즘(순환적) ­ 이진탐색트리가 공백상태이면 NULL 반환함. 학습자님의   ­ 탐색키가 현재 트리의 루트 키값과 같으면 루트를 반환함. ­ 탐색키가  루트키값보다  작으면  왼쪽  서브트리를  순환호출을  이용하여  계속  탐색함.  아니면  오른쪽 서브트리를 순환호출을 이용하여 계속 탐색함.
4) 이진 탐색을 구현하는 방법 : 반복적 방법, 순환적 방법
① 노드의 구조체 정의 
② 순환적 방법  ­ 찾고자 하는 키 값이 더 작으면 왼쪽 자식노드를 매개변수로 넣어서 함수를 순환호출함. ­ 찾고자 하는 키 값이 더 크면 오른쪽 자식노드를 매개변수로 넣어서 함수를 순환호출함.
③ 반복적 방법  ­ 매개변수 node가 NULL이 아니면 반복을 계속함. ­ 반복 루프 안에서 현재 node의 키 값이 key와 같은지 검사함. ­ 만약 같으면 탐색성공으로 현재 노드 포인터를 반환하고 종료함. ­ 만약 key값이 현재 노드 키 값보다 작으면 node포인터를 node의 왼쪽 자식을 가리킴. ­ 만약 key값이 현재 노드 키 값보다 크면 node포인터를 node의 오른쪽 자식을 가리킴. ­ 계속 반복 수행하여 node가 NULL값이 될 때까지 계속 반복함.  학습자님의   ▶ 삽입 연산

1) 이진 탐색 트리에서의 삽입 연산 ­ 이진 탐색 트리에 요소를 삽입하기 위해서는 먼저 탐색을 수행해야 함. ­ 탐색에 실패한 위치가 바로 새로운 노드를 삽입하는 위치가 됨.
2) 이진 탐색 트리 삽입 알고리즘(자연어 버전)
1. 트리 T에서 z에 대한 탐색을 먼저 수행함.
2. 탐색이 실패하면 탐색이 끝난 지점에 노드 z를 삽입함.
① 이진탐색트리에 위 알고리즘에 따라서 9를 삽입하는 예 [ 알고리즘 설명 ]
Ÿ p는 부모노드 포인터, t는 탐색을 위한 포인터
Ÿ t가 NULL이 될 때까지 탐색을 수행함.
Ÿ 현재 탐색포인터의 값을 부모노드 포인터에 복사
Ÿ 삽입할 키 값이 t의 키 값보다 작으면 왼쪽 자식노드로 탐색 진행
Ÿ 삽입할 키 값이 t의 키 값보다 크면 오른쪽 자식노드로 탐색 진행
Ÿ key를 포함하는 트리노드 생성
Ÿ 반복이 끝났고, 만약 부모노드가 NULL이면 현재 트리가 공백 상태임.
Ÿ 따라서 새로운 노드를 루트로 설정함.
Ÿ 부모 노드의 키 값과 비교하여 작으면 왼쪽 자식으로 연결함.
Ÿ 아니면 오른쪽 자식으로 연결함. 학습자님의  

3) 이진 탐색 트리에서 삽입 연산 프로그램 ▶ 삭제 연산
1) 이진 탐색 트리에서의 삭제 연산 [ 삭제 전에 트리 탐색으로 위치 파악의 3가지의 경우 ]
Ÿ 삭제하려는 노드가 단말노드일 경우
Ÿ 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브트리 중 하나만 가지고 있는 경우
Ÿ 삭제하려는 노드가 두 개의 서브트리 모두 가지고 있는 경우
① 첫 번째의 경우 : 삭제하려는 노드가 단말노드의 경우  ­ 단말노드를 삭제함. ­ 단말노드의 삭제는 그 부모노드를 찾아서 부모노드 안의 해당 링크를 NULL로 변경함.
② 두 번째의 경우 : 삭제하려는 노드가 하나의 서브트리만 가지고 있는 경우 ­ 삭제되는 노드가 왼쪽이나 오른쪽 서브트리 중 하나만 가지고 있는 경우 ­ 자기노드는 삭제하고 그 서브트리를 자기 노드의 부모노드를 가리키게 함. 학습자님의  
③ 세 번째의 경우 : 삭제하려는 노드가 두 개의 서브트리를 가지고 있는 경우 ­ 삭제노드와 가장 비슷한 값을 가진 노드를 삭제노드 위치로 가져옴. ­ 삭제노드의 왼쪽이나 오른쪽 자식노드를 그대로 가져오면 이진탐색트리의 조건이 맞지 않음. [ 삭제노드의 값과 가장 비슷한 값을 가진 노드를 가져와야 함. ]
Ÿ 왼쪽  서브트리의  가장  큰  값이나  오른쪽  서브트리 의 가장 작은 값이 삭제노드의 값과 가장 가까움.
Ÿ 왼쪽  서브트리의  가장  큰  값은  이  트리의  가장  오른쪽  노드이고,  오른쪽  서브트리의  가장  작은  값은 이 트리의 가장 왼쪽 노드임.
Ÿ 이진탐색트리를 중위순회하면  각각 선행노드와 후속노드임.    

2) 이진 탐색 트리의 삭제 함수 프로그램 학습자님의   학습자님의   ▶ 이진 탐색 트리의 성능분석 ­ 이진  탐색  트리의  탐색,  삽입,  삭제연산의  시간  복잡도는  트리의  높이를  h라고  했을  때  h 에 비례함. ­ 시간복잡도는 높이 h일 때 O(h)임.
① 최선의 경우  ­ 이진트리가 균형적으로 생성되어 있는 경우 ­ h = log ■ 2
② 최악의 경우 ­ 한쪽으로 치우친 경사 이진트리의 경우 ­ h=n ­ 순차탐색과 시간복잡도가 같음. 3. 이진 탐색 트리의 응용 : 영어 사전의 예 ▶ 이진 탐색 트리의 응용

1) 영어사전 입력(i) ­ 단어와 의미를 입력하여 하나의 노드 추가 삭제(d) ­ 단어를 입력하면 해당 노드를 찾아 트리에서 제거 단어탐색(w) ­ 단어를 입력하면 해당 단어의 노드를 찾아 화면에 출력 의미탐색(m) ­ 의미를 입력하면 해당 의미의 노드를 찾아 화면에 출력 사전출력(p) ­ 사전의 모든 단어를 알파벳 순서대로(inorder) 화면에 출력 종료(q) ­ 프로그램을 종료
Ÿ 입력 시 insert_node 함수 사용
Ÿ 탐색 시 search 함수 사용
Ÿ 삭제 시 delete_node 함수 사용 학습자님의  
① element 타입은 구조체로 선언  ­ 두 개의 문자열 배열 필요 : word와 meaning필드 생성
② compare 함수 : 두 개의 element 항목의 순서를 비교  ▶ 이진 탐색 트리를 이용한 영어사전 프로그램 학습자님의   학습자님의   학습자님의   학습자님의   학습자님의   ▶ 이진 탐색 트리 프로그램 실행 결과  v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.284~304 학습자님의   우선순위 큐1 수업목표  

1. 우선순위 큐의 개념을 이해하고, 설명할 수 있다. 10주차 
① 우선순위 큐의 소개, 추상 자료형의 소개 1교시 
② 우선순위 큐의 구현 방법 세부내용  (배열을 사용하는 방법, 연결 리스트를 사용하는 방법, 히프를 사용하는 방법)
③ 히프의 개념 및 최대 히프, 최소 히프 1. 우선순위 큐의 소개, 추상 자료형의 소개 ▶ 우선순위 큐

1) 우선순위 큐(priority queue) ­ 우선순위를 가진 항목들을 저장하는 큐 ­ ex)Iex)O 순서가 아니라  우선순위가 높은 데이터가 먼저 나가게 됨.       ▶ 우선순위 큐 추상 데이터타입
1) 가장 일반적인 큐 : 스택이나 ex)Iex)O큐를 우선순위 큐로 구현할 수 있음. 자료구조 삭제되는 요소 스택 ­ 가장 최근에 들어온 데이터 큐 ­ 가장 먼저 들어온 데이터 우선순위 큐 ­ 가장 우선순위가 높은 데이터
2) 응용분야  ­ 시뮬레이션 시스템 (여기서의 우선순위는 대개 사건의 시작임.) ­ 네트워크 트래픽 제어 ­ 운영체제에서의 작업 스케쥴링
3) 우선순위 큐의 구현 방법 ­ 배열 ­ 연결리스트 ­ 히프(heap) : 가장 효율적인 방법 학습자님의   ▶ 우선순위 큐 ADT ­ 우선순위 큐는 0개 이상의 요소의 모임임. ­ 각 요소들은 우선순위 값을 가짐. ­ 가장 중요한 연산은 insert 연산(요소 삽입), delete 연산(요소 삭제)임. ­ 우선순위 큐에서는 요소들은 같은 우선순위를 가질 수 있음. ­ 우선순위 큐는 2가지로 구분 : 최소 우선순위 큐, 최대 우선순위 큐 v 우선순위 큐의 사용 예 
Ÿ 사업자가 기계를 보유하고 이 기계를 서비스하는 사업을 함. 각 사용자는 사용할 때마 다 사용료를 지불함. 사용자마다 사용 시간은 다름. 이 경우 수익을 최대화하기 위해서 는  우선순위는  사용  시간이  됨.  사용자가  기계  사용  요청을  하면  사용자의  요구는  최 소  우선순위  큐에  삽입됨.  기계  사용  가능한  경우  가장  시간을  적게  요구한  사용자가  우선순위 큐에서 선택됨. 만약 각 사용자가 일정한 시간 동안만 기계를 사용하고 사용 자마다 서로 다른 금액을 낸다면 우선순위 큐의 우선순위는 사용자가 지불하고자 하는  금액이 됨.  기계  사용  가능한 경우에  가장  많은  금액을 지불하는 사용자가  선택됨.  이  때의 우선순위 큐는 최대 우선순위 큐가 됨. 2. 우선순위 큐의 구현 방법 ▶ 배열을 사용하는 방법

1) 정렬이 안 된 배열을 사용하는 큐 : 삽입이 가장 간단함. ­ 기존의 요소의 맨 끝에 삽입하면 됨. ­ 삽입의 시간 복잡도는 O(1)임. 그러나 삭제의 경우 즉, 우선순위가 가장 높은 요소를 삭제 하는 경우는 처음부터 끝까지 모든 요소를 스캔하여야 함. ­ 삭제의 시간복잡도는 O(n)임. 요소를 삭제한 후 뒤에 있는 요소를 앞으로 이동시키는 오버 헤드가 발생함. 학습자님의  
2) 정렬이 된 배열의 경우  ­ 삽입할 때 다른 요소와 비교하여 우선순위에 따라 삽입 위치를 결정함. 삽입 위치 탐색으로  순차탐색이나 이진탐색 방법을 사용함. 삽입 위치를 탐색한 후 삽입 위치 뒤에 있는 요소를  뒤로 이동시켜야 함. 이동시킨 자리에 요소를 삽입함. ­ 삽입 시의 시간복잡도는 O(n)임. ­ 삭제 시는 숫자가 높은 것이 우선순위가 높다고 가정하면 맨 뒤에 위치한 요소를 삭제함. ­ 삭제 시의 시간복잡도는 O(1)임. ▶ 연결리스트를 이용한 우선순위 큐 ­ 정렬된 상태의 연결리스트와 정렬되지 않은 연결리스트를 사용함.
1) 정렬이 안 된 연결리스트의 경우 ­ 삽입 시 첫째 노드에 삽입이 유리함. ­ 배열과 달리 다른 노드를 이동할 필요가 없음. 포인터만 변경하면 됨. ­ 삽입의 시간복잡도는 O(1)임. ­ 삭제 시는 포인터에 따라 모든 노드를 탐색해야 함.  ­ 삭제 시 시간복잡도는 O(n)임
2) 정렬된 연결리스트 사용의 경우  ­ 우선순위가 높은 요소가 앞에 위치하는 것이 유리함. ­ 우선순위가 높은 요소가 첫 노드가 되게 함. ­ 삽입 시는 우선순위 값을 기준으로 삽입 위치를 찾으므로 시간복잡도는 O(n)임. ­ 삭제 시는 첫 노드를 삭제하면 되므로 시간복잡도는 O(1)임. ▶ 히프(heap)를 이용한 우선순위 큐 ­ 히프는 완전이진트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조임. ­ 히프는 반정렬 상태를 유지함. 반정렬 상태를 이용하여 우선순위 큐를 구현함. ­ 히프의  시간복잡도는  O(log ■)으로  다른  방법보다  유리함.  O(n)과  O(log ■)은  큰  차이가  2 2 있음. n이 1000의 경우 O(n)은 1000초가 걸림. O(log ■)은 10초 걸림. 2 학습자님의   ▶ 우선순위 큐의 구현 방법 표현 방법 삽입 삭제 순서 없는 배열 O(1) O(n) 순서 없는 연결 리스트 O(1) O(n) 정렬된 배열 O(n) O(1) 정렬된 연결리스트 O(n) O(1) 히프 O(log ■) O(log ■) 2 2 3. 히프의 개념 및 최대 히프, 최소 히프 ▶ 히프의 개념
1) 히프의 개념 ­ 히트는 ‘더미’의 의미, 완전이진트리 기반의 ‘더미’와 비슷한 모습, 특정 자료구조를 의미함. ­ 히프는 여러 개의 값 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만든 자료 구조임. ­ 히프는  부모노드의  키  값이  자식노드의  키  값보다  항상  큰(작은)  이진트리임.  즉  A가  B의  부모노드이고 부모노드의 키 값이 자식노드의 키 값보다 항상 크다고 하면, 다음 조건(히프  조건)이 항상 성립하는 트리임.  key(A) >= key(B)   ­ 히프트리는 중복된 값을 허용함. 이진트리탐색에서는 중복된 값을 허용하지 않음. ­ 히프  안에는  데이터들이  느슨한  정렬  상태를  유지함.  큰  값이  상위레벨에  있고  작은  값이  하위레벨에 있다는 정도를 의미함. ­ 히프의 목적은 삭제 연산이 수행할 때마다 가장 큰 값을 찾아내는 것임. ­ 가장 큰 값은 루트 노드이므로 전체를 정렬할 필요가 없음. 학습자님의   ▶ 최대 히프, 최소 히프
1) 두 가지 히프트리가 존재함.
① 최대히프(max heap) 
Ÿ 부모노드의 키 값이 자식 노드보다 큼.
② 최소히프(min heap) 
Ÿ 부모노드의 키 값이 자식 노드보다 작음. ⇨ 두 히프는 부등호만 달라지고 나머지는 완전 동일함.
① 최대히프(max heap) 
Ÿ 부모노드의 키 값이 자식노드의 키 값보다 크거나 같은 완전이진트리
Ÿ key(부모노드) >= key(자식노드)
② 최소히프(min heap) 
Ÿ 부모노드의 키 값이 자식노드의 키 값보다 작거나 같은 완전이진트리
Ÿ key(부모노드) <= key(자식노드) ⇨ 히프는 완전이진트리임. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.309~315 학습자님의   우선순위 큐2

1. 히프의 동작원리와 효율성을 이해, 설명할 수 있으며, 프로그램 10주차  수업목표   을 할 수 있다. 2교시 
① 히프의 구현 세부내용 
② 삽입 연산, 삭제 연산, 히프의 복잡도 분석 1. 히프의 구현 ▶ 히프의 구현 ­ 히프는 완전이진트리로 노드에  차례대로 번호를 붙일 수  있음. 이  번호를 배열의 인덱스로  하여 배열에 히프 노드를 저장함. ­ 히프를  저장하는  표준적인  자료구조는  배열임.  구현의  편의상  배열의  첫  인덱스  0은  사용 하지 않음. ­ 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않음. ­ 부모노드와 자식노드를 찾기는 쉬움.
Ÿ 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
Ÿ 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
Ÿ 부모의 인덱스 = (자식의 인덱스) / 2 ­ 히프는 1차원 배열로 표현 ­ 히프의 요소를 구조체로 표현 ­ heap_size는 현재 히프 안에 저장된 요소의 개수임. 학습자님의   2. 삽입 연산, 삭제 연산, 히프의 복잡도 분석 ▶ 삽입 연산

1) 삽입 연산 ­ 히프의 삽입연산은 회사에서 신입사원이 들어오면  일단 말단 위치에 앉힌 다음에 신입사원의 능력을 봐서  위로 승진시키는 것과 유사함. ­ 히프에 새로운 요소가 들어오면 일단 새로운 노드를  히프의 마지막 노드에 이어서 삽입,  삽입 후 새로운 노드를 부모노드들과 교환해서  히프의 정의를 만족시킴.
2) 히프트리의 삽입연산 ­ 번호순으로 가장 마지막 위치에 이어서 새로운 요소 8을 삽입함.    ­ 부모노드의 4와 비교하여 삽입노드 8이 더 크므로 교환함. ­ 부모노드 7과 비교하여 삽입노드 8이 더 크므로 교환함. ­ 삽입노드 8이 부모노드 9보다 작으므로 더 이상 교환하지 않음. 학습자님의  
3) 히프트리의 삽입알고리즘(자연어 버전)
① 히프의 끝에 새로운 노드를 삽입함.
② 삽입된 노드와 그 부모 노드의 키 값을 비교함. 삽입한 노드의 키 값이 부모노드의 키  값보다 크면 두 노드의 위치를 바꿈.
③ 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 
②를 반복함.

4) 히프트리의 삽입알고리즘(유사코드 버전) [ 알고리즘 설명 ] 1. 히프 크기를 하나 증가시킴. 2. 증가된 히프크기 위치에 새로운 노드를 삽입함. 4. i가 루트노드가 아니고 i번째 노드가 i의 부모 노드보다 크면  5. I번째 노드와 부모노드와 교환 6. 한 레벨 위로 올라감.(승진)
5) 히프트리의 삽입함수(C언어 버전) 학습자님의   ▶ 삭제 연산
1) 삭제 연산 ­ 삭제연산은 회사에서 사장 자리가 비게 되면  먼저 제일 말단 사원을 사장 자리로 올린 다음에  능력에 따라 강등시키는 것과 비슷함. ­ 최대 히프에서 삭제는  가장 큰 키 값을 가진 노드를 삭제하는 것을 의미함.  따라서 루트노드가 삭제됨. 루트노드 삭제 후 히프를 재구성하는 것이 문제임.
2) 히프 재구성 순서
① 먼저 루트노드가 삭제됨. 빈 자리에는 히프의 마지막 노드를 가져옴.
② 새로운 루트인 3과 자식 노드들을 비교하여 자식 노드가 더 크므로 교환함.  자식 중에 더 큰 값과 교환함. 3과 7이 교환됨.
③ 아직도 3이 자식 노드들보다 더 작기 때문에 3과 자식 노드 5를 교환함. 학습자님의  

3) 히프트리의 삭제알고리즘(유사코드 버전) [ 알고리즘 설명 ] 1. 루트노드값 반환을 위하여 item변수로 옮김. 2. 말단노드를 루트노드로 옮김. 3. 히프의 크기를 하나 줄임. 4. 루트의 왼쪽 자식부터 비교를 시작함. 5. i가 히프트리의 크기보다 작으면(즉 히프트리를 벗어나지 않았으면) 6. 오른쪽 자식이 더 크면  7~8 두 개의 자식노드 중 큰 값의 인덱스를 largest로 옮김. 9. largest의 부모노드가 largest보다 크면 10. 중지 11. 그렇지 않으면 largest와 largest 부모노드를 교환함. 12. 한 레벨 밑으로 내려감. 14. 최대값을 반환함.
4) 히프트리에서의 삭제함수(C언어 버전) 학습자님의  
5) 히프트리 프로그램 ▶ 히프의 복잡도 분석 ­ 삽입연산에서  최악의  경우는  루트노드까지  올라가야  하므로  트리의  높이에  해당하는  비교  연산과 이동 연산이 필요함. ­ 히프는 완전 이진트리이므로 히프의 높이는 log n가 되고,  2 삽입연산의 시간복잡도는 O(log ■)이 됨. 2 ­ 삭제연산도  마찬가지로  마지막  노드를  루트로  가져온  후  자식노드들과  비교하여  교환하는  부분이 가장 긴 시간이 소요됨. ­ 최악의 경우 가장 아래 레벨까지 내려가야 하므로 역시 트리의 높이만큼의 시간이 걸림. ­ 따라서 삭제연산의 시간복잡도도 O(log ■)가 됨. 2 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.316~325 학습자님의   우선순위 큐3 10주차  수업목표  
1. 히프의 배열을 이용하여 프로그램을 할 수 있다. 3교시 
① 히프 정렬, 이산 이벤트 시뮬레이션  세부내용 
② 허프만 코드 프로그램 1. 히프 정렬, 이산 이벤트 시뮬레이션 ▶ 히프의 응용 : 히프 정렬 ­ 최대 히프를 이용하면 정렬이 가능함. ­ n개의 요소는 O(log ■) 시간 안에 정렬됨. 2 ­ 요소의 개수가 n개이므로 전체적으로 O(nlog ■)의 시간이 걸림. 2 ­ 삽입정렬의 알고리즘의 O(n2)보다 좋음. ­ 먼저 정렬해야 할 n개의 요소들로 최대 히프를 초기화함. ­ 한 번에 하나씩 요소를 히프에서 삭제하여 배열의 뒤부터 저장하면 됨. ­ 삭제되는 요소들은 값이 감소되는 순서임. ­ 히프정렬이 가장 필요한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇 개만 필 요할 경우임. ▶ 히프정렬 프로그램 학습자님의   ▶ 시뮬레이션 ­ 큐가 자주 사용되는 분야 중 하나가 시뮬레이션임. [ 컴퓨터 시뮬레이션 ]
Ÿ 실재하거나  이론적으로  존재하는  물리적인  시스템의  모델을  디자인하고  그  모델을  디 지털 컴퓨터에서 실행하고 그 실행 결과를 분석함. ­ 시뮬레이션은  시간을  기반으로  해서  연속  시간(continuous  time)  시뮬레이션,  이산  시간 (discrete time) 시뮬레이션, 이산 이벤트(discrete event time) 시뮬레이션으로 구분함. ▶ 이산 이벤트 시뮬레이션 ­ 모든  시간의 진행은 이벤트의 발생에  의해서 이루어짐. 즉 이벤트가 발생되면 시간이  진행 됨. 많은 이벤트가 발생하고 이벤트들은 시간적으로 먼저 발생된 이벤트가 먼저 처리됨.

1) 우선순위 큐를 이용하여 이벤트를 저장하고 이벤트의 발생시각을 우선순위로 하여 처리하 는 시뮬레이션을 만들어 보자.
① 아이스크림 가게 시뮬레이션 ­ 아이스크림 가게의 손님이 들어오고 나가는 과정을 시뮬레이션함. ­ 시뮬레이션 파라미터는 가게의 의자의 개수임. ­ 손님이 들어왔다가 의자가 없으면 그냥 나감. ­ 몇 개의 의자를 비치해야 이익을 극대화할 수 있는지 시뮬레이션함. [ 아이스크림 가게에서 발생하는 이벤트 3가지 종류 ]
Ÿ 손님이 도착하는 이벤트 (ARRIVAL)
Ÿ 손님이 주문하는 이벤트 (ORDER)
Ÿ 손님이 가게를 떠나는 이벤트 (LEAVE) ­ 각각의 이벤트들은 이벤트가 발생된 시각과 손님의 숫자를 가지고 있음. ­ 도착한 손님은 랜덤한 시간 후에 주문 이벤트를 발생시킴. ­ 손님은 주문을 하고 나서 랜덤한 시간 후에는 가게를 떠나는 이벤트가 발생함.

2) 시뮬레이션의 처음 부분에서 일정 시간 동안 손님이 도착하는 이벤트를 몇 개 발생시켜서  우선순위 큐에 넣음. ­ 프로그램은 우선순위 큐에서 이벤트가 발생한 시각 순으로 이벤트를 꺼내어 처리함. ­ 우선순위 큐에 더 이상 이벤트가 없으면 프로그램은 종료함. 학습자님의   v 이벤트는 각각의 종류에 따라 다르게 처리함.  [ 손님이 도착하는 이벤트 처리 ]
Ÿ 먼저  손님의  숫자와  현재  남아  있는  의자를  비교하여  남아  있는  의자가  더  많으면  손 님을 받음.
Ÿ 남아 있는 의자의 수는 손님의 숫자만큼 줄어듦.
Ÿ 남아 있는 의자가 적으면 손님은 주문하지 않고 나감. [ 주문 이벤트 처리 부분 ]
Ÿ 손님의 숫자대로 주문을 받음. 잠시 후 손님이 떠나는 이벤트를 발생함. [ 손님이 떠나는 이벤트 처리 부분 ]
Ÿ 떠나는 손님 숫자만큼 남아있는 의자의 개수를 증가함.
Ÿ 손님의 숫자, 주문을 하는데 걸리는 시간 가게에 머무는 시간 등은 모두 랜덤 처리함.
Ÿ 먼저 발생한 이벤트를 먼저 처리하여야 하므로 우선순위 큐는 최소히프를 사용함.
Ÿ element 타입은 정수가 아니고 구조체임. ▶ 아이스크림 가게 시뮬레이션 프로그램(최소히프 사용) 학습자님의   학습자님의   학습자님의   학습자님의   2. 허프만 코드 프로그램 ▶ 허프만 코드 ­ 이진 트리는 각 글자의 빈도가 알려져 있는 메시지의 내용을 압축하는데 사용될 수 있음.  이런 종류의 이진트리를 허프만 코딩 트리라고 부름. ­ 테이블의 숫자는 빈도수라 함.  빈도수를 이용하여 데이터 압축을 하기 위해서는  각 글자들을 나타내는 최소 길이의 엔코딩 비트열을 만듦. ­ 전체 데이터의 양을 줄이기 위하여 고정된 길이를 사용하지 않고 가변 길이의 코드를 사용함.  ­ 가장  많은  글자에는  짧은  비트열을  사용하고,  잘  나오지  않는  글자에는  긴  비트열을  사용 함. ▶ 허프만 코드의 예 만약 텍스트가 e, t, n, i, s의 5개의 글자로만 이루어졌다고 가정하고 각 글자의 빈도수가  다음과 같다고 가정하자.   글자 비트 코드 빈도수 비트 수 e 00 15 30
Ÿ 텍스트의 길이 45글자 * 3비트  t 01 12 24 = 135비트 필요 ■ 10 8 16
Ÿ 압축하여 가변길이 코드 사용의 경우는 i 110 6 18 15*2+12*2+8*2+6*3+4*3  s 111 4 12 = 88비트 필요 합계 88
Ÿ 각각의 비트를 어떤 코드로 표현했는지 알려주는 테이블이 필요함.
Ÿ teen = 01000010
Ÿ 코딩된 비트열을  왼쪽에서  오른쪽으로 조사하면 정확히  하나의 코드만  일치함. 이  특수한  코드를 허프만 코드(Huffman codes)라고 함. 학습자님의   ▶ 허프만 코드 생성 절차 글자 비트 코드 빈도수 비트 수 e 00 15 30 t 01 12 24 ■ 10 8 16 i 110 6 18 s 111 4 12 합계 88 ­ 먼저 빈도수에 따라 5개 글자를 나열함.( s(4), i(6), n(8), t(12), e(15) ) ­ 가장 작은 빈도수 갖는 글자 2개를 추출하여 이를 단말노드로 함.( s(4), i(6) ) ­ 루트의 값은 각 자식 노드의 값을 합한 값이 됨. 합쳐진 값을 글자 리스트에 삽입 (10, 8,  12, 15)를 만듦. 이 빈도수를 정렬하면 (8, 10, 12, 15)가 됨. 이 중 가장 작은 값 2개를  단말노드로 하여 이진트리를 구성함.   ­ 합쳐진 값을 글자 리스트에 삽입(12, 15, 18)를 만듦. 이 중 가장 작은 값 2개를 단말노드 로 하여 이진트리를 구성함. ­ 위와 같이 하면 (18, 27)이므로 이 두 값을 단말노드로 이진트리를 구성함. 학습자님의   ­ 허프만 트리에서 왼쪽 간선은 비트 1을 나타내고, 오른쪽 간선은 비트 0을 나타냄. ­ 허프만 코드는 루트노드에서 단말노드까지의 경로에 있는 간선의 라벨 값을 읽으면 됨. ­ 빈도수 6에 해당하는 글자 i의 코드는 110임. ­ 허프만 코드의 알고리즘은 가장 작은 2개의 빈도수를 얻는 과정임. 이것은 최소히프트리를  이용하면 가장 효율적으로 구성함. ­ 프로그램은  각  빈도수를  단일노드로  만든  다음에  가장  빈도수가  작은  노드  2개를  합쳐서  하나의 트리로 만드는 과정을 반복함. ▶ 허프만 코드 프로그램 (최소히프 사용) ­ 히프에 저장되는 element 타입은 구조체로서 트리 가리키는 포인터와 그 트리의 weight값 을 key값으로 가짐.  ­ 우선순위는 이 트리의 weight값에 의해 결정됨. ­ make_tree함수는  매개변수로  받은  포인터들을  왼쪽  자식과  오른쪽  자식으로  하는  루트노 드를 만들어서 변환함. ­ for루프는 제일 작은 값 두 개를 꺼내어 합침. n
-1번만 수행함. ­ 마지막에 남은 노드가 전체 이진트리의 루트가 됨. 이 이진트리로부터 허프만 코드를 할당함. 학습자님의   학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.105~166 v C로 배우는 쉬운 자료구조, 이지영, pp.98~104 학습자님의   정렬 1

1. 정렬의  개념을  이해하고,  선택정렬과  삽입  정렬의  동작원리를  11주차  수업목표   파악하고 프로그램에 적용할 수 있다. 1교시 
① 정렬의 개념과 대상 및 정렬의 분류 세부내용 
② 선택/삽입 정렬 원리, 알고리즘, 프로그램, 분석 1. 정렬의 개념과 대상 및 정렬의 분류 ▶ 정렬의 개념

1) 정렬이란? ­ 물건을 크기 순으로 오름차순이나 내림차순으로 나열하는 것 ­ 어떤 형태의 것도 서로 비교가 가능하면 정렬할 수 있음. ­ 정렬은 컴퓨터공학을 포함한 모든 과학기술 분야에서 가장 기본적이고 중요한 알고리즘 중  하나임. 일상생활에서 많이 사용됨. ­ 정렬은 자료탐색에 있어서 필수적임. v 만약 영어사전에서 단어들이 알파벳 순으로 정렬되어 있지 않다면?  ▶ 정렬의 대상 ­ 일반적으로 정렬시켜야 될 대상은 레코드(record)라고 함. ­ 레코드는 필드(field)라는 보다 작은 단위로 구성됨. ­ 키필드로 레코드와 레코드를 구별함. 학습자님의   ▶ 정렬 알고리즘 개요 ­ 모든 경우에 최적인 정렬 알고리즘은 없음. ­ 각 응용분야에 적합한 정렬 방법을 사용해야 함.
Ÿ 레코드 수의 많고 적음
Ÿ 레코드 크기의 크고 작음
Ÿ key의 특성(문자, 정수, 실수 등)
Ÿ 메모리 내부/외부 정렬 ­ 정렬알고리즘 평가는 비교연산의 횟수와 이동 연산의 횟수의 효율성을 기준으로 함. ­ 빅오표기법을 이용하여 근사적으로 표현함. ­ 횟수는 자료의 초기화 여부에 의존적임. ­ 이동횟수와 비교횟수는 서로 비례하지 않음. ­ 숫자와 숫자의 비교와 이동은 시간이 걸리지 않음. ­ 문자열과 문자열의 비교는 상당히 시간이 걸리는 작업임. ­ 큰 구조체를 이동시키려면 상당한 시간이 걸림. ▶ 정렬 알고리즘 분류

1) 단순하지만 비효율적인 방법  ­ 구현하기 쉽지만 비효율적임. ­ 삽입정렬, 선택정렬, 버블정렬 등
2) 복잡하지만 효율적인 방법  ­ 효율적인 반면에 구현하기가 어려움. ­ 퀵정렬, 히프정렬, 합병정렬, 기수정렬 등
3) 내부정렬(internal sorting)  ­ 모든 데이터가 주기억장치에 저장된 상태에서 정렬
4) 외부정렬(external sorting) ­ 외부 기억장치에 대부분의 데이터가 있고 일부만 주기억장치에 저장된 상태에서 정렬 ▶ 정렬 알고리즘의 안정성(stability) ­ 동일한 키 값을 갖는 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음. ­ 안정하지 않은 정렬의 예 학습자님의   2. 선탭/삽입 정렬 원리, 알고리즘 프로그램, 분석 ▶ 선택정렬(selection sort)
1) 선택정렬의 원리 ­ 가장 쉬운 정렬방법 ­ 왼쪽 리스트와 오른쪽 리스트의 두 개의 리스트가 있음.
Ÿ 왼쪽 리스트에는 정렬이 완료된 숫자들이 들어 있음.
Ÿ 오른쪽 리스트에는 정렬이 되지 않은 숫자들이 들어 있음. ­ 초기상태에는 왼쪽은 비어있고, 정렬할 숫자들은 모두 오른쪽 리스트에 존재함. ­ 오른쪽 리스트에서 최소값 선택하여 왼쪽 리스트로 이동하는 작업을 반복함. ­ 선택정렬은 오른쪽리 스트가 공백 상태가 될 때까지 이 과정을 되풀이하는 정렬기법임. 왼쪽 리스트 오른쪽 리스트 설명 ( ) (5, 3, 8, 1, 2, 7) 초기상태
(1) (5, 3, 8, 2, 7) 1선택 (1, 2) (5, 3, 8, 7) 2선택 (1, 2, 3) (5, 8, 7) 3선택 (1, 2, 3, 5) (8, 7) 5선택 (1, 2, 3, 5, 7) (8) 7선택 (1, 2, 3, 5, 7, 8) ( ) 8선택 ­ 이 방법은 공백상태의 리스트가 필요하여 공간의 낭비가 있음. ▶ 선택정렬 알고리즘

1) 제자리 정렬(in
-place sorting) ­ 공백상태 리스트가 없이 입력배열만으로 정렬하는 방법 ­ 최소값을 배열의 첫 번째 요소와 교환을 계속 반복하는 방법
Ÿ 왼쪽 리스트 크기 1 증가
Ÿ 오른쪽 리스트 크기 1 감소
Ÿ 오른쪽리 스트가 소진되면 정렬 완료 학습자님의  

2) 선택정렬 알고리즘(유사코드) ­ i값이 0애서 n
-2까지만 변화한다. ­ A[0]부터 A[n
-2]까지 정렬이 되었으면 이미 A[n
-1]이 가장 큰 값이다.

3) 선택정렬 알고리즘(C언어 코드) ­ 레코드와 레코드의 교환을 위하여 SWAP 매크로를 사용함. ▶ 선택정렬의 복잡도 분석
1) 선택정렬의 복잡도 분석
① 비교횟수 : 두 개의 for루프 실행횟수 계산
Ÿ 외부루프 : n
-1번 실행  
Ÿ 내부루프 : 0에서 n
-2까지 변하는 i 에 대하여 (n
-1) 
- i 번 반복   
Ÿ 키 값의 비교는 내부 루프 안에서 실행되므로  (n
-1)+(n
-2)+.....+1 = n(n
-1)/2 = O(n2) 
② 교환횟수 : 외부루프 실행횟수와 같음. 한 번 교환에 3번의 이동이 필요
Ÿ 전체이동횟수 = 3(n
-1)

2) 선택정렬의 장점 ­ 자료 이동횟수가 미리 결정됨.
Ÿ 자료가 정렬된 경우에는 불필요하게 자기 자신과의 교환을 하게 됨.
Ÿ if문 추가로 해결   if(i!=least)        SWAP(list[i], list[least], temp) 학습자님의   ­ 비교연산 1개가 교환연산 3개보다 시간이 적게 걸리므로 효과적임. ­ 전체 시간적 복잡도 : O(n2)

3) 선택정렬의 단점 ­ 안정성을 만족하지 않음. 같은 값의 레코드의 경우 상대적인 위치가 변경됨. ▶ 삽입 정렬
1) 삽입 정렬 ­ 정렬되어 있는 부분에 새로운 레코드를 올바른 위치에 삽입하는 과정을 반복함. ­ 손 안의 카드를 정렬하는 방법과 유사함. ­ 정렬된 리스트와 정렬되지 않은 리스트로 구분하여 사용함.
2) 정렬 과정 ­ 정렬되지  않은  리스트의  첫  번째  숫자가  정렬된  리스트의  어느  위치에  삽입되는지를  판단 한 후 해당 위치에 이 숫자를 삽입함. 정렬된 리스트의 크기는 1 증가하고, 정렬되지 않은  리스트의 크기는 1 감소함. 위의 과정을 반복함.
① 전체 리스트(5, 3, 8, 1, 2, 7) 삽입정렬 과정 학습자님의  

3) 삽입정렬의 알고리즘 [ 알고리즘 설명 ]
Ÿ 인덱스 i부터 시작한다.
Ÿ 인덱스 0은 이미 정렬된 것으로 볼 수 있다.
Ÿ 현재 삽입될 숫자인 i번째 정수를 key변수로 복사한다.
Ÿ 현재 정렬된 배열은 i
-1까지이므로 i
-1번째부터 역순으로 조사한다.
Ÿ j값이 음수가 아니고 key값보다 정렬된 배열에 있는 값이 크면
Ÿ j번째를 j+1번째로 이동한다.
Ÿ j를 하나 감소한다.
Ÿ j번째 정수가 key보다 작으므로 j+1번째가 key 값이 들어갈 위치이다. 학습자님의  

4) 삽입 정렬의 복잡도 분석
① 최선의 경우 O(n) : 이미 정렬되어 있는 경우 ­ 비교 : 각 단계별 이동 없이 1번만 비교하므로 n
-1번
② 최악의 경우 O(n2) : 역순으로 정렬되어 있는 경우 ­ 모든 단계에서 앞에 놓인 자료 전부를 이동 ­ 비교 : 외부루프 안에 각 반복마다 i번 비교 실행 ­ 이동
③ 평균의 경우 : O(n2)  [ 삽입 정렬의 복잡도 분석 ]
Ÿ 많은 이동이 필요하여 레코드가 클 경우는 비효율적임.
Ÿ 안정된 정렬방법으로 레코드가 작을 경우는 알고리즘이 간단하여 효율적임.
Ÿ 레코드가 이미 정렬되어 있는 경우 매우 효율적임. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.325~351 학습자님의   정렬 2

1. 버블/셀/합병  정렬의  동작원리를  파악하고  프로그램에  적용할  11주차  수업목표   수 있다. 2교시 
① 버블정렬의 원리, 알고리즘, 버블정렬 프로그램 세부내용 
② 셀/합병 정렬의 원리, 셀/합병 정렬의 구현, 분석 1. 버블정렬의 원리, 알고리즘, 버블정렬 프로그램 ▶ 버블정렬

1) 버블정렬 ­ 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환함. ­ 비교
-교환 과정(스캔)을 리스트의 왼쪽 끝에서 오른쪽 끝까지 반복함. ­ 비교
-교환 과정을 한 번 완료하면 가장 큰 레코드가 리스트의 오른쪽 끝으로 이동함. ­ 정렬이 안 된 리스트를 한 번 스캔하면 리스트의 오른쪽 끝에 가장 큰 레코드가 위치함. ­ 스캔 과정을 정렬이 안 된 리스트의 왼쪽에서 반복 적용하면 정렬이 완료됨.

2) 버블정렬 알고리즘 하나의 스캔은 j = 0부터 j = i
-1까지 반복하는 루프로 구성된다. j 번 째 요소와 j+1번 째 요소를 비교하여 크기 순이 아니면 교환한다. i는 하나의 스캔이 끝날 때마다 1씩 감소한다. 이 스캔과정을 n
-1번 반복하면 정렬은 끝난다. 학습자님의  

3) 버블정렬의 C언어 구현
4) 버블정렬의 복잡도 분석 : 비교횟수와 이동횟수의 계산
① 비교횟수 (최상, 평균, 최악의 경우 모두 일정) 
② 이동횟수  ­ 역순으로 정렬된 경우(최악의 경우) : 3*비교횟수 SWAP함수에 3번의 이동 ­ 이미 정렬된 경우(최선의 경우) : 이동횟수 = 0 ­ 평균의 경우 : O(n2)
③ 버블정렬의 문제점  ­ 순서에 맞지 않는 요소를 인접한 요소와 교환한다는 것. ­ 하나의 요소를 왼쪽에서 오른쪽으로 이동하기 위해서 배열에서 모든 다른 요소와 교환해야 함. ­ 레코드의 이동 과다 : 이동연산은 비교연산보다 더 많은 시간이 소요됨. ­ 단순하지만 비효율적 ⇨ 잘 사용하지 않음. 2. 셀/합병 정렬의 원리, 셀/합병 정렬의 구현, 분석 ▶ 셀 정렬(sell sort)

1) 셀 정렬(sell sort) : Donald L. Shell이 제안한 방법 ­ 삽입정렬이 어느 정도 정렬된 리스트에서 대단히 빠른 것에 착안. ­ 삽입정렬은  요소들이  이웃한  위치로만  이동하므로  많은  이동에  의해서만  요소가  제자리를  찾아감. ­ 요소들이  멀리  떨어진  위치로  이동할  수  있게  하면,  보다  적게  이동하여  제자리  찾을  수  있음. ­ 셀정렬은 요소들이 멀리 떨어진 위치로 이동 가능함. ­ 셀정렬은 삽입정렬과 다르게 전체 리스트를 한 번에 정렬하지 않음. ­ 전체리스트를 일정 간격(gap)의 부분 리스트로 나눔. ­ 나누어진 각각의 부분 리스트를 삽입정렬함. ­ 모든 부분리스트가 다시 전체리스트를 더 적은 개수의 부분리스트로 만든 후에 반복함. ­ 위 과정의 부분리스트의 개수가 1이 될 때까지 반복함. 학습자님의  
2) 셀 정렬의 예 ­ 부분리스트 구성은 주어진 리스트의 각 k번 째 요소를 추출하여 만듦. 이 k를 간격(gap)이 라 함. ­ 각 스텝마다 간격 k를 줄여가므로 수행과정이 반복될수록 하나의 부분 리스트에 속하는 레 코드들의 개수는 증가함. ­ 마지막 스텝에서는 간격이 1임. v (10, 8, 6, 20, 4, 3, 22, 1, 0, 15, 16) 리스트의 셀 정렬 수행과정  학습자님의   ▶ 셀 정렬의 구현 
Ÿ 간격은 처음에는  으로 한다. 각 패스마다 간격을 절반씩 줄이는 방식을 사용한다.  
Ÿ shell_sort함수의 변수 gap이 간격을 나타낸다. 
Ÿ shell_sort함수는 gap이 1이 될 때까지 gap을  를 줄이면서 반복한다.  
Ÿ 부분리스트의 개수는 gap이다.
Ÿ 부분리스트의 삽입정렬 함수 inc_insertion_sort호출한다.
Ÿ 만약 간격이 짝수이면 1을 더하는 것이 좋은 것으로 분석되었다. ▶ 셀 정렬 복잡도 분석

1) 셀 정렬의 예
① 셀 정렬의 장점  ­ 불연속적인 부분리스트에서 원거리 자료 이동으로 보다 적은 위치 교환으로 제자리를 찾을  가능성이 증대함. ­ 부분리스트가 점진적으로 정렬된 상태가 되므로 삽입정렬 속도가 증가함.
② 시간적 복잡도  ­ 최악의 경우 O(n2)  ­ 평균적인 경우 O(n1.5)  학습자님의   ▶ 합병 정렬

1) 합병 정렬 ­ 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분리스트를 정렬하는 방법 ­ 정렬된 두 개의 부분 리스트를 합하여 전체리스트를 정렬함.
① 분할정복(divide and conquer) 방법 사용 ­ 문제를  보다  작은  2개의  문제로  분리하고  각  문제를  해결한  다음,  결과를  모아서  원래의  문제를 해결하는 전략 ­ 분리된 문제가 아직 해결하기 어렵다면(즉 충분히 작지 않다면)  분할정복방법을 다시 적용함.(순환호출 이용) 분할
Ÿ 배열을 같은 크기의  (Divide) 2개의 부분배열로 분할
Ÿ 부분배열을 정렬함. 
Ÿ 부분배열의 크기가  정복 충분히 작지 않으면  (Conquer) 순환호출을 이용하여  다시 분할정복기법을 적용함. 결합
Ÿ 정렬된 부분배열을  (Combine) 하나의 배열에 통합함.

2) 합병 정렬의 예 학습자님의  
3) 합병 정렬 알고리즘
1. 만약 나누어진 구간의 크기가 1이상이면
2. 중간 위치 계산한다.
3. 앞쪽 부분 배열을 정렬하기 위하여 merge_sort함수를 순환호출한다.
4. 뒤쪽 부분 배열을 정렬하기 위하여 merge_sort함수를 순환호출한다.
5. 정렬된 2개의 부분 배열을 통합하여 하나의 정렬된 배열로 만든다.
4) 합병 알고리즘
Ÿ 합병정렬에서  실제로 정렬이 이루어지는 시점은  2개의 리스트를 합병하는 단계임.
Ÿ 추가의 리스트가 필요함.
Ÿ 2개의 리스트 요소를  처음부터 비교하여  작은 요소를 새로운 리스트로 옮김.
Ÿ 반복 작업을 함.

5) 합병 정렬 알고리즘 학습자님의  
6) 배열 list에 있는 두 개의 list를 배열 sorted에 합병하는 세부과정
7) 합병 정렬의 C언어 구현 ­ merge_sort 함수에서 주어진 list 배열을 2등분한 부분배열에 대하여 다시 merge_sort 함 수를  순환호출함.  이  방식은  부분배열의  숫자가  1개  남을  때까지  함.  다음은  merge  함수  이용하여 합병 시작함. 실제로 정렬이 되는 곳은 이 합병과정임.
8) 합병 정렬의 복잡도 분석 : 순환호출 방식임. 레코드의 개수 n이 2 거듭제곱으로 가정하자.
Ÿ n=의 경우 23  → 22  → 21 → 20 으로 줄어들어 순환호출의 깊이는 3임.
Ÿ k = log n임. 2
Ÿ 부분배열로 나누어지는 단계에서는 비교연산이나 이동연산이 수행되지 않음.
Ÿ 부분배열이 합쳐지는 merge 함수에서 비교연산과 이동연산이 수행됨.
Ÿ 순환호출 깊이만큼 합병단계가 필요함. 학습자님의  

9) 합병 단계에서의 비교연산 n=23인 경우
Ÿ 크기 1인 부분배열 2개를 합병 → 최대 2개의 비교연산      부분배열 쌍이 4개 → 2 * 4 = 8번 비교연산
Ÿ 크기 2인 부분배열 2개를 합병 → 최대 4개의 비교연산      부분배열 쌍이 2개 → 4 * 2 = 8번 비교연산
Ÿ 일반적인 경우 하나의 합병단계에서는 최대 n번의 비교연산이 필요함.
Ÿ 합병단계가 k= log n번이므로 총 비교연산은 최대 nlog n번이 필요함. 2 2

10) 합병 단계에서의 이동연산
Ÿ 하나의  합병단계에서  임시배열에  복사했다가  다시  가져오므로  총  부분배열의  요소  개 수 n인 경우 레코드 이동 2n번 발생함.
Ÿ 총 log n개의 합병단계가 필요하므로 총 2nlog n개의 이동연산이 필요함. 2 2
Ÿ 합병정렬은 비교연산과 이동연산의 경우 O(nlog ■)의 복잡도를 가짐. 2

11) 합병 정렬의 장단점 ­ 레코드의 크기가 큰 경우에는 매우 시간적 낭비가 큼. ­ 레코드를 연결리스트로 구성하여 합병 정렬할 경우
Ÿ 링크 인덱스만 변경되므로 데이터의 이동은 극히 작아짐.
Ÿ 크기가 큰 레코드를 정렬할 경우, 다른 어떤 정렬방법보다 효과적임. ­ 안정적인 정렬방법으로 데이터의 분포에 영향을 덜 받음. 즉 입력데이터의 종류와는 관계없 이 정렬 시간은 동일함. 최악, 평균, 최선의 경우 복잡도는 O(nlog ■)으로 동일함. 2 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.351~370 학습자님의   정렬 3

1. 퀵정렬과  히프/기수  정렬의  동작원리를  파악하고  프로그램에  11주차  수업목표   적용할 수 있다. 3교시 
① 퀵정렬의 개념, 알고리즘, 프로그램, 복잡도 분석 세부내용 
② 기수정렬의 개념, 알고리즘, 구현, 프로그램, 분석 1. 퀵정렬의 개념, 알고리즘, 프로그램, 복잡도 분석 ▶ 퀵정렬

1) 퀵정렬 : 평균적으로 가장 빠른 정렬방법 [ 분할정복법을 사용함 ]
Ÿ 리스트를  2개의  부분리스트로  비균등  분할하고  각각의  부분리스트를  순환호출하여  퀵 정렬함.
Ÿ 비균등분할은 리스트 안에 있는 한 요소를 피벗(pivot)으로 선택함.
Ÿ 리스트의 첫 요소를 피벗으로 함.
Ÿ 피벗보다 작은 요소는 피벗의 왼쪽으로 옮기고,  피벗보다 큰 요소는 피벗의 오른쪽으로 옮김.
Ÿ 피벗의 왼쪽과 오른쪽을  다시 퀵정렬(순환호출)하면 전체리스트가 정렬됨.  

2) 퀵정렬 알고리즘(C언어) [ 알고리즘 설명 ]
Ÿ 정렬대상은 배열 list, 정렬범위는 left에서 right까지로 가정
Ÿ 정렬할 범위가 2개 이상의 데이터면 partition 함수 호출로 피벗을 기준으로 2개의 리 스트로 분할한다.
Ÿ left에서 피벗 바로 앞까지를 대상으로 순환호출한다.(피벗은 제외)
Ÿ 피벗 바로 다음부터 right까지를 대상으로 순환호출한다.(피벗은 제외) 학습자님의  

3) 분할(partition) 함수 ­ 분할함수는 피벗을 기준으로 2개의 부분리스트로 나눔. ­ 피벗(pivot) : 가장 왼쪽 숫자라고 가정 ­ 두 개의 변수 low(왼쪽부분 리스트)와 high(오른쪽부분 리스트)를 사용함. ­ low는 피벗보다 작으면 통과, 크면 정지 ­ high는 피벗보다 크면 통과, 작으면 정지 ­ 정지된 위치의 숫자를 교환 ­ low와 high가 교차하면 종료 ­ low와 high를 리스트의 왼쪽과 오른쪽 출발하여 부적절한 데이터를 만나면 교환,  아니면 계속 진행하다가 엇갈리면 멈춰서 피벗을 중앙으로 이동시키면 정렬이 됨. v 분할과정 예 
4) partition함수 (C언어) 학습자님의   [ 함수 설명 ] 6. low는 left+1에서 출발. do
-while루프에서 먼저 증가시킴. 7. high는 right에서 출발. do
-while루프에서 먼저 감소시킴. 8. 정렬할 리스트의 가장 왼쪽 데이터를 피벗으로 선택함. 9. low와 high가 교차할 때까지 계속 반복함. 10~12. list[low]가 pivot보다 작으면 계속 low를 증가시킴. 13~15. list[high]가 pivot보다 크면 계속 high를 증가시킴. 16. low와 high가 아직 교차하지 않았으면 list[low]와 list[high]를 교환함. 17. 만약 low와 high가 교차하였으면 반복을 종료함. 19. list[left]와 list]high]를 교환함. 20. 피벗의 위치인 high를 반환함.

5) 퀵정렬의 전체 과정 ▶ 퀵정렬 복잡도 분석
1) 최선의 경우(거의 균등한 리스트로 분할되는 경우)  n이 2의 거듭제곱으로 가정한 경우     n개의 레코드를 가지는 리스트는     으로 나누어짐.           크기가 1이 될 때까지 나눔.   로 나누어짐.   따라서 k=log n개의 패스가 필요함. 평균 n번 정도 비교가 발생함. 2 퀵정렬은 비교연산을 총 nlog n번 실행하므로 O(nlog ■) 복잡도를 가지는 알고리즘임. 2 2 이동횟수는 비교횟수보다 적으므로 무시함. 학습자님의  
2) 최악의 경우(극도로 불균등한 리스트로 분할되는 경우)
① 이미 정렬된 리스트를 정렬하는 경우
Ÿ 총 n번의 패스 실행
Ÿ 각 패스 안에서의 n2번의 비교가 실행
Ÿ 총 비교연산은 실행
Ÿ 퀵정렬은 최악의 경우 O(n2)의 복잡도를 가짐.  

2) 퀵정렬 복잡도 분석 ­ 퀵정렬은 다른 정렬 알고리즘과 비교 시 가장 빠름. ­ 불필요한  데이터  이동을  줄이면서  먼  거리의  데이터를  교환하며,  결정된  피벗은  연산에서  제외되는 특성으로 기인함. 장점 ­ 속도가 빠르고 추가메모리 공간이 필요하지 않음. ­ 정렬된 리스트에 대해서는 수행시간이 많이 걸림. 단점 ­ 피벗 선택 시 중간값(midian)을 선택하여 단점을 해소함. ▶ 히프정렬 ­ 히프는 우선순위 큐에서 설명하였음.  ­ 히프의 응용으로 히프정렬도 소개하였음. ­ 히프는  우선순위큐를  완전이진트리로  구현하는  방법으로  최대  값,  최소값을  쉽게  추출하는  자료구조임. ­ 히프는 최대히프와 최소히프가 있으며, 정렬에는 최소히프 사용이 편리함. ­ 최소히프는 부모값이 자식값보다 작으므로 루트노드가 가장 작은 값임. ­ 정렬할  배열을  먼저  최소히프로  변환한  다음  가장  작은  요소부터  차례대로  추출하여  정렬 하는 방법임. 학습자님의   2. 기수정렬의 개념, 알고리즘, 구현, 프로그램, 분석 ▶ 기수정렬
1) 기수정렬 ­ 대부분의 정렬 방법들은 레코드들을 비교함으로써 정렬을 수행함. ­ 기수정렬(radix sort)은 레코드를 비교하지 않고 정렬을 수행함.
Ÿ 비교에 의한 정렬방법의 하한인 O(nlog ■)보다 좋음. 2
Ÿ 기수정렬은 O(dn)의 시간적 복잡도를 가짐.(대부분 d<10) v 기수정렬의 단점
Ÿ 추가적 메모리가 필요함. 하지만 속도가 빠르기 때문에 인기가 좋은 기법임.
Ÿ 정렬할 수 있는 레코드의 타입이 한정됨.(실수, 한글, 한자 등은 정렬 불가)
Ÿ 즉 레코드의 키들이 동일한 길이를 가지는 숫자나 단순 문자(알파벳 등)이어야 함. ­ 기수(radix)는 숫자의 자리수임. ­ 기수정렬은 숫자의 자리수를 가지고 정렬하는 방법임. ­ 기수정렬은 다단계 정렬이고, 단계의 수는 데이터의 자릿수 개수와 동일함.

2) 기수정렬의 예 : 한 자리수(8, 2, 7, 3, 5)의 기수정렬 과정 ­ 단순히 자리수에 따라 버켓(bucket)에 넣었다가 꺼내면 정렬됨. v 어떻게 비교하지 않고 정렬을 할 수 있을까?
Ÿ 십진수는  각  자리수가  0~9까지의  값만을  가 짐.  10개의  버켓을  만들어  입력데이터를  각  자릿수의  값에  따라  버켓에  넣음.  위에서부터  순차적으로  버켓  안에  있는  데이터를  추출하 므로  정렬됨.  여기서는  비교연산을  전혀  사용 하지 않았다. v 만약 2자리수의 정렬은?  (28, 93, 39, 81, 62, 72, 38, 26)
Ÿ 낮은 자리수를 먼저 정렬하고  높은 자리수를 정렬함. 학습자님의   ▶ 기수정렬 알고리즘 ­ LSD(least significant digit)는 가장 낮은 자릿수 ­ MSD(most significant digit)는 가장 높은 자릿수 ­ 버켓은 큐로 구현함. 먼저 들어간 숫자가 먼저 나옴. ­ 버켓에 숫자를 넣는 연산은 큐의 삽입연산으로, 버켓에서 숫자를 읽는 연산은 큐의 삭제연 산으로 함. ­ 버켓의 개수는 키의 표현방법과 밀접한 관계가 있음.
Ÿ 이진법을 사용한다면 버켓은 2개 필요
Ÿ 알파벳 문자를 사용한다면 버켓을 26개 필요
Ÿ 십진법을 사용한다면 버켓은 10개 필요 ­ 32비트의 정수의 경우, 8비트씩 나누면 버켓은 256개 필요,  대신 필요한 패스의 수는 4개로 줄어듦. ▶ 기수정렬의 구현 ­ 십진수의 경우, 10개의 버켓이 필요하므로 큐도 10개가 필요함. 학습자님의   ▶ 기수정렬 복잡도 분석 ­ 입력리스트가 n개의 레코드를 가진다면 알고리즘 내부루프는 n번 반복함. ­ d개의 자릿수로 이루어진 키를 기수정렬 할 경우 메인 루프는 자릿수 d번 반복, 큐에 n개  레코드 입력 수행 ­ 시간 복잡도는 d에 비례하기 때문에 기수정렬의 수행시간은 정수의 크기와 관련이 없음. ­ 기수정렬의 시간적 복잡도는 O(dn) 키의 자릿수 d는 10이하의 작은 수이므로 거의 영향이 없어 빠른 정렬임.  ⇨ O(n)이라고 해도 무리가 없음. ▶ 정렬 알고리즘의 비교

1) 정렬 방법의 이론적 성능을 비교한 표  ­ 최적의 정렬방법은 정렬해야 할 레코드의 수, 크기, 타입 등에 따라 다름. ­ 정렬방법들의 장단점을 고려하여 적합한 정렬방법을 사용함. 알고리즘 최선 평균 최악 삽입 정렬 O(n) O(n2) O(n2) 선택 정렬 O(n2) O(n2) O(n2) 버블 정렬 O(n2) O(n2) O(n2) 쉘 정렬 O(n) O(n1.5) O(n1.5) 퀵 정렬 O(nlog ■) O(nlog ■) O(n2) 2 2 히프 정렬 O(nlog ■) O(nlog ■) O(nlog ■) 2 2 2 합병 정렬 O(nlog ■) O(nlog ■) O(nlog ■) 2 2 2 기수 정렬 O(dn) O(dn) O(dn)
2) 정수 60,000개를 정렬알고리즘으로 정렬할 때 소요되는 시간 측정  알고리즘 실행 시간 (단위 : sec) 삽입 정렬 7.438 선택 정렬 10.842 버블 정렬 22.894 쉘 정렬 0.056 히프 정렬 0.034 합병 정렬 0.026 퀵 정렬 0.014 ▶ 정렬의 응용
1) 정렬의 응용 : 영어사전을 위한 정렬 ­ 영어사전은 단순하게 배열로 구현한다고 가정 ­ 구조체에  단어와  의미  저장,  이  구조체를  배열로  만든  다음  정렬  방법을  적용하여  배열을  정렬함. ­ 배열이 정렬되면 이진탐색 등 효율적인 알고리즘으로 탐색 가능함. 학습자님의   v 구조체 배열 정렬하는 과정
Ÿ 구조체 크기 비교는 비교함수 제작
Ÿ 비교함수는 퀵정렬에서 qsort의 비교함수 형태 사용함.
Ÿ 이 형태가 C의 strcmp함수의 반환값과 일치함.
Ÿ 정렬방법은 퀵정렬 사용 ▶ 영어사전프로그램 학습자님의   학습자님의   v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.370~389 학습자님의   그래프 1

1. 그래프의  개념과  표현하는  방법을  이해하고,  이를  프로그램에  수업목표   적용할 수 있다. 12주차 
① 그래프란? 1교시 
② 그래프 추상데이터 타입 세부내용 
③ 그래프 표현방법
④ 그래프의 탐색(깊이우선탐색, 너비우선탐색) 1. 그래프란? ▶ 그래프 소개 ­ 그래프 : 연결되어 있는 객체 간의 관계를 표현하는 자료구조 ­ 많은  문제들은  공통적으로  도시,  소자,  자원,  프로젝트  등의  객체들이  서로  연결된  구조로  표현됨. ­ 가장 일반적인 자료구조 형태
Ÿ 앞에서 배운 트리도 그래프의 특수한 경우
Ÿ 전기회로의 소자 간 연결 상태
Ÿ 운영체제의 프로세스와 자원 관계
Ÿ 큰 프로젝트에서 작은 프로젝트 간의 우선순위
Ÿ 지도에서 도시들의 연결 상태 ▶ 그래프의 역사 ­ 1800년대 수학자 오일러에 의하여 창안되었음.

1) 오일러의 문제 : 모든 다리를 한 번만 건너서 처음 출발했던 장소로 돌아오는 문제  
2) A, B, C, D 지역의 연결 관계로 표현  ­ 위치 : 정점(node) ­ 다리 : 간선(edge) 위치 간의 관계 학습자님의  
3) 오일러의 정리  ­ 모든 정점에 연결된 간선의 수가 짝수이면 오일러의 경로가 존재함. ­ 그래프(b)에는 오일러 경로가 존재하지 않음. ▶ 그래프의 용어 : 그래프 G는 (V, E)로 표시함. ­ 여러 가지 특성을 가질 수 있는 객체를 의미함. 정점 ­ V(G) : 그래프 G의 정점들의 집합을 의미함. (vertex) ­ 노드(node)라고도 함. ­ 정점들 간의 관계를 의미함. 간선 ­ E(G) : 그래프 G의 간선들의 집합을 의미함. (edge) ­ 링크(link)라고도 불림. ▶ 그래프로 표현하는 것들 도로망 영역 간 인접 관계 선수과목 관계 ▶ 그래프의 종류
1) 무방향 그래프(undirected graph)  ­ 무방향 간선만 사용함.   ­ 간선을 통해서 양방향으로 갈 수 있음. ­ 도로의 왕복통행 길 ­ (A,B)와 같이 정점의 쌍으로 표현 ­ (A,B) = (B,A) 학습자님의  
2) 방향 그래프(directed graph)  ­ 방향 간선만 사용함. ­ 간선을 통해서 한 쪽 방향으로만 갈 수 있음. ­ 도로의 일방통행 길 ­ <A,B>와 같이 정점의 쌍으로 표현 ­ <A,B> /= <B,A>
3) 가중치 그래프(weighted graph)  ­ 네트워크(network)라고도 함. ­ 간선에 비용(cost)이나 가중치(weight)가 할당된 그래프 v 가중치 그래프 예
Ÿ 정점 : 각 도시
Ÿ 간선 : 도시를 연결하는 도로
Ÿ 가중치 : 도로의 길이   

4) 그래프 표현의 예 : 그래프를 집합으로 표현한 예 학습자님의  
5) 부분그래프(sub graph)  ­ 정점 집합V(G)와 간선집합 E(G)의 부분집합으로 이루어진 그래프
① 그래프 G1의 부분 그래프들
② 인접 정점(adjacent vertex) ­ 하나의 정점에서 간선에 의해 직접 연결된 정점 ­ G1에서 정점 0의 인접 정점 : 정점 1, 정점 2, 정점 3
③ 무방향 그래프의 차수(degree) ­ 하나의 정점에 연결된 다른 정점의 수 ­ G1에서 정점 0의 차수 : 3 ­ 무방향 그래프의 모든 차수의 합은 간선 수의 2배 (G1의 차수의 합 : 10,  G1의 간선의 합 : 5) ­ 진입차수(in
-degree) : 외부에서 오는 간선의 수 ­ 진출차수(out
-degree) : 외부로 향하는 간선의 수 ­ G3에서 정점 1의 차수 : 내차수 1, 외차수 2 ­ 방향그래프의 모든 진입(진출) 차수의 합은 간선의 수 (G3의 진입차수의 합 : 3, G3의 진출차수의 합 : 3,  G3의 간선의 합 : 3) ▶ 그래프의 경로

1) 그래프의 경로(path) ­ 무방향 그래프의 정점 s로부터 정점 e까지의 경로
Ÿ 정점의 나열 s, v1, v2, .....vk, e
Ÿ 나열된 정점들 간에 반드시 간선 (s,v1), (v1,v2),...(vk,e)이 존재해야 함. ­ 방향 그래프의 정점 s로부터 정점 e까지의 경로
Ÿ 정점의 나열 s, v1, v2, .....vk, e
Ÿ 나열된 정점들 간에 반드시 간선 (s,v1), (v1,v2),...(vk,e)이 존재해야 함. ­ 경로의 길이(length) : 경로를 구성하는데 사용된 간선의 수  ­ 단순경로(simple path) : 경로 중에서 반복되는 간선이 없는 경로 ­ 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경로
Ÿ G1의 0,1,2,3은 경로지만 0,1,3,2는 경로가 아님.
Ÿ G1의 1,0.2.3은 단순경로이지만  1,0,2,0은 단순경로가 아님.
Ÿ G1의 0,1,2,0과 G3의 0,1,0은 사이클임.    학습자님의   ▶ 그래프의 연결 정도

1) 연결그래프(connected graph) ­ 무방향 그래프 G에 있는 모든 정점쌍에 대하여 항상 경로가 존재함. ­ G2는 비연결 그래프임.
2) 트리(tree)  ­ 그래프의 특수한 형태로서 사이클을 가지지 않는 연결그래프
3) 완전그래프(complete graph) ­ 모든 정점이 연결되어 있는 그래프 ­ n개의 정점을 가진 무방향 완전그래프의 간선의 수 : n * (n
-1)/2 ­ n=4, 간선의 수 = (4*3)/2 = 6 2. 그래프 추상데이터 타입 ▶ 그래프 추상데이터 타입 ­ 그래프에 정점을 추가하려면 insert_vertex 연산 사용 ­ 그래프에 간선을 추가하려면 insert_edge 연산 사용 3. 그래프 표현방법 ▶ 그래프 표현방법 ­ 그래프 문제를 프로그램으로 해결하려면 그래프(정점의 집합과 간선의 집합)을 메모리에 저 장해야 함. 학습자님의   v 그래프를 메모리에 표현하는 방법 
① 2차원 배열 사용하는 인접행렬 방법
② 연결리스트를 사용하는 인접리스트 방법
Ÿ 그래프  문제의 특성에  따라  두  가지 표현  방법 각각의  메모리  사용량과  처리  시간  등 의 장단점을 고려하여 적합한 방법을 선택하여 사용함. ▶ 인접행렬 방법

1) 인접행렬(adjacent matrix) 방법 ­ 2차원 배열인 인접행렬 M의 각 원소를 다음 규칙에 할당하여 표현하는 방법
Ÿ if (간선 (i,j)가 그래프에 존재하면)           M[i][j] = 1                       그렇지 않으면      M[i][j] = 0 ­ 인접행렬의 대각선 성분은 모두 0(자체 간선 불허)
① 무방향 그래프의 인접행렬 : 대칭
Ÿ n개의  정점인  그래프  인접행렬로  표현하기  위하여는  간선의  수에  무관하게  항상  n2개 의 메모리가 필요함.  
Ÿ 인접행렬은 (a)와 같은 그래프에 간선이 많이 존재하는 밀집그래프 표현에 적합함.
Ÿ 그림(b)와 같은 그래프에 간선이 적은 희소그래프는 메모리의 낭비가 큼.
Ÿ 인접행렬 사용하여 두 정점을 연결하는 간선의 존재 여부를 O(1)시간에 즉시 알 수 있 음. 즉 간선은 M[i][j] 값을 조사하면 바로 알 수 있음.
Ÿ 정점의 차수는 인접행렬의 행이나 열을 조사하면 바로 알 수 있어 O(n)의 연산임.  즉 정점 i에 대한 차수는 인접행렬의 i번째 행에 있는 값을 모두 더하면 됨.
Ÿ 그래프에 존재하는 모든 간선의 수는 인접행렬 전체를 조사해야 하므로 n2번의 조사가  필요, O(n2)이 요구됨. 학습자님의   ▶ 인접리스트로 표현방법 ­ 각 정점에 인접한 정점들을 연결리스트로 표현함. ­ 정점의 번호를 알면 배열의 인덱스로 하여 각 정점의 연결리스트에 접근 가능함. ­ 그래프 표현의 일관성을 유지하기 위하여 인접리스트가 정점의 오름차순으로 연결로 가정함.
Ÿ 정점의 수가 n개, 간선의 수가 e개인  무방향 그래프를 표시하기 위한  연결리스트는 n개가 필요,  n개의 헤드포인터 2e개의 노드 필요함.
Ÿ 인접리스트 표현은 간선의 개수가 적은  희소그래프의 표현에 적합함. 
Ÿ n개의 정점, e개의 간선을 가진 그래프에서  전체의 간선의 수는 헤더노드 포함,  모든 인접리스트 조사가 필요하여  O(n+e) 연산이 요구  4. 그래프의 탐색 ▶ 그래프의 탐색 ­ 그래프의  가장  기본적인  연산으로  하나의  정점으로부터  시작하여  차례대로  모든  정점들을  한 번씩 방문하는 것. ­ 많은 문제들이 단순히 그래프의 노드를 탐색하는 것으로 해결됨.
Ÿ 도로망에서 특정 도시에서 다른 도시로 갈수 있는지 여부
Ÿ 전자회로에서 특정 단자와 다른 단자가 서로 연결되어 있는지 여부 ­ 그래프 탐색방법 : 깊이 우선 탐색 방법, 너비 우선 탐색 방법 ▶ 깊이 우선 탐색

1) 깊이 우선 탐색의 개념 (Dex)S:depth
-first search) ­ 한 방향으로 갈 수 있을 때까지 가다가  더 이상 갈수 없게 되면  가장 가까운 갈림길로 돌아와서  이 곳으로부터 다른 방향으로 다시 탐색 진행함. ­ 되돌아가기 위해서는 스택이 필요 (순환함수 호출로 묵시적인 스택 이용 가능) 학습자님의  

2) 깊이 우선 탐색 알고리즘 ­ 그래프의 시작 정점에서 출발함. 시작 정점에 v를 방문하고 표시함. ­ v 인접 정점에서 방문하지 않은 정점 u를 선택함. ­ 만약 방문하지 않은 정점이 없으면 종료함. ­ 만약 방문하지 않은 정점 u가 있으면 이 u를 시작정점으로 순환 호출함. ­ 다시 v에 인접 정점들 중 방문이 안 된 정점을 찾음.
3) 예제 그래프 : 깊이 우선 탐색 결과를 표시   학습자님의  
4) 깊이 우선 탐색의 구현 ­ 순환호출을 이용하여 구현하는 방법 ­ 명시적인 스택을 사용하여 구현하는 방법
5) 순환호출을 이용하여 구현하는 방법 ­ 방문여부 기록을 위한 visited 배열 사용함. ­ 정점의 visited 배열값은 ex)ALSE로 초기화하고 방문할 때마다 TRUE로 변경함. ­ 인접행렬 adj_mat[v][w] 값이 1(정점 v와 정점w는 인접한 것)이고 정점 w가 방문 전이면,  정점 w를 시작 정점으로 하여 함수호출 dfs_mat(g,w)로 깊이 우선 탐색을 다시 시작함. 
6) 인접리스트로 표현된 그래프 깊이 우선 탐색
7) 깊이 우선 탐색의 분석 ­ 모든 간선을 조사하므로 정점의 수 n, 간선의 수 e인 그래프의 깊이 우선 탐색 시간은 인접리스트로 표현된 경우는 O(n+e), 인접행렬로 표현된 경우는 O(n2) ­ 희소그래프의 경우 깊이 우선 탐색은 인접리스트의 사용이 인접행렬의 사용보다 효과적임. 학습자님의   ▶ 너비 우선 탐색
1) 너비 우선 탐색 (Bex)S : breadth
-first search) ­ 시작  정점으로부터  가까운  정점을  먼저  방문하고  멀리  떨어져  있는  정점을  나중에  방문하 는 순회방법 ­ 큐를 사용하여 구현됨. ▶ 너비 우선 탐색 알고리즘

1) 너비 우선 탐색 알고리즘 ­ 먼저 시작 정점인 0을 방문함. 다음은 정점 0의 인접정점 {1,2,4}를 차례로 방문함.  정점 {1,2,4}에 인접한 정점들을 조사하여 방문하지 않은 정점을 방문함.  여기에 해당하는 정점 {3}으로 정점 3을 방문하고 종료함. ­ 시작 정점부터 어떤 정점까지 가장 짧은 경로의 길이 ­ 거리가  0인  시작  정점  방문  후,  거리가  1인  정점,  거리가  2인  정점,  거리가  3인  정점  등  순서로 정점들을 방문함. [ 알고리즘 설명 ]
Ÿ 시작 정점 0이 방문된 다음, 큐에 삽입됨.
Ÿ while 루프에서 큐가 공백이 아니므로 큐에서 요소 하나 삭제하고 0이 추출됨.
Ÿ for 루프에서 인접한 정점인 1,2,4가 방문되고, 큐에 삽입됨.
Ÿ 다시  while  루프  처음으로  와서  큐에서  정점  1이  추출되고  정점  1에  인접한  정점  {0,2}를 조사함.
Ÿ 정점 {0,2}는 이미 방문되었기에 for 루프는 종료
Ÿ 다시 정점 2를 큐에서 꺼내어 정점 2에 인접한 정점인 {1,3,4}가 조사됨.
Ÿ 이 중에서 정점 3은 방문되지 않았기에 방문하고 큐에 삽입함.
Ÿ 다시 정점 4를 큐에서 꺼내어 인접 정점 조사 모두 방문하고 정점 3을 큐에서 꺼내어  조사 이미 인접정점이 모두 방문된 상태임.
Ÿ 큐가 공백상태가 되고 탐색이 종료됨. 학습자님의   학습자님의   ▶ 너비 우선 탐색의 구현

1) 인접행렬로 표현된 그래프의 너비 우선 탐색 프로그램
2) 인접리스트로 표현된 그래프의 너비 우선 탐색 프로그램 ▶ 너비 우선 탐색의 분석 ­ 인접리스트로 표현된 경우는 전체 수행시간이 O(n+e) ­ 인접행렬로 표현된 경우는 O(n2) ­ 너비 우선 탐색도 깊이 우선 탐색과 같이 희소그래프인 경우 인접리스트 사용이 효율적임. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.395~420 학습자님의   그래프 2
1. 최소비용신장트리  알고리즘을  이해하고  프로그램에  적용할  수  수업목표   12주차  있다. 2교시 
① 연결성분(connected component) 세부내용 
② 신장트리(spanning tree)
③ 최소비용 신장트리(MST : minimum spanning tree) 1. 연결성분 ▶ 연결성분(connected component) ­ 그래프 순회의 간단한 응용 ­ 최대로 연결된 부분그래프 ­ 연결된 부분그래프들 중에서 크기가 최대인 그래프를 연결성분이라 함. v (a)는 2개의 연결성분이 있음. ▶ 연결성분 찾기

1) 깊이 우선 탐색이나 너비 우선 탐색을 반복 이용함. ­ Dex)S 또는 Bex)S 탐색 프로그램의 visited[v]=TRUE; 를 visited[v]=count;로 교체함. ­ count를 증가시키면서 반복적으로 깊이 우선 탐색 프로그램을 호출함. ­ count는 전역변수로 0으로 초기화함. ­ 배열 visited에 같은 번호로 표시된 정점들은 하나의 연결성분을 구성함. ­ (a)의 연결성분을 표시한 배열 visited (b)임. ­ 각 정점의 집합 {0,1,2}와 집합 {4,5}가 각각 하나의 연결성분임. 학습자님의   ▶ 연결성분 프로그램 2. 신장트리 ▶ 신장트리(spanning tree) ­ 그래프 내의 모든 정점을 포함하는 트리 ­ 모든 정점들이 연결되어 있어야 하고 사이클을 포함해서는 안 됨. ­ n개의 정점을 가지는 그래프의 신장트리는 n
-1개의 간선을 가짐. ­ 최소의 링크를 사용하는 네트워크 구축 시 사용함. : 통신망, 도로망, 유통망 등 ­ 신장트리 찾기는 깊이 우선 탐색이나 너비 우선 탐색을 사용함. ­ 신장트리는 깊이 우선 탐색과 너비 우선 탐색 도중 사용된 간선만 모으면 만들 수 있음.
Ÿ (b)의 왼쪽 신장트리 (깊이 우선 신장트리) : 시작 정점 0으로 깊이 우선 탐색 도중 사 용된 간선만으로 만들어짐.
Ÿ (b)의 중간 신장트리 (너비 우선 신장트리) : 시작 정점 0으로 너비 우선 탐색할 때 사 용된 간선만으로 만들어짐. ▶ 신장트리 알고리즘 학습자님의   ­ 신장트리는 그래프의 최소연결부분 그래프가 됨. ­ 최소의 의미는 간선의 수가 가장 적다는 의미임. ­ n개의 정점을 가지는 그래프는 최소한 n
-1개의 간선의 수로 연결됨. ­ ■
-1개의 간선으로 연결되어 있으면 트리 형태가 되고 이것이 신장트리임. 3. 최소비용 신장트리 ▶ 최소비용 신장트리(MST : minimum spanning tree) ­ 네트워크에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결한 트리 ­ 신장트리 중에서 사용된 간선들의 가중치 합이 최소인 신장트리 v 응용 예 ­ 도시들을 모두 연결하면서 도로의  도로 건설 길이를 최소가 되도록 하는 문제 ­ 단자들을 모두 연결하면서 전선의  전기 회로 길이를 가장 최소로 하는 문제 ­ 전화선의 길이가 최소가 되도록  통신 전화 케이블망을 구성하는 문제   ­ 파이프를 모두 연결하면서 파이프의  배관 총 길이를 최소로 하는 문제 ▶ 최소비용 신장트리를 구하는 방법 최소비용 신장트리를 구하는 방법
① Kruskal이 제안한 알고리즘
② Psim이 제안한 알고리즘 ­ 이 알고리즘들은 최소비용 신장트리가 간선의 가중치의 합이 최소이어야 함. ­ 반드시 n
-1개의 간선만 사용해야 함. ­ 사이클이 포함되어서는 안 됨.

1) Kruskal의 MST알고리즘 ­ 탐욕적인 방법(greedy method)을 이용함. ­ 탐욕적인 방법은 알고리즘 설계에 중요한 기법 중 하나임. ­ 각 단계에서 그 순간 최선의 답을 선택하는 과정을 반복함으로써 최종적인 해답에 도달함. ­ 탐욕적인 방법은 항상 최적의 해답을 주는지 검증이 필요함. ­ Kruskal MST알고리즘은 최적의 해답임이 증명되었음. ­ MST는 최소비용의 간선으로 구성됨과 동시에 사이클을 포함하지 않아야 함. ­ 각 단계에서 사이클을 이루지 않는 최소비용 간선을 선택함. 학습자님의  
Ÿ 그래프의 e개 간선들을 가중치의 오름차순으로 정렬
Ÿ 정렬된 간선 중에서 사이클을 형성하지 않는 간선을 현재의 MST 집합에 추가
Ÿ 만약 사이클이 형성하면 그 간선은 제외

2) Kruskal 알고리즘 이용하여 최소비용 신장트리 만드는 과정
Ÿ 간선들을 가중치의 오름차순으로 정렬 후 가장 가중치((a,f)10)가 낮은 간선을 먼저 선 택함. Er에 포함함.
Ÿ 계속 낮은 가중치 간선들을 선택함.
Ÿ (d,g)의 경우는 b,c,d,g,b의 사이클이 형성되므로 제외함.
Ÿ (e,g)도 사이클 형성으로 제외함.
Ÿ (e,f) 선택으로 간선의 수 6개로 정점의 수 7
-1이므로 종료함.  학습자님의  

3) union
-find 알고리즘 ­ 두 집합들의 합집합을 만듦. ­ 원소가 어떤 집합에 속하는지 알아냄. ­ Kruskal의 MST알고리즘에서 사이클 검사에 사용함. ­ Kruskal의 MST알고리즘에서 사이클을 생성하는지 체크해야 함. ­ 사이클은 새로운 간선이 이미 다른 경로에 의하여 연결된 정점들을 연결할 때 발생함. ­ 정점이 같은 집합에 속하면 간선을 추가하면 사이클이 형성됨. ­ 양끝 정점이 서로 다른 집합에 속하면 두 정점을 연결하여도 사이클이 형성되지 않음. ­ 추가하고자 하는 정점이 간선의 양 끝 정점이 같은 집합에 속해 있는지를 먼저 검사함. 이  검사 알고리즘이 union
-find 알고리즘임.
Ÿ union(x,y)연산 : 원소 x와 y가 속해 있는 집합을 입력 받아 2개 집합의 합집합을 만듦.
Ÿ find(x)연산 : 원소 x가 속한 집합을 반환함.
① 예 S = {1, 2, 3, 4, 5, 6} 집합 가정    
- 집합 원소 하나씩 분리하여 독자 집합을 만듦.      {1}, {2}, {3}, {4}, {5}, {6}    
- union(1,4), union(5,2)를 하면 다음과 같이 변화됨.      {1,4}, {5.2}, {3}, {6}    
- union(4,5), union(3,6)을 하면 다음과 같은 결과를 얻음.      {1,4,5,2} {3,6} ­ 집합 구현 방법은 비트 벡터, 배열, 연결리스트를 이용하여 구현함. ­ 가장 효율적인 방법은 트리 형태를 사용하는 것임. ­ 각 집합을 그 집합에 들어 있는 원소들의 트리로 표현함. ­ 집합은 트리의 루트에 의하여 대표됨. 학습자님의  

4) union
-find 프로그램

5) Kruskal 알고리즘 ­ Kruskal 알고리즘은 대부분 간선들을 정렬하는 시간에 좌우됨.
Ÿ 사이클 테스트 등의 작업은 정렬에 비해 매우 신속하게 수행됨. ­ 네트워크의 간선 e개를 퀵 정렬과 같은 효율적인 알고리즘으로 정렬한다면 Kruskal 알고리 즘의 시간복잡도는 O(elog(e))가 됨.

6) Prim의 MST 알고리즘 ­ 시작 정점에서부터 출발하여  신장트리 집합을 단계적으로 확장해 나감. 시작 단계에서는 시작 정점만이  신장트리 집합에 포함됨. ­ 신장 트리집합에 인접한 정점 중에서  최저 간선으로 연결된 정점 선택하여  신장 트리집합에 추가함. ­ 이 과정은 신장트리 집합이 n
-1개의 간선을  가질 때까지 반복함. 학습자님의  
Ÿ Kruskal  알고리즘  :  간선  선택을  기반으로  하는  알고리즘으로  이전  단계와  관계없이  최선 간선만을 선택하는 방법
Ÿ Prims  알고리즘  :  정점  선택을  기반으로  하는  알고리즘으로  이전  단계에서  만들어진  신장트리를 확장하는 방법

7) Prim 최소비용 신장트리 알고리즘
8) Prim 알고리즘 분석 ­ 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복하므로 Prim의 알고리즘은  O(n2)의 복잡도를 가짐.
Ÿ 희박한 그래프 : O(elog(e))인 Kruskal의 알고리즘이 유리함.
Ÿ 밀집한 그래프 : O(n2)인 Prim의 알고리즘이 유리함. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.420~437 학습자님의   그래프 3

1) 최단경로 알고리즘과  그래프 문제  풀이  응용 방법을  이해하고,  12주차  수업목표   이를 프로그램 할 수 있다. 3교시 
① 최단경로(shortest path) 세부내용 
② 위상정렬(topological sort) 1. 최단경로 ▶ 최단경로(shortest path) ­ 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는  경로 ­ 간선의 가중치는 비용, 거리, 시간 등을 말함. v 정점 0에서 정점 3으로 가는 최단 경로 문제 
Ÿ 인접행렬에서 간선이 없는 노드 쌍의 가중치는 ∞임.
Ÿ 0,4,1,2,3이 최단 경로임.
Ÿ 최단경로 길이 : 3+2+4+2=11 ▶ 최단경로 발견 방법 Dijkstra 알고리즘 ­ 하나의 시작 정점에서 모든 다른 정점까지의 최단경로를 구함. ex)loyd 알고리즘 ­ 모든 정점에서 다른 모든 정점까지의 최단 경로를 구함. ­ 가중치는 가중치 인접행렬이라는 2차원 배열에 저장한다고 가정함. ­ 인접행렬에서는 간선이 없으면 인접행렬의 값은 0임. ­ 가중치 인접행렬에서는  간선의 가중치가 0의 경우도  있기에 0의  값이  간선이 없음을  나타 내지 못함. ­ 가중치가 0인 경우는 무한대의 값을 가중치 인접행렬에 저장함. ­ 컴퓨터에서는 무한대의 값이 없음. 따라서 상당히 큰 값을 무한대라고 생각하고 저장함. ▶ Dijkstra의 최단경로 알고리즘 ­ 하나의 시작 정점으로 부터 모든 다른 정점까지의 최단경로를 찾음. ­ 최단 경로는 경로의 길이 순으로 구해짐.

1) 집합 S : 시작 정점 v로부터의 최단경로가 이미 발견된 정점들의 집합 학습자님의  
2) distance 배열 ­ 최단경로가 알려진 정점들만을 이용한 다른 정점들까지의 최단경로 길이를 기록하는 배열 ­ distance배열의 초기값은 (시작정점 v) ­ distance[v] = 0 ­ 다른 정점에 대한 distance값은 시작 정점과 해당 정점 간의 가중치
3) weight인접행렬 ­ 가중치를 저장하므로, distance[w] = weight[v][w] ­ 정점 v에서 정점 w로 직접 간선이 없는 경우는  무한대 값을 저장함. ­ 시작 단계에서는 최단 경로가 발견된 것이 없으므로 S={v}  ­ 매 단계 알고리즘이 진행되면서  최단 거리가 발견되는 정점들이 S에 추가됨.    ▶ 최단경로 알고리즘 증명 distance 값이 가장 작은 정점을 u라고 하자.  그러면 시작 정점 v에서 정점 u까지의 최단거리는 경로 
①이 된다.  정점 w를 거쳐서 정점 u로 가는 가상적인 더 짧은 경로가 있다고 가정해 보자. 그러면 정점 v에서 정점 u까지의 거리는 정점 v에서 정점 w까지의 거리 
②와  정점 w에서 정점 u로 가는 거리 
③을 합한 값이 된다.  그러나 경로 
②는 경로 
①보다 항상 길 수 밖에 없다.   왜냐하면 현재 distance 값이 가장 작은 정점은  u이기 때문이다. 따라서 매 단계에서 distance 값이  가장 작은 정점들을 추가해나가면 시작 정점에서  모든 정점까지의 최단거리를 구할 수 있다. 새로운 정점이 S에 추가되면 S에 있지 않은 다른 정점들이 distance값을 갱신한다. 새로 추가된  정점  u를 거쳐서  정점까지 가는  거리와 기존의 거리를  비교하여  더 작은 거 리로 distance 값을 수정한다. distance[w] = min(distance[w],distance[u]+weight[u][w]) 학습자님의   ▶ 최단경로 알고리즘 v 예제 그래프에서 집합 S와 distance의 초깃값을 구하자.
(1) STEP 1 S={0}    
- distance[0] = weight[0][0] = 0    
- distance[1] = weight[0][1] = 7    
- distance[2] = weight[0][2] = ∞    
- distance[3] = weight[0][3] = ∞    
- distance[4] = weight[0][4] = 3    
- distance[5] = weight[0][5] = 10    
- distance[6] = weight[0][6] = ∞ (2) STEP 2 ­ 정점 0에서 정점4까지의 최단경로는 가장 작은 값 3을 가짐. ­ 새로운 정점이 S에 추가되면 다른 정점들의 distance 값이 변경됨. ­ 새로운  정점을 통해서  그 정점에  갈 수  있는  경로  값이  현재의  distance값보다  더 작으면  현재의 distance값을 새로운 경로 값으로 변경함. ­ 정점 4를 통하여 정점 6으로 갈 수 있고 그 경로 값이 8이므로 현재의 값인 ∞를 8로 변경함. ­ 정점 3도 ∞에서 14로 변경됨. ­ 정점 1까지의 값인 7도 정점 4를 통하여 가는 값인 5가 더 작으므로 5로 변경함. 학습자님의   S={0, 4}    
- distance[0] = 0    
- distance[1] = min(distance[1], distance[4] + weight[4][1]) = min(7, 3+2) = 5    
- distance[2] = min(distance[2], distance[4] + weight[4][2]) = ∞    
- distance[3] = min(distance[3], distance[4] + weight[4][3]) = min(∞, 3+11) = 14    
- distance[4] = 3    
- distance[5] = min(distance[5], distance[4]+ weight[4][5]) = min(10, 3+ ∞) = 10    
- distance[6] = min(distance[6], distance[4] + weight[4][6]) = min(∞, 3+5) = 8 (3) STEP 3 S={0, 4, 1}    
- distance[0] = 0    
- distance[1] = 5    
- distance[2] = min(distance[2], distance[1]+weight[1][2]) = min(∞, 5+4) = 9    
- distance[3] = min(distance[3], distance[1]+weight[1][3])= min(14, 5+10) = 14    
- distance[4] = 3    
- distance[5] = min(distance[5], distance[1]+weight[1][5])= min(10, 5+6) = 10    
- distance[6] = min(distance[6], distance[1]+weight[1][6]) = min(8, 5+ ∞) = 8 학습자님의   (4) STEP 4  S = { 0, 4, 1, 6 }     
- distance[0] = 0    
- distance[1] = 5    
- distance[2] = min(distance[2], distance[6]+weight[6][2]) = min(9, 8+ ∞) = 9    
- distance[3] = min(distance[3], distance[6]+weight[6][3])= min(14, 8+4) = 12    
- distance[4] = 3    
- distance[5] = min(distance[5], distance[6]+weight[6][5])= min(10, 8+ ∞) = 10    
- distance[6] = 8 (5) STEP 5 S = { 0, 4, 1, 6, 2 }     
- distance[0] = 0    
- distance[1] = 5    
- distance[2] = 9    
- distance[3] = min(distance[3], distance[2]+weight[2][3]) = min(12, 9+2) = 11    
- distance[4] = 3    
- distance[5] = min(distance[5], distance[2]+weight[2][5]) = min(10, 9+ ∞) =10    
- distance[6] = 8 학습자님의   (6) STEP 6  S = {0, 4, 1, 6, 2, 5}     
- distance[0] = 0    
- distance[1] = 5    
- distance[2] = 9    
- distance[3] = min(distance[3], distance[5]+weight[5][3])= min(11, 10+9) = 11    
- distance[4] = 3    
- distance[5] = 10    
- distance[6] =ž distance[0] = 0 (7) STEP 7  S = { 0, 4, 1, 6, 2, 5, 3 }     
- distance[0] = 0    
- distance[1] = 5    
- distance[2] = 9    
- distance[3] = 11    
- distance[4] = 3    
- distance[5] = 10    
- distance[6] = 8 학습자님의   ▶ 최단 경로 Dijkstra프로그램 ▶ Dijkstra의 최단경로 알고리즘 복잡도 ­ 네트워크에 n개의 정점이 있다면, Dijkstra의 최단경로 알고리즘은 주 반복문을 n번 반복하 고 내부 반복문을 2n번 반복하므로 O(n2)의 시간복잡도를 가짐. 학습자님의   ▶ ex)loyd 최단 경로 알고리즘 ­ 모든 정점 사이의 최단경로를 한 번에 찾아주는 알고리즘 ­ 2차원 배열 A를 이용하여 3중 반복을 하는 루프로 구성됨.

1) 인접행렬 weight를 구성 
Ÿ i == j 이면, weight[i][j] = 0
Ÿ 두 개의 정점 i, j 사이에 간선이 존재하지 않으면, weight[i][j] = ∞
Ÿ 정점 i, j 사이에 간선이 존재하면, weight[i][j]는 간선 (i, j)의 가중치가 됨.
Ÿ 배열 A의 초기값은 인접행렬인 weight가 됨. [ 알고리즘 설명 ] Ak[i][j]
Ÿ 0부터 k까지의 정점만을 이용한 정점 i에서 j까지의 최단경로 길 최종적인 답 : An
-1[i][j]
Ÿ 0부터 n
-1까지의 모든 정점을 이용한 최단거리이기 때문
Ÿ A
-1→A0 → A1 → … → An
-1순으로 최단 경로 구하자는 것
Ÿ A
-1은 weight 배열의 값

2) Ak
-1까지 구해진 상태에서 k번째 정점이  추가로 고려되는 상황을 생각하자.
① 0부터 k까지의 정점만을 사용하여  정점 i에서 정점 j로 가는 최단 경로 정점 k를 거치지 않는 경우
Ÿ Ak[i][j] 는 k보다 큰 정점은 통과하지 않으므로 최단거리는 여전히 Ak
-1[i][j]]임. 정점 k를 거치는 경우
Ÿ I에서 k까지의 최단거리 Ak
-1[i][k]에 k에서 j까지의 최단거리 Ak
-1[k][j]를 더한 값이 됨. 최종적인 최단거리는 두 가지 중 더 작은 값이 됨.
Ÿ Ak
-1[i][j]와 Ak
-1[i][k] + Ak
-1[k][j] 중 더욱 작은 값이 Ak[i][j]가 됨.
Ÿ 정점  k를  경유하는  것이  종은  경로이면  Ak
-1[i][j]의  값이  변경되고,  아니면  이전  값을  유지함. 학습자님의   ▶ 예제 그래프에 대한 A배열이 변경되는 과정                                ▶ ex)loyd 최단경로 프로그램 ▶ ex)loyd 최단경로 알고리즘 복잡도 ­ 네트워크에  n개의  정점이  있다면,  ex)loyd의  최단경로  알고리즘은  3중  반복문을  실행하므로  시간 복잡도는 O(n3)이 됨. ­ 모든  정점  쌍의 최단경로를 구하려면 Dijkstra의  알고리즘 O(n2)을 n번 반복해도  되며, 이  경우 전체 복잡도는 O(n3)이 됨. ­ 모든  정점 쌍의  최단경로를  구하는데  있어 두 알고리즘 모두  동일한 O(n3)의 복잡도를 가 지지만  ex)loyd의  알고리즘은  매우  간결한  반복구문을  사용하므로  Dijkstra의  알고리즘보다  효율적임. 학습자님의   2. 위상정렬 ▶ 위상정렬(topological sort)

1) 최단경로(topological sort) ­ 방향그래프에서 간선 <u,v>가 있다면 정점 u는 정점 v를 선행함. ­ 방향그래프 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열함. ­ 선수과목은 과목들의 선행 관계를 표현함. 과목 번호 과목명 선수 과목 0 컴퓨터개론 없음 1 이산수학 없음 2 C언어 0 3 자료구조 0,  1,  2 4 확률 1 5 알고리즘 2,  3,  4  ▶ 위상순서(topological order) ­ (0, 1, 2, 3, 4, 5), (1, 0, 2, 3, 4, 5) (2, 0, 1, 3, 4, 5)는 위상순서가 아님. → 2번 정점이 0번 정점 앞에 오기 때문    ▶ 위상순서 예 ­ 초기상태에서 1을 제거하고 정점 4가 진입차수가 0이 됨. → 후보 정점 0, 4 ­ 정점 0을 선택 제거하면 정점 2가 진입차수가 0이 됨. → 후보 정점 1, 4, 0, 2 ­ 정점 2를 선택 제거하면 정점 3이 진입차수가 0이 됨. → 후보 정점 1, 4, 0, 2, 3 ­ 정점 3을 선택 제거하면 정점 5가 진입차수가 0이 됨. → 후보 정점 1, 4, 0, 2, 3, 5 학습자님의   ▶ 그래프 위상정렬 알고리즘 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.105~166 v C로 배우는 쉬운 자료구조, 이지영, pp.98~104 학습자님의   해싱 1 수업목표   1. 해싱의 개념과 구조를 이해하고 설명할 수 있다. 13주차  1교시 
① 해싱의 개념 및 추상자료형 사전구조 세부내용 
② 해싱의 구조
③ 이상적인 해싱과 실제의 해싱 1. 해싱의 개념 및 추상자료형 사전구조 ▶ 해싱이란? ­ 대부분의 탐색방법들은 키값을 비교함으로써 탐색하고자 하는 항목에 접근함. 해싱  ­ 키값에 대한 산술적 연산에 의해 테이블의 주소를 계산하여 항목에  (hashing) 접근함. 해시 테이블  ­ 키값의 연산에 의해 직접 접근이 가능한 구조 (hash table) ­ 해싱은 물건을 정리하는 것과 같음.   ­ 키값 비교에 의한 탐색방법은 정렬이 안 되어 있으면 O(n), 정렬이 되어 있으면 O(log ■)임. 2 ­ 해싱은 이론적으로 O(1)의 시간 안에 탐색을 마침. ­ 해싱은 사전과 같은 자료구조를 구현할 때 최상의 선택이 됨. ▶ 추상자료형 사전구조

1) 사전구조(dictioncary) ­ 맵(map)또는 테이블(table)로 불림. 탐색 키와 관련된 값의 2가지 필드로 구성됨. 
① 영어단어나 사람의 이름 같은 탐색 키(search key)
② 단어의 정의나 주소 또는 전화번호 같은 탐색 키와 관련된 값(value)  ­ 사전구조는 오직 탐색키에 의해서만 관리됨. ­ 리스트는 근본적으로 위치에 의하여 관리되는 자료구조임. 학습자님의   ▶ 사전구조의 연산 ­ 새로운 항목을 사전에 삽입(add) ­ 탐색 키에 과련된 항목을 삭제(delete) ­ 탐색 키에 관련된 값을 탐색(search)
Ÿ 사전구조를 이진탐색트리를 사용한다면 O(n)이 됨.
Ÿ 해싱은 탐색키의 비교가 아닌 탐색 키에 수식을 적용하여 바로 탐색 키가 저장된 위치 를 얻음. 2. 해싱의 구조 ▶ 해싱의 구조 ­ 탐색 키들이 0부터 999까지의 정수로 가정 ­ 가장  빠르게  자료를  저장하고  꺼낼  수  있는  방법은  1000개의  요소를  가지는  배열을  만드 는 것임. ­ 배열의 인덱스를 탐색키로 탐색을 하면 O(1)임. ­ 탐색 키들이 문자열이거나 큰 숫자이기에 탐색 키를 배열의 인덱스로 사용하기 무리가 있음. ­ 탐색 키를 작은 정수로 사상(mapping)시킨 어떤 함수가 필요함. ­ 해싱이란 어떤 항목의 탐색 키만 가지고 바로 항목이 저장되어 있는 배열의 인덱스를 결정 하는 기법임. ▶ 해시함수(hash function) ­ 탐색 키를 입력 받아  해시주소(hash address)를 생성함.  이 해시주소가 배열로 구현된  해시테이블(hash table)의 인덱스가 됨. ­ 키값 k를 입력받아 해시함수 h()로 연산한 결과  해시주소 H(k)를 인덱스로 사용하여  해시테이블에 있는 항목을 탐색함. 학습자님의   ▶ 해시테이블의 구조

1) 해시테이블 ht 
Ÿ M개의 버켓(bucket)으로 구성된 테이블
Ÿ ht[0], ht[1],...., ht[M
-1]의 원소를 가짐.
Ÿ 하나의 버켓에 s개의 슬롯(slot)이 가능함.

2) 충돌(collision)  ­ h() = 0 ≤ h(k) ≤  M
-1 ­ 서로 다른 두 개의 탐색 키 k1과 k2에 대하여 h(k1) = h(k2)인 경우, k1과 k2를 동의어(synonym)라 함. ­ 서로  다른  두  개의  키가  해시함수에  의해  동일한  주소로  변환되는  경우  여러  개의  슬롯을  두어 해결함.

3) 오버플로우(overflow)  ­ 충돌이 버켓에 할당된 슬롯 수보다 많이 발생하는 것 ­ 오버플로우 해결방법은 반드시 필요함. ­ 충돌이 자주 발생하면 버켓 내부의 순차탐색시간이 길어져 탐색성능이 저하됨. ­ 해시함수를 수정하거나 해시테이블의 크기를 조절함. 3. 이상적인 해싱과 실제의 해싱 ▶ 이상적인 해싱 [ 학생 정보를 해싱으로 저장, 탐색해보기 ]
Ÿ 5자리 학번 중에 앞 2자리가 학과번호,  뒤 3자리가 각 학과의 학생번호
Ÿ 같은 학과 학생들만 가정하면  뒤의 3자리만 사용해서 탐색 가능
Ÿ 학번이 00023이라면  이 학생의 인적 사항은 해시테이블 ht[23]에 저장
Ÿ 만약  해시테이블이  1000개의  공간을  가지고  있다면  탐색 시간이 O(1)이 되므로 이상적임. ▶ 실제의 해싱
Ÿ 실제로는  해시테이블의  크기가  제한되므로  존재  가능한  모든  키에  대해  저장  공간을  할당할 수 없음.
Ÿ h(k) =k mod M의 예에서 보듯이 필연적으로 충돌과 오버플로우가 발생함.
Ÿ 탐색 키는 매우 많고 해시테이블의 크기는 제약을 받는 것이 일반적임. 학습자님의   [ 주민등록번호가 탐색키인 경우 ]
Ÿ 탐색 키 하나 당 공간을 할당하는 경우,  해시테이블은 매우 큰 공간이 필요함.
Ÿ 주민등록번호 13자리이므로 1013개의 공간이 필요함.
Ÿ 가능한 탐색 키의 수는 10조 개이지만  실제 데이터인 국민의 수는 5천만 명임.
Ÿ 탐색 키에 비하여 해시테이블의 크기는 작고,  탐색 키 중에 일부만 사용함.
Ÿ 전체의 공간을 항상 준비할 필요는 없음.
Ÿ 간단하면서도 강력한 방법은 탐색 키를 해시테이블의 크기로 나누어서 그 나머지를 해 시테이블의 주소로 하는 것임.
Ÿ 정수를  해시테이블  크기  M으로  나누어서  나머지를  취하면  0에서  M
-1까지의  숫자가  생성됨.
Ÿ 이 값은 해시테이블을 위한 유효한 인덱스가 됨.  [ h(k) = k mod M ]
Ÿ 이  해시함수는  완벽하지  않아서  두  개  이상의  탐색  키가  동일한  해시테이블의  공간을  매핑될 수 있음.
Ÿ 예로서 테이블의 크기 31의 경우 h(00023)과 h(00054)가 같은 주소로 매핑됨. 이를  충돌이라고 함. 해싱에서 충돌의 해결은 매우 중요함. [ 하나의 버킷에 여러 개의 슬롯이 있는 경우 ]
Ÿ 알파벳 문자열 키의 해시함수가 키의 첫 번째 문자 순서라고 하자.    
- h("array") = 0    
- h("binary") =1
Ÿ 입력데이터 : array, binary, bubble,, file, digit, direct, zero, bucket
Ÿ 충돌과 오버플로우가 계속 발생함.
Ÿ 문자열 “bucket”은 오버플로우로 저장되지 않음. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.438~475 학습자님의   해싱 2

1. 좋은 해시함수의 조건 3가지를 제시할 수 있다. 해시함수의 종 수업목표   류를  열거할  수  있다.  충돌  해결책의  선형조사법과  체이닝을  13주차  이해하고, 프로그램을 할 수 있다. 2교시 
① 좋은 해시함수의 조건
② 해시함수의 종류 세부내용 
③ 비트 추출 방법과 숫자 분석 방법
④ 충돌해결책 1. 좋은 해시함수의 조건 ▶ 좋은 해시함수의 조건 ­ 키 값을 해시테이블의 주소로 변환하는 해시 함수가 잘 설계되어야 함. < 좋은 해시함수의 조건 3가지 >
① 충돌이 적어야 함.
② 해시함수 값이 해시테이블의 주소 영역 내에서  고르게 분포되어야 함.
③ 계산이 빨라야 함.  ­ 영문인  은행  지점명의  첫  번째  글자를  취하여  해시함수로  사용하는  것은  해시테이블을  균 일하게 사용하지 않음. → 문자 “X” 시작하는 지점명은 별로 없기 때문 ­ 해시테이블의  크기가  M인  경우  해시함수는  탐색  키(주로  정수,  문자열)들을  [0,  M
-1]의  범위의 정수로 변환시켜야 함. 2. 해시함수의 종류 ▶ 제산함수 ­ 탐색 키를 정수로 가정함. ­ 나머지  연산자(mod)를  사용하여  탐색  키를  해시테이블의  크기로  나눈  나머지를  해시주소 로 사용하는 방법

1) 탐색 키 k에 대하여  ­ h(k) = k mod M ­ 해시테이블의 크기 M은 소수로 나누어지지 않는 수를 선택함. ­ 해시함수의 범위 : 0 ~ (M
-1) ­ 해시테이블의 인덱스로 사용하기에 이상적인 값임. 이 방법은 해시주소를 상당히 고르게 분 포시키는 좋은 방법임. 학습자님의  

2) M 선택의 중요성  ­ M이 짝수이면 k mod M은 k가 짝수이면 짝수가 되고 k가 홀수이면 홀수가 됨. ­ 메모리주소를 가지고 해싱을 한다면 k가 짝수가 될 가능성이 높음. (메모리주소는 2의 배수) ­ M은 항상 홀수이어야 함. ­ M이 소수이고 자기 자신과 1만을 약수로 가지는 수이면 k mod M은 0에서 M
-1을 골고 루 사용하는 값을 만들어 냄. ­ 나머지 연산에서 음수가 나올 수도 있음. ­ k mod M이 음수라면 여기에 M을 더하여 결과 값이 항상 0에서 M
-1이 되도록 함.

3) 최종적인 해시함수  ▶ 폴딩함수 ­ 탐색 키를 여러 부분으로 나누어 모두 더한 값을 해시주소로 함. ­ 탐색 키를 나누고 더하는 방법 : 이동폴딩과 경계폴딩이 대표적임.
Ÿ 이동폴딩(shift folding) : 탐색 키를 여러 부분으로 나눈 값들을 더해 해시주소로 사용
Ÿ 경계폴딩(boundary folding) : 탐색 키의 이웃한 부분을 거꾸로 더하여 해시주소로 사용 ­ 폴딩 방법을 구현할 때는 키 값을 해시테이블 크기만큼의 수를 가지는 부분으로 분할한 후,  분할된 부분을 합하여 해시주소를 만듦.
Ÿ 키 값이 “12320324111220”이고 해시주소가 10진수 3자리로 구성된 경우  이동폴링과 경계폴링의 예 ­ 탐색 키가 해시테이블의 크기보다 더 큰 정수일 경우에 사용함. ­ 탐색  키가  32비트,  해시테이블의  인덱스는  16비트  정수인  경우탐색  키의  앞  16비트를  무 시하고 뒤 16비트를 해시코드로 사용하면 충돌이 발생함. ­ 탐색 키를 몇 개로 나누어 이를 더하거나 비트별로 XOR 부울연산을 하면 좋음. 이것을 폴 딩(folding)이라고 함. ­ 32비트의 키를 2개의 16비트로 나누어 비트 별로 XOR 연산하는 코드         hsah_index=(short)(key^(key>>16)) 학습자님의   ▶ 중간제곱함수 ­ 탐색 키를 제곱한 다음, 중간의 몇 비트를 취해서 해시주소를 생성함. ­ 제곱한  값의  중간  비트들은  대개  탐색  키의  모든  문자들과  관련이  있기  때문에  서로  다른  탐색 키는 몇 개의 문자가 같을지라도 서로 다른 해싱 주소를 갖게 됨. ­ 탐색 키값을 제곱한 값의 중간 비트들의 값은 비교적 고르게 분산됨. 3. 비트 추출 방법과 숫자 분석 방법 ▶ 비트 추출 방법과 숫자 분석 방법

1) 비트 추출 방법 ­ 해시테이블의 크기가  M=2k일  때 탐색  키를  이진수로  간주하여 임의의  위치의 k개의 비트 를 해시주소로 사용함. ­ 방법은 아주 간단하지만 탐색 키의 일부 정보만을 사용하므로 해시주소의 집중현상이 일어 날 가능성이 높음.
2) 숫자 분석 방법 ­ 숫자로 구성된 키에서 각각의 위치에 있는 수의 특징을 미리 알고 있을 때 유용함. ­ 키의 각각의 위치에 있는 숫자 중에서 편중되지 않는 수를 해시테이블의 크기에 적합한 만 큼 조합하여 해시주소로 사용 ­ 학생의  학번  200812345라면  입학년도를  의미하는  앞  4자리  수는  편중되어  있으므로  사 용하지 않고 나머지 수를 조합하여 해시주소로 사용함. ▶ 탐색 키가 문자열일 경우 주의할 점 ­ 문자열 안의 문자에 정수를 할당한다. ­ ‘a’부터 ‘z’에 1부터 26을 할당함. ­ 문자의 아스키코드나 유니코드 값을 사용하는 것도 방법 “book”, “cup”, “car”, “desk” 등을 해시주소 변환하면 
Ÿ 가장 간단한 방법은 첫 번째 문자의 아스키 값을 해시주소로 사용하는 것임.
Ÿ book과 cup는 구분되나, cup과 car는 구분하지 못함. ­ 충돌을 막기 위해 문자열 안의 모든 문자를 골고루 사용해야 함.
Ÿ 각 문자의 아스키 값을 모두 더하는 것임.
Ÿ 문자열이 동일하지만 위치가 다른 경우는 구분할 수 없음.
Ÿ are와 era와 같은 탐색 키는 구분할 수 없음. 학습자님의   ­ 더 좋은 방법 : 문자들의 아스키 값 위치에 기초한 값을 곱하는 것
Ÿ 문자열 S가 n개의 문자를 가지고 있으면,  S안의 i번째 문자가 ui라고 하여 해시주소를 계산함. u gn
-1 + u gn
-2 + ... + u g + u 0 1 ■
-2 ■
-1 g는 양의 정수로 보통 31을 사용함.
Ÿ 호너의 방법 사용 (..(u g + u )g + u ) + ... + u )g + u 0 1 2 ■
-2 ■
-1 v 함수  4. 충돌해결책 ▶ 충돌해결책

1) 충돌(collision) ­ 서로 다른 탐색 키를 갖는 항목들이 같은 해시주소를 가지는 현상 ­ 충돌이 발생하면 해시테이블에 항목 저장이 불가능함. ­ 충돌을 효과적으로 해결하는 방법이 반드시 필요함.
2) 2가지 해결책
① 선형조사법  ­ 충돌이 일어난 항목을 해시테이블의 다른 위치에 저장하는 방법
② 체이닝 ­ 테이블의 하나의 위치가 여러 개의 항목을 저장할 수 있도록 해시테이블 구조를 변경함.  ­ 각 버켓에 삽입과 삭제가 용이한 연결리스트 할당함. 학습자님의   ▶ 선형조사법(linear probing)

1) 선형조사법(linear probing) ­ 특정 버켓에서 충돌이 발생하면 해시테이블에서 비어 있는 버켓을 찾는 방법 ­ 조사 : 해시테이블에서 비어 있는 공간을 찾는 것 [ 충돌이 ht[k]에서 발생했다면 ]
Ÿ ht[k+1]이 비어 있는지 조사함.
Ÿ 만약 비어 있지 않다면 ht[k+2] 조사함.
Ÿ 비어 있는 공간이 나올 때까지 계속 조사함. 
Ÿ 테이블의 끝에 도달하게 되면 다시 테이블의 처음부터 조사함.
Ÿ 조사 시작한 곳으로 다시 되돌아오면 테이블이 가득 찬 것.
Ÿ 조사되는 위치 : h(k), h(k)+1, h(k)+2, h(k)+3, ......

2) 선형조사법의 예
Ÿ 크기가 7인 해시테이블에서 해시함수로 h(k)=k mod 7을 사용 8, 1, 9, 6, 13 의 순으로 탐색 키를 저장하면  선형조사법은 오버플로우가 발생하면 빈 버켓을 순차적으로 탐색하여 저장함. ▶ 선형조사법의 구현

1) 선형조사법의 구현 ­ 해시테이블은 1차원 배열로 구현함. 키필드와 키와 관련된 자료필드를 가짐. ­ 탐색 키가 문자열로 되어있음. v 선형조사법의 구현 part 1  학습자님의   v 해시테이블을 초기화시키는 함수 part 2  ­ 해시테이블의 초기화 과정은 각 버켓들을 공백상태로 만드는 것임. ­ 문자열이 탐색 키이므로 탐색 키의 첫 번째 문자가 NULL값이면 버켓이 비어 있는 것임. v 선형조사법의 구현 part 2 v 선형조사법의 구현 part 3  ­ 해시테이블에 탐색 키를 삽입하기 위해서는  탐색 키를 정수로 바꾸어주는 해시함수가 필요함. ­ 문자열을 먼저 정수로 바꾸고 여기에 다시 제산함수를 적용시킴. ­ 문자열을 정수로 변환하는 함수는 문자열의 각 문자 아스키 코드를 전부 합하는 방법을 사 용함. 학습자님의   v 선형조사법의 구현 part 3 사례  탐색키로 삽입되는 것
Ÿ “do”, “ for ”, “ if ”, “case”, “else”, “return”, “function”
Ÿ 각 탐색 키에 대한 문자열에서 정수로 변환 과정을 거쳐서 해시주소를 구함. 탐색 키 덧셈식 변환 과정 덧셈 합계 해시 주소 do 100+111 211 3 for 102+111+114 327 2 if 105+102 207 12 case 99+97+115+101 412 9 else 101+108+115+101 425 9 return 114+101+116+117+114+110 672 9 function 102+117+110+99+116+105+111+110 870 12 버켓 1단계 2단계 3단계 4단계 5단계 6단계 7단계 [0] function [1] [2] for for for for for for [3] do do do do do do do [4] [5] [6] [7] [8] [9] case case case case [10] else else else [11] return return [12] if if if if if 학습자님의   v 선형조사법의 구현 part 4  ­ case, else, return은 모두 같은 해시주소를 가짐. if, function도 같음. ­ 충돌의 발생은 선형조사법으로 해결함. ­ 버켓조사는 원형으로 회전함. 즉 테이블의 마지막에 도착하면 다시 처음으로 돌아감. ­ 한 번 충돌이 시작되면 그 위치에 항목들이 집중되는 군집화(clustering) 현상이 보임. ­ 삽입함수 hash_1p_add 함수는 먼저 탐색 키의 해시주소를 계산함.  그 주소가 비어 있는지를 검사해서 비어 있지 않으면 먼저 그 주소에 저장된 탐색 키와 현 재 삽입하려고 하는 탐색 키가 동일한지 체크함.  ­ 동일하면 탐색 키가 중복되었다는 것을 화면에 출력하고 복귀함.  ­ 저장된 탐색 키가 중복되지 않았으면 현재 주소를 나타내는 변수 i를 증가하여 다음 버켓을  가리킴.  ­ 만약 증가된 주소가 시작 주소로 되돌아온 경우에는 다른 모든 버켓을 조사해도 빈 버켓이  없는 경우이므로 더 이상 삽입이 불가능한 오류상태를 알리고 복귀함. ­ empty 함수는 현재 버켓이 비어 있는지를 검사하는 함수임. ­ equal 함수는 두 개의 항목이 동일한지를 검사하는 함수임. 학습자님의   v 선형조사법의 구현 part 5  ­ 저장된 항목을 탐색하는 함수를 작성하자. ­ 탐색  키에  해시함수를  적용시켜서  계산된  주소에서  항목을  찾지  못하면  해당  항목을  찾을  때까지 연속된 버켓을 탐색함. ­ 탐색하다가 시작주소로 되돌아오면 해당 항목이 테이블에 없음. 학습자님의   v 선형조사법의 구현 part 6  ­ 위의 함수들을 호출하여 사용하는 main함수를 만듦. ­ hash_1p_print 함수는 현재 테이블에 저장된 탐색 키들을 출력하는 함수임. ▶ 선형조사법의 구현 정리 ­ 비교적 간단한 이 방법은 탐색 키가 집중되어 저장되는 군집화 현상이 발생함. ­ 최악의 경우는 집중된 항목들이 결합하는 현상까지 발생하여 탐색 시간이 길어지는 단점이  있음. ­ 선형조사법은 간단한 장점에 비해 오버플로우가 자주 발생하면 집중과 결합에 의해 탐색의  효율이 저하되는 단점이 있음. 학습자님의   ▶ 선형조사법 구현에서 항목의 삭제

1) 항목이 삭제되면 탐색이 불가능함. 크기가 10인 해시테이블과  h[k]=k mod 10인 해시함수를 가정하자.
Ÿ 탐색 키가 5,15,25 순서로 삽입하면  모두 충돌이 발생함.
Ÿ 이 상태에서 탐색 키 15를 삭제한 후  25를 탐색하면 중간이 비어서  탐색이 불가함.    

2) 삭제 시 탐색이 가능하게 하려면 버켓을 분류하여야 함.
Ÿ 한 번도 사용이 안 된 버켓, 사용되었으나 현재는 비어있는 버켓, 현재 사용 중인 버켓 으로 분류함.

3) 한 번도 사용이 안 된 버켓을 만나야 탐색이 중단됨. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.475~487 학습자님의   해싱 3 수업목표   1. 이차조사법과 이중해시법을 비교하여 설명할 수 있다.  13주차 
① 이차조사법(quadratic probing) 3교시 
② 이중해싱법(double hashing)  세부내용 
③ 체이닝(chaining)
④ 해싱의 성능분석 1. 이차조사법 ▶ 이차조사법(quadratic probing) ­ 선형조사법과 유사하지만, 다음 조사할 위치를 아래 식을 사용함.
Ÿ (h(k)+inc*inc) mod M  for inc = 0, 1, ..., M
-1
Ÿ 조사되는 위치는 h(k), h(k)+1, h(k)+4, h(k)+9, ... ­ 모든 위치를 조사하게 만들려면 테이블 크기는 소수여야 함. ­ 선형조사법의 문제점인 집중과 결합을 크게 완화할 수 있음. ­ 2차 집중문제가 발생될 수 있지만 1차 집중보다 심각한 것은 아님. ­ 2차  집중문제는  동일한  위치로  매핑되는  탐색 키들이  같은  순서에  의하여 빈  버켓을 조사 함. → 이중해싱법으로 해결할 수 있음. ­ 이차조사법의 구현은 다음 조사 위치를 찾는 부분만 변경하면 됨. ▶ 이차조사법의 구현 학습자님의   2. 이중해싱법 ▶ 이중해싱법(double hashing) ­ 재해싱(rehashing)이라고도 함. ­ 오버플로우가 발생하면 원 해시함수와 다른 별개의 해시함수를 사용하는 방법 ­ 항목들을 해시테이블에 더욱 균일하게 분포시키므로 효과적임.

1) 선형조사법과 이차조사법은 충돌이 발생하면 해시함수 값에 어떤 값을 더해서 다음 위치를 찾음.
Ÿ 선형조사법은 더해지는 값은 1임.
Ÿ 이차조사법은 더해지는 값은 i2임.
Ÿ 해시함수 값이 같으면 조사되는 위치도 같음.
Ÿ 크기가 10인 해시테이블에서 제산함수를 해싱함수로 사용할 때 15와 25는 이차조사법 에서 5, 6, 9, 14, ...와 같은 조사순서를 생성함.
Ÿ 이중해시법은 탐색 키를 참조하여 더해지는 값이 결정됨.
Ÿ 해시함수 값이 같아도 탐색 키가 다르면 다른 조사순서를 가짐.
Ÿ 이중해싱법은 이차집중을 피할 수 있음.
①  두 번째 해시함수는 조사간격을 결정함. step= C 
- (k mod C)      이 함수는 [1...C] 사이의 값을 갖는다.
② 충돌이 발생한 경우 조사되는 위치는 다음과 같음. h(k), h(k)+step, h(k)+2*step, h(k)+3*step......
③ C는 보통 테이블의 크기인 M보다 약간 작은 소수임.
④ 집중현상이 매우 드묾.
⑤ 같은 해시함수 값과 같은 탐색순서를 갖는 요소가 거의 없음. 예) 크기가 7인 해시테이블에서
Ÿ 첫 번째 해시함수가 h(k)=k mod 7
Ÿ 오버플로우 발생 시의 해시함수는 h'(K)=5
-(k mod 5)
Ÿ 입력 요소는 8, 1, 9, 6, 13     학습자님의   예에서 마지막 탐색 키 13의 삽입 시를 보자.  h(13) = 13 mod 7 = 6
Ÿ h'(13) = 5
-(13 mod 5) = 2
Ÿ 첫 번째 조사 위치 = h(13) = 6
Ÿ 두 번째 조사 위치 = (h(13)+h'(13))mod7=(6+2)mod7 = 1 
Ÿ 세 번째 조사 위치 = (h(13)+2*h'(13)) mod 7=(6+2*2)mod7 = 3 ­ 조사는 인덱스 2에서 시작하여 2씩 증가한다. ­ 조사되는 인덱스를 나열해 보면 6,1,3,5,0,2,4... 로 테이블의 모든 위치를 조사함. ­ 선형조사법의 문제점은 한 번도 사용하지 않은 위치가 있어야 탐색이 빨리 끝난다는 것임. ▶ 이중해싱법의 구현 3. 체이닝 ▶ 체이닝(chaining) ­ 선형조사법이 탐색 시간이 많이 걸리는 이유는 해시주소를 다른 탐색 키와 비교해야 하는데  있음.  만약  해시주소가  같은  탐색  키들을  하나의  리스트로  묶는다면  불필요한  비교는  하지  않아도 됨. 이 리스트는 그 크기를 예측할 수 없기에 연결리스트로 구현하는 것이 편리함. ­ 충돌을  해결하는  두  번째  방법은  해시테이블의  구조를  변경,  각  버켓이  하나  이상의  값을  저장하도록 하는 것임. ­ 체이닝은 오버플로우 문제를 연결리스트로 해결함.
Ÿ 각 버켓에 고정된 슬롯이 할당되어 있지 않음.
Ÿ 각 버켓에 삽입과 삭제가 용이한 연결리스트를 할당함.
Ÿ 버켓 내에서는 연결리스트를 순차탐색함. 학습자님의   ­ 크기가  7인  해시테이블에서  h(k)=k  mod  7의  해시함수  사용,  입력  요소(8,  1,  9,  6, 

13)  적용함. ­ 연결리스트의 어느 부분에 새로운 항목을 삽입하느냐를 결정해야 함. ­ 탐색 키의 중복을 허용하면 연결리스트의 처음에 삽입하는 게 가장 효율적임.  중복을 허용하지 않으면 연결리스트의 뒤로 삽입함. ▶ 문자열 키에 대한 체이닝 해싱의 구현을 위한 구조체 선언 ▶ 체이닝의 구현 ­ hash_table은 ListNode 구조체를 가리키는 포인터 배열로 되어있음. ­ 탐색 키가 버켓에 들어오면 동적 메모리 할당을 이용하여 연결리스트의 노드를 생성함.  이  새로운 노드에 탐색 키를 복사함. ­ 버켓에 연결되어 있는 기존의 연결리스트에서 동일한 탐색 키를 검사함. ­ 동일한 탐색키가 발견되면 오류메시지를 출력하고 복귀함. ­ 동일한  탐색키가  없으면  연결리스트의  맨  끝에  새로운  탐색  키를  포함하는  새로운  노드를  연결함. ­ 기존의 연결리스트에 없으면 해시 테이블의 포인터에 새로운 노드를 연결함. 학습자님의   ­ node_before 포인터가 필요한 이유는 node 포인터가 NULL이 되면 for루프가 끝남. ­ 해시테이블을  연결리스트로  구성하므로  필요한  메모리만  사용하여  공간적  사용  효율이  매 우 우수함. ­ 오버플로우가  발생할 경우에도  해당  버켓에  할당된  연결리스트만  처리하므로  수행시간에서 도 매우 효율적임. 학습자님의   4. 해싱의 성능분석 ▶ 해싱의 성능분석 ­ 해싱의 주요한 연산은 탐색연산임. 탐색연산은 성공탐색과 실패탐색이 있음.
1) 체이닝 소스에서의 각 포인터의 역할 
2) 이상적인 해싱 시간복잡도 : O(1)
① 해시테이블이 얼마나 채워져 있는지를 나타내는 척도  ­ 해시테이블의 적재밀도(loading density), 적재 비율(loading factor)이라 함. ­ 저장되는 항목의 개수 n과 해시테이블의 크기 M의 비율임. 저장된항목의개수      해싱테이블의버켓의개수  ­ 가 0이면 해시테이블은 공백임. ­ 선형조사법은 해시테이블이 가득 찬다면 각 버켓 당 하나의 항목이 저장되므로  는 1임.       실패한탐색               성공한탐색        

2) 선형조사법에서의 비교연산 횟수  실패한 탐색 성공한 탐색 0.1 1.1 1.1 0.3 1.5 1.2 0.5 2.5 1.5 0.7 6.1 2.2 0.9 50.5 5.5 ­ 해시테이블의 절반 정도가 채워진 상태에서는 실패한 탐색은 2.5개의 비교연산을 요구하고,  성공한 탐색의 경우는 1.5개의 비교연산을 요구함. ­ α 가 0.5를 넘어갈수록 실패한 탐색은 급격하게 탐색시간이 증가함. ­ 결론적으로 해시테이블의 적재밀도가 0.5를 넘어가지 않도록 해야 함. 학습자님의  
3) 체이닝에서의 비교연산 실패한탐색                성공한탐색       ­ 체이닝에서는 α가 항목의 개수를 연결리스트의 개수로 나눈 것임. ­ α 는 평균적으로 하나의 연결리스트 당 몇 개의 항목을 가지고 있느냐가 됨. ­ 실패한 탐색은 찾고자 하는 위치에 연결리스트가 비어있으면 O(1)임. ­ 평균적인 경우는 α만큼의 항목을 탐색함. ­ 성공한 탐색의 경우는 항상 연결리스트에 항목이 존재함. ­ 평균적으로 α / 2항목을 비교함. ­ 해시테이블에 존재하는 포인터까지 계산한다면 1+α /2가 됨.
4) 체이닝에서의 비교연산 횟수  실패한 탐색 성공한 탐색 0.1 0.1 1.1 0.3 0.3 1.2 0.5 0.5 1.3 0.7 0.7 1.4 0.9 0.9 1.5 1.3 1.3 1.7 1.5 1.5 1.8 2.0 2.0 2.0
5) 각 알고리즘에 따른 평균 버켓 접근 수    .50 .70 .90 .95  해싱 함수 체인 선형조사 체인 선형조사 체인 선형조사 체인 선형조사 중간 제곱 1.26 1.73 1.40 9.75 1.45 37.14 1.47 37.53 제산 1.19 4.52 1.31 7.20 1.38 22.42 1.41 25.79 이동 폴딩 1.33 21.75 1.48 65.10 1.40 77.01 1.51 118.56 경제 폴딩 1.39 22.97 1.57 48.70 1.55 69.63 1.55 97.56 숫자 분석 1.35 4.55 1.49 30.62 1.52 89.20 1.52 125.59 이론적 1.25 1.50 1.37 2.50 1.45 5.50 1.45 10.50 V.Lum, P.Yuen, M.Dodd, CACM, 1971, Vol. 14, No.4 참조 ­ 제산함수와 체이닝을 같이 사용하는 방법이 가장 효율적임. 학습자님의   ▶ 해싱의 정리 ­ 선형조사법은 적재밀도를 0.5 이하로 유지해야 함. ­ 이차조사법과 이중해싱법은 적재밀도를 0.7 이하로 유지하는 것이 좋음. ­ 체이닝은 적재밀도에 비례하는 성능을 보임. ­ 성능을 저하하지 않고 저장 요소를 늘릴 수 있음. ­ 링크를 위한 메모리 낭비 문제는 저장되는 자료의 크기에 따라 달라짐. ­ 배열을 이용하는 이진탐색과 해싱을 비교하면 해싱이 빠름. ­ 해싱은 삽입이 쉬우나 이진탐색은 삽입이 어려움. ­ 해싱은 순서가 없음. 해시테이블의 크기가 불명확함. ­ 최악의 경우 모든 버켓이 하나의 버켓으로 집중하면 시간복잡도는 O(n)임. ­ 이진탐색트리는 현재 값보다 다음 큰 값이나 작은 값을 쉽게 찾음. ­ 값의 크기 순으로 순회하는 것이 쉬움. ▶ 해싱과 다른 탐색 방법과의 비교 탐색 방법 탐색 삽입 삭제 순차 탐색 O(n) O(1) O(n) 이진 탐색 O(log ■) O(log n+n) O(log n+n) 2 2 2 균형 트리 O(log ■) O(log ■) O(log ■) 이진 탐색 트리 2 2 2 경사 트리 O(n) O(n) O(n) 최선의 경우 O(1) O(1) O(1) 해싱 최악의 경우 O(n) O(n) O(n) v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.487~497 학습자님의   탐색 1
1. 탐색의 개념을 설명할 수 있으며, 프로그램을 할 수 있다. 순환 수업목표   호출  이진탐색,  재귀호출  이진탐색,  반복  이진탐색을  구분하여  14주차  설명할 수 있다. 1교시 
① 탐색(search)이란? 세부내용 
② 순차탐색 
③ 이진탐색 1. 탐색(search)이란? ▶ 탐색(search)이란? ­ 여러 개의 자료 중에서 원하는 자료를 찾는 작업 ­ 컴퓨터가 가장 많이 하는 작업 중의 하나 ­ 탐색을 효율적으로 수행하는 것은 매우 중요함.
① 탐색 키(search key) : 항목과 항목을 구별해주는 키(key)
② 탐색을 위하여 사용되는 자료구조  : 배열, 연결리스트, 트리, 그래프 등    2. 순차탐색 ▶ 순차탐색(sequential search) ­ 탐색 방법 중에서 가장 간단하고 직접적인 탐색방법 ­ 정렬되지 않은 배열을 처음부터 마지막까지 하나씩 검사하는 방법

1) 평균비교횟수  ­ 탐색 성공 : (n+1)/2번 비교 ­ 탐색 실패 : n번 비교
2) 시간 복잡도 : O(n)  학습자님의   ▶ 개선된 순차 탐색 ­ 반복문의 리스트 끝을 테스트에서 배제함.
Ÿ 리스트의 끝에 탐색 키를 저장함.
Ÿ 키 값을 찾을 때 반복문을 탈출함. ▶ 정렬된 배열에서의 탐색

1) 정렬된 배열에서의 탐색 ­ 정렬되지 않은 배열의 순차탐색은 이해와 구현이 쉬움. ­ 배열이 많은 항목을 가지는 경우, 순차탐색은 비효율적인 방법임. ­ 정렬된 배열에서의 순차탐색은 탐색 실행 중 키 값보다 큰 수를 만나면 탐색항목이 없음을  알 수 있음. ­ 찾고자 하는 항목이 배열의 마지막 부분에 있으면 원래 순차탐색과 큰 차이가 없음. ­ 순차탐색은 프로그램이 간단하고 작은 배열의 탐색에 효과적이나 큰 배열의 탐색에는 부적 합함. ­ 정렬된 배열의 탐색에는 이진탐색이 가장 적합함.
2) 정렬된 배열에서의     순차탐색 프로그램 
3) 시간 복잡도 : O(n)  학습자님의   3. 이진탐색  ▶ 이진탐색(binary search)
1) 이진탐색(binary search) ­ 정렬된 배열의 탐색에 적합함. ­ 배열의  중앙에  있는  값을  조사하여  찾고자  하는  항목이  왼쪽  또는  오른쪽  부분  배열에  있 는지를 알아내어 탐색의 범위를 반으로 줄여가며 탐색을 진행함. ­ 매 단계마다 리스트의 크기를 반으로 줄여가며 진행함. 예 : 10억 명 중에서 특정한 이름 탐색 ­ 이진탐색 : 단지 30번의 비교로 탐색함. ­ 순차탐색 : 평균 5억 번의 비교가 필요함. A가 B가 생각하고 있는 숫자를 맞추는 게임 ­ B는  1에서  100만까지의  숫자를  하나  생각함.  A는  중간  숫자를  말하고  B는  그  숫자가  맞는지,  큰지,  작은지  만을  말함.  B의  대답을  바탕으로  A는  수의  범위를  반으로  줄인  상황에서 다시 중간 숫자를 말함. 이 게임에서 몇 번 만에 A는 B가 생각하는 숫자를 맞 출 수 있는가?  ­ 답은 20번임. 만약 숫자의 범위가 작으면 더 적은 횟수에서 맞출 수 있음. 영어사전에서 단어를 찾을 때도 방법은 같음.  ­ 이진탐색은 비교가 이루어질 때마다 탐색 범위가 반으로 줄어듦.  (찾고자 하는 항목이 속하지 않은 부분은 전혀 고려하지 않기 때문) ­ 이진탐색을 적용하기 전에는 반드시 정렬을 실행해야 함. ­ 데이터의 삽입이나 삭제가 빈번한 경우는 적합하지 않고 고정된 데이터의 탐색에 적합함. 학습자님의   ▶ 순환호출을 사용하는 이진탐색 ­ 대상이 되는 자료는 list[low]부터 list[high]에 들어 있다고 가정
Ÿ 유사코드는  list[low]에서  list[high]에서의  탐색은  list[low]에서  list[middle
-1]의  탐색 이 되거나 list[middle+1] 에서 list[high]에서의 탐색이 됨.
Ÿ 2가지의 탐색은 원래의 문제의 크기를 반으로 줄임. 재귀호출을 이용하여 쉽게 구현할  수 있음.
Ÿ 재귀호출의 구현은 알고리즘의 파라미터를 low와 high로 함. 즉 어떤 시점에서 탐색되 어야 할 범위는 low에서 high까지가 됨.
Ÿ 맨 처음의 호출에서는 low는 0, high는 n
-1로 배열 전체가 탐색범위임.
Ÿ 재귀호출을 끝내기 위한 코드가 필요함.
Ÿ 탐색범위가 1보다 적으면, 재귀호출을 하지 않음.
Ÿ 이진탐색은 재귀호출로 구현되지만 반복문도 구현됨. 효율성은 반복문이 더 좋음. ▶ 재귀호출을 이용한 이진탐색 학습자님의   ▶ 반복을 이용한 이진탐색 v 반복문을 적용한 이진탐색이 어떻게 동작하는지 검토하자.
Ÿ 탐색 키가 34일 때, 맨 처음에는 low=0, high=15이므로(low+high)/2에 의해 인덱스  middle을 7로 결정함.
Ÿ 인덱스 7의 값이 27이므로 오른쪽 부분리스트를 탐색함.high는 변화 없지만 low는 8 이 되어 오른쪽 리스트만을 탐색하게 됨.
Ÿ 다시  결정한  인덱스  middle은  11이  되어  인덱스  11의  값이  38로  34보다  크기에  왼 쪽  부분 리스트를  탐색함.  low는  8이고 high는  10이  됨.  따라서 인덱스  middle은  9 가 되어 값 30
Ÿ 인덱스 9의 값 30은 34보다 작기에 오른쪽 부분리스트를 탐색함. low와 high가 모두  10이므로 인덱스 middle은  10이  되고, 인덱스 10의 값은 34이므로 탐색은 성공하고  인덱스 10을 반환함. ▶ 이진탐색의 시간복잡도 ­ 이진탐색은 탐색을 반복할 때마다  비교 탐색범위 탐색 범위를 반으로 줄임.  0 ■ 탐색범위가 더 이상 줄일 수 없는 1일 때의  1 n/2 2 n/4 반복 횟수를 k라 하면 시간복잡도는 표와 같음. ­ 표의 마지막행 n/2k=1이므로, k=log n임.  … … 2 4 n/2k 따라서 이진탐색의 시간복잡도는 O(log ■)임. 2 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.105~166 학습자님의   탐색 2

1. 색인순차탐색,  보간탐색,  균형이진탐색트리의  개념을  이해하고  수업목표   프로그램을  할  수  있다.  AVL트리의  탐색연산과  삽입연산의  특 14주차  징을 설명할 수 있다.  2교시 
① 색인순차탐색(indexed sequential search)
② 보간탐색(interpolation search) 세부내용 
③ 균형이진탐색트리
④ AVL 트리  1. 색인순차탐색 ▶ 색인순차탐색(indexed sequential search) ­ 인덱스라 불리는 테이블을 사용하여 탐색의 효율을 높이는 방법 ­ 인덱스 테이블은 주자료 테이블에서 일정 간격으로 발췌한 자료를 저장함. ­ 자료 테이블과 인덱스 테이블은 모두 정렬되어 있어야 함.
Ÿ 인덱스 테이블의 크기 = m
Ÿ 주자료 테이블의 크기 = n ­ 각 인덱스 항목은 주자료 테이블의 각 n/m번째 데이터를 가지고 있음. ­ 시간복잡도 : O(m+n/m) ▶ 색인순차탐색 알고리즘
Ÿ 인덱스 테이블에서  index[i] <= key <index[i+1]을 만족하는 항목을 찾음.
Ÿ 인덱스 테이블에서 위 조건 만족하는 항목으로부터  주자료 테이블에서 순차탐색을 수행함.
Ÿ 주자료 테이블에서 탐색 시간을 상당히 줄임.  
Ÿ 빠른 시간에 원하는 항목을 찾을 수 있는 파일처리,  데이터베이스 등 응용 분야에 많이 사용됨. 학습자님의   ▶ 색인순차탐색 알고리즘의 구현 : 인덱스 테이블을 구조체로 선언함.
Ÿ index 필드에는 리스트의 인덱스의 값이 저장됨.
Ÿ key 필드에는 인덱스가 가리키는 곳의 키 값이 저장됨. ▶ 색인순차탐색 프로그램
Ÿ main 함수는 키값을 매개변수로 사용하여 search_index 함수 호출함.
Ÿ 탐색이 성공하면 search_index 함수는 해당 키의 인덱스를 반환함. 학습자님의   ▶ 색인순차탐색 알고리즘의 탐색 성능

1) 인덱스 테이블의 크기가 좌우함. ­ 인덱스 테이블의 크기를 줄이면 주자료 테이블의 탐색시간을 증가시킴. ­ 인덱스 테이블의 크기를 늘리면 인덱스 테이블의 탐색시간을 증가시킴.
2) 인덱스 테이블의 크기 m, 주자료 테이블의 크기 n, 시간복잡도 O(m+n/m) ­ 데이터의 수가 증가하여 1차 인덱스 테이블의 크기가 매우 커지면, 2차 테이블을 사용함. ­ 2차 인덱스 테이블은 1차 인덱스 테이블의 인덱스를 가리킴. ­ 탐색은 2차  인덱스 테이블의  탐색에서 시작하여 1차  인덱스 테이블을  거쳐서 주자료  테이 블의 탐색이 이루어짐. 2. 보간탐색 ▶ 보간탐색(interpolation search)
1) 보간탐색(interpolation search)
① 사전이나 전화번호부를 탐색하는 방법과 같이 탐색키가 존재할 위치를 예측하여 탐색하는 방법 ­ ‘ㅎ’으로 시작하는 단어는 사전의 뒷부분에서 찾음. ­ ‘ㄱ’으로 시작하는 단어는 사전의 앞부분에서 찾음.
② 보간탐색은 이진탐색과 유사한 리스트를 불균등 분할하여 탐색함. ­ 이진탐색에서 탐색위치는 항상 (low+high)/2이나,  보간탐색에서 탐색위치는 찾고자 하는 키 값과 현재의 low, high 위치의 값을 고려함.

2) 보간탐색에서 탐색위치 [ 탐색위치 ]      k=찾고자 하는 키 값, low, high=탐색할 범위의 최소, 최대 인덱스의 값
① 탐색 위치를 결정할 때 찾고자 하는 키 값이 있는 곳에 근접하게 되도록 가중치를 주는 것
② 다음의 비례식을 정리한 것, 즉 값과 위치는 비례한다는 가정에서 탐색키에 해당되는 위치 를 비례식으로 구한 것임. 학습자님의   [ 예 ] 
Ÿ (3, 9, 15, 22, 31, 55, 67, 88, 91) 리스트의 탐색구간은 0~9임.  찾을 키 값을 55인 경우를 보면,
Ÿ 계산되어 나오는 수는 실수를 정수로 변환해 주어야 함.
Ÿ 소수점 이하를 버리는 방법을 사용함.
Ÿ 많은 데이터가 비교적 균등하게 분포되어 있는 경우는 보간탐색이 이진탐색보다 우수함.
Ÿ 시간복잡도는 보간탐색 알고리즘은 이진탐색과 비슷하게 O(log ■)임. 2 ▶ 보간탐색 프로그램 ­ 나눗셈 계산할 시에는 반드시 float로 형 변환해야 함. 아니면 정수로 계산되어 항상 0이 됨. 학습자님의   3. 균형이진탐색트리 ▶ 이진탐색과 이진탐색트리의 차이점

1) 이진탐색(binary search)과 이진탐색트리(binary search tree)의 차이점 ­ 이진탐색과 이진탐색트리는 근본적으로 같은 원리에 의한 탐색구조임. ­ 자료들이 배열에 저장되어 있으므로 삽입/삭제가 매우 어려움. 이진탐색 ­ 자료를 삽입/삭제 시마다 앞뒤의 요소들을 이동시켜야 함. 이진탐색트리 ­ 매우 빠르게 삽입과 삭제를 수행함. ­ 삽입과 삭제가 많지 않은 정적인 자료를 대상으로 하는 탐색은 이진탐색도 무난함. ­ 삽입과 삭제가 빈번히 발생하는 경우는 이진탐색트리를 사용하는 것이 적합함. ▶ 이진탐색트리의 시간복잡도 ­ 균형트리의 경우 : O(log ■) 2 ­ 불균형트리의 경우 : O(n) → 순차탐색과 동일함. 그림(a) (5, 2, 8, 1, 7, 3, 9) 정수를 공백 이진탐색트리에 삽입 그림(b) 만약 (1, 2, 3, 5, 7, 8, 9)순으로 입력됨.   
Ÿ 그림 (a)의 최대비교횟수는 3회이나, (b)는 7회가 됨.
Ÿ 모든 항목이 균일하게 탐색한다는 가정 하에 평균비교횟수는 (a)는 (1+2+2+3+3+3+3)/7 = 2.4회, (b)는 (1+2+3+4=5+6+7)/7 = 4회
Ÿ 이진탐색트리가  (b)와  같은  경사트리가  되면  탐색시간은  순차탐색과  같아져서  효율이  매우 떨어짐.   
Ÿ 이진탐색트리는 균형을 유지하는 것이 매우 중요함. 학습자님의   4. AVL 트리 ▶ AVL 트리 스스로 균형트리를 만드는 AVL트리 등 몇 가지 탐색 트리를 보자. 이들은 상당히 복잡하 므로 주제 전체를 다루지는 않음. 설명을 간단히 하기 위하여 트리의 노드에 저장된 자료 는 정수로 가장하자.

1) AVL 트리 ­ Adelson
-Velskii와 Landis에 의해 1962년 제안된 트리 ­ 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차이가 1이하인 이진탐색트리 ­ AVL 트리는 트리가 비균형트리가 되면 스스로 노드들을 재배치하여 균형상태를 유지함. ­ AVL 트리는 균형트리가 항상 보장되기에 탐색시간이 O(log ■) 됨.  2 삽입, 삭제연산도 O(log ■)의 탐색시간이 됨.  2 따라서 평균, 최선, 최악의 시간복잡도은 O(log ■)임. 2 그림(a) ­ 모든 노드에서 양쪽 서브트리의 높이의 차이가 1이하 ­ 노드  5에서  왼쪽  서브트리의  높이가  2인  반면  오른쪽  서브트리의  높이가  0 그림(b) 이므로 높이의 균형이 되지 않아서 AVL 트리가 아님.

2) 균형인수(balance factor) 균형인수 = 왼쪽 서브트리의 높이 ­ 오른쪽 서브트리의 높이 ­ 모든 노드의 균형인수가 ±1이하이면 AVL 트리임. ­ 위 그림 각 노드의 옆의 숫자가 균형인수를 나타냄. ­ (a)는 모든 노드의 균형인수가 ±1이하이기에 AVL 트리임. ­ (b)는 5와 7의 균형인수가 2이기 때문에 AVL 트리가 아님. 학습자님의   ▶ AVL 트리의 연산
1) AVL 트리의 탐색연산 ­ 이진탐색트리와 동일함. ­ 시간복잡도는 O(log ■)으로 동일함. 2
2) AVL 트리의 삽입연산 ­ 삽입연산과 삭제연산으로 균형 상태가 깨질 수 있음. ­ 삽입연산은 삽입되는 위치에서 루트까지의 경로에 있는 조상노드들의 균형인수에 영향을 줌. ­ 삽입 후에 불균형 상태로 변한 가장 가까운 조상노드. 즉 균형인수가 가까운 조상노드의 서 브트리들에 대해 다시 균형을 잡음. ­ 삽입노드부터 균형인수가 ±가 된 가장 가까운 조상노드까지 회전함. ­ 그림(a)는 균형을 이룬 AVL트리임. 여기에 정수 1을 삽입하면 그림(b)처럼 노드 5와 노드 7의 균형이 깨짐. ­ 균형인수가 2가 된 가장 가까운 조상노드인 노드 5부터 그 아래에 있는 노드들을 다시 배 치하여 균형상태를 만듦.  
① 재균형 방법  ­ 균형이  깨진  트리를  다시  균형으로  만드는  방법은  새로운  노드부터  균형인수가  ±가  된  가장 가까운 조상노드까지를 회전시키는 것 ­ (b)의 경우 노드 1, 3, 5를 오른쪽으로 회전시키면 다시 균형트리가 됨. 다른 노드들은 변 경시키지 않았음. 학습자님의   ▶ AVL트리의 균형이 깨지는 4가지 경우

1) 삽입된 노드 N으로부터 가장 가까우면서 균형인수가 ±가 된 조상노드를 A라고 하자. LL타입  ­ N이 A의 왼쪽 서브트리의 왼쪽 서브트리에 삽입함. RR타입  ­ N이 A의 오른쪽 서브트리의 오른쪽 서브트리에 삽입함. LR타입 ­ N이 A의 왼쪽 서브트리의 오른쪽 서브트리에 삽입함.  RL타입 ­ N이 A의 오른쪽 서브트리의 왼쪽 서브트리에 삽입함. ­ LL과 RR은 대칭이고 LR과 RL도 대칭임.
2) 재균형시키는 방법도 각각 다름.
① 각타입별 재균형 방법 LL타입  ­ A부터 N까지의 경로상 노드를 오른쪽 회전함. RR타입  ­ A부터 N까지의 경로상 노드를 왼쪽 회전함. LR타입 ­ A부터 N까지의 경로상 노드를 오른쪽 
- 왼쪽으로 회전함. RL타입 ­ A부터 N까지의 경로상 노드를 왼쪽 
- 오른쪽으로 회전함.
② 단순회전(single rotation) : 한 번만 회전시키는 것  ­ RR회전, LL회전이 해당함. ­ 탐색 순서를 유지하면서 부모와 자식 원소의 위치를 교환함.
③ 이중회전(double rotation) : 두 번 회전시키는 것 ­ LR회전, RL회전이 해당함. v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.511~528 학습자님의   탐색 3

1. LL회전·RR회전·RL회전·LR회전의  개념을  각각  비교하여  설명할  수업목표   수 있다. AVL트리의 구현 방식에 대해 이해할 수 있다.  14주차  2
-3트리, 2
-3
-4트리의 탐색연산을 설명할 수 있다. 3교시 
① LL회전, RR회전, RL회전, LR회전
② AVL 트리 구현 세부내용 
③ 2
-3트리 
④ 2
-3
-4트리  1. LL회전, RR회전, RL회전, LR회전 ▶ LL회전

1) (a)는 LL타입으로 6, 5, 2 순으로 노드를 삽입한 경우임.
Ÿ 노드 6은 균형인수가 2로 불균형임. 
Ÿ 오른쪽 회전한 결과 다시 균형트리가 됨.

2) LL회전의 일반적인 경우  ­ LL타입은 조상노드 A의 왼쪽 서브트리의 왼쪽 서브트리에 노드가 추가되면 발생함.  ­ 그림처럼 노드를 오른쪽으로 회전함. ▶ RR회전
1) (a)는 왼쪽 회전의 경우 6, 8, 9 순으로 노드를 삽입한 경우
Ÿ 트리를 왼쪽으로 한 번 회전하면  균형트리가 됨.
Ÿ 회전한다는 의미는  부모와 자식노드의 위치를 바꾸면 됨. 학습자님의  

2) RR타입의 일반적인 경우  ­ RR타입은 조상노드 A의 오른쪽 서브트리의 오른쪽 서브트리에 노드를 추가하므로 발생함.  ­ 노드 A와 B의 위치를 바꾸어 주고 서브트리를 정리하면 균형트리가 됨. ▶ 단순회전인 LL회전과 RR회전 알고리즘 ▶ RL회전
1) RL회전 ­ RL타입은 조상노드 A의 오른쪽 서브트리의 왼쪽 서브트리에 노드 추가로 발생함. ­ RL회전은 균형트리를 만들려면 2번 회전이 필요함. ­ RL회전은 LL회전을 한 다음, RR회전을 함.
2) RL회전의 일반적인 경우 ­ AVL트리의  노드  A의  오른쪽  서브트리의  왼쪽  서브트리에  새로운  노드를  추가하면  비균형 트리가 됨. ­ LL회전과 RR회전, 2번의 회전함. 학습자님의   ▶ LR회전
1) LR회전 ­ LR타입은 조상노드 A의 왼쪽 서브트리의 오른쪽 서브트리에 노드 추가로 발생함. ­ LR회전은 균형 트리를 위해서 2번의 회전이 필요함. ­ LR회전은 RR회전 후, LL회전을 함.
2) LR회전의 일반적인 경우  ­ AVL트리의  노드  A의  왼쪽  서브트리의  오른쪽  서브트리에  새로운  노드를  추가하면  비균형 트리가 됨. ­ RR회전과 LL회전, 2번의 회전함. ▶ 이중회전인 RL회전과 LR회전의 알고리즘 ▶ 예제 (7, 8, 9, 2, 1, 5, 3, 6, 4)의 순서로 데이터가 삽입한다고 가정하자.  AVL트리가 만들어지는 과정을 보자. ­ 삽입되는 노드는 황토색으로, 위치가 변경되는 노드는 노란색으로 표시함. 학습자님의  
Ÿ 7, 8을 삽입하면 (a), (b)임.
Ÿ 9 삽입의 경우 : 7 오른쪽 서브트리 높이 2이고, 왼쪽 서브트리는 0으로 비균형임.
Ÿ (c) 노란색 2개 노드를 RR회전함.
Ÿ 2 삽입은 문제가 없음.
Ÿ 1 삽입으로 비균형트리가 됨.
Ÿ 트리를 LL방향으로 회전함.
Ÿ 5 삽입으로 비균형트리가 됨.
Ÿ 3개의 노란색 노드를 LR회전시킴.
Ÿ 3, 6을 문제없이 삽입함.
Ÿ 4 삽입으로 비균형트리가 됨.
Ÿ RL회전으로 재균형을 찾음. 학습자님의   2. AVL 트리 구현 ▶ AVL 트리 구현 ­ AVL트리는 이진탐색트리의 일종임. ­ 노드  구조는  이진탐색트리와  동일하게  왼쪽과  오른쪽  자식을  가리키는  포인터와  데이터가  저장되는 필드로 구성됨. ­ 데이터는 정수로 가정함.

1) AVL트리 구현 #1 )
Ÿ LL회전, RR회전, RL회전, LR회전 함수 구현
Ÿ LL회전, RR회전은  루트와 자식노드를 바꾸고 링크를 수정함.
Ÿ RL, LR회전은  LL회전함수와 RR회전함수를 이용 구현함.

2) AVL트리 구현 #2 ) 학습자님의  
3) AVL트리 구현 #3 )
① 트리 높이 측정 방법 ­ 순환호출을 이용하여 구현함. ­ 루트  노드의  왼쪽  서브트리와  오른쪽  서브트리에  각각  순환호출을  적용하여  높이를  구함.  이들 중 더 큰 값에 1을 더하면 트리의 높이임. ­ 양쪽 서브트리의 높이의 차이는 각 서브트리의 높이를 구한 후 왼쪽 서브트리 높이에서 오 른쪽 서브트리 높이를 빼면 됨.

4) AVL트리 구현 #4 )
① 균형트리를 만드는 함수 구현 ­ 양쪽 서브트리 높이 차이를 구한 후, 왼쪽 서브트리가 더 높으면  왼쪽 서브트리의  높이 차이를 다시 구함.  여기에  따라  LL회전인지,  LR회전인지  결정 해당 함수를 호출함. ­ 오른쪽 서브트리의  높이 차이 구하고  RR회전, RL회전인지 결정함. 학습자님의  

5) AVL트리 구현 #5 )
① AVL트리의 삽입함수 ­ 삽입함수의 첫 번째 파라미터 root는 AVL트리를 현재 조사하는 노드를 가리키는 포인터임.  두 번째 파라미터 new_key는 삽입할 탐색 키임. ­ root가 NULL이면 삽입할 탐색 키가 존재하지 않음. ­ 탐색이 실패한 현재 위치가 삽입위치임. ­ 동적 메모리 할당으로 새로운 노드를 만듦. ­ root포인터가 새로운 노드를 가리키고 포인터를 반환함. ­ 현재  노드의  값보다  탐색  키가  작으면  왼쪽  서브트리에  삽입함수를  순환호출함.  순환호출  후 균형화 함수(rebalance)를 호출함. ­ 현재  노드의  값보다  탐색  키가  더  크면  오른쪽  서브트리에  삽입함수  호출함.  순환호출  후  균형화 함수를 호출함. ­ 만약 탐색 값과 노드 저장 값이 같으면 탐색 키 중복으로 오류 발생함. 학습자님의  

6) AVL트리 구현 #6 ) 학습자님의   3. 2
-3트리 ▶ 2
-3트리

1) 2
-3트리 ­ 차수가 2 또는 3인 노드를 가지는 트리로 삽입, 삭제 알고리즘이 AVL트리보다 간단함. ­ 2
-3트리는 하나의 노드가 2
-3개의 자식노드를 가짐. ­ 차수가 2인 노드 2
-노드 ­ 이진탐색트리처럼 하나의 데이터 k1과 두 개의 자식노드를 가짐. ­ 2개의 데이터 k1, k2와 3개의 자식노드를 가짐. ­ 왼쪽 서브트리에 있는 데이터는 모두 k1보다 작은 값임. 3
-노드 ­ 중간 서브트리에 있는 데이터는 모두 k1보다 크고 k2보다 작음. ­ 오른쪽에 있는 데이터는 모두 k2보다 큼. ▶ 2
-3트리의 탐색연산 ­ 이진탐색트리 알고리즘을 약간 확장함. ­ 노드가 2
-노드, 3
-노드에 따라 해당하는 탐색을 진행함.
Ÿ 30은 2노드 데이터 값인 50보다 작으므로 왼쪽 서브트리로 감.
Ÿ 30은 3노드 데이터 값인 10과 35와 비교함.
Ÿ 30은 10과 35사이 값이므로 중간 서브트리로 감.
Ÿ 중간서브트리에 30이 있음. 탐색 성공    학습자님의   ▶ 2
-3트리에서의 탐색 프로그램 ▶ 2
-3트리 삽입연산 리스트 ADT 구현 ­ 2
-3트리 노드는 2개 데이터 값을 저장함. ­ 데이터 추가 시에는 노드에 추가할 수 있을 때까지 추가하고저장할 장소가 부족할 때에 노 드를 분리함. 예 : 30, 60, 20순으로 데이터삽입 가정
Ÿ 30 삽입 시 노드 하나 생성하고 저장함.
Ÿ 60 삽입은 노드 두 개까지 저장함.
Ÿ 20 삽입은 현재 노드 추가 저장이 안 되므로 노드를 3개로 분리함.
Ÿ 중간값을 한 레벨 위로 올림.
Ÿ 제일 작은 값은 왼쪽 노드로, 제일 큰 값은 오른쪽 노드로 만듦.   ▶ 노드분리의 3가지 경우

1) 노드분리의 3가지 경우
① 단말노드를 분리하는 경우
② 비단말노드를 분리하는 경우
③ 루트노드를 분리하는 경우 학습자님의  

2) 단말노드를 분리하는 경우 ­ 새로운 데이터 삽입은 단말노드 분리가 필요 ­ 부모노드가 2노드라면 새로운 노드와 기존 2개의 노드 중에서 중간 값은 부모노드로, 작은  값과 큰 값은 새로운 노드로 분리함. ­ 부모노드가 3노드라면 부모노드를 분리함.
2) 비단말노드를 분리하는 경우 ­ 중간 값을 부모노드로 하고,  작은 값과 큰 값을 별개의 노드로 분리함.
3) 루트노드를 분리하는 경우 ­ 루트노드를 분리하면 새로운 노드가 생기므로 트리 높이가 하나 증가함. ­ 새로 만들어지는 노드가 루트노드가 됨. ­ 2
-3트리에서 트리 높이가 증가하는 경우임. 학습자님의   4. 2
-3
-4트리 ▶ 2
-3
-4트리

1) 2
-3
-4트리
① 하나의 노드가 4개의 자식까지 가질 수 있도록 2
-3 트리를 확장 ­ 4개의 자식을 가질 수 있는 노드로 3개의 데이터를 가짐. 4
-노드 ­ 4
-노드의  3개의  데이터를  small,  middle,  large로  4
-노드의  서브트리에는  그 림과 같이 데이터가 들어감.
② 2
-3
-4트리 탐색은 2
-3트리 탐색알고리즘에 4
-노드 처리 부분 추가
③ 4
-노드의 정의 

2) 2
-3
-4트리의 삽입연산 ­ 키를 삽입해야 할 단말노드가 2
-노드 또는 3
-노드이면 간단히 삽입함. ­ 키를 삽입해야 할 단말노드가 4
-노드이면 후진분할(backward split)이 발생함. ­ 2
-3
-4노드는 후진분할연산 방지를 위하여 삽입노드 탐색순회(루트 → 단말)시 4
-노드를 만 나면 미리 분할을 수행함. ­ 미리 분할을 수행하므로 후진 분할은 필요가 없음.

3) 2
-3트리와 비교 ­ 2
-3트리는  삽입  또는  삭제의  순회(루트  →  단말)와  분할과  합병의  영향으로  순회(단말  →  루트)가 필요함.

4) 2
-3
-4트리의 장점  ­ 루트에서 단말 노드로 한 번만 이동하면서 삽입, 삭제가 가능함. ­ 2
-3
-4트리는  삽입을  위하여  루트에서  단말노드로  순회하는  동안  4
-노드를  만나면  무조건  분할함.
Ÿ 단말노드에  도달하면 단말노드의  부모노드는 4
-노드가  아닌  것을  보장함.  따라서  후진  이동이 발생하지 않음. 학습자님의   ▶ 4
-노드 3가지 경우의 알고리즘

1) 4
-노드가 루트인 경우

2) 4
-노드의 부모가 2
-노드인 경우

3) 4
-노드의 부모가 3
-노드인 경우 v C언어로 쉽게 풀어쓴 자료구조, 천인국 외, 생능출판사, pp.529~535 학습자님의 
