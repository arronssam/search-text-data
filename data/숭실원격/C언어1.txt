① 컴퓨터의 정의와 구성요소
② 프로그래밍 언어 세부내용 
③ 프로그램 작성 과정 및 단계
④ C언어의 기본 문법과 입출력 1. 컴퓨터의 정의와 구성요소 ▶ 컴퓨터란? Q, 컴퓨터(computer)는 무엇인가? A. 컴퓨터는 기본적으로 계산(compute)하는 기계 Q. 컴퓨터를 이용하여 데이터를 처리하려면 반드시 데이터가 숫자 형태이어야 한다. 왜? A. 컴퓨터는 숫자 계산을 하기 때문에 데이터는 숫자로 표시되어야 함.
- 디지털 이미지의 경우 : 각 화소의 밝기와 색상을 숫자로 표현한다.
- 디지털 음악의 경우 : 각 파형의 높이를 숫자로 표현한다. ▶ 컴퓨터의 정의 Q. 그렇다면 계산만 빠르게 할 수 있으면 컴퓨터인가? A. 현대적인 의미에서의 컴퓨터는 명령어들의 리스트에 따라 데이터를 처리하는 기계라고  할 수 있음. 
- 계산기는 정해진 기능만을 수행한다. 기능을 변경할 수 없다.
- 컴퓨터는 프로그램이라는 개념을 도입하여 수행하는 기능을 쉽게 변경할 수 있다.  C언어  I  ▶ 컴퓨터의 구성 요소 Q. 컴퓨터의 구성 요소를 크게 2가지로 분류하면? A. 컴퓨터는 기본적으로 하드웨어와 소프트웨어로 구분함.

1) 하드웨어와 소프트웨어의 분리
① 최초의 컴퓨터에서는 분리되지 않았음.
② 1950년대에 폰노이만이 제시한 아이디어
- 프로그램을 메모리에 저장
- 메모리에서 프로그램의 문장을 꺼내와서 하나씩 실행 ▶ 프로그램의 역할 Q. 컴퓨터에서 프로그램이 하는 일은 무엇인가? A. 프로그램은 우리가 하고자 하는 작업을 컴퓨터에게 전달하여 주는 역할을 함.  C언어  I  2. 프로그래밍 언어 ▶ 컴퓨터가 이해하는 언어 ­ 컴퓨터는 인간의 언어를 이해할 수 없다. ­ 컴퓨터는 이진수로 된 기계어만을 이해한다.  ­ 컴파일러는 프로그램을 기계어로 변환한다.  C언어  I  ▶ 프로그래밍 언어의 분류 ­ 기계어(machine language)  ­ 어셈블리어(assembly language)  ­ 고급 언어(high
-level language)  ▶ C언어 ­ 1970년대 초 AT&T의 Dennis Ritchie에 의하여 개발 ­ B언어 → C언어 ­ UNIX 운영 체제 개발에 필요해서 만들어짐. ­ 처음부터 전문가용 언어로 출발 Ken Thomson과 Dennis Ritchie가 클린턴 대통령으로부터  National Medal of Technology 상을 받는 장면l Medal of Technology 상을 받는 장면 ▶ C언어의 버전

1) K & R C
- 1978년 “C Programming Language” 책 출간
- 비공식적인 명세서 역할

2) ANSI C
- 1983년 ANSI(American National Standards Institute)는 X3J11이라는 위원회에 의한 표준

3) C99
- 1999년에 ISO에 의한 표준
- C++에서 사용되는 특징 추가
- 아직 마이크로소프트는 지원하지 않음.(이유: C++에 집중) ▶ C언어의 특징 ­ 간결함. ­ 효율적임. ­ 하드웨어를 직접 제어하는 하는 저수준의 프로그래밍 가능 ­ 고수준의 프로그래밍 가능  ­ 이식성이 뛰어남.  ­ 초보자가 배우기가 어려움.  C언어  I  ▶ C언어의 미래 Q. 앞으로도 C언어는 사용될 것인가?
- C언어는C++와 JAVA, C#, Objective
-C의 공통적인 부분임. 
- 임베디드 시스템에서는 C언어가 많이 사용됨.  ­ mp3 플레이어도 CPU와 플래시 메모리 등이 들어가 있는 임베디드 시스템이다. v 임베디드 시스템
- 특수 목적의 시스템으로 컴퓨터가 장치 안에 있는 MP3 플레이어, 스마트폰 등이 여기에 속함. 3. 프로그램 작성 과정 및 단계 ▶ 프로그램 작성 과정 ▶ 프로그램 작성 단계

1) 편집(edit)
- 에디터를 이용하여 원하는 작업의 내용을 기술하여 소스 코드 작성
- 소스파일(source file) : 소스 코드가 들어 있는 텍스트 파일 (예) test.c

2) 컴파일(compile)
- 소스 파일 → 기계어로 변환
- 오브젝트 파일(object file) : 기계어로 변환된 파일 (예) test.obj

3) 링크(link)
- 오브젝트 파일들을 라이브러리 파일들과 연결하여 하나의 실행 파일 생성
- 실행 파일 (executable file): 실행이 가능한 파일 (예) test.exe  C언어  I  4. C언어의 기본 문법과 입출력 ▶ C언어 기본 구조

1) 변수
- 기본형(정수, 실수, 문자), 확장형(열거, 배열, 포인터, 구조체, 공용체)

2) 연산자
- 논리 연산자, 비트 연산자

3) 제어문
- 분기문(if else, switch case), 반복문(while, for, do while)

4) 함수
- 사용자 정의 함수, 재귀 함수 ▶ C 프로그램의 기본 구조

1) C 프로그램의 기본 구조
- 함수 기반의 언어로 최소한 1개 이상의 함수들로 구성됨.
- 함수는 여러 개의 문장들로 구성됨.
- 프로그램의  시작을  알리는  함수는  main()  함수라고  하고  하나의  프로그램은  단  하나의  main()함수를 가져야 함.

2) 기본 형식 ­ 프로그램 구조
- #include <stdio.h>   // 1) 선행 처리 지시자 void main() // 2) 프로그램 시작 함수 { // 3) 프로그램의 시작 // contents // 4) 문장들 } // 5) 프로그램의 종료 ▶ C언어의 특징 ­ 칼럼이나 행의 제약 없이 자유로운 코딩이 가능함.  ­ 문장과 문장은 세미콜론(;)으로 구분함. ­ 프로그램의 시작은 main() 함수를 통해 시작한다.  ­ { }은 함수의 범위를 나타냄.  ­ C언어는 함수 기반의 언어임.  C언어  I  ▶ 함수의 종류 ­ 사용자 정의 함수 : 사용자에 의해 만들어지는 함수 ­ 표준 라이브러리 함수 : ANSI C 표준으로 모든 컴파일러에서 제공되는 기본 함수 ▶ 함수의 구성 요소

1) 함수의 구성 요소
- 리턴 타입 : 함수 처리 후 반환될 자료형
- 함수 이름 : 함수의 이름 
- 파라메터 리스트 : 함수에 전달할 매개변수 리스트
- 문장들 : 함수 안에서 처리되는 명령 단위  [리턴타입] [함수이름]( [매개변수리스트] )  {  형식         [문장들];  }  int sum(int x, int y){        int result = x + y;  예       return result;  }  ▶ 표준 라이브러리 함수 종류

1) 표준라이브러리 함수 종류
- 입출력 함수, 스트링 조작 함수, 수학 계산 함수, 날짜 및 시간 관련 함수, 메모리 관리 함 수 등등…

2) 어떻게 프로그램에서 이 표준 라이브러리 함수를 사용할 수 있을까?
- 프로그램 코드에 사용될 라이브러리 함수 정보를 알려줌.
- 방법 : 선행 처리 지시자(#include) 이용
- 사용되는 함수의 해더파일(*.h) 정보 알려줌.예> #include <stdio.h> ▶ 표준 라이브러리 함수 
- 기본 입출력 함수

1) 표준 라이브러리 함수 ­ 기본 입출력 함수
- printf() 출력 함수
- scanf() 입력 함수
- 입출력 관련 함수 정보는 stdio.h 파일에서 제공됨.
- 사용자의 프로그램에 입출력 함수 사용하고자 할 경우 이 헤더 파일을 프로그램의 시작 부 분에 다음과 같이 포함함. #include <stdio.h>  C언어  I  ▶ printf() 함수

1) printf() 함수
- 사용자가 표현하고자 하는 정보를 화면상에 출력

2) 함수의 형식
- 출력함수 : printf( “문자열”, 인수1, 인수2, ...);  문자열 ­ 일반 문자, 개행 문자, 형식 지정 문자들로 구성 인수 ­ 값을 포함하는 변수나 계산식으로 구성

3) 개행 문자
- 화면상의 제어를 위해 사용되는 문자들 개행 문자 설 명 개행 문자 설 명 \a Bell \t HTAB \b Back space \v VTAB \f ex)orm feed \\ Back slash \n Line feed \' Apostrophe \r Carriage return \'' Quote \0 null \N, \xN (N은 상수)Octal, Hex

4) 형식지정 문자
- 인수 값을 받아 출력시키는 위해 사용
- 각각의 인수는 해당 형식 지정 문자에 순서대로 할당  C언어  I 

5) printf() 함수 사용 예
- printf("C Program \t is simple and good \n");
- int a=3,b=5,c=6;
- printf(" %d * %d + %d = %d \n",a,b,c,a*b+c); ▶ scanf() 입력 함수

1) scanf() 입력 함수
- 키보드로부터 값을 입력받는 함수

2) [함수의 형식]
- scanf( “형식지정문자”, &변수이름);  형식지정 문자 ­ printf()함수에서 사용되는 동일한 형식 지정 문자 ­ 키보드로부터 입력 받은 값을 저장할 변수 이름 변수 이름 ­ 변수 이름 앞에 &(주소)를 포함하여 입력함수에 전달

3) scanf() 활용 예
① 키보드로부터 하나의 정수 값 입력 int input; scanf("%d",&input);
② 키보드로부터 3개의 정수 값 입력 int a,b,c; scanf("%d%d%d",&a,&b,&c); 입력된 순서대로 a,b,c값에 저장
③ 타입이 서로 다른 4개의 값을 입력 int a,b; float c; char d; scanf( "%d%d%f%c",&a,&b,&c,&d);  C언어  I  C언어 개발 환경 익히기 1. 프로그램 개발환경을 이해한다.  수업목표   2. 프로그램 디버깅과 에러의 종류에 대해 이해한다.  1주차  3. 프로그램 개발 시 빈번히 사용되는 명령들을 정리한다. 2교시 
① C언어 개발 환경의 이해 세부내용 
② 비주얼 C++ 통합 개발 환경 활용하기
③ 프로그램 디버깅 문제 다루기 1. C언어 개발 환경의 이해 ▶ 프로그램 작성과 컴파일 그리고 실행

1) 컴퓨터 환경
① UNIX 계열
- C 프로그램에 대한 컴파일러 내장
- 편집기를 통해 코드 작성 후 명령라인에서 컴파일과 실행
② PC 계열
- 운영체제 자체에서 C언어의 컴파일러 제공하지 않음.
- 사용하고자 하는 컴파일러 인스톨 후 사용 v 대표적 컴파일러 종류 ­ Turbo C/C++ ­ Borland C/C++ ­ Microsoft Visual C++
- 컴파일러는 프로그램 개발 환경을 포함하고 있기 때문에 프로그램 개발이 편리함.
- 해당 통합 환경에 대한 코드 작성, 컴파일 그리고 실행 방법의 학습 필요 2. 비주얼 C++ 통합 개발 환경 활용하기 ▶ 통합 개발 환경의 종류

1) 비주얼 C++(Visual C++)
- 마이크로소프트사의 제품
- 윈도우 기반의 거의 모든 형태의 응용 프로그램 제작 가능
- 우리가 사용할 버전 : 비주얼 스튜디오 커뮤니티 2017
- 무료로 사용가능
- http://www.microsoft.com/express/vc/  C언어  I  ▶ 비주얼 스튜디오 설치  C언어  I   C언어  I  ▶ 비주얼 스튜디오 실행 ▶ 비주얼 스튜디오 환경 설정  C언어  I  ▶ 솔루션과 프로젝트

1) 솔루션(solution)
- 하나의 애플리케이션을 만들기 위한 프로젝트의 그룹 
- 하나 이상의 프로젝트들로 구성

2) 프로젝트(project)
- 하나의 실행 파일을 만들기 위하여 필요한 파일들의 그룹  C언어  I  ▶ 프로젝트 생성  C언어  I  ▶ 파일 생성 v SDL(Security Development Lifecycle) 설정 해제 SDL은  소프트웨어  보안  관련  버그와  관련된  소프트웨어의  안정성을  높이기  위해  Microsoft 에서 사용 및 제안한 소프트웨어 개발 프로세스  ­ 이를 위해 다른 형식의 API를 사용해야 하기 때문에 이 기능을 해제한다.   v 파일 생성  C언어  I  ▶ 소스 코드 입력

1.   #include <stdio.h>
2.
3.   int main(void)
4.   {
5.     printf("Hello World!");
6.     return 0;
7.   }  C언어  I  ▶ 솔루션 빌드 ▶ 프로그램 실행 ▶ 우리가 작성한 프로그램  C언어  I  3. 프로그램 디버깅 문제 다루기 ▶ 프로그램 디버깅 문제 다루기
1) C프로그램 디버깅하기
① 문제
- 다음페이지의  프로그램을  MagicNumber.c  파일로  작성하고  아래의  실습  단계를  진행하여  보자.
② 실습

1) 14라인에 중단점 설정
2) 디버그 모드로 실행
3) 14라인의 num 변수 값 확인
4) 한 스텝 증가 후 매직 숫자 입력
5) 이후 저장된 num 값 확인
6) 다음 라인(17)으로 진행 이때의 num값은?
7) 다음 라인(18)으로 진행 이때의 num값은?
8) 나머지 단계 진행 v MagicNumber.c 
③ 실습(계속)

9) 설정된 중단점 해제
10) 16라인과 17라인을 하나의 문장으로 변경    num = num / 3 ­ 8;
11) 수정된 프로그램 저장
12) 수정 후 컴파일, 링크 과정을 거친 후 실행   C언어  I  ▶ 비주얼 C++ 통합 환경에서 디버깅 도구 사용
1) 중단점 설정
- 먼저 중단할 위치로 커서를 옮김.
- 상단 메뉴에서 디버그 클릭
- [중단점  설정/해제]  메뉴  선택(단축키 ex)9) ▶ 디버깅 모드로 실행
- [디버그]  →  [디버깅  시 작] 메뉴 선택 (ex)5)
- 시작된  프로그램은  설정 된  처음  중단점에서  멈 춤. ▶ 디버깅 스텝 증가 방법
- 멈춤 위치에서 다음 단계로 진행하는 방법
- 디버깅 모드 실행 시 디버깅 관련 메뉴가 다음과 같이 나타남.  C언어  I 

1) 중단점 위치에서 다음 단계 진행 방법 한 스텝 증가시키는 데 그 문장이 함수를 호출할 경우 그 함수 내부로 진행 그렇지  않을 경우 다음 라인으로 진행 한 스텝 증가시키는데 함수로 상관없이 다음 라인으로 진행 해당 블록을 벗어남. 커서가 위치한 곳까지 진행 ▶ 디버깅 과정에서 변수 값 확인
- 현재 진행되는 시점에서 값의 내용 추적
- 하단의 윈도우를 통해 확인

1) 자동 윈도우 활용
- 디버깅하는  현재  상황에  포함된  변수들의  값이  자동적으로 보여줌.
- 디버깅  모드  동작  시  왼쪽  하단에  자동적으로  나타남
- 보이지 않을 경우 : [디버그]→[창]→[자동]선택

2) [조사식]윈도우를 이용한 변수 값 확인
- 사용자가  보고자  하는  변수를  지정하여  확인  가 능
- [이름]필드에 확인을 원하는 변수 이름 입력
- [값]필드는 현재 시점에서의 변수 값 보여줌.
- 보이지 않을 경우 : [디버그]→[창]→[조사식]선택 ▶ 디버깅 중단과 재실행 ­ 디버깅 중단 및 재실행 명령 → 디버깅 메뉴를 통해 이루어짐.  C언어  I  디버깅의 재실행
- 처음부터 디버깅 과정 다시 수행
- 더 이상 디버깅 과정이 필요하지 않을 경우 디버깅 중단
- 디버깅 작업 완료시킴. ▶ 중단점 해제
- 설정된 중단점을 제거하고자 할 때

1) 해제 단계
- 제거하고자  하는  중단점  위치로  커서를  이동 시킴.
- 오른쪽 마우스 버튼 클릭하여 팝업 메뉴 얻기
- [중단점 삭제] 메뉴 선택  C언어  I  C언어 구성 요소의 의미 익히기 1. C언어의 기본 구성 요소를 이해한다.  수업목표   2주차  2. 각 구성요소들의 문법적인 관계를 이해한다.  1교시 
① C언어를 구성하는 각각의 구성요소 세부내용 
② 주석, 식별자, 예약어, 상수, 연산자, 분리자 등    (의미 파악 및 사용 방법 이해) 1. C언어를 구성하는 각각의 구성요소 ▶ 프로그램의 구성 요소 ­ C 프로그램은 다음과 같은 요소들로 구성됨. 주석
- // 또는 /*         */  식별자
- 변수, 함수, 상수의 이름으로 사용자에 의해 만들어지는 이름 예약어
- C 언어에 의해 미리 정의된 문자 ( int, long 등) 상수
- 실제 데이터 값 표현  연산자
- *, + , 
- , & 등의 연산 기호 분리자
- ( ) , { } , , , ; 등  2. 주석, 식별자, 예약어, 상수, 연산자, 분리자 등 ▶ 주석 ­ 프로그램의 이해 목적 
- 문서화 ­ 컴파일러에 의해 해석되지 않는 문장

1) 형식
- // : 해당 라인에 대한 주석처리
- /* */: 다중 라인에 대한 주석처리

2) 자주 사용되는 주석의 위치
① 프로그램의 시작 부분 ­ 프로그램에 대한 개괄적인 정보나 작성자 및 작성일자를 포함하는 기본 정보
② 함수의 시작 부분 ­ 함수의 입/출력 정보와 함수의 쓰임새 정보
③ 문장 작성 바로 뒤 부분 ­ 해당 문장의 의미가 분명하지 않을 경우 설명을 위해  C언어  I 

3) 주석(comment) : 프로그램에 대한 설명
4) 헤더 파일 포함 형식 #include <헤더파일> #include <stdio.h> 예 #include <memory.h>
- #include는 소스 코드 안에 특정 파일을 현재의 위치에 포함
- 헤더 파일(header file): 컴파일러가 필요로 하는 정보를 가지고 있는 파일
- stdio.h : standard input output header file
- 주의!: 전처리기 지시자 문장 끝에는 세미콜론을 붙이면 안 됨. 

5) 줄바꿈 및 들여쓰기  C언어  I  ▶ 식별자 ­ 프로그램 안에서 사용자가 만들어내는 이름을 지칭 ­ 변수, 함수, 상수의 이름
1) 식별자 작성 규칙
- 영문자와 숫자 그리고 밑줄( _ )를 이용하여 구성함. 
- 시작은 문자나 _ 로 시작해야 함.
- 식별자 크기 제한이 없지만 컴파일러마다 최대 크기가 다름. 
- 영문 대/소문자를 구별함.

2) 예제
1. max, Max, MAX ( O ),  _sBs        ( O ) 
2. happy_Bus            ( O ),  2ndValue    ( X ) 
3. isHome?                ( X ),  HI_5           ( O )
4.
-display                 ( X ),  number#5   ( X )

3) 변수
- int x;// 첫번째 정수를 저장하는 변수 
- int y;// 두번째 정수를 저장하는 변수 
- int sum; // 두 정수의 합을 저장하는 변수  Q. 변수란 무엇인가? A. 프로그램이 사용하는 데이터를 일시적으로 저장할 목적으로 사용하는 메모리 공간 

4) 변수의 종류
- 변수는 데이터를 담는 상자로 생각할 수 있음.
- 변수에는 데이터의 종류에 따라 여러 가지 타입이 존재함.  C언어  I 

5) 변수 선언
- 컴파일러에게 어떤 타입의 변수가 사용되는지를 미리 알리는 것

6) 자료형(data type)
- 변수가 저장할 데이터가 정수인지 실수인지, 아니면 또 다른 어떤 데이터인지를 지정하는 것

7) 변수 선언
- int x;// 첫번째 정수를 저장하는 변수 
- int y;// 두번째 정수를 저장하는 변수 
- int sum; // 두 정수의 합을 저장하는 변수   C언어  I 

8) 함수(function)
① 특정한 작업을 수행하기 위하여 작성된 독립적인 코드
- 함수는 이름을 가지며 입력을 받아서 특정한 작업을 실행하고 결과를 반환함.
② 작업을 수행하는 문장은 함수 안에 들어가야 함.

9) main() 함수
- C 프로그램에서 가장 먼저 실행되는 함수

10) 함수의 구성요소
11) 문장
① 함수는 여러 개의 문장으로 이루어짐.
② 문장들은 순차적으로 실행됨.
③ 문장은 ;(세미클론)으로 끝나야 함. 
- 소스코드의 문장들은 기본적으로 차례대로 실행됨.  C언어  I 

12) 함수 반환문
- return은 함수의 결과값을 외부로 반환함. ▶ 예약어
- C언어에서 미리 규정된 단어로 특별한 목적을 위해 사용
- 사용자가 임의대로 식별자 이름 사용 금지

1) ANSI 표준 C 예약어 auto, double, int, struct, break, else, long, switch, case, enum, register, typedef,  char,  extern,  return,  union,  const,  float,  short,  unsigned,  continue,  for,  signed,  void default, goto, sizeof, volatile, do, if, static, while
- 많은 다른 컴파일러들인 자신들에 추가된 예약어 존재
- #으로 시작하는 프리프로세스 역시 식별자로 사용할 수 없음. ▶ 상수(constant) 

1) 데이터 값을 표현
2) 그 값이 프로그램이 실행하는 동안 변하지 않는 수
- 변수는 실행 도중에 값을 변경할 수 있으나 상수는 한번 값이 정해지면 변경이 불가능함.  C언어  I 

3) 상수의 종류 : 5가지 (정수, 실수, 문자, 문자열, 기호)
- 소수점이 없는 수치로 8진수, 10진수, 16진수 형태로 표현 정수 상수
- 8진수 : 023, 10진수 : 34, 16진수 : 0x3A1
- 실수 값 표현으로 두 가지 형태 존재 실수 상수
- 실수 형식 : 3.14159
- 지수 형식 : 1.3e
-4
- 하나의 문자 표현, 단일 인용부호(' ')에 포함 문자 상수
- 예> 'A', 'b', '3'
- 문자들의 집합으로 이중 부호(" ")안에 표현 (예 : “Hi everyone!”)
- 메모리 저장 형태 문자열 상수
- 문자열은 자동적으로 마지막에 '\0'(널문자)를 포함하여 저장 
- #define 문에 의해 정의된 상수 기호 상수
- 상수 값에 의미를 부여하고 싶을 경우에 사용
- 예> #define PI 3.1415914 ▶ 연산자
- 특수한 의미를 가지는 문자

1) 연산자의 종류 (3장에서 다룸)
- 산술(+, 
- , *, /), 논리(&&, ||, !), 관계( >, <, >=, <=, !=, ==), 할당(=)연산자 등등… ▶ 분리자
- 문장, 단어들을 구분하고 요소들을 그룹화하기 위해 사용

1) 분리자의 종류
- ( )  : 요소들의 그룹
- { }  : 블록을 구분
- ;  : 문장 단위 구분
- , : 단어의 구분  C언어  I  ▶ 대입 연산

1) 대입 연산(assignment operation) : 변수에 값을 저장하는 연산
- 대입 연산 = 배정 연산 = 할당 연산
- x = 100;
- y = 200; v = 연산자는 변수에 값을 저장함.

2) 대입 연산(cont.)
- 다음과 같은 연산은 변수 x의 값을 하나 증가시킴.
- 수학적인 의미와는 다름.
- x = x + 1; ▶ 산술 연산 연산 연산자 C 수식 수학에서의 기호 덧셈 + x+y x+y 뺄셈
- x
-y x
-y 곱셈 * x*y xy 나눗셈 / x/y x/y 또는 x÷y 나머지 % x%y x mod y  C언어  I  C언어 구성 요소 활용하기 1. C언어 구조와 이들에 포함된 구성요소의 관계를 이해한다.  수업목표   2. 프로그래밍 스타일에 대해 생각해 본다.  2주차 
① 구구단 출력 프로그램 구조 분석 2교시 
② 덧셈 프로그램 구현 세부내용 
③ 저축액 계산 프로그램 구현
④ 원의 면적 프로그램 구현
⑤ 사각형 둘레와 면적 구하기 1. 구구단 출력 프로그램 구조 분석 ▶ 구구단 출력 프로그램 구조 분석

1) 구구단의 일부를 출력 2. 덧셈 프로그램 구현 ▶ 첫 번째 덧셈 프로그램 Q. 2개의 변수 x, y를 이용하여 더하는 프로그램을 만드시오.  C언어  I  ▶ 두 번째 덧셈 프로그램 Q. 사용자로부터 입력 받은 2개의 값을 이용하여 더하는 프로그램을 만드시오. 3. 저축액 계산 프로그램 구현 ▶ 저축액을 계산하는 프로그램 Q. 월급을 입력 받으면 10년 동안 저축액을 출력하는 프로그램을 만드시오.   C언어  I  4. 원의 면적 프로그램 구현 ▶ 원의 면적 프로그램 Q. 반지름을 입력하면 원의 면적을 계산하는 프로그램을 작성하시오. 5. 사각형 둘레와 면적 구하기 ▶ 프로그래밍 스타일 ­ 이 프로그램은 구문 에러 없이 잘 동작하지만 무엇인가 어색한 부분이 많다. 변경해보자!  C언어  I  ▶ C 프로그램 구성 요소 분석하기
1) 문제 : 사각형의 높이와 길이가 주어질 때 이 사각형의 둘레와 면적을 구하는 프로그램 1단계 ­ 다음 페이지의 코드 부분의 빈 공간을 완성하여 프로그램 작성 2단계 ­ 컴파일 후 에러 발생 위치 찾고 수정 3단계 ­ 프로그램의 요소를 분류하여 작성 4단계 ­ 프로그램 저장 후, 빌드 그리고 실행 5단계 ­ 사각형의 높이를 345.4로, 폭을 230.7로 입력한 후 결과 확인
2) 문제에 대한 해답
①. main()
②. scanf("%f %f", &width, &length); 
③. %f 
④. %f 
⑤. 프로그램 요소 분류 
- 주석 : 01~03/* */과 05, 07, 08, 09 11, 12, 14, 16의//부분 총: 9개 
- 식별자 : 변수이름 (예> width, length) 
- 예약어 : 미리 정의된 언어 (예>float, void 등) 
- 상수 : 실제 값 (예>2 )
- 연산자 : + 
- = 등 
- 분리자 : 문자이나 단어 사이의 분리 (예> , ; {} )
⑥. 1098.199951 
⑦. 70357.976563   C언어  I  기본 자료형의 이해 1. 자료형과 변수에 대해 이해한다.  수업목표   2. 기본 자료형과 열거형에 대해 이해한다.  3주차 
① 변수와 상수 1교시 
② C언어가 제공하는 자료형의 종류 식별 세부내용 
③ 기본 자료형의 이해
④ 확장 자료형의 이해
⑤ 자료형과 자료형 변환 활용 1. 변수와 상수 ▶ 변수 Q. 변수(variable)이란 무엇인가? A. 프로그램에서 일시적으로 데이터를 저장하는 공간 Q. 변수는 왜 필요한가? A. 데이터가 입력되면 어딘가에 저장해야만 다음에 사용할 수 있음.
- 성적들의 평균이 구해지려면 먼저 성적들이 어딘가에 저장되어 있어야 함. ▶ 변수=상자 ­ 변수는 물건을 저장하는 상자와 같음.  C언어  I  ▶ 변수가 만들어지는 곳 ­ 변수는 메인 메모리에 만들어짐. ▶ 변수가 필요한 이유 Q. 만약 메모리를 변수처럼 이름을 가지고 사용하지 않고 주소로 사용한다면?                             “219번지에 0을 대입하라” A. 충분히 가능하지만 불편함. 인간은 숫자보다는 기호를 더 잘 기억함. ▶ 변수와 상수 변수 ­ 저장된 값의 변경이 가능한 공간 (variable) ­ (예) i, sum, avg 상수 ­ 저장된 값의 변경이 불가능한 공간 (constant) ­ (예) 3.14, 100, ‘A’, “Hello World!” ▶ 상수의 이름 Q. 상수도 이름을 가질 수 있는가? A. 보통 상수는 이름이 없음. 이러한 상수를 리터럴(literal) 이라고 함.    하지만 필요하다면 상수에도 이름을 붙일 수 있음. 이것을 기호 상수라고 함.  C언어  I  ▶ 예제 ▶ 변수 선언

1) 컴파일러에게 어떤 변수를 사용하겠다고 미리 알리는 것
2) 변수 선언의 예
- char c;
- int i;
- double interest_rate;
- int w, h; ▶ 변수의 초기화  C언어  I  ▶ 변수에 값을 저장하는 방법 ▶ 변수 선언 위치 ­ 변수는 함수의 첫 부분에서만 선언할 수 있음. ▶ 변수의 사용

1) 대입 연산자를 이용해서 값을 저장함.  C언어  I 
2) 저장된 값은 변경이 가능함. ▶ 달러를 원화로 바꾸는 예제  C언어  I  2. C언어가 제공하는 자료형의 종류 식별 ▶ 자료형(data type): 데이터의 타입(종류)
- 정수형 데이터(100) 
- 실수형 데이터(3.141592)
- 문자형 데이터(‘A’) ▶ 다양한 자료형 Q. 다양한 자료형이 필요한 이유는? A. 상자에 물건을 저장하는 것과 같음. ­ 물건이 상자보다 크면 들어가지 않을 것이다. ­ 물건이 상자보다 너무 작으면 공간이 낭비될 것이다. ▶ 자료형의 종류

1) 기본형 
- 정수형 구분 설명 바이트 수 범위 부 short short형 정수 2
-32768~32767 int 정수 4
-2147483648~2147483647 호 있 long long형 정수 4
-2147483648~2147483647 음 정 unsigned 수 부호 없는 short형 정수 2 0~65535 부 short 형 호 unsigened 부호 없는 정수 4 0~4294967295 없 int unsigned 음 부호 없는 long형 정수 4 0~4294967295 long

2) 기본형 
- 문자형 구분 설명 바이트 수 범위 부호 문 char 문자 및 정수 1
-128~127 있음 자 부호 형 unsigned char 문자 및 부호 없는 정수 1 0~255 없음  C언어  I 

3) 기본형 
- 부동소수점형 구분 설명 바이트 수 범위 부동 float 단일 정밀도 부동소수점 4 1.2E
-38∼3.4E38 소수점형 double 두 배 정밀도 부동소수점 8 2.2E
-308∼ 1.8E308

4) 확장형 구분 설명 바이트 수 범위 열거형 enum 사용자 정의 열거형 4 0~4294967295 배열형 [] 변수의 배열형 ■ 포인터형 * 메모리 주소 저장 4 구조체형 struct 변수의 집합 ■   공영체형 union 변수의 공용 1~8 가장 큰 변수의 값 ▶ 오버플로우(overflow)
- 변수가 나타낼 수 있는 범위를 넘는 숫자를 저장하려고 할 때 발생  C언어  I 
- 규칙성이 있음. 수도 계량기나 주행거리계와 비슷하게 동작 3. 기본 자료형의 이해 ▶ 정수형 (int, long)
- 정수 값을 표현하는 자료형
- 소수점이 없는 음수, 0, 양수를 가짐.

1) 정수의 표현 범위 정수형 타입 비트의 크기 수의 표현 범위 짧은 정수형(short) 16
-32.768~32767(
-216~216
-1) 표준 정수형(int) 16 또는 32 216~216
-1 또는 
-231~231
-1 긴 정수형(long) 32
-231~231
-1
- Int형은 사용하는 운영체제나 컴파일러의 특성에 따라 다름.

2) 정수 자료형 수정자 (unsigned) : 자료의 값을 양수로 취급
- unsigned short : 0 ~ 65,535 ( 0 ~ 216) 
- unsigned int    : 0 ~ 216 또는  0 ~ 232
- unsigned long    : 0 ~ 232 ▶ 자료형의 크기

1) sizeof 연산자 이용  C언어  I  v [기초다지기] 자료형 익히기
1) 정수형의 데이터 저장 공간의 크기를 알아보자.  v 분석
- sizeof()함수 : 해당 타입의 크기를 바이트(Byte) 단위로 반환
- 부호 없는(unsigned) 형이나 부호 있는 형들 모두 동일한 크기

2) 정수형 데이터 공간에 표현 가능한 최대 최소 크기를 알아보자.  v 분석
- limits.h파일 : 자료형의 최대 최소값을 선언하고 있는 헤더파일
- unsigned 타입은 0부터 시작하여 양수 값의 표현 ­ printf()함수
① %d 형식 지정자는 부호 있는 정수를 표현
② %u는 부호 없는 정수 표현을 위해 사용
③ %lu는 long형의 unsigned 값을 표현하기 위해 사용  C언어  I  ▶ 문자형(char)
- ASCII 코드 표 기반의 하나의 문자를 저장하는 자료형
- 문자의 크기 8bit
- 문자형에 정수 값을 표현할 수 있음. ( 
-128~127 크기 )
- unsigned 수정자를 포함할 수 있음.

1) 문자형 표현 범위 문자형 비트의 크기 수의 표현 범위 문자형(char) 8 ASCII코드 또는 정수(
-128~127) Unsigned char 8 정수(0~255)(0~28
-1)

2) ASCII 코드 표 v [기초다지기] 자료형 익히기
1) 문자형 자료의 크기와 값을 출력하자.   C언어  I  v 분석
- 문자형의 크기 : 1Byte ­ 표현 범위 
① 부호 있는 경우 : 최대값은 
-127에서 128 
② 부호 없는 형 : 0에서 255 ­ printf()에서 한 문자를 출력
① %c의 형식 지정 문자를 사용
② %d를 사용할 경우 해당 문자에 해당되는 ASCII 코드 값을 출력 ­ 문자형은 문자나 작은 크기의 숫자를 기억하기 위해 사용  ▶ 실수형(float, double)
- 소수점이 존재하는 수치 표현
- float형 : 32bit를 이용한 실수 표현
- double형 : 64bit를 통한 실수 표현
- 보다 큰 수를 표현을 위해 수정자 long이 사용 가능함.

1) 실수형 표현범위 실수형 타입 비트의 크기 수의 표현 범위 표준 실수형(float) 32 3.4E±3S (유효자리수 7) 긴 실수형(double) 64 1.7E±30S  (유효자리수 15) 1.7E±30S  (유효자리수 15) long double 64 또는 80 1.2E±4932  (유효자리수 19)
- long double은 사용하는 운영체제나 컴파일러의 특성에 따라 다름.
- Visual studio는 64 사용(double로 처리함) v [기초다지기] 자료형 익히기

1) 실수 자료형의 크기에 대해 알아보자.
- 실수형 : float, double, long double : 각각의 자료형의 크기는 4, 8, 8로 표현
- ANSI 표준에서 long double은 double 보다 크거나 같은 크기를 가지지만 실제 사용되는  운영체제나 컴파일러의 특성에 따라 약간의 차이점을 가짐.
- 윈도우 계열의 PC에서는 double과 long double은 동일한 크기   C언어  I  v [기초다지기] 변수와 형변환 익히기 

1) 자료형에 대한 변수 선언과 할당 방법을 익히자.  v 분석 ­ 정수형 변수 iValue와 실수형 변수 dValue, dInit인 3개의 변수 ­ C에서 모든 변수는 선언 후 사용 ­ 선언 방법
① 변수 이름만 쓰는 방법
② 선언과 동시에 초기값을 할당하는 방법( double dInit=3.84) ­ 할당연산자(=)를 통해 언제든 필요시 변수에 값을 할당 가능 ­ 출력 구문 printf에서 실수값(float, double)의 출력은 %f나 %e
① %f 출력 : 단정도형 출력
② %e 또는 %E는 배정도 형 출력  ▶ 형 없음(void)
- 특수형으로 타입이 존재하지 않음을 이야기함.
- 주로 함수의 리턴 타입을 위해 정의됨.
- 예> void main(){…} 4. 확장 자료형의 이해 ▶ [기초다지기] 자료형 익히기

1) 열거형(enum)
- 의미가 불분명한 수치 데이터에 의미 부여
- 정수 값 표현 
- 프로그램을 읽기 쉽게 하는데 사용
- 예>enum  season  {Spring,  Summber,  ex)all,  Winter};열거된  순서에  의해  정수값  부여 (0,1,2,3)  C언어  I 

2) 열거형의 활용 방법을 익히자.  ­ 열거형 선언을 위한 키워드 : enum v 예 : season의 열거형
- Spring, Summer, ex)all, Winter라는 의미를 부여
- 순서대로 Spring은 정수값 0의 의미를 가지며 나머지는 1씩 증가된 정수 값을 가짐.
- 정수값에 의미를 부여하여 프로그램에 사용
- ex)all=5의 의미 : ex)all의 정수값을 5로 설정, 이후 Winter는 5에서 1 증가한 6 값 5. 자료형과 자료형 변환 활용 ▶ 자료형과 자료형 변환 활용 문제

1) 문제 정의 : 한 주간 입/출금 내역서 보기
2) 문제 조건
- 한 주간의 수입과 지출에 대한 리스트를 출력함.
- 한 주는 일요일부터 토요일까지 되며 총 수입/지출 금액과 주일 평균 수입/지출 금액을 계 산함.

3) 한 주간의 수입과 지출에 대한 리스트
- 일 : 용돈 받기    5,000
- 월 : 교재 구입    14,000
- 화 : 친구 만나기    10,000
- 수 : 영화보기    14,000
- 목 : 아르바이트 하기    34,000
- 금 : 노트북 수리하기    50,000
- 토 : 집안 청소    14,000  C언어  I 

4) 실습 단계 1단계 문제에 맞게 프로그램을 작성하여 보자. 2단계 프로그램을 davwork.c로 저장하고 컴파일 한다. 에러 없이 정상적으로 컴파일 한 후 실행하여라. 이 때 이 프로그램을 정확한  답은 만들어 내지 못한다. 그 원인을 찾아 수정하여라. 3단계
1) 변수의 초기화 문제
2) 계산 시 발생되는 잘림 현상 문제 4단계 수정 후 실행하고 그 결과를 작성하여 보자. ▶ 실습  C언어  I  ▶ 정답  C언어  I  자료형과 변수 그리고 형 변환 수업목표   1. 형 변환과 변수의 통용 범위에 대해 이해한다.  3주차 
① 변수들 간의 형 변환 이해 2교시 
② 함수의 기본 구조 이해 세부내용 
③ 변수의 통용범위 이해
④ 변수 그리고 기억 클래스 활용 1. 변수들 간의 형 변환 이해 ▶ 자료형과 변수 그리고 형 변환

1) 변수의 선언과 할당
① 변수
- 어떤 값을 저장하기 위한 공간의 이름
- C언어는 변수의 사용을 위해서는 반드시 선언되어야 함.
② 변수의 선언
- <변수의 자료형> 변수명[,변수명];
- 예 : 
- 변수 선언은 컴파일러에게 미리 자료형을 알려줌으로써 기억 장소를 확보할 수 있게 함.
- 사용자에게 자료형과 변수의 잘못된 사용을 방지함.
③ 변수 선언과 초기화
- 선언과 동시에 초기값 할당 방법
- 예 : 
- 선언 후 변수에 값을 할당하는 방법
- 형식 : 변수 = 값
- 예 :

2) 자료의 형 변환
- 변수는 다양한 자료형을 가지고 있으며 이들 간의 연산에 의해 자료형이 변경될 수 있음.
- C언어는 두 가지 형태의 자료 변환 방법을 제공함.  C언어  I  ­ 계산 결과에 의해 자동적으로 형이 변형됨. 묵시적인 ­ 계산 결과는 값이 큰 자료형으로 자동 변환됨. 형 변환 ­ 타입 변환 규칙  ­ 사용자에 의해 강제적으로 형을 변경함. 명시적인 ­ Cast 연산자 이용 형 변환 ­ 변수 앞에 괄호를 포함한 자료형으로 변환시킴. 묵시적 형 변환의 예 명시적 형 변환의 예 ▶ [기초다지기] 변수와 형변환 익히기

1) 자료 형들의 변환 과정을 이해하자. 
① 정수형과 실수형 간의 형 변환 과정 v dValue = iValue * dInit 문장
- 정수와 실수간의 곱을 한 후 결과를 dValue에 저장
- 정수와 실수의 곱셈은 두 타입 중 큰 타입으로 자동 형변환 v iResult1 = iValue * (int)dInit 문장
- (int)dInit는  실수값을  강제적인  형  변환을  통해  정수  값으로  변화시킨  후  그  결과와  iValue값과 곱
- 두 값은 정수이므로 정수의 결과를 만들어내고 이것을 iResult1에 저장 v iResult2 = (int)(iValue * dInit) 문장은 iValue와 dInit 곱 ­ 정수와 실수의 곱을 통해  실수값을 만듦. ­ 이후 (int)에 의해 만들어진 실수 값을 정수형으로 강제 형변환 ­ 실수값이 정수형으로 형변환 될 때 소수점 이하 자릿수는 모두 잘림.  C언어  I  2. 함수의 기본 구조 이해 ▶ 기억클래스와 변수의 통용범위

1) 함수의 선언과 사용
- C언어는 함수 기반 언어로,크게 라이브러리 함수와 사용자 정의 함수로 나누어짐.
① 사용자 정의 함수 사용 예
② 프로그램에서 함수의 사용은 3단계를 포함함.
- 함수의 선언(프로토타입) : 사용하고자 하는 함수의 프로토 타입을 선언
- 함수의 구현
- 함수의 호출
③ 함수의 구성 형식  C언어  I 

2) 함수의 호출
- [리턴 변수] = [함수의 이름]( [실 매개 변수 리스트] ); 
- 함수의 이름을 통한 함수 호출
① 실 매개 변수 : 함수 호출에 전달되는 실제 값 리스트
② 형식 매개 변수 : 함수 호출 시 전달되는 실제 값을 받아들이는 형식 매개 변수
③ 함수 호출 과정

3) 지역 변수와 전역 변수
- 변수의 선언 위치는 크게 함수의 내부와 함수의 외부로 나누어질 수 있음.  ­ 함수의 내부에 선언된 변수 지역 변수 ­ 이 변수는 자신의 함수에서만 사용 가능한 변수 ­ 함수 외부에 선언된 변수 전역 변수 ­ 선언 위치부터 모든 함수에서 사용할 수 있는 변수
- 지역 변수와 전역 변수가 동일한 이름으로 동시에 존재할 경우 지역 변수를 사용함.
① 지역 변수와 전역변수 사용 예

4) 기억 클래스
- 변수의 기억 공간의 위치
- 변수의 생존 기간 규정  C언어  I 

5) C언어에서 변수 할당 가능 기억 공간 ­ 메모리 스택 (Stack) : 임시적 데이터를 저장하는 메모리 공간 ­ 메모리의 동적 공간(Heap) : 사용자가 임의로 생성 삭제 가능한 데이터를 저장하는 메모리 공간 ­ 메모리의 정적 공간(Data) : 영구적인 데이터를 저장하는 메모리 공간 ­ CPU의 레지스터 : CPU에 존재하는 아주 빠른 기억 공간
6) 기억 클래스의 종류 기억클래스의 종류 설명 auto ­ 임시 저장 공간인 스택(Stack)에 저장 register ­ CPU레지스터(Register)에 저장 static ­ 메모리의 정적 공간에 저장(Data) extem ­ 다른 곳에 이미 정의된 외보변수의 사용을 선언
① auto 기억 클래스
- 자동 변수
- 주로 함수나 블록의 내부에 선언되며 그 함수의 내부에서만 유효한 특징을 가짐.
- 지역 변수의 역할 v auto 변수 선언 예 ­ 함수나  블록  내부의  선언  변수는  지역적인  특성  때문에  자동적으로  auto변수로  인식되며  생략 가능함.
② register 기억 클래스
- 변수를 메모리 영역이 아닌 CPU 레지스터 영역에 기억
- 빠른 처리 속도 제공 (주로 고속에 데이터 처리를 위해) v register 클래스 사용 시 제약사항 Ÿ 시스템마다  한정된  레지스터  공간을  가지고  있기  때문에  많은  수의  레지스터  변수를  선언할 수 없음.
Ÿ 한계를 초과하여 register 변수를 선언 시 초과된 부분은 auto 변수로 자동 변환함. 
Ÿ register 변수로 선언된 변수의 주소 값을 참조할 수 없음. 
Ÿ 실수형 데이터는 register로 지정할 수 없음.  C언어  I 
③ static 기억 클래스
- static으로 선언된 변수는 영구적으로 기억공간에 존재함.이러한 변수를 정적 변수라 함.
- 정적 변수는 선언 위치에 따라 두 가지 형태를 가짐. 전역적 정적 변수 ­ 함수 밖에서 선언되는 정적 변수로 모든 함수에 영향을 미침. ­ 함수나 블록 내부에 존재하는 정적 변수로 사용 범위가 해당 함수와  지역적 정적 변수 블록으로 제한되지만 그 값은 계속 지속함. ­ 해당 함수의 종료 후에도 지속적으로 값을 유지함. v static 기억 클래스의 활용 예
④ extern 기억 클래스
- 여러 파일에서 공유 될 수 있는 기억 클래스
- 전역 변수의 참조는 한 개의 파일 내에서만 가능
- extern 기억 클래스를 활용한 파일간의 변수 공유  C언어  I  ▶ 변수와 선언위치 그리고 기억 클래스 관계 선언 위치 기억 클래스 기억장소 수명 사용범위(scope) 정적 영역 없음 영구적 ­ 모든 함수에 전역적 사용 (Heap) 함수의 정적 영역 ­ 외부에  정의된  변수를  선언된  파일의  static X 외부 (Data) 모든 함수에 전역적 사용 ­ 외부에  정의된  변수를  선언된  파일의  extern X X 모든 함수에 전역적 사용 임시 영역 없음 임시적 ­ 선언된 함수나 블록내부 (Stack) 임시 영역 auto 임시적 ­ 선언된 함수나 블록내부 (Stack) 함수 또는 CPU  register 임시적 ­ 선언된 함수나 블록내부 블록 내부 Register 정적 영역 static 영구적 ­ 선언된 함수나 블록내부 (Data) ­ 외부에  정의된  변수를  선언된  파일의  extern X X 함수나 블록 내부에서 사용 3. 변수의 통용범위 이해 ▶ [기초 다지기] 변수 통용 범위 익히기 

1) 사용자 정의 함수를 사용 
- 특정 부분을 함수로 구성하기 위해서는 함수의 선언, 구현 그리고 호출부로 나누어 작성  C언어  I 

2) 지역변수와 전역변수 활용하기 v 지역 변수와 전역 변수 활용하기 ⇨ [분석] 
- 두 개의 함수 functionA와 functionB
- 전역 변수 : gValue, 지역 변수 : local변수
- functionA()에서 local 변수는 지역 변수이기 때문에 functionA안에서만 영향을 미침.
- gValue는  전역  변수로  선언되어  있기  때문에  gValue에  20의  할당  후  Main()함수에서  gValue 출력 시 functionA()에서 할당한 값이 출력
- functionB()에서 변수 gValue가 지역 변수로 선언
- 전역 변수 gValue와 지역 변수의 gValue가 동일한 이름  Ÿ 함수 내부의 gValue의 지역 변수로써 동작
- 함수 밖에 선언된 전역 변수는 모든 함수들에 영향을 미치지만 함수 내부에 동일한 이름의  변수가 지역적으로 선언될 경우 지역 변수에 우선권을 가짐.

3) auto와 register 기억 클래스 활용하기  C언어  I  v 분석
- x와 y는 정수형으로 기억클래스가 auto
- 함수  내부에  선언된  변수들은  기억  클래스를  생략할  경우  자동적으로  auto  기억클래스를  가지며 스택에 저장
- register 기억클래스는 정수형 타입에 값을 저장 

4) static 기억 클래스 활용하기  v static 기억 클래스 활용하기 ⇨ [분석]  
- gValue 전역 변수로 선언, 기억 클래스로 static
- 지역 변수인 sValue와 aValue Ÿ sValue는 static 기억클래스를 가진 지역 변수
Ÿ aValue는 auto 기억 클래스를 가진 지역 변수 (지역 변수일 경우 auto 생략 가능)
- 기억 클래스가 static이냐 auto이냐에 따라 생존 기간이 다름. Ÿ static일 경우 : 처음 생성된 이후 프로그램 종료 시까지 계속적으로 존재하며 값의 초 기화는 단 한 번 이루어짐.
Ÿ auto 기억 클래스를 가진 지역 변수 : 해당 함수 블록이 종료되는 시점에 사라지며 다 시 함수 호출 시 새롭게 생성
- static 기억클래스를 가진 전역 변수와 지역 변수의 차이는 통용 범위에서 발생 Ÿ static  지역  변수는  함수가  수행  이후에도  지속적으로  존재하지만  해당  함수  내부에서 만 사용 가능  C언어  I 

5) extern 기억 클래스 활용하기 v 분석
- 두  프로그램은  다른  파일로  만들어져  존재할  때  한  파일(main.c)의  변수를  다른  파일 (func.c)에서 사용하고자 할 때 extern 기억 클래스를 사용
- main.c에 정의된 eValue 변수는 func.c에서 그 변수 값 사용 가능
- static  기억클래스를 가진 전역 변수가  단지 한  파일 내에서만  접근 가능하다면 extern  기 억 클래스는 다른 파일 안에서 접근 가능  4. 변수 그리고 기억 클래스 활용 ▶ 변수와 기억 클래스 활용 예 

1) 문제 : 박물관 방문자 입장/퇴장 관리 
- 다음  프로그램은  박물관  출입  관리를  위한  프로그램이다.  이  프로그램은  전체  입장객  수와  현재 입장객 수, 그리고 각 박물관 룸(Book Room, Media Room, History Room)에 입장 한 입장객 수를 출력한다. 이 프로그램은 두개의 파일로 구성된다. museum.c 는 메인함수를  가지고 박물관 입/출력을 담당하고 있으며 museumSub.c는 입장과 퇴장 함수들을 가진다. 

1) 입장 : 1,  퇴장 : 2,  종료 : 
-1 작업 선택  입력 조건

2) 입장하고자 하는 방 선택  1: Book Room, 2 : Media Room, 3 : History Room  전체 입장객 수, 현재 입장객 수,  출력 조건 현재 각 방 별(Book Room, Media Room, History Room) 입장객 수  C언어  I  ▶ 알고리즘
1) Main 함수
- 작업을 사용자로부터 입력 받음.(1:입장, 2:퇴장, 
-1:종료)
- 작업에 따라 입장, 퇴장 함수를 호출함.
- 전체/현재 입장객 수를 출력함.

2) 박물관 입장은 enterMuseum 함수로 함.
- 전체 입장객 수를 증가함.
- 현재 입장객 수를 증가함.
- 입장을 원하는 방을 선택함.
- roomAction 함수로 처리함.

3) 박물관 퇴장은 exitMuseum 함수로 함.
- 현재 방문자 수를 감소함.
- 퇴장을 원하는 방을 선택함.
- roomAction 함수로 처리함.

4) 각 룸의 정보는 roomAction 함수에서 처리함.
- 각 룸의 입장 퇴장에 따라 값을 +1, 
-1 해 줌.
- 각 룸의 현재 입장객 수를 출력함. ▶ 변수 그리고 기억 클래스 활용

1) 실습 단계 1단계 ­ 문제를 읽고 프로그램을 작성하여라. 2단계 ­ 두 파일을 작성 후 컴파일 한다. ­ 이상이  없이  컴파일이  완료되면  실행시켜  보자.  원하는  결과를  만들어  내지  3단계 못할 것이다. 로직 상의 에러를 찾아 수정하여라. 4단계 ­ 저장 후 테스트 값에 대한 최종 결과를 작성하여라.  C언어  I  ▶ museum.c  C언어  I  ▶ museumSub.c  C언어  I  ▶ 테스트 값  C언어  I  연산자의 종류 1. 연산자의 종류에 대해 이해한다.  수업목표   4주차  2. 연산자들의 특징을 이해한다.  1교시 
① 프로그램 작성과 연산자 세부내용 
② C언어의 다양한 연산자
③ 부분별 연산자 활용 1. 프로그램 작성과 연산자 ▶ 프로그램 작성과 연산자
- 프로그램 작성 시 연산자는 변수나 상수를 포함하는 수식이나 문장의 한 요소로 활용됨.
- C언어는 다양한 연산자를 제공함. 2. C언어의 다양한 연산자 ▶ 연산자의 종류

1) 문장에서 사용되는 수식의 구조 : 연산자(Operator), 피연산자(Operand)
2) 연산자의 종류
- 산술연산자, 관계연산자, 논리연산자,  비트연산자, 대입연산자, 기타연산자 Ÿ 조건 연산자, 포인터 연산자, 크기계산 연산자, 형 변환 연산자, 괄호, 구조체, 배열 연 산자, 콤마 연산자 등

3) 피연산자의 수에 의한 분류 ­ 단항 연산자 : 피연산자의 수가 하나인 연산 ­ 이항 연산자 : 피연산자의 수가 두 개인 연산
4) 아래의 수식에서 단항 연산자와 이항 연산자를 식별해보자.  C언어  I  ▶ 산술 연산자 ­ 기본적인 사칙연산과 나머지 연산 등을 포함
1) 산술 연산자의 종류 연산자 피연산자의 수 기능 적용 예 z의 값(x=100, y=20) 단항 양의 부호 z=+x z=100 + 이항 덧셈 z=x+y z=120 단항 음수 부호 z=
-y z=
-20
- 이항 뺄셈 z=x
-y z=80 * 이항 곱셈 z=x*y z=2000 / 이항 나눗셈 z=x/y z=5 % 이항 나머지 z=x%y z=0 전위 1증가 z=++x z=101, x=101 ++ 단항 후위 1증가 z=x++ z=100, x=101 전위 1감소 z=
-xx z=99, x=99
-
- 단항 후위 1감소 z=x
-
- z=100, x=99

2) 사칙 연산 시 고려할 사항
① 단항 연산자의 피 연산자는 항상 정수형이어야 함. 
② 정수와 정수의 나눗셈 계산 결과가 소수점이 발생할 때 이 값은 절사됨. 그러므로 피연산 자의 두 정수 중 하나는 실수로 변환한 후 계산하여야 함. 
-  예> int x=28, y=8;              float z;              z = x / y;          // 결과 : 
① 3.0             z = x / (float) y;   // 결과 : 
② 3.5
③ 전위 연산자는 값을 먼저 계산 후 그 결과를 전달하는 반면후위 연산자는 값을 먼저 전달 하고 자신을 자신의 값을 계산함.  ▶ 관계 연산자 ­ 두 식간의 관계 식별 ­ 결과는 참(1)이거나 거짓(0)값을 가짐. ­ 주로 제어구조의 비교 과정에서 이용됨.

1) 관계 연산자의 종류 연산자 기능 적용 예 설명 < 보다 작은가? x<y x가 y보다 작으면 참(1) 아니면 거짓(0) <= 보다 작거나 같은가? x<=y x가 y보다 작거나 같으면 참(1) 아니면 거짓(0)
> 보다 큰가? x>y x가 y보다 크면 참(1) 아니면 거짓
>= 보다 크거나 같은가? x>=y x가 y보다 크거나 같으면 참(1) 아니면 거짓(0) == 같은가? x==y x가 y와 같으면 참(1) 아니면 거짓(0) != 다른가? x!=y x가 y와 다르면 참(1) 아니면 거짓(0)  C언어  I  ▶ 논리 연산자 ­ 여러 조건에 대한 참(1)과 거짓(0)을 판단함.

1) 논리 연산자의 종류 연산자 피연산자 수 기능 사용 예 설명 && 이항 논리곱(AND) x&&y 두 조건식이 참일 경우만 참(1) II 이항 논리합(OR) xIIy 두 조건식 중 하나라도 참이면 참(1) ! 단항 논리부정(NOT) !x 참은 거짓(0), 거짓은 참(1)
2) 조건식의 결과와 연산자의 관계 x y x&&y xIIy !x 0(거짓) 0(거짓) 0(거짓) 0(거짓) 1(참) 0(거짓) 1(참) 0(거짓) 1(참) 1(참) 1(참) 0(거짓) 0(거짓) 1(참) 0(거짓) 1(참) 1(참) 1(참) 1(참) 0(거짓)
3) 논리 연산 처리 시 고려사항
① C언어에서 거짓은 0으로 나타내고 0이 아닌 나머지는 참으로 인식됨. 
② 논리 연산은 shorted circuit 처리를 함. 이 의미는 두 조건식의 비교 과정에서 앞쪽 조건 식에 의해 의미가 결정될 때 나머지 조건식은 비교 하지 않고 다음으로 진행된다는 의미 
- 예>  1 int x=10, y=20, z= 30;  2 if(x < y || x > z){...} // x > z는 수행되지 않음. 3 if(x > y && x < z){...} // x < z는 수행되지 않음. ▶ 비트 연산자 ­ 컴퓨터의 모든 데이터는 0과 1인 2진수로 표현됨. ­ 비트 연산자는 이러한 2진수 데이터를 조작함.

1) 비트 연산자의 종류 연산자 기능 적용 예 z의 값(x=5, y=7) & 비트 논리곱(AND) z=x&y 00000101&00000111=0000101 l 비트 논리합(OR) z=xly 00000101l00000111=0000111 ^ 비트 배타적합(XOR) z=x^y 00000101^00000111=0000010 ~ 비트 부정(1의보수) z=~x ~00000101=11111010
>> 비트 오른쪽이동 z=x>>2 00000101>>2=00000001 << 비트 왼쪽 이동 z=y<<2 00000111<<22=00011100  C언어  I  ▶ 대입 연산자 ­ 연산 결과를 할당하는 이항 연산자 ­ 대입 연산자는 기본 대입연산자(=)와 복합 대입 연산자로 구성

1) 대입 연산자의 종류 연산자 기능 사용 예 일반 식 x의 값(x=28, y=8) 기본 = 오른쪽 결과 왼쪽에 할당 x=y x=y 8 += 누적 덧셈 x+=y x=x+y 36
-= 누적 뺄셈 x
-=y x=x
-y 20 산술 *= 누적 곱셈 x*=y x=x*y 224 /= 누적 나눗셈 x/=y x=x/y 3 %= 누적 나머지 x%=y x=x%y 4 &= 비트 논리곱과 x&=y x=x&y 8 l= 비트 논리합과 할당 x l=y x=xly 28 비트 ^= 배타적 논리합과 할당 x^=y x=x^y 20
>>= 오른쪽 이동과 할당 x>>=3 x=x>>3 3 <<= 왼쪽 이동과 할당 y<<=2 y=y<<2 112 ▶ 기타 연산자 ­ 조건, 포인터(*,&), 크기 계산(sizeof), 형변환(cast), 괄호("()"), 콤마(,) 연산자 등을 포함함.

1) 조건 연산자 ( ? : )
- 표현식 : 조건식 ? 수식 1 : 수식 2;
- 조건식 계산하여 참일 경우 수식 1을 거짓일 경우 수식 2를 수행
- 사용 예> int x = 3, y = 5, z; z = (x > y) ? (x
-y) : (y
-x); 결과 : 2 

2) 크기 계산 연산자 (sizeof)
- 연산 대상의 크기를 바이트 수로 반환
- 형식 : sizeof(수식이나 자료형 또는 변수 이름)
- 사용 예> 1      short sx=2;  2      int ix=10,iy=20,iz;  3      iz = sizeof(sx+ix);      // iz의 값 : 4(int 크기) 4      iz = sizeof(iy);  // iz의 값 : 4(iint 크기) 5      iz = sizeof(double);  // iz의 값 : 8(double 크기)  C언어  I 

3) 괄호 및 구조체 그리고 배열 연산자
- 수식에서 괄호는 가장 먼저 수행하게 만드는 연산자
- 사용 예> x = (x + y) * z 이 연산은 (x + y)를 무엇보다도 먼저 수행하게 만듦.
- 구조체 연산자 (. or 
->) : 구조체에서 자세히 다룸.
- 배열 연산자 ([])  : 배열에서 자세히 다룸.

4) 콤마 연산자
- 여러 수식을 분리하기 위해 사용
- 한 문장에 여러 수식 존재할 경우 각각을 ","로 구분
- 사용 예> z = x +y , y++, x
-
-;

5) 포인터 연산자
- * : 간접 지정 연산자 (해당 주소에 저장하고 있는 값을 반환)
- & : 주소 연산자 (해당 변수의 메모리 상의 주소 반환)
- 포인터 관련 장에서 자세히 다룸. ▶ [기초 다지기] 연산자 익히기

1) 산술 연산자의 연산 결과를 알아보자. v 분석
- 두 수에 대한 사칙연산, 부호연산, 나머지 연산, 전위 및 후위 증가/감소 연산
- 정수와 정수의 나눗셈은 정수의 결과를 나타내므로 소수점 이하가 절사됨.  C언어  I 
- 나눗셈 결과를 실수 값으로 얻기 위해 두 정수 중 하나를 실수 형으로 변환하여 처리
- 전위 증가/감수는 먼저 값을 증가/감소시킨 후 값 전달
- 후위 증가/감소는 먼저 값을 전달한 후 값을 1증가/감소 

2) 관계 연산의 결과를 알아보자. v 분석
- 관계 연산의 결과는 참 또는 거짓 값을 만듦.
- C에서 참은 정수값 1로 표현되며 거짓은 정수값 0으로 표현 

3) 논리 연산 결과에 대해 알아보자.
- &&(AND)는 조건 대상 값들 모두가 참일 경우만 참을, 그렇지 않을 경우 거짓을 반환
- ||(OR)는 조건 대상 값들 중 하나라도 참일 경우 참을, 그렇지 않을 경우 거짓을 반환
- !(NOT)은 참을 거짓으로 거짓을 참으로 만듦.   C언어  I 

4) 비트 연산자 활용하기 v 분석
- 비트단위 곱(& AND), 합(| OR), 배타적 합(^ XOR), 부정(~ NOT) 그리고 Shift 연산
- 계산결과는 비트 계산 후 10진 결과로 표현 

5) 대입 연산자 활용 방법에 대해 알아본다. v 분석
- x = x + y의 식은 x += y의 식으로 대처될 수 있음.
- 대입 연산(=)은 각각의 산술 및 비트 연산자들과 결합하여 복합 대입 연산자를 만듦.
- x += y, x *= y, x &= y 등 필요에 따라 축약해서 사용 가능   C언어  I 

6) 조건 연산자 활용 예 v 분석
- z = (x > y) ? x : y 문장 Ÿ x > y의 조건이 참(1)일 경우 z = x를 수행
Ÿ 거짓일 경우 z = y 수행
- (조건)? 참일 때 할 일 : 거짓일 때 할 일로 구성  3. 부분별 연산자 활용 ▶ 사칙 연산 프로그램 ­ 산술 연산자의 활용법을 다룸. 1단계 ­ 다음 페이지의 프로그램을 작성하자! 2단계 ­ 출력 결과를 작성한다. ­ 원하는 결과 출력되었는지를 검토하자.  특히 나눗셈 연산 x/y의 결과 확인해보고 잘못된 문장을 수정하자! 3단계 4단계 ­ 수정 후 실행결과를 작성한다.  C언어  I  ▶ 증가 및 감소 연산자 활용

1) 증가(++)및 감소(
-
-)연산자의 특징과 전위(++/
-
-a)와 후위(a++/
-
-)의 관계를 이해함. 1단계 ­ 다음 페이지의 프로그램을 작성한다. ­ 프로그램을 컴파일하고 디버깅 과정을 통해 각 단계 수행 후의 변화되는 값을  2단계 확인하자. 6라인부터 9라인의 값을 작성하여라. 3단계 ­ 최종 결과를 작성하자. v 증가 및 감소 연산자 활용 프로그램 13, 1 ▶ 비트 처리 연산자 활용
- 2진수의 데이터 값 처리 1단계 ­ 다음 페이지의 프로그램을 작성하고 저장한다. ­ 각 단계별 수행 과정의 결과의 2진수 형태를 작성하여 보자. 2단계 ­ 4,5,6,8 라인 ­ 9라인과 11라인의 처리 결과에 대한 2진수 값을 작성해보자. 3단계 v 비트 처리 연산자 활용 예  C언어  I   C언어  I  연산자 우선순위와 결합성 1. 연산자의 우선순위와 결합성을 이해한다.  수업목표   4주차  2. 연산시의 형 변환 과정을 이해한다.  2교시 
① 다양한 연산자를 포함하는 수식의 이해 세부내용 
② 연산자들의 우선순위와 결합성
③ 연산자 종합 활용 1. 다양한 연산자를 포함하는 수식의 이해 ▶ 다양한 연산자를 포함하는 수식의 이해
- 다양한 연산자를 포함하는 수식은 그들간의 결합성과 우선 순위를 가짐. 2. 연산자들의 우선순위와 결합성 ▶ 우선순위
- 어떤 연산자를 먼저 계산할 것인지에 대한 규칙 ▶ 우선순위와 결합성

1) 우선순위  ­ 일반적으로 수식은 다양한 연산자들이 복합적으로 사용됨.
① 우선순위
- 한 수식에 포함된 다양한 연산자들의 연산에 대한 순서를 부여 
② 결합성
- 동일한 우선순위를 가진 연산자들이 존재할 경우 어떤 방향으로 결합해야 하는지를 나타냄.
③ 일반적 적용 형태
- 연산자  우선순위에  의해  먼저  계산될  대상이  선정되고  만약  동일한  우선순위를  가질  경우 에는 결합성에 의해 순서가 결정
- 연산식에서 괄호는 가장 먼저 수행할 대상을 나타내고 이항 연산자 보다 단항 연산자가 보 다 높은 우선순위를 가짐.
- 기본적으로  왼쪽에서  오른쪽의  결합  순서를  가지지만  단항연산자와  대입연산자  그리고  조 건연산자는 오른쪽에서 왼쪽으로의 결합성을 가짐.  C언어  I  ­ 수식에서 어떤 연산자를 먼저 계산할 것인지의 문제 우선 순위 연산자 결합 규칙 1 () [] 
-> . ++(후위) 
-
-(후위)
->(좌에서 우) sizeof &(주소) ++(전위) 
-
-(전위) ~ ! *(역참조) +(부호) 
-(부호),  2 <
-(우에서 좌) 형변환 3 *(곱셈) / %
->(좌에서 우) 4 +(덧셈) 
-(뺄셈)
->(좌에서 우) 5 << >>
->(좌에서 우) 6 < <= >= >
->(좌에서 우) 7 == !=
->(좌에서 우) 8 &(비트연산)
->(좌에서 우) 9 ^
->(좌에서 우) 10 |
->(좌에서 우) 11 &&
->(좌에서 우) 12 ||
->(좌에서 우) 13 ?(삼항) <
-(우에서 좌) 14 = += *= /= %= &= ^= |= <<= >>= <
-(우에서 좌) 15 ,(콤마)
->(좌에서 우) ▶ 우선순위의 일반적인 지침 콤마 < 대입 < 논리 < 관계 < 산술 < 단항 
- 괄호 연산자는 가장 우선순위가 높음. 
- 모든 단항 연산자들은 이항 연산자들보다 우선순위가 높음. 
- 콤마 연산자를 제외하고는 대입 연산자가 가장 우선순위가 낮음. 
- 연산자들의 우선 순위가 생각나지 않으면 괄호를 이용함. ( x <= 10 ) && ( y >= 20 ) 
- 관계 연산자나 논리 연산자는 산술 연산자보다 우선순위가 낮음. x + 2 == y + 3  ▶ 결합 규칙
- 동일한 우선 순위를 가지는 연산들이 여러 개가 있으면 어떤 것을 먼저 수행하여야 하는가 에 대한 규칙 v 예제  C언어  I  ▶ 연산자 우선순위와 결합성

1) 적용 예
- 값  a=3,  b=4,  x=5,  y=10,  z=7일  경우  아래의  연산식에  대한  수행  순서를  적고  결과  값 을 작성해 보자! v 예제  C언어  I  ▶ [기초다지기] 우선순위와 결합성 익히기

1) 연산자 우선순위를 이해하자. v 분석
- +, >, *에 대한 연산 결과
- 하나의 연산자 : 우선순위 없이 개별적으로 처리
- x + y > 3*z는 여러 연산자들이 한 문장에 작성된 형태 Ÿ 연산자들 간의 우선순위가 고려되어 처리
Ÿ 우선순위는 *, 
-, > 순으로 이루어짐.
- ((x + y) > 3) * z의 문장 Ÿ 연산자들의 우선순위를 가장 높은 우선순위를 가진 연산자( )

2) 동일 우선순위에서 결합성을 이해하자. v 분석 :  x++ 
- 
-
-y + 
-z의 식의 연산 순서
Ÿ 먼저 우선순위에 의해 ++, 
-
-, 
-의 연산이 수행된 후 +, 
- 연산 처리
Ÿ 이 때 ++, 
-
-, 
-가 동일한 연산우선 순위를 가지기 때문에 이때 결합성에 의해 연산 순 서가 결정
Ÿ 단항 연산자의 결합규칙 : 오른쪽에서 왼쪽으로 전개
Ÿ
- + 역시 동일 우선순위를 가지기 때문에 결합성에 의해 전개 : 산술 연산자의 결합성 은 왼쪽에서 오른쪽으로 전개   C언어  I 

3) 연산자 우선순위와 결합성을 통한 연산식  v 분석
- 연산자 우선순위와 결합성을 통해 계산된 연산 식
- 각 연산 결과 수행 후 만들어진 결과는 다음 연산 식의 입력 값으로 작용  3. 연산자 종합 활용 ▶ 연산자 종합 활용
- 다양한 연산자를 활용한 문제 상황 적응 능력을 키움.
- 다양한 연산자를 활용하여 판매 실적 계산 프로그램을 만들어 본다. ▶ 판매 실적 계산 프로그램

1) 문제 정의
- 어느  영업점에서 물품 판매에 대한 실제 이익을 계산하고자 한다.  작성하고자 하는 프로그 램은 판매 품목에 대한 가격, 수량, 디스카운트율, 그리고 품목에 대한 세금을 고려하여 실 제 판매 이익을 계산하는 프로그램이다. ­ 품목에 대한 가격 입력 조건 ­ 판매 수량 ­ 디스카운트율  ­ 총판매 금액  출력 조건 ­ 디스카운트 적용 후 실제 판매 금액  ­ 세금 계산 후 판매 이익과 세금 (실제 판매 금액의 10%는 세금)  C언어  I 

2) 알고리즘 1.1 품목에 대한 가격 입력  1. 판매 내용을 입력한다.  1.2 판매 수량 입력  1.3 디스카운트율 입력  2.1. 품목 가격과 판매 수량을 이용해 판매 금액 계산  2.2. 판매 금액에 디스카운트 율 적용하여 실 판매 금액 계산  2. 판매 내용을 계산한다.  2.3 실 판매 금액을 통해 세금 계산  2.4 판매 이익 계산  3.1. 총 판매 금액 출력  3. 결과를 출력한다.  3.2. 실 판매 금액 출력 (디스카운트 적용 후)  3.2. 세금과 판매 이익 출력  v 1단계 : 앞의 문제의 프로그램을 작성한다. v 2단계 : sale.c로 저장하고 다음과 같은 결과 검사
① 입력 값
- 품목에 대한 가격 : 234000 
- 판매 수량 : 34 
- 디스카운트율 (%) : 20 
② 출력 결과  C언어  I   C언어  I  선택 제어 구조 ­ if else 구조 1. 선택 제어구조의 문법을 이해한다.  수업목표   2. if
-else 제어구조를 이해한다. 5주차 
① if 구문 1교시 
② 기본 if 문 및 if else 구조의 이해 세부내용 
③ 중첩 if 구문의 이해
④ 다중 선택 구조 (if ~ else if 구조)의 이해 1. if 구문 ▶ 조건문 ­ 제어문 : 문장이 실행되는 순서에 영향을 주는 문장 ­ 조건문 : 조건에 따라서 여러 개의 실행 경로 가운데 하나를 선택 ­ 반복문 : 조건에 따라서 여러 개의 같은 처리를 반복 ▶ 일상 생활에서의 조건문의 예
- 만약 비가 오지 않으면 테니스를 친다.
- 만약 결석이 1/3이상이면 ex)학점을 받는다.
- 만약 시간이 없는 경우에는 택시를 탄다.
- 만약 날씨가 좋고 공휴일이면 공원에 산책을 간다.
- 점수가 60점 이상이면 합격이고 그렇지 않으면 불합격이다.  C언어  I  ▶ if문

1) 조건에 따라서 결정을 내리는 경우에 사용
- 조건식이 참으로 계산되면 문장이 실행된다. ­ 파란 화살표는 조건이 참인 경우이고, 빨간색 화살표는 조건이 거짓인 경우임. ▶ if 문의 예 ­ if 문이 끝나면 if 문 다음 문장이 실행된다. ▶ 예제#1  C언어  I  ▶ 예제 #2 ▶ 복합문
- 중괄호를 사용하여 문장들을 그룹핑하는 것, 블록(block)이라고도 함. 
- 단일문 대신 들어갈 수 있음. 2. 기본 if문 및 if else 구조의 이해 ▶ if
-else 문  C언어  I  ▶ 예제 #1 ▶ 복잡한 조건식도 가능 ­ 학점 결정 코드 ­ 공백 문자들의 개수를 세는 코드  C언어  I  ▶ 예제#2 ▶ 예제 #3  C언어  I  3. 중첩 if 구문의 이해 ▶ 중첩 if

1) if 문에 다시 if 문이 포함 ▶ if와 else의 매칭 문제  C언어  I  ▶ 중첩 if ▶ 연속적인 if
1) 성적을 입력 받아서 연속적인 if를 사용하여 학점을 매기는 코드  C언어  I  ▶ 학점 결정 예제 ▶ 문자 분류 예제  C언어  I  ▶ 산술 계산기 예제 ▶ 선택 제어 구조 ­ if else 구조
1) 제어구조의 종류 순차구조 ­ 한 문장 수행 후 순차적으로 다음 문장 수행(일반적 프로그램 흐름) 선택구조 ­ 조건에 따른 분기 처리 반복구조 ­ 일정 구간의 반복 처리
2) if 선택 구조 기본
- if 문은 조건에 따른 제어 흐름을 결정
- if 문에서 사용되는 조건 식은 논리와 관계 연산자를 포함
- if 구조는 단지 참인 경우만을 처리  C언어  I 

3) if 선택 구조 예 형식 플로우차트 설명 단일 종속 문장 구조    if(조건) 문장 1 ;  한 문장에 대한 수행 여부 판별  문장 2 ; 예> if(x＞ 0) printf("x는 양수입니다") ; 다중 종속 문장 구조 if(조건) {       문장 1 ; 블록( { })을 이용한 다음      ... 문장 수행 여부 판별     문장 N ; 예> if(x＞ 0) { }           z=x+y ;  다음 문장            x++ ;       }
4) if else 구조
- 참과 거짓인 경우를 나누어 처리 형식 플로우차트 설명 단일 종속 문장 구조    if(조건)  한 문장에 대한 수행 여부 판별 문장 1 ;  예> if(x＞ 0)  else           printf("x는 양수입니다") ; 문장 2        esle           printf("x는 음수입니다") ; 다중 종속 문장 구조    if(조건) { 블록( { })을 이용한 다음  문장들   문장 수행 여부 판별   }else { 예> if(x＞ 0) { 문장들            z=x+y ;   }           x++ ;  다음 문장        }else {           x=x
-y ;       }  C언어  I  4. 다중 선택 구조(if ~ else if 구조)의 이해 ▶ 다중 선택 구조 (if ~ else if 구조) ­ if else 구조의 확장 ­ 조건에 맞지 않을 경우 다시 비교가 이루어짐. ­ 비교 및 판단의 조건이 여러 개일 경우else 절 이하에 다시 if문 포함시키는 구조

1) 사용 형식 형식 플로우차트 설명 if(조건) {   ... 조건에 만족하지 않을 경우  } 다시 조건을 비교하는  else if(조건) { 과정으로 이루어진다.   ... else if 구문은  }else { 무한히 반복될 수 있다.    ... }  C언어  I  선택 제어 구조 ­ switch case 구조 1. switch case 제어구조를 이해한다.  수업목표   2. 선택 구조 활용 방법을 이해한다.  5주차 
① switch 문 2교시 
② break 문 세부내용 
③ default 문
④ switch 문과 if
-else 문
⑤ switch case 구조 1. switch 문 ▶ switch 문

1) 여러 가지 경우 중에서 하나를 선택하는데 사용  C언어  I 
2) 예제 ▶ 사용자가 1을 입력하는 경우  C언어  I  2. break 문 ▶ break가 생략되는 경우
1) break를 만날 때까지 계속 문장을 실행합니다. ▶ 의도적인 break 생략 ­ 2개의 경우를 하나로 묶어서 처리하기 위하여 이러한 기법을 사용  C언어  I  3. default문 ▶ default 문 : 어떤 case문과도 일치되지 않는 경우에 선택 ▶ 주의할 점
- 반드시 정수 수식만 사용 4. switch 문과 if
-else 문 ▶ switch 문과 if
-else 문  C언어  I  ▶ 예제  C언어  I  5. switch case 구조 ▶ 선택 제어 구조 
- switch case 구조

1) switch 구조
- if문은 참과 거짓이라는 두 조건에 대한 분기 제공
- 3개 이상의 조건에 대해 중첩된 if나 다중 if문 사용으로 인해 프로그램의 복잡성 증가
- 이러한 문제 해결을 위해 switch 구조 사용
- 다중 조건에 대한 분기 구조 제공

2) switch case 구조 형식 플로우차트 설명 switch(정수식) { case label_1: 문장1;                     문장2; 이  switch문은  이  정수식의  case label_2: 문장3; 결과가  case문의  label  값과  case label_n: 문장4; 일치하는지를  평가하여  동일할                       경우 해당 문장부터 처리한다. 문장n; default : 문장 n+1; } ▶ switch 구문의 특징 ­ switch문에서 비교 식은 정수형 상수 값이어야 한다.  ­ case 문의 label 값은 정수나 문자 상수 또는 정수를 나타내는 식이다.  ­ default : 문장은 생략될 수 있다.   C언어  I  ▶ [기초다지기] if else 구조 익히기
1) if문을 이용한 프로그램 (덧셈/뺄셈) 선택 구문  C언어  I 
2) 1번에서 곱셈, 나눗셈, 다른 입력 처리 작업 추가  ▶ [기초다지기] switch 구조 익히기 
1) 예습 1교시 문제 2번을 Switch 구조로 변경   C언어  I  v 분석
- 다중 if 구조는 switch case 구조로 변경 가능
- switch(input)에서 input 값은 정수형(문자) 상수 값이어야 함. Ÿ 이 프로그램에서 input는 문자 상수로 조건을 만족
- 하나의 case 문이 끝나는 지점에 break 문을 작성
- case 구문에 break 문이 존재하지 않을 경우 다음 case 구문을 계속해서 실행  ▶ 문제 ­ 컴퓨터와  가위바위보  게임을  하는  프로그램을  작성하여  보자.  컴퓨터는  사용자에게  알리지  않고 가위, 바위, 보 중에서 임의로 하나를 선택한다. 사용자는 프로그램의 입력 안내 메시 지에 따라서 3개중에 하나를 선택하게 된다. Ÿ 입력 : 가위(0), 바위(1), 보(2)를 입력하세요 :
Ÿ 출력 : 비겼습니다. 당신이 졌습니다. 당신이 이겼습니다.
Ÿ 사용 라이브러리 : stdlib.h, time.h
Ÿ 사용 함수: srand(time(0)), rand()  C언어  I  반복 제어 구조 문법 1. 반복 제어구조의 종류와 활용 방법을 이해한다.  수업목표   2. 반복 제어구조의 다양한 조건 표현 방법을 이해한다.  6주차  3. 내포형 반복 제어구조(Nested Loops)에 대해 이해한다.  1교시 
① C언어가 제공하는 반복 구조의 문법적 특징
② 반복 제어 구조의 종류와 특징 세부내용 
③ for, while, do
-while 구문의 사용
④ 내포된 반복 구조에 대한 이해 1. C언어가 제공하는 반복구조의 문법적 특징 ▶ 반복문 Q. 반복 구조는 왜 필요한가? A. 같은 처리 과정을 되풀이하는 것이 필요하기 때문임.     학생 30명의 평균 성적을 구하려면 같은 과정을 30번 수행해야 함. ▶ 프로그램의 흐름을 제어하는 방법 순차 구조 ­ 차례대로 실행 선택 구조 ­ 조건을 검사하여 여러 개의 실행 경로 중에서 하나를 선택 반복 구조 ­ 조건이 만족될 때까지  C언어  I  ▶ 마일을 미터로 바꾸는 프로그램 2. 반복 제어 구조의 종류와 특징 ▶ 반복문의 종류 ▶ 반복 제어 구조의 종류와 특징
- while()문
- do
-while()문
- for()문  C언어  I  3. for, while, do
-while 구문의 사용 ▶ while 문

1) while 문
- 주어진 조건이 만족되는 동안 문장들을 반복 실행함.

2) 예제 ­ 0 마일은 0 미터입니다  ­ 1 마일은 1609 미터입니다  ­ 2 마일은 3218 미터입니다   C언어  I  ▶ 반복문의 실행 과정  C언어  I  반복 횟수 i의 값 i < 3 반복여부 첫 번째 반복(시작위치) 0 참(1) 반복 두 번째 반복(시작위치) 1 참(1) 반복 세 번째 반복(시작위치) 2 참(1) 반복 네 번째 반복(시작위치) 3 거짓(0) 중지 ▶ 예제 #1
1) while 문을 이용한 구구단 출력 프로그램  ▶ 예제#2
1) 1부터 n까지의 합을 계산하는 프로그램 ­ n이 무엇이 될지 모르는 경우라면 다음과 같이 계산  C언어  I  ▶ 예제 ▶ 센티널(보초값의 이용)
1) 센티널(보초값의 이용)
① 센티널(sentinel) : 보초병, 감시병
- 입력되는 데이터의 끝을 알리는 특수한 값

2) 성적들의 평균을 구하는 문제 1. 필요한 변수들을 초기화한다.  성적의 평균을 구한다. ⇨ 2. 성적을 입력 받아서 합계를 구하고 성적의 개수를 센다.  3. 평균을 계산하고 화면에 출력한다. 
① sum을 0으로 초기화한다.  1. 필요한 변수들을 초기화한다. ⇨
② n을 0으로 초기화한다.
③ grade를 0으로 초기화한다. 
- while 성적이 0보다 작지 않으면 

2. 성적을 입력 받아서 합계를 
① 사용자로부터 성적을 읽어서 grade에 저장한다.  ⇨ 구하고 성적의 개수를 센다.
② sum에 이 점수를 누적한다. 
③ n을 하나 증가한다. 

3. 평균을 계산하고 
① sum을 n으로 나누어서 average에 저장한다.  ⇨ 화면에 출력한다.
② average를 화면에 출력한다.   C언어  I  ▶ 센티널 예제

1) while 문을 이용한 성적의 평균 구하기 프로그램  ▶ if 문과 while 문의 비교
- if문은 while 문으로 변경할 수 있음.
- while 문도 if문으로 변경할 수 있음.  C언어  I  ▶ while 문에서 주의할 점 ▶ do
-while 문  C언어  I  ▶ 예제

1) do
-while 문을 이용한 메뉴  ▶ 글자 게임 예제  C언어  I  ▶ for 루프
- 정해진 횟수만큼 반복하는 구조 ▶ for 문의 구조 ▶ for 문의 예  C언어  I  ▶ for문의 실행 과정 반복 횟수 i의 값 i<10 반복 여부 1번째 반복 0 참 반복 2번째 반복 1 참 반복 3번째 반복 2 참 반복 4번째 반복 3 참 반복 5번째 반복 4 참 반복 6번째 반복 5 참 반복 7번째 반복 6 참 반복 8번째 반복 7 참 반복 9번째 반복 8 참 반복 10번째 반복 9 참 반복 11번째 반복 10 거짓 중지  C언어  I  ▶ 예제

1) 반복을 이용한 정수합 프로그램
2) 반복을 이용한 네모 그리기
3) 반복을 이용한 팩토리얼 구하기   C언어  I  ▶ while 루프와 for 루프와의 관계 ▶ 다양한 증감수식의 형태  C언어  I  4. 내포된 반복 구조에 대한 이해 ▶ 중첩 반복문(nested loop)
- 반복문 안에 다른 반복문이 위치 ▶ 예제

1) 중첩 for 문을 이용하여 *기호를 사각형 모양으로 출력하는 프로그램   C언어  I  ▶ 반복 제어 구조의 종류와 선택 종류 선택형 설명 사용되는 구문 수행 전 반복횟수  ­ 반복할 횟수를 미리 알고 있는 형 while문 계수 반복 미리 결정 태에서 사용 for문 감시 ­ 특수한  값으로  끝나는  임의의  길 while문 이벤트형 제어 반복과정에서  이를 가진 자료를 얻어올 때 사용 for문 반복 파일 반복횟수 결정 ­ 임의의  크기의  파일을  읽어오기  while문 제어 위해 사용 for문 ­ 적정범위내의  값이  입력되는지를  입력 검사하여  입력처리를  반복하는  대 do
-while문 이벤트형 검증 반복과정에서  화형 형태에서 사용 반복 반복횟수 결정 일반 ­ 요구조건이  만족할  때까지  실행을  while문 조건 반복할 때 사용 for문  C언어  I  기타 분기 제어 구조 수업목표   1. 분기 제어 구조를 이해한다.  6주차  2교시 
① 분기 제어문의 종류와 특징, 문법(break, continue, goto 구문) 세부내용 
② 기타 분기 제어 구조 익히기
③ 반복 구조 활용 및 응용 1. 분기 제어문의 종류와 특징, 문법 ▶ 학습 개요 ­ 분기 제어문의 종류 : break 문, continue 문, goto 문 ▶ break문 ­ 반복 구조에서 해당 반복 블록을 빠져 나올 때 사용 ­ break  문은 단지 해당되는 하나의 블록만을 빠져 나오므로 다중  블록을 포함하는 경우 중 첩된 수만큼의 break문 요구 v 사용 예 ­ 반복루프를 빠져 나오는데 사용됨.  C언어  I  ▶ 예제 ▶ continue문
- 반복구조에서 사용되며 반복 제어의 시작으로 위치를 이동시키는 역할
- break문이  해당  블록을  빠져  나오는데  사용되는데  반해  continue문은  반복  구조에서  continue문 이후를 수행하지 않고 다음 반복을 수행함. v 사용 예  C언어  I  ­ 현재의 반복을 중단하고 다음 반복을 시작하게 함. ▶ 예제 ▶ goto 문 ­ 무조건적인 분기 명령 v 사용 형식
- goto문은 [레이블 이름]과 쌍으로 만들어짐.
- 문장에서 goto문을 만나면 해당 레이블로 무조건 분기
- 하나의 함수 내부에서만 이동 가능
- 다중 블록을 모두 빠져 나와야 할 경우 자주 이용
- 기타 상황에서는 자수 이용되지 않음.  C언어  I  ­ 조건 없이 어떤 위치로 점프 ­ 사용하지 않는 것이 좋음. ▶ 예제 ▶ 중첩 반복의 경우에는 goto로 탈출  C언어  I  2. 기타 분기 제어 구조 익히기 ▶ [기초다지기] 기타 분기 제어 구조 익히기

1) continue와 break문의 활용 예를 익히자. v 분석
- while 문의 반복과 while문 안의 문장의 반복 횟수 얻기
- 초기 조건 if(i % 2 == 0) 문장에서 i값을 2로 나누어 0이 되면(짝수일 경우) continue문 을 통해 아래의 문장을 수행하지 않고 while문의 처음으로 이동
- 홀수인 경우 아래의 문장을 반복 수행하고 i값이 100을 넘으면(101일 때) break문을 통해  이 while문을 종료
- while_  count는  1에서  101까지  101번  수행되고  all_count는  1에서  101까지  홀수일  때  반복되어 총 51번의 반복 

2) goto 문의 구조에 대해 이해하자. v 분석
- goto 문을 통해 반복 구조
- 첫 번째 if문에 의해 3의 배수 값들을 누적
- 두 번째 if문에서 i<100 즉 100보다 작을 동안 loop 레이블로 분기
- 결국 1에서 100까지의 3의 배수의 합을 구할 수 있음.  C언어  I  3. 반복 구조 활용 및 응용 ▶ 반복 구조 활용

1) 자동차 오일 주입일 계산 프로그램
① 문제 정의
- 자동차  오일을  주입한  후  얼마  후에  다시  오일을  주유해야  하는지를  판단하는  프로그램이 다.  사용자는  초기  오일  주입량을  입력하면  3일단위로  오일  소비량,  주행  거리,  그리고  오 일 주입 요청 여부를 알려주고 최초의 오일 주입 요청날짜를 다음 오일 주입일로 출력한다. 입력 조건 ­ 자동차 오일 주입량(단위 : 리터) ­ 3일  단위로  현재의  날짜,  잔여  오일량,  주행거리,  오일  보충  여부  표시,  출력 조건 다음 오일 주입 일자(최초 오일 보충일)
② 출력 예
③ 알고리즘(플로우차트)  C언어  I 

2) 프로그램 작성 1단계 다음 페이지의 프로그램을 작성한 후 oil.c이름으로 저장하자. 정상적으로  컴파일이  완료된  후  다음과  같은  입력에  대한  출력  결과를  작성해  보자.  2단계
Ÿ 입력값 : 45리터 
Ÿ 입력값 : 345리터  C언어  I 

3) 자릿수 지정자
- printf()함수에서  사용되는  형식  지정자 문자를  확장하여  출력  형식 지정(최소 필드 자릿수  지정)
① 형식
- %[
-][최소필드의 크기][.][소숫점 이하 자릿수] 형식지정자 타입 
② 설명
- []에 포함된 내용은 생략 가능함. 
- 모든 수치데이터는 우측 정렬되어 출력되나 
- 부호를 적을 경우 좌측 정렬됨.
- 정수형 형식 지정자는 소숫점 이하 자릿수를 가지지 않음. 
- 실수값의 소숫점 이하 자릿수 값은 자동적으로 반올림됨. 
- 출력될  값이  최소  필드의  크기보다  작을  경우  남은  경우  공백으로  채워지고  클  경우  자동 적으로 출력될 값의 크기로 확장됨. 
- 실수형 형식 지정자에 대해 소숫점이하 자릿수를 부여할 수 있음. 
- 최소필드 크기값을 0으로 시작할 경우 남은 자릿수는 0으로 채워짐.
③ 사용 예 ▶ 반복 구조 응용

1) 두 수의 최대공약수 계산 프로그램
① 문제 정의
- 두 정수의 최대 공약수를 계산하는 프로그램을 작성하시오. 이 최대 공약수는 두 정수의 공 통요소의 곱으로 나타낸다. 아래에 제시된 알고리즘을 이용하여 프로그램을 완성해 보시오. 입력 조건 ­ 최대 공약수 계산에 사용되는 두 정수 값 출력 조건 ­ 두 정수의 최대 공약수
② 관련 함수 및 식
- 최대 공약수 = 두 정수의 공통요소의 곱   C언어  I 
③ 알고리즘(또는 플로우차트)
- 두  수  중  하나를  다른  하나로  나누고  나머지를  얻어온다.  나머지가  0일  경우  나누었던  수 가 최대 공약수가 된다. 
- 나머지가  0이  아닐  경우  나머지를  이용해  이전단계에  사용한  제수를  피제수로  하여  나눈 다. 나머지가 0이면 그 제수가 최대공약수 이고 그렇지 않을 경우 2단계를 반복한다. 
- 최종 나눗셈의 나머지가 0일 때 그 제수가 최대공약수가 된다.
④ 적용 예

2) 프로그램 작성 1단계 다음 프로그램을 작성하자. 정상적으로 컴파일될 때 아래의 값을 입력으로 하여 출력 결과를 작성하자.
Ÿ 입력 조건 2단계
- 입력된 두 수 : 235,435
- 입력된 두 수 : 234, 292  C언어  I  배열의 기본 개념 1. 배열의 의미와 특징에 대해 이해한다.  수업목표   2. 배열의 초기화 및 입력방법을 이해한다.  7주차  3. 다차원 배열과 활용에 대해 이해한다.  1교시 
① 배열의 개념  세부내용 
② 배열의 선언과 초기화 방법
③ 다차원 배열의 개념과 의미(2차원, 3차원 배열의 구조) 1. 배열의 개념 ▶ 배열의 필요성 ­ 학생이 10명이 있고 이들의 평균 성적을 계산한다고 가정하자.  C언어  I  ▶ 배열의 개념

1) 배열이란?
- 배열(array) : 동일한 타입의 데이터가 여러 개 저장되어 있는 데이터 저장 장소
- 배열 안에 들어있는 각각의 데이터들은 정수로 되어 있는 번호(인덱스)에 의하여 접근
- 배열을 이용하면 여러 개의 값을 하나의 이름으로 처리할 수 있음. 2. 배열의 선언과 초기화 방법 ▶ 배열의 선언 자료형 ­ 배열 원소들이 int형이라는 것을 의미 배열 이름 ­ 배열을 사용할 때 사용하는 이름이 grade 배열 크기 ­ 배열 원소의 개수가 10개 ­ 인덱스(첨자)는 항상 0부터 시작함. ▶ 배열 원소 접근  C언어  I  ▶ 배열 선언 예제  C언어  I  ▶ 잘못된 인덱스 문제 ­ 인덱스가 배열의 크기를 벗어나게 되면 프로그램에 치명적인 오류를 발생시킴. ­ C에서는 프로그래머가 인덱스가 범위를 벗어나지 않았는지를 확인하고 책임을 져야 함.  ▶ 잘못된 인덱스 예제  C언어  I  ▶ 배열의 초기화

1) int grade[5] = { 10,20,30,40,50 };
2) int grade[5] = { 10,20,30 };
3) 배열의 크기가 주어지지 않으면 자동적으로 초기값의 개수 만큼이 배열의 크기로 잡힘. ▶ 배열 초기화 예제  C언어  I  ▶ 배열 원소의 개수 계산  C언어  I  ▶ 예제 ▶ 최솟값 탐색  C언어  I  ▶ 빈도 계산 3. 다차원 배열의 개념과 의미 ▶ 2차원 배열  C언어  I  ▶ 2차원 배열의 활용 ▶ 2차원 배열의 초기화  C언어  I  ▶ 다차원 배열 예제  C언어  I  ▶ 다차원 배열을 이용한 행렬의 표현 ▶ 다차원 배열의 이해
1) 다차원 배열의 개념
- 2차원 이상의 배열 (첨자가 두 개 이상인 배열)
- C언어는 7차원 정도의 배열을 지원하지만 보통 3차원 정도를 이용해 프로그래밍함.
- 차원이 복잡할수록 프로그램의 이해가 어려움.
- 첨자의 수에 따라 차원이 결정 Ÿ 첨자 2개 : 2차원 배열
Ÿ 첨자 3개 : 3차원 배열  C언어  I 

2) 3차원 배열의 사용
- 2차원 배열에 면의 개념을 포함시켜 표현됨.
- 면, 행, 열의 개념으로 3개의 첨자로 표현
- 선언, 논리적 표현 그리고 메모리 구조 관계

3) 3차원 배열의 초기화
- 3차원 배열의 초기화 역시 2차원 배열의 초기화 과정과 유사
- 초기화 시 생략 가능한 첨자는 면에 대한 첨자임. v 사용 예
- static int data[][2][3]={1,2,3,4,5,6,7,8,9};
- 0면에 2행 3열의 6개 값이 채워지고1면에 나머지 값이 채워짐.
- 결국 이 문장은 data[2][2][3]의 3차원 배열을 가짐.  C언어  I  문자열 관련 함수들 수업목표   1. 문자열에 대해 이해한다.  7주차 
① 문자표현방법 2교시 
② 문자 배열의 초기화 세부내용 
③ 다차원 배열의 이해
④ 문자열 관련 함수들 1. 문자표현 방법 ▶ 문자표현 방법 ­ 컴퓨터에서는 각각의 문자에 숫자코드를 붙여서 표시함.  v 아스키코드(ASCII code) : 표준적인 8비트 문자코드
- 0에서 127까지의 숫자를 이용하여 문자표현 v 유니코드(unicode) : 표준적인 16비트 문자코드
- 전 세계의 모든 문자를 일관되게 표현하고 다룰 수 있도록 설계

1) 아스키코드  C언어  I 
2) 유니코드 ▶ 문자 변수와 문자 상수  C언어  I  ▶ 아스키 코드 출력 ▶ 문자열 표현 방법
1) 문자열(string) : 문자들이 여러 개 모인 것
- "A"
- "Hello World!” ▶ 문자열 상수와 변수 ­ 변경되지 않는 문자열을 저장 문자열 상수 ­ (예) “Hello World ” ­ 변경되는 문자열을 저장 문자열 변수 ­ (예) char str[100];  C언어  I  ▶ NULL 문자

1) 문자열의 끝을 나타냄. v 문자열의 끝에는 항상 NULL 문자가 들어가야 한다.
2) 왜 NULL 문자가 필요한가?
- 문자열은 어디서 종료되는지 알 수가 없으므로 표시를 해주어야 함. v NULL 문자의 필요성 : 정상적인 데이터와 쓰레기값을 분리하기 위해서이다.  C언어  I  2. 문자 배열의 초기화 ▶ 문자 배열의 초기화

1) 문자 배열 원소들을 중괄호 안에 넣어주는 방법.
2) 문자열 상수를 사용하여 초기화하는 방법 ­ 만약 배열을 크기를 지정하지 않으면  컴파일러가 자동으로 배열의 크기를 초기화값에 맞추어 설정 ▶ 예제 #1 ▶ 예제 #2  C언어  I  ▶ 예제 #3 3. 다차원 배열의 이해 ▶ 다차원 배열의 이해
1) 다차원 문자열
- 문자열을 배열로 가진 형태
- 문자열 배열은 문자열 자체가 문자 배열의 형태를 가지므로 2차원 배열 형태를 가짐.
- 문자열 배열은 주로 메뉴를 구성하는 많이 이용됨. v 사용 예
- static char txt[3][10];
- 9자 크기의 문자열에 대한 3개의 문자배열 선언
① 문자열 배열의 초기화
- static char txt[3][8] = {"New","Open","Save As"};
- 메모리 구조  C언어  I  4. 문자열 관련 함수들 ▶ 문자열 함수의 사용

1) 문자열 함수의 종류
- 문자열 비교, 길이 구하기, 문자열 복사, 두 문자열 연결, 문자열의 값 반환

2) 문자열 관련 함수는 모두 string.h 헤더파일에 포함되어 있음.
3) 문자열  함수를  사용하기  위해서는  이  스트링  관련  헤더  파일을  프로그램에  다음과  같이  선언해야 함. ▶ 문자열 관련 함수들
1) 두 문자열 비교 함수(strcmp, strncmp)
- ASCII 코드 값에 의해 두 문자열의 크기를 비교함.  v 사용 예 ▶ 문자열 비교 반환 값 s1과 s2의 관계
>0 s1이 s2보다 뒤에 있다. 0 s1이 s2와 같다. <0 s1이 s2보다 앞에 있다.  C언어  I  ▶ 문자열 관련 함수들

1) 두 문자열 비교 함수(strcmp, strncmp)
2) 문자열 길이  C언어  I 
3) 문자열의 길이 얻기 (strlen)
- 문자열의 크기를 얻어옴.
① 형식  
② 사용 예

4) 문자열의 처리 (strcpy, strcat, strlwr, strupr)
- 문자열 처리는 문자열 복사, 연결, 대소문자 변환 함수를 포함
① strcpy 함수
- 문자열 복사 
- 한 문자열을 다른 문자열로 복사
- 형식 : strcpy(str1,str2) Ÿ str2의 문자열을 str1에 복사함. 
Ÿ str1은 str2의 공간보다 크거나 같아야 함. 그렇지 않을 경우 잘림 현상
② stncpy 함수
- strcpy함수와 동일하지만 복사할 문자열의 크기를 지정할 수 있음.
- 형식 : strncpy(str1,str2,n) Ÿ str2의 n개의 문자를 복사하여 str1에 저장

5) 문자열 복사  C언어  I 
6) strcpy 사용시 주의점 ­ strcpy()에서는 두 번째 인수를 첫 번째 인수로 복사합니다. 방향에 주의하세요!
7) 문자열의 처리
① strcpy와 strncpy 사용 예
② strcat 함수
- 두 문자열을 하나의 문자열로 결합
- 형식 : strcat(str1,str2) Ÿ str1에 str2의 문자열을 결합함.
Ÿ str1은 두 문자열이 결합된 크기보다 커야 함.
③ strncat 함수
- 결합할 문자열의 크기를 지정할 수 있음.
- 형식 : strncat(str1,str2,n) Ÿ str2의 n의 크기만 str1에 결합함.  C언어  I 
④ 문자열 연결
⑤ strcat와 strncat 함수 활용 예

8) 문자열의 처리 : 대소문자 변환 함수 (strlwr, strupr)
① strlwr 함수
- 문자열을 소문자로 변환하고 이때의 주소를 반환
- 문자열 포인터 변수 = strlwr(문자열)
② strupr 함수
- 문자열을 대문자로 변환하고 이때의 주소를 반환
- 문자열 포인터 변수 = strupr(문자열)   C언어  I 
③ 사용 예

9) 문자열의 처리 : 기타 문자열의 처리 함수
① strrev 함수
- 문자열을 역순으로 변환하는 함수
- 형식 : 문자열 변수 = strrev(문자열) // 해당 문자열을 역순으로 반환
② strset 함수
- 문자 상수로 문자열 변수를 모두 채움.
- 형식 : strset(문자열 변수, 문자 상수)
③ 사용 예

10) 문자열 검색 (strstr)
- 특정 문자열에서 해당 문자열을 포함하고 있는 최초의 위치를 반환함.
① 사용형태
- 문자열 포인터 변수 = strstr(str1,str);
- str1의 문자열에서 str2의 문자열을 포함하는 최초의 위치를 문자열 포인터 변수에 전달함.
② 사용 예  C언어  I  ▶ 문자검색, 문자열 검색

1) 문자열에서 문자 검색
2) 문자열에서 문자열 검색 ▶ [기초 다지기] 문자열 함수 이용하기
1) 문자열 비교, 검색, 결합 등을 이용한 문자열 처리  C언어  I  ▶ 한영 사전 구현  C언어  I  포인터의 개념 1. 포인터의 개념을 이해한다.  수업목표   9주차  2. 배열과 포인터의 관계를 이해한다. 1교시 
① 포인터의 의미와 활용 방법 세부내용 
② 주소 관련 연산자
③ 다중 포인터의 개념 1. 포인터의 의미와 활용 방법 ▶ 포인터의 개념

1) 포인터란?
- 포인터(pointer) : 주소를 가지고 있는 변수 Ÿ 포인터는 메모리의 주소를 가진 변수입니다.  포인터를 이용하여 메모리의 내용에 직접 접근할 수 있습니다. ▶ 메모리의 구조 ­ 변수는 메모리에 저장됨. ­ 메모리는 바이트 단위로 액세스됨.
Ÿ 첫 번째 바이트의 주소는 0, 두 번째 바이트는 1,… ▶ 변수와 메모리 ­ 변수의 크기에 따라서 차지하는 메모리 공간이 달라짐. ­ Char형 변수 : 1바이트 ­ int형 변수 : 4바이트  C언어  I  ▶ 변수의 주소 ­ 변수의 주소를 계산하는 연산자 :& ­ 변수 I의 주소 : &i ▶ 포인터의 개념

1) 포인터의 개요
- 데이터 값의 위치를 나타내는 메모리 주소를 저장하기 위해 사용되는 특별한 변수 일반 변수 ­ 특정 공간의 메모리 주소에 할당되고 변수 이름을 통해 접근 ­ 특정 공간의 메모리 주소를 저장하는 변수 포인터 ­ 포인터 변수를 통해 메모리 주소의 조작이 가능 ▶ 변수의 주소 ▶ 포인터의 선언
- 포인터 : 변수의 주소를 가지고 있는 변수  C언어  I  ▶ 다양한 포인터의 선언 ▶ 간접 참조 연산자

1) 간접 참조 연산자 * : 포인터가 가리키는 값을 가져오는 연산자
2) 간접 참조 연산자의 해석 
- 간접 참조 연산자 : 지정된 위치에서 포인터의 타입에 따라 값을 읽어 들임.
- *p하면 p가 가리키는 위치에서 4바이트를 읽어 옴.  C언어  I  ▶ 포인터의 개념 정리

1) 포인터 변수의 선언
- 포인터 변수를 사용하기 위해 먼저 선언되어야 함.
① 선언 방법 : [데이터 형] *[포인터변수명];
- 데이터 형 : 저장된 주소가 가리키는 공간에 저장된 데이터 형
- 포인터 변수명 : 주소를 저장할 공간의 이름
- 사용 예 : int *px; 2. 주소 관련 연산자 ▶ 주소 관련 연산자

1) 포인터 변수의 활용
- 어떻게 값이 저장된 변수의 주소를 얻어올 수 있는가? Ÿ 주소 연산자(&)
Ÿ 변수의 주소 값을 얻어오는 연산자
- 어떻게 포인터 변수가 가리키고 있는 주소의 실제 값을 얻어올 수 있는가? Ÿ 간접 지정 연산자(*)
Ÿ 포인터 변수가 가리키는 위치의 값을 얻어오는 연산자

2) 포인터에서 사용되는 “*”의 의미 선언 시의 “*” ­ 변수가 포인터 변수라는 것을 알려줌. 활용 시의 “*” ­ 간접 지정 연산자의 역할  C언어  I  ▶ 포인터 변수 활용 예 ▶ 사용되는 메모리 구조 ▶ 포인터 예제 #1  C언어  I  ▶ 포인터 예제 #2 ▶ 포인터 예제 #3 ▶ 포인터 사용 시 주의점 ­ 초기화가 안 된 포인터를 사용하면 안 됨.  C언어  I 
- 포인터가 아무것도 가리키고 있지 않는 경우에는 NULL로 초기화
- NULL 포인터를 가지고 간접 참조하면 하드웨어로 감지할 수 있음. 
- 포인터의 유효성 여부 판단이 쉬움. Ÿ 포인터가  아무  것도  가리키지  않을  때는  반드시 NULL로 설정하세요.
- 포인터의 타입과 변수의 타입은 일치하여야 함. Ÿ 아무래도 데이터가 너무 커서 
Ÿ 옆의 데이터가 다칠 것 같군. 3. 다중 포인터의 개념 ▶ 다중 포인터

1) 다중 포인터
- 포인터에 대한 포인터
- 포인터가 다른 포인터의 주소를 가리키는 구조
- 이론적으로  여러  개의  포인터들이  서로  연결될  수  있지만  주로  두  개의  포인터로  구성된  이중 포인터 형식이 많이 사용됨.  C언어  I 

2) 이중 포인터에 대한 선언
- 형식 : [데이터 형] **[포인터 변수명]; ▶ 이중 포인터의 활용 예

1) 이중 포인터의 활용 예
2) x와 *px 그리고 **ppx의 관계
3) 출력 결과  C언어  I  ▶ [기초다지기] 포인터 개념 익히기 
1) 포인터 변수와 주소지정 연산자 이용하기 v 분석
- 문자형 변수 c나 정수형 변수 value의 주소는 & 연산자를 통해 얻음.
- 변수의 주소값 : cp = &c와 ip = &value
- cp와 ip는 변수의 형에 대한 포인터 변수로 char *cp 그리고 int *ip로 선언
- printf 함수에서 포인터 변수의 주소 출력 : %X(16진수 표기)
- printf 함수에서 사용되는 *cp에서 * ⇨ 간접 지정 연산자로 cp주소가 가리키고 있는 값을  가져옴 .  C언어  I 

2) 이중 포인터 활용하기 v 분석
1) 이중 포인터  ­ 포인터 변수에 대한 주소를 가진 변수 ­ 포인터에 대한 포인터로 인식
2) 프로그램은 4개의 수 중 가장 큰 수를 포인터를 이용하여 얻어옴.
3) 일반변수 i,j,x,y, 포인터 변수 ip, xp, 이중 포인터 변수 ipp 선언
4) 처리과정
- 첫 번째 scanf를 통해 두 수를 입력 받아 큰 값을 가진 변수의 주소를 ip에 할당
- 두 번째 scanf에서도 두 개의 변수를 입력 받고 큰 수를 가진 변수의 주소를 xp에 저장
- 그  다음  if문을 통해  ip가  가리키는  값(*ip)와  xp가  가리키는  값(*xp)를  비교하여 큰 값을  가리키고 있는 포인터 변수를 ipp에 저장
- 마지막으로  printf함수에서  두개의  간접지정  연산자(**ipp)를  통해  ipp가  가리키는  주소의  포인터 변수가 가리키는 값 출력   C언어  I  배열과 포인터 그리고 연산자

1. 포인터를 이용한 주소 계산과 활용 방법과 동적 메모리 할당과  수업목표   사용법을 이해한다. 
2. 포인터 활용 연산자에 대해 이해한다.  9주차 
① 포인터 조작 연산자 2교시 
② 배열과 포인터 세부내용 
③ 이차원 배열과 포인터의 관계
④ 문자열 배열과 포인터
⑤ 메모리 동적 할당 함수 1. 포인터 조작 연산자 ▶ 포인터 조작 연산자

1) 포인터의 사용 목적 : 주소 조작을 보다 편리하기 사용하기 위해
2) 포인터 조작 연산자
- 포인터 변수를 대상으로 수행되며 주소 값의 변화를 제공
- 주소에 대한 덧셈과 뺄셈 연산만이 사용 가능함.
- 포인터 값의 1 증가는 실제 데이터 타입의 크기만큼 증가가 이루어짐.

3) 연산자 종류와 사용형태 그리고 메모리와의 관계 메모리 주소(P값 100번지라고 가정) 연산자 설명 사용 예 char(1) short(2) int(4) double(8) + 덧셈 p=p+2 102(p+1*2) 104(p+2*2) 108(p+4*2) 116(p+8*2)
- 뺄셈 p=p
-1 98 96 92 84 ++ 1증가 p++, ++p 101 102 104 108
-
- 1감소 p
-
-, 
-
-p 99 98 96 92 ▶ 포인터 연산 ­ 가능한 연산  증가, 감소, 덧셈, 뺄셈 연산 ­ 증가 연산의 경우 증가되는 값은 포인터가 가리키는 객체의 크기 포인터 타임 ++연산 후 증가되는 값 char 1 short 2 int 4 float 4 double 8 v 포인터를 증가시키면 가리키는 대상의 크기만큼 증가합니다.  C언어  I  ▶ 증가 연산 예제 ▶ 포인터의 증감 연산  C언어  I  ▶ 간접 참조 연산자와 증감 연산자 수식 의미 V=*p++ ­ P가 가리키는 값을 v에 대입한 후에 p를 증가함. V=(*P)++ ­ P가 가리키는 값을 v에 대입한 후에 가리키는 값을 증가함. v=*++P ­ P를 증가시킨 후에 P가 가리키는 값을 V에 대입함. v=++*p ­ P가 가리키는 값을 가져온 후에 그 값을 증가하여 V에 대입함. 2. 배열과 포인터 ▶ 포인터 조작 연산자 사용 예 v 포인터 변수와  배열의 메모리 관계  C언어  I  ▶ 배열과 포인터 ­ 배열과  포인터는  서로  밀접한  연관관계를  가지고  있기  때문에  필요에  따라  이들을  교환하 여 사용할 수 있음.

1) 배열
- 동일한 유형의 데이터들이 기억장소에 순차적으로 저장된 형태
- 배열의 대표 명은 배열의 시작 주소

2) 배열에 대한 포인터 변수 할당 예
3) 메모리 구조  C언어  I   C언어  I  3. 이차원 배열과 포인터의 관계 ▶ 이차원 배열과 포인터
1) 프로그램에 대한 메모리 구조
- p = data; 일 경우 포인터 변수 p와 data의 관계 p == data == data[0] == &data[0][0] == 1940번지 Ÿ 이차원 배열은 행렬로 표현되며 포인터 변수를 통해 조작 가능

2) 활용 예  C언어  I  4. 문자열 배열과 포인터 ▶ 문자열 배열과 포인터 ­ 문자열 배열 역시 포이너를 통해 조작 가능함.
1) 사용 예 v 변수들의 메모리 관계 ▶ 포인터 배열 ­ 포인터 변수를 배열로써 관리 ­ 포인터 변수들을 집단으로 관리하는 상황에서 자주 사용됨. ­ 문자열 배열 관리를 위해 주로 이용됨.
1) 문자열 배열의 사용 예 v 메모리 구조
- 문자열을 가리키는 주소를 저장하는 1차원 배열
- 각각의 배열 요소는 독립적인 공간을 가진 문자열 주소를 저장
- 문자열 배열에 비해 메모리 낭비를 줄임.  C언어  I  ▶ [기초다지기] 배열과 포인터 관계 이해 

1) 1차원 배열과 포인터 관계
2) 이차원 배열과 포인터 활용   C언어  I 
3) 포인터 배열에 대한 이해 5. 메모리 동적 할당 함수 ▶ 메모리 동적 할당 함수 개요
1) 주기억 장치 구조
① 정적인 데이터 정보 저장 공간(Data) ­ 전역 변수나 정적 변수 등의 저장 공간 ­ 프로그램 수행 시 항상 존재하는 변수 저장
② 임시데이터 정보저장 공간(Stack) ­ 지역변수 ­ 프로그램 수행 도중 임시적으로 발생되는 변수 저장 공간

2) 메모리 동적 할당
- 실행 도중 메모리 공간을 할당하여 사용
- 힙(Heap) 영역을 이용한 메모리 할당

3) 동적메모리 할당 관련 함수 헤더파일
- 동적 메모리 관련 함수 정보
- #include <stdlib.h>  C언어  I  ▶ calloc 함수

1) calloc 함수
- 배열을 저장할 크기의 기억 장소를 할당하고 할당된 주소를 리턴함. (0으로 비트 초기화)
① 함수의 원형
- size_t 타입 :unsigned int 타입을 재정의 
- num : 생성할 배열의 수
- size : 요소의 크기
- 반환 결과 : 정상적일 경우 할당된 주소 비정상적인 경우 NULL

2) calloc 함수 활용 예  C언어  I  ▶ malloc 함수
1) malloc 함수 ­ 하나의 데이터 크기에 대한 기억장소 할당
① 함수의 원형
- size : 데이터의 크기

2) 사용 예 ▶ calloc와 malloc 관계 ­ 둘 다 메모리의 공간을 할당하는 함수 ­ 인자의 형태가 다름.
Ÿ calloc 함수 : 배열형 할당
Ÿ malloc 함수 : 데이터형 할당 ­ 인자의 형태가 다르지만 메모리 공간 할당 행위는 동일함. ­ malloc 함수를 이용해 calloc 함수와 동일한 공간을 할당 가능함.
Ÿ p1 = (int *) calloc(10,sizeof(int));
Ÿ p2 = (int *) malloc(sizeof(int)*10); ­ p1과 p2는 둘 다 정수형 10개의 배열 공간을 할당하고 있음.  C언어  I  ▶ 기타 함수

1) free 함수
- 할당된 메모리 공간 해제 함수
- 동적  메모리를  통해  할당된  기억공간은  더  이상  사용하지  않을  경우  반드시  그  메모리  공 간을 해제하여 주어야 함.
- 기억 공간이 해제 후 다른 프로그램에서 이 공간을 사용할 수 있음.
① 함수의 원형
- 이전 calloc나 malloc을 통해 할당 받은 주소를 free 함수에 전달
② 사용 예

2) realloc 함수
- 이미 할당된 메모리 공간을 늘리거나 줄일 경우에 사용
- 기존에 존재하는 데이터는 보존
① 함수의 원형
- ptr : 이전에 할당된 메모리 주소
- size : 새롭게 할당할 메모리 크기
② 사용 예  C언어  I  ▶ [기초다지기] 메모리와 동적 할당 함수 

1) calloc 함수 활용하기 
2) malloc와 realloc 함수 활용   C언어  I  함수의 기본 개념 이해
1. 함수의 정의 및 선언 그리고 함수 프로토타입(원형)에 대해  수업목표   이해한다.  10주차 
2. 함수들 간의 매개변수 전달 방법을 이해한다.  1교시 
① 함수의 의미와 구조
② 함수 호출과 반환, 인수와 매개 변수, 반환값 세부내용 
③ 함수 원형
④ 함수의 기본 개념 1. 함수의 의미와 구조 ▶ 함수가 필요한 이유 ­ 같은 작업이 되풀이되는 경우 ▶ 함수가 있다면 ­ 함수는 한 번 작성되면 여러 번 사용(호출)이 가능함.  C언어  I  ▶ 모듈의 개념

1) 모듈(module) : 독립되어 있는 프로그램의 일부분
2) 모듈러 프로그래밍 : 모듈 개념을 사용하는 프로그래밍 기법
3) 모듈러 프로그래밍의 장점
- 각 모듈들은 독자적으로 개발 가능
- 다른 모듈과 독립적으로 변경 가능
- 유지 보수가 쉬워짐.
- 모듈의 재사용 가능

4) C에서는 모듈==함수 ▶ 함수의 개념 ­ 함수(function) : 특정한 작업을 수행하는 독립적인 부분 ­ 함수 호출(function call) : 함수를 호출하여 사용하는 것 ­ 함수는 입력을 받으며 출력을 생성함.
Ÿ 함수는 이름을 가지며 입력을 받아서 특정한 작업을 실행하고 결과를 반환합니다. ▶ 함수들의 연결
- 프로그램은 여러 개의 함수들로 이루어짐.
- 함수 호출을 통하여 서로 서로 연결됨.
- 제일 먼저 호출되는 함수 : main( ) Ÿ 각 함수들은 함수 호출을 통해서 서로 결합되어 프로그램을 구성합니다.  C언어  I  ▶ 함수의 종류 ▶ 함수의 정의 ­ 반환형(return type), 함수 헤더(function header), 함수 몸체(function body) ▶ 사용자 정의 함수의 정의와 사용

1) 함수의 형식 ❶ 결과 반환 데이터형 : 함수 처리 후 결과 반환 데이터 형 ❷ 함수의 이름 : 사용자 정의 함수 이름 ❸ 매개변수 리스트 : 호출 시 전달되는 변수 이름 ❹ 함수 내부 지역 변수 선언 : 함수 내부 변수 ❺ 함수 실행 문장들  ❻ return [결과데이터] : 처리 결과 전달 문   C언어  I  ▶ 함수의 구조 ▶ 반환형 ­ 함수 이름 앞에 반환하는 데이터의 유형을 표시함.  ­ char, int, long, double … 등이 가능함. ­ 반환형이 없으면 void로 표시 ▶ 함수 이름
- 일반적으로 동사+명사 v 예 Ÿ compute_average() 
Ÿ get_integer()
Ÿ set_speed() ▶ 매개 변수(parameter)
- 함수가 외부로부터 전달받는 데이터를 가지고 있는 변수  C언어  I  ▶ 지역 변수(local variable)
- 함수 안에서 정의되는 변수 ▶ 함수 정의 예제 ­ 함수를 프로그램을 이루는 부품이라고 가정하자. ­ 입력을 받아서 작업한 수에 결과를 생성함.

1) 예제 #1
- 정수의 제곱값을 계산하는 함수  C언어  I 

2) 예제#2
- 두 개의 정수 중에서 큰 수를 계산하는 함수

3) 예제 #3
- 정수의 거듭 제곱값(xy)을 계산하는 함수  C언어  I  ▶ 함수 정의 예제 : 함수의 사용

1) 함수의 사용
- 함수의 이름을 호출하고 매개변수를 전달하는 과정으로 이루어짐.

2) 함수를 포함한 프로그램 구조
- 함수의  원형의  선언은  컴파일러에게  함수의 원형 함수의 사용을 알려줌.
- 함수의 이름을 이용해 함수를 호출 함수의 호출
- 매개변수 존재할 경우 매개 변수 전달 함수의 정의
- 함수의 구현부로 실제 처리 담당 2. 함수 호출과 반환, 인수와 매개 변수, 반환값 ▶ 함수 호출과 반환

1) 함수 호출(function call)
- 프로그램 함수를 사용하기 위하여 함수의 이름을 적어주는 것
- 함수 안의 문장들이 순차적으로 실행됨.
- 문장의 실행이 끝나면 호출한 위치로 되돌아감.
- 결과값을 전달할 수 있음.  C언어  I  ▶ 반환값(return value)
- 호출된 함수가 호출한 곳으로 작업의 결과값을 전달하는 것
- 인수는 여러 개가 가능하나 반환값은 하나만 가능 ▶ 값을 반환하는 문장

1) return 문장을 사용하여서 값을 반환함.
2) return 문장의 사용 예  3. 함수 원형 ▶ 함수 원형
1) 함수 원형(function prototyping) : 컴파일러에게 함수에 대하여 미리 알리는 것  C언어  I 
2) 예제  C언어  I 
3) 함수 원형(function prototyping) : 컴파일러에게 함수에 대하여 미리 알리는 것
4) 함수원형 예제  C언어  I  ▶ 함수 원형을 사용하지 않으려면 ­ 함수가 미리 정의되면 됨.  그러나 특수한 경우에는 이것이 불가능함. 따라서 함수 원형을 사용하는 것이 바람직함.  ▶ 함수 원형을 사용하지 않는 예제 ▶ 함수 원형과 헤더 파일 ­ 보통은 헤더 파일에 함수 원형이 선언되어 있음.  C언어  I  4. 함수의 기본 개념 ▶ 함수의 기본 개념 이해
1) 함수 간의 데이터 전달 방법
- 함수 호출과정에서 매개변수 전달 방법
① 종류
- 값에 의한 전달방식 (Call by Value)
- 주소에 의한 전달방식 (Call by Reference)
② 매개변수의 분류 ­ 함수 호출 시 전달되는 실제 데이터 실 매개변수 ­ 함수 호출을 위해 전달되는 매개변수 ­ 실제 데이터를 받아들이는 변수 형식 매개변수 ­ 함수에 선언된 매개변수 ▶ 값에 의한 호출 ▶ 참조에 의한 호출  C언어  I  ▶ swap() 함수

1) 변수 2개의 값을 바꾸는 작업을 함수로 작성
2) 값들이 복사되었고 원본 변수에는 아무런 영향이 없음.
3) 포인터를 이용  C언어  I  ▶ 2개 이상의 결과를 반환  C언어  I  ▶ 배열이 함수 인수인 경우
1) 일반 변수 vs 배열
2) 배열의 원본을 함수로 전달하는 이유
- 크기가 큰 배열을 복사하려면 많은 CPU 시간 소모
- 따라서 배열의 경우, 배열의 주소를 전달하여서 원본을 직접 전달함.

3) 예제  C언어  I  ▶ 함수가 포인터를 반환하는 경우 ­ 함수는 포인터도 반환할 수 있음. ­ 함수가 종료되더라도 남아 있는 변수의 주소를 반환하여야 함. ­ 지역 변수의 주소를 반환하면, 함수가 종료되면 사라지기 때문에 오류 ▶ 포인터 사용의 장점
1) 연결 리스트나 이진 트리 등의 향상된 자료 구조를 만들 수 있음.  C언어  I 
2) 참조에 의한 호출
- 포인터를 매개 변수로 이용하여 함수 외부의 변수의 값을 변경할 수 있음.

3) 동적 메모리 할당 가능 ▶ 사용자 정의 함수의 분류 ­ 함수의 결과 유형과 매개변수 전달 방법에 따른 분류 매개변수 값 반환 종류 전달방법 사용 예 설명 (return) 값 주소 기본형 X void fun() 단순 출력용 출력매개  X 함수의  결과를  매개변수로  O void fun(int*x) 변수형 전달 목적 입력매개  X 입력 내용에 대한 단순 출력  X void fun(intx) 변수형 목적 O 입/출력 함수에  대한  입력과  출력을  O void fun(intx,int*y) 매개변수형 매개변수를 통해 처리함. 리턴형 X intfun() 내부처리 후 결과 반환 리턴/출력 X 처리  결과를  매개변수와  반 O intfun(int*x) 매개변수형 환값으로 처리 리턴/입력 O 입력 값에 대한 하나의 결과  X intfun(intx) 매개변수형 제공 O 리턴 입/출력 입력  값에  대한  처리  결과를  O intfun(intx,int*y) 매개변수형 매개변수와 리턴 값으로 전달  C언어  I  구조적 프로그래밍 순환 함수와 함수 포인터 그리고 메인 함수 1. 구조적 프로그래밍 기법에 대해 이해한다.  수업목표   2. 순환함수 및 함수포인터에 대해 이해한다.  3. 메인함수를 보다 자세히 이해한다.  10주차 
① 함수 기반의 구조적 프로그래밍 및 설계 기법 2교시 
② 하향식 설계 기법 세부내용 
③ 순환(재귀)함수
④ 함수 주소를 이용한 함수 포인터 및 메인 함수
⑤ 사용자 정의 함수 활용 1. 함수 기반의 구조적 프로그래밍 및 설계 기법 ▶ 프로그래밍 설계 기법 ­ 현실적으로 프로그램은 매우 크고 복잡한 구조를 가짐. ­ 어떻게 프로그램을 분석하고 설계할 것인가? v 분할 정복 방식 (Divide and Conquer)
Ÿ 큰 문제를 여러 개의 작은 단위로 분리하고 그 작은 단위의 문제부터 해결해 나가는 방식 v 하향식 설계 원리 ­ 해결 가능한 최소의 단위를 함수를 통해 구성함. ­ 구조체 차트(Structure Chart) 활용
Ÿ 한 문제와 다른 문제 사이의 관계를 효율적으로 분석 ­ 알고리즘 및 플로우 차트
Ÿ 각 단위의 문제에 대한 흐름 파악 2. 하향식 설계 기법 ▶ 하향식 접근 방식을 통한 프로그램 설계 흐름
① 문제의 이해
② 알고리즘 작성
③ 보다 작은 단위의 문제로 분할
④ 작은 부 문제를 이용해 구조체 차트 작성
⑤ 각 요소 중 보다 상세한 기술이 요구되는 부분을 위해 흐름도(플로우 차트)작성
⑥ 분할된 요소를 중심으로 프로그램 작성
⑦ 테스트  C언어  I  ▶ 하향식 접근 방식을 통한 프로그램 설계 흐름 예

1) 문제 정의
- 산술처리를 담당하는 프로그램을 작성해야 한다고 가정해 보자. 이 프로그램은 사용자의 입 력에 의해 사칙 연산을 수행하고 이 입력 결과를 화면에 출력함. 

2) 알고리즘 작성
- 프로그램 작성 과정을 문장을 통해 간략히 기술함. v 알고리즘 1. 데이터 입력  1.1 데이터 값을 입력 받는다.  1.2 연산형태를 입력 받는다.  2. 계산 처리  2.1 + 연산자 : 덧셈 처리  2.2 
- 연산자 : 뺄셈 처리  2.3 * 연산자 : 곱셉 처리  2.4 / 연산자 : 나눗셈 처리  3. 계산 결과 출력

3) 작은 단위의 문제 분할 
① 분할 정책
- 부 문제로 분류할 부분을 찾아 함수로 분할
- 분할된 문제가 더 작은 단위로 분할 가능한지를 분석
- 부  문제는  그  분할된  의미가  분명해야  하며  다른  곳에서  사용  가능한지  여부를  고려하여  구분함.
② 이 프로그램은 사칙 연산에 대한 부분을 작은 단위로 분리하고 함수로 정의함.
- 덧셈 처리       : int add(int x, int y) 
- 뺄셈 처리       : int sub(int x, int y) 
- 곱셈 처리       : int mul(int x, int y) 
- 나눗셈 처리   : double div(int x, int y)   C언어  I 

4) 부 문제를 포함하여 구조체 차트 작성
① 해설
- 구조체  차트는  레벨을  가지고  있으며  최상위  문제에서  분할된  부  문제와  다시  그  부  문제 에서 분할된 부 문제로 나누어져 구성됨.

5) 요소 중 상세한 기술이 요구되는 부분에 대한 흐름도 작성
① 해설
- 흐름도(플로우 차트)는 하나의 구성요소에서의 제어 흐름을 세부적으로 보여줄 수 있음.
- 제어 흐름이 많거나 중요한 부분을 대상으로 흐름도를 작성함. v 이  프로그램에서는  [0.산술처리]가  다양한  요소를  포함하고  있기  때문에  이  부분에  대한  흐름도를 작성함.  C언어  I 

6) 프로그램 코드 작성
- 프로그램 분석 완료 후 이들 알고리즘, 구조체 차트 그리고 흐름도를 이용해 코드로 작성함. v 프로그램 코드  C언어  I  3. 순환(재귀)함수 ▶ 순환(재귀)함수 ­ 자기 자신을 호출하는 함수 ­ 재귀적으로 서로 상이한 매개변수 값을 가지고자기 자신을 호출하는 구조 ­ 반복 처리의 대안으로 널리 이용됨. ­ 반복 구조에 비해 처리 면에서 다소 느리지만 복잡한 구조를 간결하게 구성할 수 있게 함. v 순환 함수의 구성 Ÿ 자기 자신과 나머지의 집합
Ÿ 종결조건 ▶ 순환(recursion)

1) 순환(recursion)이란?
- 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법 v (예제) 팩토리얼의 정의 ▶ 팩토리얼 구하기

1) 팩토리얼 프로그래밍
- (n
-1)! 
- 팩토리얼을 현재 작성중인 함수를 다시 호출하여 계산(순환 호출)  C언어  I 

2) 팩토리얼의 호출 순서
- factorial(3)  = 3 * factorial(2)  = 3 * 2 * factorial(1)  = 3 * 2 * 1  = 3 * 2  = 6 ▶ 팩토리얼 예제  C언어  I  ▶ 순환(재귀)함수 프로그램 예

1) 순환 함수 호출 흐름 : N의 입력 값이 3일 경우 순환 함수 처리 과정  ▶ 순환 알고리즘의 구조
1) 순환 알고리즘은 다음과 같은 부분들을 포함함.
- 순환 호출을 하는 부분, 순환 호출을 멈추는 부분 ­ 순환 호출을 멈추는 부분이 없다면 시스템 오류가 발생할 때까지 무한정 호출하게 됨.  C언어  I  ▶ 순환 ↔ 반복

1) 컴퓨터에서의 되풀이
- 순환(recursion): 순환 호출 이용
- 반복(iteration): for나 while을 이용한 반복

2) 대부분의 순환은 반복으로 바꾸어 작성할 수 있음.
- 순환적인 문제에서는 자연스러운 방법 순환
- 함수 호출의 오버헤드
- 수행속도가 빠름. 반복
- 순환적인 문제에 대해서는 프로그램 작성이 아주 어려울 수도 있음. ▶ 팩토리얼의 반복적 구현 4. 함수 주소를 이용한 함수 포인터 및 메인 함수 ▶ 함수 포인터

1) 함수 포인터(function pointer)
- 함수 역시 특정 주소에 저장됨. 그 결과 함수 주소에 대한 포인터 연산이 가능
- 함수 포인터 선언과 할당
① 선언 방법 : [데이터 형] (*[포인터명])([매개변수리스트])
Ÿ [데이터 형] 함수의 리턴 타입 형
Ÿ (*[포인터명]) : 함수의 주소를 저장할 함수 포인터 이름
Ÿ [매개변수리스트] : 함수에 전달되는 매개변수 리스트  C언어  I 
② 함수 포인터(function pointer) : 함수를 가리키는 포인터
- 반환형    (*함수포인터이름)  (매개변수1,    매개변수2, ...); v 예 int (*pf)(int, int);
③ fp1.c  C언어  I  ▶ 함수 포인터 배열

1) 함수 포인터 배열
- 함수 포인터 역시 배열로 관리될 수 있음.
① 함수 포인터 배열 선언 : [데이터형](*[포인터명][배열의크기])([매개변수리스트])
Ÿ [데이터 형] 함수의 리턴 타입 형
Ÿ *[포인터명] : 함수의 주소를 저장할 함수 포인터 이름
Ÿ [배열의 크기] : 함수 포인터 배열의 크기
Ÿ [매개변수리스트] : 함수에 전달되는 매개변수 리스트
② 동일 유형의 함수 구조를 그룹화하여 관리 가능
- 사용 예 : int (*pfuns[2])(int *); ▶ 메인 함수(main)의 확장

1) 메인 함수의 원형
① [반환 데이터형] main([매개변수 리스트]); 
② [반환 데이터형] : 정수형이나 void 형 사용
- main함수의 실행이 정상적인지 아닌지를 판단하기 위해 사용
- 함수의 정상 종료 시 : 0
- 비정상 종료 시  : 1
③ [매개변수 리스트]
- 명령라인에서 입력된 값을 얻기 위해 사용
- 두 개의 인자 존재 ❶ 명령 라인에 입력된 인자의 수 (정수형) ❷ 명령 라인에 입력된 실제 데이터 배열 공간 (문자열 포인터 배열 변수)

2) 메인 함수의 매개 변수 사용 예
① 프로그램
Ÿ argc : 명령 라인에서 입력된 인자의 수
Ÿ *argv[] : 입력된 인자의 문자열 배열  C언어  I 
② 사용 예 : 명령 라인에서 다음과 같이 입력 후 두 인자의 결과 C:> maintest.exe Hi 2030 world
- maintest.exe는 프로그램의 이름
③ argc와 *argv[]의 저장 값 5. 사용자 정의 함수 활용 ▶ 집합 연산자 만들기

1) 문제 정의
- C언어는 산술, 관계, 논리 연산자 등 다양한 연산자를 제공하고 있지만 집합에 대한 연산은  제공하지 않음. 
- 수치 집합들에 대한 처리 과정에서 집합 처리 연산이 요구됨. 필요한 집합연산은 합집합(∪),  교집합(∩), 차집합(−)을 계산해야 함.
- 이러한 연산을 제공하는 프로그램을 작성하여라.  

2) 입/출력 조건
1) 정수형의 두 집합의 리스트  입력 조건
2) 각각의 집합에 대한 크기와 값들이 입력됨. 
1) 두 집합에 대한 합집합 (A∪B)  출력 조건
2) 두 집합에 대한 교집합 (A∩B) 
3) 두 집합에 대한 차집합 (A−B) 
3) 관련 함수 및 식
① 입력된 집합의 크기에 의해 동적으로 메모리 공간 확보 (calloc()함수 이용) 
② 집합 관계를 표현하는 사용자 정의 함수  합집합 ­ B의 요소가 A 집합의 요소가 아닐 경우 합집합 요소 unionSet ­ 합집합 = A의 집합 + A집합에 속하지 않은 B의 요소들  교집합 ­ B요소가 A집합의 요소이면 합집합의 요소  commSet ­ 합집합 = B요소가 A집합인 요소들 차집합 ­ A요소이면서 B의 집합에 속하지 않는 경우 차집합의 요소 diffSet ­ 차집합 = A요소 중 B의 집합에 속하지 않은 요소들 v 한 요소가 집합에 속하는지 여부 판별 : isElement   C언어  I 
③ 한 요소와 집합의 관계
- 한 요소와 집합에서의 첫 번째 요소 비교 부분과 나머지들의 비교 부분
- 순환 알고리즘으로 구성 ▶ 알고리즘 (또는 플로우 차트)

1) 개괄적 알고리즘 흐름
- 1.1 집합 A의 크기와 값 입력  1. 두 집합 입력
- 1.2 집합 B의 크기와 값 입력 
- 2.1 합집합 계산  2. 계산 결과 처리와 출력
- 2.2 합집합 출력 
- 2.3 교집합과 차집합은 2.1과 2.2 순으로 동일하게 출력  v 구조체 차트  C언어  I  ▶ 코드  C언어  I   C언어  I   C언어  I  ▶ 프로그램 작성

1) 프로그램 작성 : 2단계
- 정상적으로 컴파일 되면 아래의 값을 입력하여 출력 결과를 기록하자. 입력 조건 출력 결과 A 집합의 수 : 8   집합 : 4 5 3 8 6 9 13 15 B의 집합의 수 : 7   집합 : 1 2 4 5 7 8 12 A 집합의 수 : 9   집합 : 1 3 5 7 8 6 15 11 6 B의 집합의 수 : 5   집합 : 3 6 9 12 15  C언어  I  구조체와 공용체의 개념 1. 구조체와 공용체 의미와 특징을 이해한다.  수업목표   2. 비트 필드 구조체 대해 이해한다.  11주차  3. 새로운 형 정의문(typedef)에 대해 이해한다.  1교시 
① 새로운 데이터 타입 정의 방법 세부내용 
② 복합 데이터 유형인 구조체와 공용체의 특징
③ 구조체와 공용체의 관련 문법  1. 새로운 데이터 타입 정의 방법 ▶ 자료형의 분류 

1) 자료형
① 기본 자료형 : char, int, float, double 등
② 파생 자료형 : 배열, 열거형, 구조체, 공용체 ▶ 구조체의 필요성

1) 학생에 대한 데이터를 하나로 모으려면?  C언어  I  ▶ 구조체와 배열
1) 구조체 vs 배열 ▶ 구조체 선언
1) 구조체 선언 형식  C언어  I  2. 복합데이터 유형인 구조체와 공용체의 특징 ▶ 구조체의 개념(struct)
- 관련된 데이터 타입을 복합하여 하나의 새로운 타입으로 정의
- 데이터 조합을 통한 의미 있는 데이터 정의
- 일반적으로 레코드 형태를 가짐.
① 구조체 형식 struct  [구조체 이름]{  [데이터 타입]   [변수이름1];   [데이터 타입]   [변수이름1];   [데이터 타입]   [변수이름1];   [데이터 타입]   [변수이름1];   ...  [데이터 타입]   [변수이름1];   };  ▶ 구조체 선언

1) 구조체 선언은 변수 선언은 아님. ­ 구조체를 정의하는 것은  구조체 와플이나 붕어빵을 만드는 틀을 정의하는 것과 같음. ­ 와플이나 붕어빵을 실제로 만들기 위해서는  구조체 변수  구조체 변수를 선언하여야 함.  C언어  I  ▶ 구조체 선언의 예
1) 구조체 형태 선언 예
① 학생에 대한 구조체 선언  C언어  I  ▶ 구조체 변수와 메모리 관계

1) 학생 구조체 변수와 메모리 관계
- 구조체의 크기는 전체 구성요소의 크기임. ▶ 구조체 변수 선언

1) 구조체 정의와 구조체 변수 선언은 다름. ▶ 구조체의 초기화
1) 일반변수나 배열 변수처럼 구조체 변수는 선언과 동시에 초기화 될 수 있음.
① 초기화 예
- struct STUDENT x = { 101, "Kim","Computer Science","20" };
- 초기 값의 구분은 쉼표(,)로 구분
- 순서대로 각 요소의 값 지정
- 정적 변수는 초기화 하지 않을 경우 디폴트 초기값을 가짐. Ÿ 숫자 : 0, 문자 : ‘\0’  C언어  I 

2) 중괄호를 이용하여 초기값을 나열함. ▶ 구조체 멤버 참조
1) 구조체 멤버를 참조하려면 다음과 같이 .연산자를 사용함. . 기호는 구조체에서 멤버를 참조할 때 사용하는 연산자입니다. ▶ 구조체 변수 사용
1) 배열 요소의 접근을 첨자를 통해 이루어짐.
2) 구조체 변수의 각 요소의 접근은 어떻게 이루어지는가?
- 구조체 요소 접근 연산자 : ".“
- [구조체 변수이름].[요소 이름]
① 사용 예 x.hackbun = 100101; strcpy(x.name,"w y kim"); strcpy(x.dept,"computer science"); x.age = 20;  C언어  I  ▶ 예제#1 ▶ 예제 #2  C언어  I  ▶ 예제 #3 3. 구조체와 공용체의 관련 문법 ▶ typedef

1) typedef의 개념
- Typedef : 기본 자료형에 새로운 자료형을 추가하는 것 ­ typedef : 새로운 자료형(type)을 정의(define) ­ C의 기본 자료형을 확장시키는 역할  C언어  I 

2) typedef의 예 ▶ typedef과 #define 비교
1) 이식성을 높여줌.
- 코드를 컴퓨터 하드웨어에 독립적으로 만들 수 있음. v (예)  int형은  2바이트이기도  하고  4바이트,  int형  대신에  typedef을  이용한  INT32나  INT16을 사용하게 되면 확실하게 2바이트인지 4바이트인지를 지정할 수 있음. ­ #define을 이용해도 typedef과 비슷한 효과를 낼 수 있음.  즉 다음과 같이 INT32를 정의할 수 있음. #define UINT32 unsigned int typedef float VECTOR[2];// #define으로는 불가능하다.  ­ 문서화의 역할도 함. Ÿ typedef을 사용하게 되면 주석을 붙이는 것과 같은 효과가 있음.  C언어  I  ▶ 다양한 구조체의 선언 방법 ­ typedef의 사용 원형 typedef 활용 1 typedef 활용 2  구조체의 이름이 없으므로 내부 에 자기 자신을 참조하지 못함.
- typedef를 활용하면 구조체 선언 시 struct를 사용하지 않아도 됨. ▶ 다양한 구조체 변수 선언과 초기화

1) 구조체 변수 선언
- 구조체 선언은 새로운 데이터 형의 선언하는 것으로 이 새로운 형의 구조체 타입을 사용하 기 위해서는 구조체 변수 선언이 요구됨.

2) 구조체 변수 선언 방법
- 구조체명이 생략된 형태로 구조체 선언과 동시에 변수들을 선언함.
- 구조체명을  가지고 있으며 구조체 선언과 동시에 변수들을 선언하고 있으며, 선언 이후 이  구조체 이름을 통해 필요한 구조체 변수를 선언할 수 있음.  C언어  I 
- typedef  문에  의해  구조체를  새로운  데이터  타입으로  정의하고  이  정의된  타입을  이용해  변수들을 선언하고 있음.  ▶ 공용체 개념

1) 공용체 개념 ­ 동일한 공간에 여러 개의 변수를 관리
① 공용체 선언 형식 union  [공용체 이름]{  [데이터 타입]   [변수이름1];   [데이터 타입]   [변수이름1];   [데이터 타입]   [변수이름1];   [데이터 타입]   [변수이름1];   ...  [데이터 타입]   [변수이름1];   }; 

2) 공용체(union)
- 같은 메모리 영역을 여러 개의 변수가 공유
- 공용체를 선언하고 사용하는 방법은 구조체와 아주 비슷  C언어  I  ▶ 예제 ▶ ip 주소 예제  C언어  I  ▶ 공용체 변수 선언

1) 공용체 변수의 선언 ­ 공용체 변수의 선언 역시 구조체와 동일한 방식으로 사용
2) 선언 형태
- 공용체명이 생략된 형태로 공용체 선언과 동시에 변수들을 선언함.
- 공용체명을  가지고 있으며 공용체 선언과 동시에 변수들을 선언하고 있으며, 선언 이후 이  공용체로 다른 공용체 변수를 선언하고 있음.
- typedef  문에  의해  공용체를  새로운  데이터  타입으로  정의하고  이  정의된  타입을  이용해  공용체 변수들을 선언하고 있음.   C언어  I 

3) 공용체 변수의 특징
- 선언과 사용 면에서는 구조체와 비슷한 구조
- 메모리 구조상 공용체는 요소들을 동일한 기억공간에 저장
① 공용체 변수의 메모리 구조

4) 공용체 변수의 접근
- 공용체 내부의 요소를 접근하기 위해서는 구조체와 동일하게 “.”인 접근 지정자를 사용함.
① 사용 예 strcpy(cd.cname,"code
-1"); cd.barcode = 323; cd.longcode = 100.234;
- 동일한 공간에 요소들이 공유되기 때문에 최후에 입력된 값만을 유지함.

5) 공용체 변수 활용 예  C언어  I  구조체 심화 학습 1. 구조체와 포인터의 관계 및 구조체 매개변수를 이해한다.  수업목표   11주차  2. 중첩된 구조체에 대해 이해한다.  2교시 
① 구조체 배열 및 구조체 포인터 세부내용 
② 중첩 구조체 및 비트 필드 구조체
③ 구조체 매개변수 1. 구조체 배열 및 구조체 포인터 ▶ 구조체 배열

1) 구조체 배열 : 구조체를 여러 개 모은 것
2) 구조체 배열의 선언 ▶ 구조체 배열의 초기화  C언어  I  ▶ 구조체 배열 예제 v 구조체와 포인터
Ÿ 구조체를 가리키는 포인터, 포인터를 멤버로 가지는 구조체 순서로 살펴봅시다. ▶ 구조체를 가리키는 포인터  C언어  I  ▶
->연산자

1) 
-> 연산자 : 구조체 포인터로 구조체 멤버를 참조할 때 사용 ▶ 예제  C언어  I  ▶ 포인터를 멤버로 가지는 구조체 2. 중첩 구조체 및 비트 필드 구조체 ▶ 중첩 구조체

1) 중첩 구조체
- 구조체에 다른 구조체를 포함하는 구조
- 하나의 데이터는 다양한 데이터를 포함하고 그 데이터는 또 다른 정보를 구성
① 중첩 구조체 예 : 학생 정보에 대한 구조체  C언어  I 

2) 학생정보에 대한 중첩 구조체 표현 ▶ 예제  C언어  I  ▶ 구조체 변수의 대입과 비교 ­ 같은 구조체 변수끼리 대입은 가능하지만 비교는 불가능함. ▶ 비트필드 구조체
1) 비트필드 구조체 ­ 비트 단위의 구조체 형식 ­ 작은 크기의 요소들의 집합을 구성하여 공간 절약 효과 제공 ­ 구성 요소 표현 방식의 변형 [데이터형] [변수명] : [비트크기];  C언어  I  ­ 구성 요소에 사용되는 데이터 형 int unsigned ­ 작은 정보의 그룹화에 유용
2) 비트필드 구조체 예
① 비트필드 구조체 정의
② 메모리 구조

3) 주의 사항
① 비트필드 비트 수 제한
- 다음과 같이 비트 필드의 멤버를 선언하는 자료형보다 큰 비트 수는 지정할 수 없음.  C언어  I 

4) 비트필드 구조체 기타 특징
- 일반 구조체와 사용방법이 동일
- 정의된 비트 범위를 초과해서 입력해서는 안 됨.
- 구조체 정의 시 일반 구조체와 비트 필드 구조체를 혼용해서 사용 가능함.
① 사용 예 3. 구조체 매개변수 ▶ 구조체와 함수

1) 구조체를 함수의 인수로 전달하는 경우
- 구조체의 복사본이 함수로 전달되게 됨.
- 만약 구조체의 크기가 크면 그 만큼 시간과 메모리가 소요됨.  C언어  I 

2) 구조체의 포인터를 함수의 인수로 전달하는 경우 
- 시간과 공간을 절약할 수 있음.
- 원본 훼손의 가능성이 있음. ▶ 구조체를 이용한 매개변수 전달

1) 구조체 변수가 함수에 인자로 전달될 때 어떤 현상이 일어나는가?
- 구조체 변수는 하나의 변수로 취급됨.
- 구조체 내의 모든 요소가 복사되어 전달 (Call by Value)
- 구조체 크기에 따라 실행 시간에 영향을 미칠 수 있음.

2) 구조체 포인터 변수가 함수의 인자로 전달될 때
- 구조체 변수의 주소 값이 전달 (Call by Reference) ▶ 구조체를 반환하는 경우 ­ 복사본이 반환됨.  C언어  I   C언어  I  ▶ 예제  C언어  I  스트림과 파일 그리고 표준 입출력 1. 스트림과 파일 시스템을 이해한다.  수업목표   12주차  2. 파일 관련 표준 함수를 이해한다.  1교시 
① 외부장치와의 논리적인 흐름을 나타내는 스트림  세부내용 
② 스트림과 파일의 관계
③ 표준 입/출력 함수들 1. 외부장치와의 논리적인 흐름을 나타내는 스트림 ▶ 스트림의 개념

1) 스트림(stream)
- 입력과 출력을 바이트(byte)들의 흐름으로 생각하는 것 2. 스트림과 파일의 관계 ▶ 스트림과 파일 ­ 스트림은 구체적으로 ex)ILE 구조체를 통하여 구현됨. ­ ex)ILE은 stdio.h에 정의되어 있음.   C언어  I  ▶ ex)ILE 구조체 ▶ 스트림과 파일

1) 스트림(Stream)
- 컴퓨터와 연결된 여러 주변장치와의 논리적인 흐름
- 주변장치와 연결하는 접속 채널의 개념
- 컴퓨터와 주변장치의 정보전달은 스트림을 통해 이루어짐.
- 모든 정보는 스트림을 통해 전달

2) 파일
- C언어에서 파일은 모든 주변 장치를 포함함. Ÿ 디스크에 저장된 파일, 디스플레이 화면, 키보드, 프린터, 직/병렬 포트, 테이프 등등…

3) 스트림과 파일의 관계
- 스트림은 파일을 연결하기 위한 논리적인 접근 통로
- 오픈된 스트림을 통해 정보를 전달하거나 받아들임.
- 스트림 사용을 위해서는 항상 오픈(Open) 되어야 하고 사용 후 닫아(Close) 주어야 함.

4) C언어에서 제공되는 표준 입/출력 장치
- 키보드 : 표준 입력 장치
- 디스플레이 화면 : 표준 출력 장치

5) 표준 입출력 스트림
- 표준 입/출력 장치의 연결을 위해 사용되는 스트림
- C 프로그램 시작 시 자동적으로 오픈되어 사용 가능함.  C언어  I  ▶ 표준 입출력 스트림

1) 표준 입출력 스트림(standard input/output stream)
- 필수적인 몇 개의 스트림
- 프로그램 실행 시에 자동으로 만들어지고 프로그램 종료 시에 자동으로 없어짐.  이름 스트림 연결 장치 stdin 표준 입력 스트림 키보드 stdout 표준 출력 스트림 모니터의 화면 stderr 표준 에러 스트림 모니터의 화면 3. 표준 입/출력 함수들 ▶ 표준 입출력 함수
- 표준 입/출력 스트림을 이용하는 함수
- 표준 입/출력 함수 정의 헤더 파일 : stdio.h v 표준 입출력 함수의 종류 Ÿ 형식이 있는 입출력 함수 : printf(), scanf()
Ÿ 단일 문자 입출력 함수 : getchar(), putchar()
Ÿ 문자열 입출력 함수 : gets(), puts()
Ÿ 버퍼형 입출력 함수 : sscanf(), sprintf() ▶ 입출력 함수의 분류

1) 사용하는 스트림에 따른 분류
- 표준 입출력 스트림을 사용하여 입출력을 하는 함수
- 스트림을 구체적으로 명시해 주어야 하는 입출력 함수 스트림 형식 표준 스트림 일반 스트림 설명 getchar() fgetc(ex)ILE*f,...) 문자 입력 함수 형식이 없는 입출력 putchar() fputc(ex)ILE*f,...) 문자 출력 함수 (문자 형태) gets() fgets(ex)ILE*f,...) 문자열 입력 함수 puts() fputs(ex)ILE*f,...) 문자열 출력 함수 형식이 있는 입출력 printf() fprintf(ex)ILE*f,...) 형식화된 출력 함수 (정수, 실수,,,) scanf() fscanf(ex)ILE*f,...) 형식화된 입력 함수  C언어  I 

2) 데이터의 형식에 따른 분류
- getchar()나 putchar()처럼 문자 형태의 데이터를 받아들이는 입출력
- printf()나 scanf()처럼 구체적인 형식을 지정할 수 있는 입출력 스트림 형식 표준 스트림 일반 스트림 설명 getchar() fgetc(ex)ILE*f,...) 문자 입력 함수 형식이 없는 입출력 putchar() fputc(ex)ILE*f,...) 문자 출력 함수 (문자 형태) gets() fgets(ex)ILE*f,...) 문자열 입력 함수 puts() fputs(ex)ILE*f,...) 문자열 출력 함수 형식이 있는 입출력 printf() fprintf(ex)ILE*f,...) 형식화된 출력 함수 (정수, 실수,,,) scanf() fscanf(ex)ILE*f,...) 형식화된 입력 함수 ▶ 단일 문자 입출력 함수

1) 단일 문자 입력 함수 ­ getchar()
- 함수의 원형 : int getchar()
- 키보드로부터 하나의 문자를 입력 받음. v 리턴 결과  Ÿ 정상적 수행 : 해당 문자에 대한 ASCII 코드 값
Ÿ 비정상적 수행 : EOex) 값 반환

2) 단일 문자 출력 함수 ­ putchar()
- 함수의 원형 : int putchar(int ch)
- 화면에 ch에 해당되는 문자를 출력 v 리턴 결과  Ÿ 정상적 수행 : 입력된 값이 반환
Ÿ 비정상적 수행 : EOex) 값 반환  C언어  I 

3) 단일 문자 입/출력 함수 사용 예 ▶ 문자열 입출력 함수
1) 문자열 입력함수 ­ gets()
- 함수의 원형 : char *gets(char *str);
- 키보드로부터 입력된 문자열 값을 저장
- *str : 입력된 문자열 저장 주소
- 입력된 문자열은 키보드로부터 <Enter>키를 누른 위치까지 포함
- 공백문자도 문자열에 포함됨.
- <Enter>값은 자동적으로 '\0'(NULL) 값으로 변경되어 저장됨. v 반환 결과  Ÿ 정상적일 경우 : 저장된 문자열의 주소
Ÿ 비정상적일 경우 : EOex) 값

2) 문자열 출력함수 ­ puts()
- 함수의 원형 : int puts(char *str);
- 입력된 문자열(*str)을 화면에 출력
- 출력시 '\0' 값은 '\n'(Enter) 값으로 변형되어 출력 v 반환 결과  Ÿ 정상적일 경우 : 음이 아닌 값
Ÿ 에러 발생 시 : EOex) 값 반환

3) 문자열 입출력 함수 사용 예  C언어  I  ▶ printf()를 이용한 출력
1) printf()를 이용한 출력
① 형식 제어 문자열의 구조 % 기호 ­ 형식 제어 문자열의 시작 ­ 출력의 정렬과 부호 출력, 공백 문자 출력,  플래그(flag) 소수점, 8진수와 16진수 접두사 출력 필드폭(width)과  ­ 데이터가 출력되는 필드의 크기 정밀도(precision) ­ 정밀도는 소수점 이하 자릿수의 개수가 됨.

2) 플래그 기호 의미 기본값
- ­ 출력 필드에서 출력값을 왼쪽 정렬함. 오른쪽 정렬됨. + ­ 결과 값을 출력할 때 항상 +와 
-의 부호를 붙임. 음수일 때만 
-부호를 붙임. ­ 출력값 앞에 공백문자 대신에 0으로 채움. ­
-와 0이 동시에 있으면 0은 무시됨. 0 채우지 않음. ­ 만약 정수 출력의 경우, 정밀도가 지정되면 역시  0은 무시됨.(예를 들어%08.5) ­ 출력값 앞에 양수나 영인 경우에는 부호 대신 공 blank('') 백을 출력함. 음수일 때는 
-가 붙여짐. 공백을 출력하지 않음. ­ +플래그가 있으면 무시됨. ­ 8진수  출력  시에는  출력값  앞에  0을  붙이고  16 # 붙이지 않음. 진수 출력 시에는 0x를 붙임.

3) 필드폭과 정밀도  C언어  I 
4) 형식 형식 지정자 설명 출력 예 %d 부호 있는 10진수 형식으로 출력 255 %i 부호 있는 10진수 형식으로 출력 255 %u 부호 없는 10진수 형식으로 출력 255 %o 부호 없는 8진수 형식으로 출력 377 %x 부호 없는 16진수 형식으로 출력, 소문자로 표기  fe %X 부호 없는 16진수 형식으로 출력, 대문자로 표기 ex)E %f 소수점 고정표기 형식을 출력 123.456 %e 지수 표기형식으로 출력, 지수 부분을 e로 표시 1.23456e+2 %E 지수 표기형식으로 출력, 지수 부분을 E로 표시 1.23456E+2 %g %e 형식과 %f 형식 중 더 짧은 형식으로 출력 123.456 %G %E 형식과 %f 형식 중 더 짧은 형식으로 출력 12.456 %p 포인터 형식으로 출력
5) 필드폭
6) 정밀도  C언어  I 
7) 과학적 표기법 출력 ▶ scanf()를 이용한 입력
1) scanf()를 이용한 입력 ­ 문자열 형태의 입력을 사용자가 원하는 형식으로 변환함.
2) scanf()의 형식 제어 문자열 ­ 현재 입력을 무시하라는 의미 * ­ 파일에서 하나의 특정한 열만 읽을 때 유용 ­ Ex) scanf("%*d%d", &i); ­ 필드폭 만큼의 문자를 읽어서 값으로 변환 필드폭 ­ 공백 문자로 입력 값을 분리하지 않고서도 여러 개의 값들을 읽을 수 있음.  ­ h가 정수형인 경우, short형으로 변환 크기 지정 ­ h가 float형 앞에 붙으면 double형으로 변환 ­ L은 long double형으로 변환  C언어  I 
3) 필드폭 지정하여 읽기
4) 8진수, 16진수 입력  C언어  I 
5) 문자와 문자열 입력 분류 형식 지정자 설명 %c ­ char형으로 입력받음. ­ 공백  문자가  아닌  문자부터  공백  문자가  나올  때  까지  변환하여  %s 입력 받음. 문자형 %[abc] ­ 대괄호 안에 있는 문자 a,b,c로만 이루어진 문자열을 읽어들임. ­ 대괄호  안에  있는  문자  a,b,c만을  제외하고  다른  문자들로  이루 %[^abc] 어진 문자열을 읽어들임. %[0
-9] ­ 0에서 9까지의 범위에 있는 문자들로 이루어진 문자열을 읽어들임.

6) 문자와 문자열 읽기
7) scanf6.c  C언어  I 
8) 문자집합으로 읽기  C언어  I  ▶ scanf() 사용시 주의점
1) 입력값을 저장할 변수의 주소를 전달
- int i;
- scanf("%d", i); // 오류!!

2) 배열의 이름은 배열을 가리키는 포인터
- int str[80];
- scanf("%s", str); // 올바름
- scanf("%s", &str); // 오류!!

3) 충분한 공간을 확보
- int str[80];
- scanf("%s", str); // 입력된 문자의 개수가 79를 초과하면 치명적인 오류 발생

4) scanf()의 형식 제어 문자열의  끝에 줄 바꿈 문자  '\n'을 사용하는 것은 해당 문자가 반 드시 입력되어야 한다는 의미
- scanf("%d\n", &i);// 잘못됨!! ▶ 스트림과 파일 그리고 표준 입출력

1) 버퍼형 입출력 함수
- 형식을  가진  형태로  표준입출력  스트림이  아닌  문자열  변수  공간(Buffer)에  값을  저장하거 나 읽어올 때 사용

2) 버퍼형 입력 함수 ­ sscanf()
- 함수의 원형 : int sscanf(char *buffer, char *format [,argument ] ... );  Ÿ buffer : 입력 데이터가 존재하는 문자열 주소
Ÿ format : 형식지정문자를 포함한 문자열
Ÿ argument : 값을 저장할 변수 리스트
Ÿ 문자열로 저장된 데이터를 형식에 맞도록 추출할 목적으로 사용  C언어  I 

3) 버퍼형 입력 함수 사용 예
4) 버퍼형 출력함수 ­ sprintf()
- 형식화된 문자열을 화면이 아닌 문자열 변수에 저장
- 여러 데이터 유형을 문자열로 만들 때 유용
- 함수의 원형 : int sprintf(char *buffer, char *format [,argument] ... );  Ÿ buffer : 출력할 문자열의 주소
Ÿ format : 형식지정문자를 포함한 문자열
Ÿ argument : 값을 저장하고 있는 변수 리스트
Ÿ buffer에 출력된 문자열의 수 반환 

5) 버퍼형 출력함수 사용 예  C언어  I  파일 입출력 함수 1. 순차 파일과 이진 파일에 대해 이해한다.  수업목표   2. 표준 입출력 함수를 이해한다.  12주차 
① 일반 파일에 대한 처리 과정  2교시 
② 파일 시스템과 파일 조작함수 세부내용 
③ 파일의 종류와 이 파일의 입출력 함수들
④ 파일의 임의 접근 방식 1. 일반 파일에 대한 처리 과정 ▶ 파일이 필요한 이유
- 메모리 : 변수, 배열, 구조체 등은 모두 메모리에 만들어지고 이것들은 모두 전원이 꺼지면  사라짐.
- 하드 디스크 : 하드 디스크에 파일 형태로 저장하면 전원이 꺼지더라도 데이터가 보존됨. ▶ 파일의 개념
- C에서의 파일은 일련의 연속된 바이트
- 모든 파일 데이터들은 결국은 바이트로 바뀌어서 파일에 저장
- 이들 바이트들을 어떻게 해석하느냐는 전적으로 프로그래머의 책임
- 파일에 4개의 바이트가 들어있을 때 이것을 int형의 정수 데이터로도 해석할 수 있고  아니면 float형 실수 데이터로도 해석할 수 있음.
- 파일은 일련의 연속된 바이트임.  C언어  I  ▶ 텍스트 파일(text file)
- 텍스트 파일은 사람이 읽을 수 있는 텍스트가 들어 있는 파일 (예 : C 프로그램 소스 파일이나 메모장 파일)
- 텍스트 파일은 아스키 코드를 이용하여 저장
- 텍스트 파일은 연속적인 라인들로 구성 ▶ 이진 파일(binary file)
- 이진 파일은 사람이 읽을 수는 없으나 컴퓨터는 읽을 수 있는 파일
- 이진 데이터가 직접 저장되어 있는 파일
- 이진 파일은 텍스트 파일과는 달리 라인들로 분리되지 않음. 
- 모든 데이터들은 문자열로 변환되지 않고 입출력
- 이진 파일은 특정 프로그램에 의해서만 판독이 가능 (예 : C 프로그램 실행 파일, 사운드 파일, 이미지 파일) ▶ 파일 처리의 개요 ­ 파일을 다룰 때는 반드시 다음과 같은 순서를 지켜야 함.
- 디스크 파일은 ex)ILE 구조체를 이용하여 접근 
- ex)ILE 구조체를 가리키는 포인터를 파일 포인터(file pointer)  C언어  I  ▶ 파일 열기 ­ 파일에서 데이터를 읽거나 쓸 수 있도록 모든 준비를 마치는 것 Ÿ 첫 번째 매개 변수 name : 파일의 이름
Ÿ 두 번째 매개 변수 mode : 파일을 여는 모드 ▶ 파일 모드 모드 설명 “r" ­ 읽기 모드로 파일을 엶. ­ 쓰기 모드로 파일을 생성함. "w" ­ 만약 파일이 존재하지 않으면 파일이 생성됨. ­ 파일이 이미 존재하면 기존의 내용이 지워짐. ­ 추가 모드로 파일을 엶. "a" ­ 만약 똑같은 이름의 기존의 파일이 있으면 데이터가 파일의 끝에 추가됨. ­ 파일이 없으면 새로운 파일을 만듦. ­ 읽기와 쓰기 모드로 파일을 엶. "r+" ­ 파일이 반드시 존재하여야 함. ­ 읽기와 쓰기 모드로 파일을 생성함. "w+" ­ 만약 파일이 존재하지 않으면 파일이 생성됨. ­ 파일이 존재하면 새 데이터가 기존 파일의 데이터를 덮어 쓰게 됨. ­ 읽기와 추가 모드로 파일을 엶. “a+" ­ 만약 똑같은 이름의 기존의 파일이 있으면 데이터가 파일의 끝에 추가됨.  ­ 읽기는 어떤 위치에서나 가능함. 파일이 없으면 새로운 파일을 만듦. "b" ­ 이진 파일 모드로 파일을 엶. “rb" ­ 읽기용 이진파일오픈, 파일 존재해야 함. "wb" ­ 쓰기용 이진파일 오픈, 파일 미존재시 새롭게 생성, 존재 시 무시 “ab" ­ 추가용 이진파일 오픈, 기존 내용 보본, 새로운 내용 추가 “rb+" ­ 읽기/쓰기용 이진파일 오픈, 파일 존재해야 함. “wb+" ­ 읽기/쓰기용 이진파일 오픈, 파일 미존재시 생성, 존재 시 무시 “ab+" ­ 읽기/추가용 이진파일 오픈, 파일 존재 시 내용 추가, 미존재 시 생성
Ÿ “r" : 파일의 처음부터 읽음.
Ÿ “w" : 파일의 처음부터 씀. 만약 파일의 내용이 존재하면 기존의 내용이 지워짐.
Ÿ “a" : 파일의 끝에 씀. 파일이 없으면 생성됨.  C언어  I  2. 파일 시스템과 파일 조작함수 ▶ 파일 시스템의 개요
- 파일에 데이터를 쓰거나 읽기 위해 스트림 형성이 필요
- 파일에 스트림 형성 방법 : 파일 포인터 이용
- 파일 포인터 : 파일을 가리키는 ex)ILE 타입의 구조체 
① ex)ILE 포인터를 이용한 파일 입출력 단계 1. 파일 포인터 선언  ex)ILE *fp; // fp는 파일 포인터 변수 2. 파일 포인터를 이용해 파일 열기  fp = fopen(…); // 파일 오픈 후 그 파일에 대한 포인터 반환 3. 파일에 대한 입/출력 처리  파일 포인터 fp을 이용한 파일 입/출력 처리 4. 파일 닫기  fclose(fp); // 사용 후 파일 포인터를 이용해 해당 파일 닫기 ▶ 파일 조작 함수 파일 스트림의 연결과 닫기 파일 열기와 닫기
- fopen 함수, fclose 함수 입출력 과정에서 발생된 에러 확인 파일 검사
- feof 함수, ferror 함수 파일의 제거 및 이름 변경 기타 파일 조작 함수
- rename 함수, remove 함수 ▶ file_open.c  C언어  I  ▶ 파일 닫기와 삭제

1) 파일을 닫는 함수
2) 파일을 삭제하는 함수 3. 파일의 종류와 이 파일의 입출력 함수들 ▶ 파일 입출력
1) 파일 입출력 과정
- 파일 입출력 과정은 버퍼 공간을 통해 이루어짐.
- 시스템에 의해 자동적으로 버퍼의 공간에 저장된 데이터 파일로 출력 v 버퍼의 사용 목적 Ÿ 두 시스템 간의 완충 작용 (CPU와 주변 장치 사이)
Ÿ 두 시스템 사이의 처리 속도 문제 해결
- 필요에 따라 버퍼의 내용을 강제적으로 출력하고자 할 경우에는 fflush 함수를 사용함.

2) fflush 함수
- 버퍼의 내용을 강제적으로 파일에 작성하고 버퍼 비우는 역할 수행
- 함수의 원형 : int fflush(ex)ILE *fp); Ÿ fp : 오픈된 파일의 포인터  C언어  I  ▶ 파일 검사 함수(feof/ferror)

1) feof 함수 : 파일의 끝에 정상적으로 도달했는지의 여부 검사 int feof(ex)ILE *fp); [처리 결과] 함수의 원형
- fp가 파일의 끝에 도달할 경우 : 0이 아닌 값
- 그렇지 않을 경우 : 0 

2) feof 함수 : 파일에 에러가 존재하는지의 여부 검사 int ferror(ex)ILE *fp); [처리 결과] 함수의 원형
- 파일 처리 과정 중 에러 발생 시 : 0이 아닌 값
- 그렇지 않을 경우 : 0 ▶ 기타 파일 조작 함수 (rename / remove)

1) rename 함수 : 파일의 이름을 변경 int rename(char *oldname, char*newname);  함수의 원형
Ÿ oldname : 변경할 파일 이름 
Ÿ newname : 새롭게 변경될 파일 이름

2) remove 함수 : 해당 파일을 삭제 int remove(char*path);  함수의 원형
Ÿ path : 제거할 파일의 경로(이름) v 두 함수 다 정상적 수행 후 결과 값을 0으로, 그렇지 않을 경우 0이 아닌 값을 반환함.  ▶ 텍스트 파일 입출력 함수

1) 텍스트 파일 입출력 함수 : 텍스트로 오픈된 파일의 조작함수
① 단일 문자 입출력 함수 v 함수의 종류
Ÿ int getc( ex)ILE *stream); // 스트림으로부터 한 문자 입력 매크로 
Ÿ int fgetc( ex)ILE *stream); // 스트림으로부터 한 문자 입력 함수 
Ÿ int putc( int c,ex)ILE* stream);   // 스트림에 한 문자 출력 매크로 
Ÿ int fputc( int c,ex)ILE* stream);  // 스트림에 한 문자 출력 함수 v 처리 결과
Ÿ 정상적 수행 : 해당 문자를 반환하고 파일 포인터를 1 증가시킴.
Ÿ 파일의 끝이거나 오류 발생 : EOex)(
-1) 값 반환  C언어  I 
② 단일 문자 입출력 함수 사용 예 ▶ 문자열 입출력 함수 (fgets / fputs) : 텍스트 파일에 대한 문자열 입출력 제공

1) fgets()함수
- 문자열 입력 함수
- 입력 스트림으로부터 n
-1개의 문자를 읽어 들여 문자열 변수에 저장
- 문자열 입력 시 '\n'문자를 만나면 그때까지의 문자열을 저장
- 문자열 마지막에 '\0'문자 자동 포함
- 함수의 원형 : char *fgets( char* string, int n, ex)ILE *stream);  Ÿ string  : 문자열 저장 버퍼 
Ÿ n      : 입력 최대 문자 수 
Ÿ stream  : 입력용 파일 포인터 
Ÿ 반환 값 : 파일의 끝이나 에러 발생시 EOex) 정상적일 경우 저장된 문자열의 주소 
① fgets() 함수 사용 예  C언어  I 
② 입/출력 결과 v test.txt 파일 v 실행화면

2) fputs 함수
- 문자열을 파일에 작성하기 위해 사용
- 문자열을 파일로 출력할 때 문자열의 맨 마지막에 존재하는 '\0' (NULL) 문자는 출력되지  않음.
- 함수의 원형 : int fputs( char *string, ex)ILE *stream);  Ÿ string  : 출력할 문자열 
Ÿ stream  : 출력 대상 파일 포인터 
Ÿ 반환 값 : 에러 발생시 EOex) 발생 정상적인 출력 시 음수가 아닌 값을 반환
① fputs()함수 사용 예  C언어  I  ▶ 형식을 갖춘 파일 입출력 ( fprintf / fscanf )

1) fprintf() 함수
- 형식을 포함하여 파일에 텍스트 문자열 작성
- printf() 함수와 비슷하지만 출력 위치가 파일임.
- 함수의 원형 : int fprintf( ex)ILE* stream, char*format [, argument ]...);  Ÿ stream : 출력 파일 포인터 
Ÿ format : 형식 지정 문자를 포함한 출력 문자열 
Ÿ argument : 인수 리스트 
Ÿ 반환 값 : 정상적인 수행 시 출력한 바이트 수를 리턴 오류 발생 시 음수 값 리턴 

2) fscanf() 함수 ­ 형식을 포함하여 텍스트 파일로부터 값 읽기 ­ scanf와 동일하게 사용되며 표준 입력 장치가 아닌 파일로부터 입력 ­ 표준 입력 장치의 파일의 끝 ( CTRL + Z )
- 함수의 원형 : int fscanf( ex)ILE *stream, char *format [, argument ]... );  Ÿ stream : 입력 파일 포인터 
Ÿ format : 입력 형식 제어 문자열 
Ÿ argument : 인수 리스트 
Ÿ 반환 값 : 정상적인 수행 시 인수의 개수를 반환, 파일의 끝이나 에러 발생시 EOex) 반환 v 두  함수에서  입력  파일  포인터를  stdin(표준  입력)으로  출력  파일  포인터를  stdout(표준  출력)으로 지정 시 scanf()와 printf()함수와 동일한 효과가 발생함. 

3) 형식을 갖춘 파일 입출력 함수 사용 예  C언어  I  ▶ 이진 파일 쓰기와 읽기
1) 텍스트 파일과 이진 파일의 차이점
- 텍스트 파일 : 모든 데이터가 아스키 코드로 변환되어서 저장됨.
- 이진 파일 : 컴퓨터에서 데이터를 표현하는 방식 그대로 저장 ▶ 이진 파일의 생성 모드 설명 “rb" ­ 읽기 모드 + 이진 파일 모드 “wb" ­ 쓰기 모드 + 이진 파일 모드 “ab" ­ 추가 모드 + 이진 파일 모드 “rb+" ­ 읽고 쓰기 모드 + 이진 파일 모드 “wb+" ­ 쓰고 읽기 모드 + 이진 파일 모드 ▶ 버퍼링 ­ fopen()을 사용하여 파일을 열면, 버퍼가 자동으로 만들어짐.  ­ 버퍼는 파일로부터 읽고 쓰는 데이터의 임시 저장 장소로 이용되는 메모리의 블록 ­ 디스크  드라이브는  블록  단위  장치이기  때문에  블록  단위로  입출력을  해야만  가장  효율적 으로 동작함. ­ 1024바이트의 블록이 일반적 ­ 파일과 연결된 버퍼는 파일과 물리적인 디스크 사이의 인터페이스로 사용  C언어  I  ▶ 이진 파일 입/출력 함수 (fread / fwrite)

1) 문자 변환 없이 이진 파일의 입/출력 함수
2) fread 함수
- 이진데이터의 입력 함수
- 함수의 원형 : size_t fread(void *buffer,size_t size,size_t count,ex)ILE *stream );  Ÿ buffer : 저장할 데이터 위치 
Ÿ size : 읽을 데이터의 크기 
Ÿ count : 읽을 데이터의 개수 
Ÿ stream : 읽을 파일 포인터 
Ÿ 반환  값  :  정상적일  경우  읽은  데이터의  개수  파일의  끝이나  오류  발생  시  실제  읽은  데이터의 개수로 count 값보다 작은 값 반환 

3) fwrite 함수
- 이진 파일의 출력 함수
- 함수의 원형 : size_t fwrite(void *buffer,size_t size,size_t count,ex)ILE *stream );  Ÿ buffer : 저장 대상 데이터 위치 
Ÿ size : 작성할 데이터의 크기 
Ÿ count : 작성할 데이터의 개수 
Ÿ stream : 작성할 파일 포인터 
Ÿ 반환 값 : 실제 저장된 데이터의 개수 오류 발생시 count 값보다 작은 값 반환 
① fread와 fwrite 함수 사용 예  C언어  I  4. 파일의 임의 접근 방식 ▶ 임의 접근 파일

1) 순차 접근(sequential access) 방법
- 데이터를 파일의 처음부터 순차적으로 읽거나 기록하는 방법

2) 임의 접근(random access) 방법
- 파일의 어느 위치에서든지 읽기와 쓰기가 가능한 방법 ▶ 임의 접근 파일의 원리

1) 파일 위치 표시자
- 읽기와 쓰기 동작이 현재 어떤 위치에서 이루어지는지를 나타냄. ▶ 임의 파일 접근 함수

1) 임의 파일 접근 함수 (fseek, ftell, rewind)
① 일반적인 파일 입출력 : 순차적 접근 방식
- 순차적으로 값을 읽고 자동적으로 파일 포인터 증가 방식
② 임의 접근 방식
- 읽고자 하는 위치로 파일 포인터 이동 
③ 임의 파일 접근 함수의 종류
- fseek
- ftell
- rewind  C언어  I 

2) fseek 함수
- 파일 포인터를 원하는 위치로 이동시키는 함수
- 함수의 원형 : int fseek( ex)ILE *stream, long offset, int origin );  Ÿ stream : 파일 포인터 
Ÿ offset  : 지정된 시작 위치에서부터 떨어진 바이트의 수 
Ÿ origin  : 시작 위치 
Ÿ 반환 값 : 정상적인 수행 후 파일 포인터 해당 위치로 이동, 결과 값 0 반환, 실패 시  0이 아닌 다른 값 반환
① 시작 위치(origin)의 종류  시작 위치 종류(origin) 의미 매크로 이름 값 SEEK_SET 0 ­ 파일의 최초 시작 위치 SEEK_CUR 1 ­ 파일 포인터가 위치한 현재 위치 SEEK_END 2 ­ 파일의 끝 위치
② fseek 함수 사용 예
- fseek(stream,  100L,  SEEK_SET);  파일의  시작  위치에서  100바이트  떨어진  위치로  파일  포인터 이동
- fseek(stream, 30L, SEEK_CUR); 파일포인터의 현재 위치에서 30바이트 증가된 위치로 파 일 포인터 이동 
- fseek(stream, 
-20L, SEEK_END); 파일의 끝 위치에서 20바이트 감소된 위치로 파일 포인 터 이동

3) ftell 함수
- 현재의 파일 포인터 위치 반환 함수
- 함수의 원형 : long ftell( ex)ILE *stream);  Ÿ stream  : 파일 포인터 
Ÿ 반환 값 : 정상적으로 수행 시 파일 포인터의 현재 위치 반환 실패 시 
-1 값을 반환

4) rewind 함수
- 파일 포인터의 위치를 처음으로 이동
- 함수의 원형 : void rewind( ex)ILE *stream);  Ÿ stream  : 파일 포인터 
Ÿ 반환 값 : 없음 (파일 포인터의 위치를 처음으로 이동)   C언어  I 

5) fseek, ftell 그리고 rewind 함수 사용 예  C언어  I  선행 처리 지시자 1. 선행처리 개념과 활용 방법을 이해한다.  수업목표   2. 선행처리 명령어들을 이해한다.  13주차  3. 매크로 사용법을 이해한다.  1교시 
① 선행 처리기의 의미와 절차 
② 선행 처리 지시자의 종류 세부내용 
③ 매크로의 의미 파악
④ 조건부 컴파일 방법  1. 선행 처리기의 의미와 절차 ▶ 전처리기란?

1) 전처리기(preprocessor)
- 컴파일하기에 앞서서 소스 파일을 처리하는 컴파일러의 한 부분

2) 선행처리기 개념
- 원시 파일을 기계어로 번역하기 전 파일에 대한 부가적인 작업 처리 담당
① 작업 내용 : 외부 파일을 원시 파일에 추가, 문장 치환, 컴파일 대상 선정
② 원시코드에서 실행파일 생성 과정  C언어  I  2. 선행 처리 지시자의 종류 ▶ 선행 처리 지시자 ­ 선행 처리 지시자 : 선행 처리기에 특정 명령 처리 요구 종류 구문 기능 #define ­ 매크로 정의 매크로(Macro) #undef ­ 매크로 정의 해제 외부파일 포함 #include ­ 원시파일에 지시된 외부 파일 포함 #ifdef,#else,#endif ­ 정의된 매크로 기반 조건부 컴파일 #ifndef,#else,#endif ­ 정의되지 않는 매크로 기반 조건부 컴파일 조건부 컴파일 #if, #else, #endif ­ 수식 기반 조건부 컴파일 #if, #elif, #else, #endif ­ 수식 기반 다중 조건부 컴파일 #error ­ 컴파일 중에 발생 가능한 에러메시지 정의 기타 #line ­ 컴파일러에 저장된 라인 속성 변경 ▶ 매크로 지시자

1) 매크로 지시자 (#define, #undef)
- 프로그램에서 자주 사용되는 문자열에 대해 의미 있는 이름을 부여하는 방식
- 프로그램의 운영성과 가독성을 증대
- 매크로 문장은 선행처리기에 의해 기계어 코드 변환 전에 모두 치환됨. 

2) 매크로 지시자의 종류
- 매크로 정의 지시자 : #define
- 매크로 해제 지시자 : #undef ▶ 매크로 정의 지시자

1) 매크로 정의 지시자 
- #define
① 매크로 정의 지시자의 종류 인수가 없는 매크로 정의
- 형식 : #define [매크로 이름] [치환 문자열] 인수를 가진 매크로 정의
- 형식 : #define [매크로 이름](인수리스트) [치환문자열]

2) 매크로 정의 규칙
- 매크로 이름은 일반변수와 구별하기 위해 주로 대문자를 많이 사용함.
- 매크로 이름 지정 시 공백을 포함해서는 안 됨. 
- 치환 문자열이 한 행에 기술하기 힘들 경우 치환문자열 마지막에 "\"을 표시하고 다음 행 에 연결해서 작성할 수 있음.   C언어  I 
- 매크로는 단순 치환의 의미를 가짐. 
- 인수리스트를 가진 매크로는 인수와 "()"사이에 공백이 존재해서는 안 됨.  ▶ 인수가 없는 매크로
- 단순 치환의 의미
- 프로그램에서 자주 사용되는 문자열에 의미 부여
① 사용 예 ▶ 외부파일 포함 지시자 (#include)
- 외부파일을 원시파일에 포함시키는 지시자
- 주로 원시 파일에 헤더파일 정보 포함시키기 위해 사용
① 사용 형태
- 미리 정의된 위치의 시스템 파일을 포함시킴. #include <외부파일명>
- 예> #include <stdio.h> , #include <stdlib.h>
- 사용자에 의해 필요한 기타 파일을 포함시킴.
- 드라이버나 폴더 정보 포함 가능 #include "외부파일명" ▶ 조건부 컴파일 지시자

1) 조건부 컴파일 지시자
- 특정 상황에 맞는 원시 코드 컴파일 대상 분리 목적
- 조건 제어 구조와 비슷한 형식
① 조건부 컴파일 지시자 사용 방법 ­ 매크로 정의 기반의 조건부 컴파일 사용 : 매크로 정의 여부를 이용한 컴파일 대상 선정 ­ 수식 기반의 조건부 컴파일 사용 : 수식 결과에 대한 컴파일 대상 선정

2) #ifdef 
- 어떤 조건이 만족되었을 경우에만 컴파일하는 조건부 컴파일 지시  C언어  I 

3) #ifdef의 예
4) 예제  C언어  I 
5) 비주얼 C++에서 설정하는 방법
6) #if
- 기호가 참으로 계산되면 컴파일
- 조건은 상수이어야 하고 논리, 관계 연산자 사용 가능

7) #if
-#else
-#endif  C언어  I 

8) 예
9) 다양한 예  C언어  I  ▶ 기타 지시자
1) #error 지시자
- 컴파일 시 에러 메시지를 발생시키기 위한 지시자
- #if, #infdef 구문과 함께 주로 사용됨.
- 형식 : #error [출력 메시지]
- 컴파일 과정에서 이 문장을 만나면 더 이상 컴파일 하지 않고 에러메시지 출력 후 종료함.
① 사용 예

2) #line 지시자
- 컴파일러가 내부적으로 저장하고 있는 라인 번호와 파일 이름값 변경
- 사용 형식 : #line [라인번호] "[파일이름]"
① 사용 예
- 05라인 이후 컴파일러에게 라인번호와 이름을 강제적으로 변경 3. 매크로의 의미 파악 ▶ 단순 매크로

1) 단순 매크로(macro)
- 숫자 상수를 기호 상수로 만든 것
① 예  C언어  I 

2) 단순 매크로의 장점
- 프로그램의 가독성을 높임.
- 상수의 변경이 용이함. Ÿ 리터럴 상수를 사용하는 경우 : 등장하는 모든 곳을 수정해야 함.
Ÿ 기호 상수를 사용하는 경우 : 기호 상수가 정의된 곳만 수정하면 됨.

3) 단순 매크로의 예  C언어  I  ▶ 함수 매크로
1) 함수 매크로(function
-like macro)
- 매크로가 함수처럼 매개 변수를 가지는 것
① 예

2) 함수 매크로의 예
3) 주의할 점  C언어  I  ▶ 함수 매크로 예제 ▶ 함수 매크로의 장단점
1) 함수 매크로의 장단점 ­ 함수 호출 단계가 필요 없어 실행 속도가 빠름.  ­ 소스 코드의 길이가 길어짐.
2) 간단한 기능은 매크로를 사용 ▶ #, ## 연산자
- 매크로에서 # 연산자는  문자열로 변환(치환) 시켜주는 연산자 # 연산자
- #은 받아온 매크로 변수를  문자열로 바꿔줌. 즉, 따옴표를 붙여줌.
- ##은 두 개의 토큰을 이어줌. ## 연산자
- 임의의 변수나 함수를 만들어내는데  활용함.  C언어  I  ▶ 설정된 매크로 해제 ­ 이미 설정된 매크로를 해제 ­ 사용 형식 : #undef [매크로 이름] ­ #undef 문이 선언된 위치부터 해당 매크로는 더 이상 사용되지 않음. ­ 프로그램 안에 동일한 매크로 이름이 여러 개 존재할 경우 가장 최근에 정의된 매크로 해제 4. 조건부 컴파일 방법 ▶ 조건부 컴파일을 이용하는 디버깅 ▶ 다수의 라인을 주석처리  C언어  I  ▶ 헤더 파일 이중 포함 방지 ▶ 예제

1) 정렬 알고리즘을 선택  C언어  I  사용자 라이브러리 파일 만들기 1. 사용자 헤더파일 작성과 활용법에 대해 이해한다.  13주차  수업목표   2. 사용자 라이브러리 파일을 만들어 본다.  2교시 
① 사용자 라이브러리 파일의 의미  세부내용 
② 사용자 라이브러리 파일 제작 과정  1. 사용자 라이브러리 파일의 의미 ▶ 다중 소스 파일 ­ 파일의 크기가 너무 커짐. 단일 소스 파일 ­ 소스 파일을 다시 사용하기가 어려움. ­ 서로 관련된 코드만을 모아서 하나의 소스 파일로 할 수 있음. 다중 소스 파일 ­ 소스 파일을 재사용하기가 간편함.  C언어  I  ▶ 예제 ▶ 헤더 파일을 사용하지 않으면 ▶ 헤더 파일을 사용하면  C언어  I  ▶ 다중 소스 파일에서 외부 변수 ▶ 비주얼 C++에서 다중 소스 파일 2. 사용자 라이브러리 파일 제작 과정 ▶ 사용자 라이브러리 파일 만들기

1) 헤더파일(*.h)와 라이브러리 파일(*.lib)
① 헤더 파일
- 함수의 원형을 관리
② 라이브러리 파일
- 함수의 구현 부분을 관리
- 원시 코드 형태가 아닌 이진 파일 형태  C언어  I 
③ 프로그램에서 라이브러리 파일 사용
- 프로그램 내에 라이브러리 파일에 대한 헤더파일 선언
- 사용 예 : #include <stdio.h>
④ 컴파일
- 라이브러리 파일의 구현 부분을 고려하지 않고 함수 원형만으로 컴파일
⑤ 링크
- 함수의 원형과 실제 함수 구현 부분과의 연결 수행
⑥ 라이브러리 파일 제공 목적
- 소스 코드에 대한 보호와 관리 용이

2) 라이브러리 파일의 종류 ­ 라이브러리  정보를  각  프로그램마다  서로  독립적인  메 정적 라이브러리 파일 (*.lib) 모리 공간에서 이용 동적 라이브러리 파일 (*.dll) ­ 라이브러리 정보를 공통의 메모리 공간을 통해 이용
3) 라이브러리 파일 구현
- 대상 : 정적 라이브러리 파일 만들기
- 개발 도구 : Visual Studio 이용 ▶ 각 단계별 진행 과정

1) 1단계
Ÿ [파일]  →  [새로  만들기]  →  [프로젝트]  →  [Win32  콘솔  응용프로그램]  선택  후  파일  정보 입력

2) 2단계
Ÿ 선택 다이얼로그에서 정적 라이브러리 선택 후 마침 클릭  C언어  I 

3) 3단계
Ÿ 앞 단계에서 완료를 클릭하면 파일들이 생성됨.
Ÿ 맨 하단의 프로젝트 디렉토리 위치 확인할 것

4) 4단계
Ÿ 프로젝트에 프로그램 추가 단계로 먼저 라이브러리 함수로 사용할 함수의 원형 정의를  위해 해더파일(*.h)을 생성하자.
Ÿ [솔루션 탐색기]에서 해더 파일에서 오른쪽 마우스 버튼 클릭 후  → [추가] →[새 항목] 선택 후 comlib.h 파일 생성  C언어  I 

5) 5단계
Ÿ 헤더 파일에 함수 원형을 작성하자.  정수형 사칙 연산에 대한 함수 원형을 다음과 같이 작성한 후 저장하자.

6) 6단계
Ÿ 구현 파일을 만들어 보자.  [솔루션 탐색기]에서 소스 파일에서 오른쪽 마우스 버튼 클릭 후 → [추가] → [새 항목] 선택 후 comlib.c 파일 생성  C언어  I 

7) 7단계
Ÿ 6단계에서 만든 파일에 아래의 함수 구현코드를 작성한자.

8) 8단계
Ÿ 함수의 구현이 완료되면 컴파일과 빌드 작업을 수행하자.
Ÿ 정상적인  수행  후  프로젝트의  [Debug]  디렉토리  아래에  프로젝트  이름으로  만들어진  정적 라이브러리 파일을 발견할 수 있을 것임.
Ÿ 예제 → common.lib

9) 9단계  C언어  I 
Ÿ 함수의 구현이 완료되면 컴파일과 빌드 작업을 수행하자.
Ÿ 정상적인  수행  후  프로젝트의  [Debug]  디렉토리  아래에  프로젝트  이름으로  만들어진  정적 라이브러리 파일을 발견할 수 있을 것임.
Ÿ 예제 → common.lib
- 이 단계들을 통해 정적 라이브러리 파일을 만들었음.
- 이 라이브러리 파일을 사용 시 2개의 파일이 사용됨.   
① 헤더파일 예제 → comlib.h   
② 라이브러리 파일 예제 → common.lib
- 9단계부터는 이 라이브러리 사용 단계를 보여줌.

10) 10단계
Ÿ “빈 프로젝트”를 선택하고 프로젝트 이름을 uselib로 프로젝트를 만들자.

11) 11단계
Ÿ 정적 라이브러리를 사용할 C 파일을 생성하자.
Ÿ [파일] → [새로 만들기] → [파일] 선택 후 다이얼로그에 libtest.c 입력  C언어  I 

12) 12단계
Ÿ 이전에  만든  라이브러리  파일을  사용하기  위해  이전  프로젝트  폴더에서  두  개의  파일 (common.lib,comlib.h)을 복사하여 현재 프로젝트의 폴더 위치에 lib폴더를 만들고 그 곳에 복사하자. 

13) 13단계
Ÿ 프로젝트에서 이 라이브러리을 사용하기 위한 환경을 설정하자.
Ÿ [프로젝트] → [속성] 선택 후 아래와 같은 다이얼로그에서 [링커] 탭 선택  →  [입력]  클릭
Ÿ [추가  종속성]  텍스트  필드의  맨  끝에  사용할  라이브러리  이름  추가  →  lib/common.lib
Ÿ 추가 후 [확인] 버튼 선택
Ÿ 이 과정을 통해 프로젝트와 라이브러리 파일이 연결됨
Ÿ 화면 캡처 → 다음 장

14) 14단계
Ÿ 프로젝트 속성 다이얼로그 화면  C언어  I 

15) 15단계
Ÿ 이전 11단계에 만든 libtest.c 파일에 다음과 같이 작성 후 저장하자.

16) 16단계
- 컴파일과 빌드 과정 처리 후 실행하여 결과를 확인하자.
- 출력 결과  C언어  I  표준 라이브러리 함수 1. 문자 관련 함수에 대해 알아본다.  수업목표   2. 자료 변환 관련 함수에 대해 알아본다.  14주차  3. 시간 및 날짜 관련 함수에 대해 알아본다.  1교시 
① 표준 라이브러리 파일들 세부내용 
② 문자, 자료 변환 함수
③ 시간 관련 함수들 1. 표준 라이브러리 파일들 ▶ 표준 라이브러리 함수

1) 표준 라이브러리 헤더파일들 헤더파일 이름 설명 포함된 함수 종류 입출력 공통 함수 fopen, fclose, feof, ferror, clearerr printf, fprintf, sprintf, scanf, fscanf,  형식화된 입출력 함수 sscanf 표준 fgetc,  fputc,  getc,  getchar,  putc,  stdio.h 입출력 문자 입출력 함수 putchar, ungetc 함수 문자열 입출력 함수 gets, puts, fgets, fputs 파일 입출력함수 fread, fwrite, fseek, ftell, rewind 파일 제어 함수 remove, rename, tmpfile, tmpnam 수학 관련 함수 abs, div, labs, ldiv, rand, srand 메모리 관리 함수 calloc, free, malloc, realloc 공통 stdlib.h 제어 함수 exit, abort, atexit, system 함수 atof,  atoi,  atol,  strtod,  strtol,  변환 함수 strtoul strcpy,  strncpy,  strcat,  strncat,  문자열 복사 관련 함수 memcpy, memmove  문자열 string.h strcmp,  strncmp,  strstr,  strpbrk,  함수 문자열 비교 함수 strchr, strrchr, memchr, memcmp 문자열 길이 관련 함수 strlen, strspn, strcspn 문자 관련 isalnum,  isalpha,  iscntrl  isdigit,  isgraph,  islower,  isprint,  ctype.h 함수 ispunct, isspace, isupper, isxdigit, tolower, toupper ceil,  exp,  fabs,  floor,  fmod,  frexp,  ldexp,  log,  log10,  수학 관련 math.h modf,  pow,  sqrt,  sin  sinh,  asin,  cos,  cosh,  acos,  tan,  함수 tanh, atan, atan2  시간 관련 clock,  time,  ctime,  asctime,  gmtime,  localtime,  difftime,  time.h 함수 mktime  C언어  I  2. 문자, 자료 변환 함수 ▶ 문자 관련 함수
1) 문자 관련 함수 : ctype.h 파일에 정의된 함수 v 함수와 함수 원형 함수 이름 함수 원형 설명/결과 문자가 영문자이거나 숫자인지 검사 isalnum int isalnum(int char_data); 참인 경우 0이 아닌 값을,  거짓인 경우 0값 반환 문자가 영문자인가 검사  isalpha in isalpha(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0값 반환 문자가 제어문자인가를 검사  iscntrl int iscntrl(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0값 반환 문자가 숫자인지를 검사 isdigit int isdigit(int char_data); 참일 경우 0이 아닌 값을,  거짓인 경우 0값 반환 공백을 제외한 프린트 가능 문자인지 검사 isgraph int isgraph(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0값 반환 문자가 소문자인지를 검사 islower int islower(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0값 반환 공백을 포함한 프린트가능 문자인지를 검사 isprint int isprint(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0값 반환 스페이스나 영문자,  숫자가 아닌 프린트 기능 문자인지 검사 ispunct int ispunct(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0값 반환 스페이스 문자인지를 검사 참인 경우 0이 아닌 값을,  거짓인 경우 0값 반환 isspace int isspace(int char_data); v 스페이스 문자  스페이스('  '),  form
-feed  ('\f'),  뉴  라인  ('\n'),  캐리지  리턴  ('\r'),  수평  탭  ('\t'), 수직 탭 ('\v') 등을 포함함.  C언어  I  문자가 대문자인지를 검사 isupper int isupper(int char_data); 참일 경우 0이 아닌 값을,  거짓인 경우 0값 반환 16진수인지를 검사 isxdigit int isxdigit(int char_data); 참일 경우 0이 아닌 값,  거짓인 경우 0(16진수 : 0~9, A~ex)) 문자를 소문자로 변환함.  tolower int tolower(int char_data); 반환이 가능하지 않을 경우  입력된 값을 다시 반환함. 문자를 대문자로 변환함.  toupper int toupper(int char_data); 반환이 가능하지 않을 경우  입력된 값을 다시 반환함.

2) 문자 관련 함수 사용 예
- 문자 데이터의 입력을 통해 영문자나 숫자인지 판단 Ÿ 영문자일 경우 소문자를 대문자로, 대문자를 소문자로 변환
Ÿ 숫자일 경우 입력된 숫자 정보 출력 ▶ 자료 변환 함수 ­ 특정 자료형을 다른 자료형으로 변환 ­ stdlib.h 파일에 정의 ­ 문자나 문자열의 값을 숫자 값으로 변환하기 위해 주로 사용  C언어  I  ▶ 자료 변환 함수 종류

1) 자료 변환 함수들과 함수 원형 함수 이름 함수 원형 설명/결과 atoi intatoi(char*char_num); ­ 문자열 값을 정수(int) 값으로 변환  atol longatol(char *char_num); ­ 문자열 값을 정수(long) 값으로 변환 atof double atof(char*char_num); ­ 문자열 값을 실수(double)값으로 변환 ­ 문자열 입력 받아 실수(double)값으로 변환
Ÿ str : 입력 문자열 double strtod
Ÿ 반환 : 입력 문자열에서 첫 번째 실수 값  strtod (char *str, char **next_str)
Ÿ next_str  :  반환  이후  나머지  문자열의  주 소 또는 에러 발생시 입력 문자열에서 에러  발생 위치 ­ 문자열을 입력 받아 정수(long)값으로 변환
Ÿ str : 입력 문자열 long strtol
Ÿ 반환 : 입력 문자열의 첫 번째 정수 값 strtol (char *str, char **next_str, 
Ÿ next_str  :  정수  값을  제외한  나머지  문자 int base) 열의  주소  또는  에러  발생  시  문자열에서  에러 발생 위치
Ÿ base : 진법 형식(2, 8, 10, 16진법) unsigned long strtoul ­ 문자열 입력 받아  strtoul (char *str, char **next_str,  양의 정수(unsigned long) 값으로 변환.  int base)
Ÿ 입력 형식은 strtol과 동일

2) 자료 변환 함수 사용 예  C언어  I 
3) 자료 변환 함수 사용 예 (문자 → 숫자) 3. 시간 관련 함수들 ▶ 시간 관련 함수
1) 시간 관련 함수 ­ 현재의 날짜나 시간 정보 계산 함수 ­ time.h파일에 정의 함수 이름 함수 원형 설명/결과 ­ 프로그램이  시작  후  경과한Clock의  수를  반 clock clock_t clock(void); 환 ­ 현재 시간을 조사하여  time time_t time(time_t *t); 1970년 1월 1일 자정 이후 경과된 초를  반환 ­ time_t 값 이용해 현재 시간을 문자열로  ctime char *ctime(time_t *t); 반환 struct tm  ­ time_t 값 이용해 그리니치 표준 시간에  gmtime *gmtime(time_t *t); 대한 구조체 타입(struct tm) 반환 struct tm  ­ time_t 값 이용해 지역 시간에 대한 구조체  localtime *localtime(time_t *t); 타입(struct tm) 반환 char  ­ 시간 구조체 타입을 이용해 시간에 대한  asctime *asctime(struct tm *t); 문자열 반환 double difftime ­ 두 time_t 값의 차를 초 단위로 반환 difftime (time_t et, time_t st); ­ et : 종료 시간, st : 시작시간 (반환 : et
-st) time_t mktime ­ struct tm 구조체 값을 이용해 time_t 값  mktime (struct tm *t) 반환  C언어  I 

2) clock()함수 활용 예
3) time과 ctime 함수 활용 예
- 시스템의 현재 시간을 얻어옴.  time 함수 
- time_t 값 반환 : 1970년 1월 1일 자정 이후 경과된 초 ctime 함수
- time_t 값을 이용해 현재 시간을 문자열로 변환 v 사용 예  C언어  I 

4) gmtime, localtime 그리고 asctime 함수 사용
① gmtime 함수
- struct tm *gmtime(time_t t);
- time_t의 시간 값을 이용해 그리니치 표준 시간에 대한 struct tm의 구조체 형태의 값 제공
② struct tm 구조체 형식
③ localtime 함수
- struct tm *localtime(time_t t);
- 지역 시간에 대한 struct tm 구조체 값 생성
- 사용형태는 gmtime과 동일
④ asctime 함수
- struct tm 구조체 값을 이용해 시간에 대한 문자열 제공
- 반환된 문자열은 총 26자릿수로 구성
⑤ 반환 문자열 구조

5) gmtime, localtime 그리고 asctime 함수 사용 예
- 프로그램 실행 시의 현지 시간과 표준 시간 출력 프로그램  C언어  I  ▶ 문자, 변환, 시간 관련 함수 활용

1) 토큰 분류 프로그램
① 문제 정의
- 수치  정보를  전문적으로  취급하는  회사에  수치  정보를  포함하는  문자열  처리  주문이  들어 왔다. 그러나 이러한 수치 데이터는 노이즈 현상에 의해 수치 정보 사이에 잘못된 문자들이  섞여  있다. 이러한 수치 정보의 잘못된 문자들을 제거하여 순수 숫자만으로 형성된 문자열 로 재구성하고 이들 문자열 수치 정보를 변환하여 그 수치 값들의 합을 구하는 프로그램을  작성해 보아라. 또한  이 프로그램의 시작에서 종료시점까지의 소요 시간도 함께 확인할 수  있는 프로그램을 작성하여라. 
② 입/출력 조건 ­ 노이즈가 포함된 숫자 형식의 문자열(구분 스페이스)  입력 조건 ­ 예> a34.5 ba343vd2.3 dvd
-24.3 340a 3w1.543 ­ 노이즈를 제거한 숫자형식의 문자열  ­ 예> 34.5 3432.3 
-24.3 340 31.543  출력 조건 ­ 숫자 형식의 문자열을 실수 값으로 변환 후 계산된 총합  ­ 이 프로그램의 총 수행 시간 
③ 관련 함수 및 식 v 사용되는 표준 함수 
- 표준 입출력 함수(stdio.h)   : getchar(), printf() 
- 문자 관련 함수(ctype.h)      : isdigit(), isspace() 
- 시간 관련 함수(time.h)       : time(), difftime() 
- 데이터 변환 함수(stdlib.h)   : strtod()  
④ 알고리즘 (또는 플로우차트) 1.1 프로그램 시작 시간을 설정  1.2 노이즈가 포함된 수치 정보 입력 (각 수치 정보는 스페이스로 구분되고 실수 값으로 존재함.) 

1. 노이즈를 포함한 
Ÿ 1.2.1 각 문자를 입력 받음.  문자열 입력 
Ÿ 1.2.2 문자가 숫자, '.', '
-' 이거나 스페이스인지 판단 
Ÿ 1.2.3 위의 조건을 만족한 문자들에 대해서만 저장 
Ÿ 1.2.4 문자열이 종료될 때까지 1.2.1부터 반복  1.3 노이즈 제거한 수치 리스트 출력 

2. 수치 문자열을  실수형 배열로 변환  3. 총합 계산 4.1 총합을 출력함.
4. 총합 및  4.2 종료 시간을 설정함. 소요시간 출력 4.3 시작과 종료 사이의 총 수행시간을 출력함.  C언어  I 
⑤ 프로그램 작성  C언어  I 
⑥ 테스트
- 프로그램의 정상적인 컴파일 후 아래의 조건에 대한 결과 입력 조건 출력 결과 초기 입력 문자열 : a34.5  ba343vd2.3  dvd
-24.3  340a 3w1.543 초기 입력 문자열 : a
-234.5  v3a1.3v  d2.3  dv
-24.3  56.40a 
-3w2.43 s254.1 345 초기 입력 문자열 : 495  343.2as  bdw
-2a.2b 
-43.1  231.ac32  C언어  I  수학 관련 함수 1. 수학 관련 함수에 대해 알아본다.  14주차  수업목표   2. 기타 자주 사용되는 함수들에 대해 알아본다.  2교시 
① 빈번하게 사용되는 수학 관련 함수들 세부내용 
② 삼각 함수 및 산술 관련 함수들 1. 빈번하게 사용되는 수학 관련 함수들 ▶ 수학 기초 함수

1) 수학 기초 함수 ­ stdlib.h 파일에 정의된 함수 ­ 절대값, 몫과 나머지 계산, 임의 값 발생 함수 등 함수 이름 함수 원형 설명/결과 abs int abs(int x); ­ 입력 x에 대한 절대 값 반환(int 값 대상) labs long labx(long x) ­ 입력 x에 대한 절대 값 반환 (long값 대상) ­ x를 y로 나눈 몫과 나머지를  div div_t div(int x, int y); div_t 타입으로 반환(int값 대상) ­ x를 y로 나눈 몫과 나머지를  ldiv ldiv_t ldiv(int x, int y); div_t타입으로 반환(long 값 대상) ­ 0에서 RAND_MAX 사이의  rand int rand(void) 임의의 정수 값 반환(RAND_MAX=32756) srand void srand(unsigned seed); ­ rand 함수의 난수 발생시작 값(seed)설정
2) div함수(ldiv 함수)
- 몫과 나머지 계산 함수
- div_t 타입의 구조체 값 반환
① div_t 구조체 타입 형태 div_t 구조체 타입  ldiv_t 구조체 타입   C언어  I 

3) srand, rand 그리고 div 함수 활용 예
- rand함수를 이용해 임의의 정수 값 발생 후 div 함수를 통해 15로 나눈 몫과 나머지 계산
- 난수 발생 값을 초기화하기 위해 srand 이용  2. 삼각 함수 및 산술 관련 함수들 ▶ 산술 및 삼각 함수 ­ math.h 파일에 정의 ­ 주로 실수(double)형의 값을 다룸. ­ 지수, 삼각함수, 제곱근, N제곱과 같은 함수들로 구성 함수 이름 함수 원형 설명/결과 ­ x보다 작지 않은 가장 작은 정수 값  ceil double ceil (double x); double형으로 반환 (예 : x=3.2 결과 = 4.0) exp double exp(double x); ­ 베이스가 자연 로그인 e인 x 제곱 값을 반환 fabs double fabs(double x); ­ 실수 값에 대한  절대 값 반환  ­ x보다 크지 않은 가장 큰 정수 값을  floor double floor(double x); double형으로 반환 (예 : x=3.7 결과 = 3.0)  double fmod fmod ­ x을 y로 나눈 실수 형 나머지를 반환 (double x, double y); double frexp frexp ­ 실수 값에 대한 가수와 지수 값을 반환 (double x, int *eptr); double ldexp ldexp ­ 가수와 지수로부터 실수 값을 반환 (double x, int exp); log double log(double x); ­ x의 자연 로그를 반환 ­ 베이스가 10인 x의  log 10 double log10(double x); ­ 로그(상용로그) 값을 반환  ­ 실수를  소수점을  기준으로  둘로  나눈  결과  반환.  double modf x : 처리대상 실수  modf (double x, double *y); y : 처리 후 반환된 정수부  반환 : 소수부  C언어  I  double pow pow ­ x의 y 승 값을 반환  (double x, double y); ­ x의 0이 아닌 제곱근()반환.  sqrt double sqrt(double x); ­ 만일 x가 음수면 에러 발생 ­ x의 사인 값을 반환하며,  sin double sin(double x); x는 라디안으로 주어진 값임.  ­ x의 쌍곡선 사인 값을 반환,  sinh double sinh(double x); (exp(x) 
- exp(
-x)) / 2 의미 ­ x의 아크 사인 값을 계산.  asin double asin(double x); x의 범위가 
-1에서 1사이를 벗어나면 에러 발생 ­ x의 코사인 값을 반환,  cos double cos(double x); x는 라디안으로 주어진 값임. ­ x의 쌍곡선 코사인 값을 반환하며,  cosh double cosh(double x); (exp(x) + exp(
-x)) / 2의미 ­ 코사인의 역함수로 x의 아크 코사인 값을 반환.  acos double acos(double x); ­ x값이 범위(
-1부터 1까지)를 벗어나면 에러 발생 ­ x의 탄젠트 값을 반환. tan double tan(double x); ­ x는 라디안으로 주어진 값임. ­ x의 쌍곡선 탄젠트 값 반환,  tanh double tanh(double x); 수학적으로 sinh(x) / cosh(x) atan double atan(double x); ­ x의 아크 탄젠트 값을 계산 double atan2 atan2 ­ x와 y라는 두 변수의 아크 탄젠트 값 반환 (double y, double x); ▶ 수식관련 함수 사용 예

1) 수식관련 함수 사용 예 (ceil, floor, pow, sqrt, …)
- 프로그램을 작성하고 어떤 결과가 나오는지 확인하자.  C언어  I 

2) 실행 결과 fmod(10.4,3.2)= 0.80, fabs(
-2.8) = 2.8 pow(10.4,3.2)= 1796.83, sqrt(10.4) = 3.22 ceil(3.2) = 4.0, floor(
-2.8)= 
-3.0 modf(
-2.8,&b)= (정수부 : 
-2.00 소수부 : 
-0.800) log(8000.0) = 8.9872, log10(8000.0) = 3.9031 계속하려면 아무 키나 누르십시오 ... ▶ 삼각 함수 사용

1) 삼각 함수 (sin,cos,tan) 사용 
- 삼각 함수는 라디안(radian) 값을 이용해 값을 구함. v 각도와 라디안 값의 관계
① 원주율(PI)을 180으로 나눈 값을 각도로 곱하면 라디안 값 
② 각도를 라디안으로 변환 : 각도 * (PI / 180) 
③ 라디안을 각도로 변환   : 라디안 * (180 / PI)  

2) 삼각 함수 사용 예
- 30도의 각도에 대한 삼각 함수(sin,cos,tan) 계산 
- 프로그램을 작성하고 계산 결과를 확인하자.  C언어  I  ▶ 수학 관련 함수 활용 : 공학용 계산기 프로그램

1) 문제 정의
- 공학 프로그램을 개발하는 과정에 수식이 자주 이용된다.  이러한 수식을 계산할 수 있는 프로그램을 만들어 보자.  이  계산기가  가지는  기능은  두  실수  값에  대한  연산을  처리하고  그  결과를  반환하는  것이 다. 처리할 연산은 N제곱, 제곱근, 각도에 대한 sin, cos, tan값과 로그 값들이 처리된다. 

2) 입/출력 조건 ­ 계산을 위한 실수 값에 대한 문자열  ­ N제곱(pow) 선택 시 N 값  입력 조건 ­ 값들은 문자열로 입력되기 때문에 실수형(double)으로 변환 필요  ­ 삼각 함수 값은 각도로 입력함. (0 ~ 360도)    출력 조건 ­ 각 연산에 대한 계산 결과
3) 관련 함수 및 식
① 문자열을 실수형으로 변환 함수 double atof(char *buf); // <stdlib.h> 
② 연산 처리를 위한 함수 double pow(double x, double y); // <math.h> N제곱 계산  double sqrt(double x) ;  // <math.h> 제곱근 계산  double sin(double x);   // <math.h>  double cos(double x);  // <math.h>  double tan(double x);  // <math.h>  double log(double x);   // <math.h> 자연로그 계산  double log10(double x); // <math.h> 상용로그 계산   C언어  I 

4) 알고리즘(또는 플로우차트) 1.1 계산 값 실수 문자열로 입력 (삼각함수 : 계산용 각도 입력)
1. 계산 값 입력 1.2 실수 형으로 문자열 변환 1.3 값이 정확하지 않을 경우 1.1부터 반복
2. 연산자 선택 [1:pow, 2:sqrt, 3:sin, 4:cos,  5:tan, 6:log, 7:log10]  3.1 pow 연산일 경우 3.1.1 N제곱의 N값 입력 3.1.2 pow 계산 3. 산술 연산일 경우  3.2 sqrt 연산일 경우    [1,2]  3.2.1 입력 값 음수인지 판단 3.2.2 음수일 경우 에러 메시지 3.2.3 음수 아닐 경우 제곱근 계산 4.1 각도를 라디안 값으로 변환 4.2 sin 함수일 경우  4.2.1 sin 값 계산
4. 삼각함수 연산일 경우 4.3 cos 함수일 경우  [3,4,5] 4.3.1 cos 값 계산 4.4 tan 함수일 경우  4.4.1 tan 값 계산  5.1 자연로그 계산일 경우  5.1.1 자연로그 값 계산 
5. 로그 연산일 경우 [6,7] 5.2 상용로그 계산일 경우  5.2.1 상용로그 값 계산 
6. 계산 결과 출력  C언어  I 
5) 프로그램 작성  C언어  I   C언어  I 
6) 테스트
- 프로그램이 정상적으로 동작하면 다음 입력에 대한 결과 작성 입력 조건 출력 결과 입력 내용       값 : 5.2       오퍼레이션 : 1 (pow)       N 값 : 6.4 입력 내용      값 : 45.7      오퍼레이션 : 2 (sqrt) 입력 내용      값 : 75      오퍼레이션 : 3 (sin) 입력 내용      값 : 56      오퍼레이션 : 5 (tan)  입력 내용      값 : 93000      오퍼레이션 : 7 (log10) 
