운영체제 www.smart.ac.kr 강  의  교  안 운영체제 운영체제 www.smart.ac.kr 운영체제의 개요(1)

1. 본 학습내용에 대한 전반적인 내용을 알 수 있다. 1주차  수업목표  
2. 컴퓨터 시스템 중요 구성요소에 대해 알 수 있다. 1교시 
1. 운영체제의 소개 세부내용 
2. 컴퓨터 시스템 구성요소 1. 운영체제의 소개 ㆍ 컴퓨터 시스템
- Windows, Linux, Unix ㆍ 스마트폰 시스템
- Android, Ios ㆍ 운영체제 (Operating System)
- 컴퓨터를 동작시키는 Software ▶ 컴퓨터 시스템 ­ 하드웨어(Hardware)와 소프트웨어(Software)로 구성 ㆍ 하드웨어(Hardware)
- 데이터를 처리하는 물리적인 기계 장치
- 프로세서(중앙처리장치), 버스, 메모리 등 다양한 주변장치로 구성 ㆍ 소프트웨어(Software)
- 특별한 작업 지시를 위해 명령어로 작성한 프로그램 ㆍ 운영체제
- 컴퓨터 하드웨어와 사용자 사이에 위치
- 하드웨어와 소프트웨어 자원을 관리하는 프로그램 ▶ 컴퓨터 시스템의 핵심 요소와 운영체제 CPU RAM HDD 중앙처리장치 주기억장치 보조기억장치 컴퓨터 시스템의 핵심 요소 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 2. 컴퓨터 시스템 구성요소 ▶ 프로세서(Processor) ­ 운영체제와 가장 밀접한 하드웨어 · 각 부분의 동작 제어 및 연산 수행 ­ 중앙처리장치(CPU: Central Processing Unit) · 레지스터, 산술 논리 연산장치, 제어장치 등으로 구성 ­ 마이크로프로세서(Microprocessor) · 주기억장치를 제외한 레지스터, 산술 논리 연산장치, 제어장치를 칩 하나로 구성 · 개인용 컴퓨터(PC: Personal Computer)에서 주로 이용 프로세서 레지스터 제어장치 산술 논리 연산장치 데이터 경로 제어 부분 (데이터 부분) 시스템 프로세서 구성요소 ▶ 버스(Bus) ­ 프로세서를 포함한 각 장치 간  또는  서브시스템을  서로  연결하여  정보(데이터)를  주고받을  수 있게 해주는 통로 · 컴퓨터 내부 각 요소의 다양한 신호 ­ 데이터 입출력 신호, 프로세서 상태신호, 인터럽트 요구와 허가 신호, Clock 신호 등) 는 공동 통신 채널, 즉 버스를 통해 전달됨 ㆍ 버스의 위치에 따른 분류
① 내부 버스
- 프로세서 내부에서 레지스터, 연산장치, 메모리와의 인터페이스 등 연결
- 시스템 버스 인터페이스 회로를 통해 외부 버스와 연결
② 외부 버스
- 프로세서와 메모리, 프로세서와 입출력장치, 입출력장치와 입출력장치연결
- 시스템 버스라 부르며 각 시스템 버스는 버스 제어기라 불리는 제어 회로를 가짐 ㆍ 버스의 기능에 따른 분류
① 데이터 버스
- 컴퓨터 시스템에서 데이터(자료), 명령어 등의 정보를 교환하는 전송로
- 프로세서에서 메모리나 입출력 장치로 데이터 출력 또는 반대로 데이터를 입력 받을  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 때 사용하는 양방향 버스
- 데이터 버스 신호선의 수가 해당 프로세서의 워드 길이와 같으므로 프로세서 성능을  결정
② 주소 버스
- 하나의 시스템 장치에서 다른 장치로 주소 정보를 전송하기 위해 사용
- 신호(주소)선의 수에 따라 최대 사용 가능한 메모리 용량이나 입출력장치 수를 결정
③ 제어 버스
- 프로세서가 저장장치와 입출력장치에 데이터를 전송할 때, 현재 수행중인 작업 종류 나 상태를 다른 장치에 알릴 때 이용하는 단방향 버스 데이터 버스와 주소 버스는 병렬 비트로 전송 모든 회선은 동일한 역할 수행(동일한 데이터/주소를 나타냄) 데이터 버스 프로세서 주소 버스 제어 버스는 각 회선이 독립된 역할 수행 제어 버스 (하나는 디스크 제어, 하나는 프린터 제어 등) 기능에 따른 버스 분류 ▶ 레지스터(Register) ­ 프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터 저장 · 특수한 값 하나를 저장하는 기억 공간으로 사용 · 컴퓨터의 구조에 따라 크기 및 종류가 다양 · 용도에 따라 전용 레지스터와 범용 레지스터, 저장되는 정보의 종류에 따라 데이터 레지 스터, 주소 레지스터, 상태 레지스터로 나뉨 · 사용자가 저장한 정보의 변경 여부에 따라 2가지로 분류
① 사용자 가시 레지스터(User
-Visible Register)
② 사용자 불가시 레지스터(User
-Invisible Register) ㆍ 사용자 가시 레지스터(User
-Visible Register)
- 운영체제(시스템)와  사용자  프로그램을  통해  접근  가능한  데이터와  주소,  일부  조건  코 드를 보관 ㆍ 사용자 불가시 레지스터(User
-Invisible Register)
- 프로세스의 제어와 상태 관리
- 프로그램  카운터,  명령어  레지스터,  프로그램  상태  레지스터,  메모리  주소  레지스터,  메 모리 버퍼 레지스터 등이 속함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 메모리(Memory)

1) 메모리 계층 구조
- 메모리 계층 구조는 1950년~1960년대 메인 메모리의 높은 가격으로 인해 제안된 방법 으로, 다양한 레벨의 메모리를 연결하여 비용,  속도, 용량, 접근  시간  등을 상호 보완한  것 비트당 비용 종류 속도 크기 레지스트 캐시 메인 메모리 자기 디스크 광학 디스크 자기 테이프 메모리 계층 구조
- 메인 메모리를 중심 · 아래 : 자기 디스크, 광학 디스크, 자기 테이프 · 위 : 캐시와 레지스터 · 다양한 메모리를 효과적으로 이용해 시스템의 성능 향상을 위해 사용 Ø 자기 디스크 : 대용량 Ø 광학 디스크 : 이동이 편리 Ø 자기 테이프 : 파일을 저장하기 위해 속도가 느림   Ø 캐시 : 메인 메모리와 프로세서의 속도 차를 보완 Ø 레지스터 : 프로세서가 사용할 자료를 보관하며 가장 빠름
- 메모리  참조가  지역성(국부성)이라는  특징을  가지는  것을  가지는  것을  활용하여  메모리  계층 구조 이용
- 지역성 · 실행 중인 프로세서가 실행기간 동안 메모리 정보를 균일하게 접근하지 않고 블록 중  일부만 집중적으로 참조하는 현상 · 발생이유
①  프로그램은  명령어를  순차적으로  실행하는  경향이  있으므로  명령어는  특정  지역  메모리에 인접해 있음
②  프로그램은  순환(단일  순환,  중첩된  순환  등)의  반복이지만  메모리  참조  영역은  일부 영역에 국한됨
③  대부분의  컴파일러는  메모리에  인접한  블록,  즉  배열로  저장하므로  프로그램은  배열 원소를 순차적으로 자주 접근하게 되어 지역적인 배열 접근 경향 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr

2) 메인 메모리
- 고유  주소를  가진  워드나  바이트로  구성된  대규모의  배열로,  주소를  읽거나  기록함으로 써 상호 작용한다는 특성을 가짐 ⋅ 메인 메모리 역할 프로세서 메인 메모리 입출력장치 메인 메모리의 역할 예
① 프로세서
- 메인 메모리로부터 처리할 데이터를 가져오거나 처리한 결과를 메인 메모리에 저장
② 입출력장치
- 메인 메모리에서 데이터를 받거나 저장 ­ 다수의 셀(Cells)로 구성되며 각 셀들은 비트들로 구성 ­ 메인 메모리에 데이터 저장 시 셀 하나 또는 여러 셀에 나뉘어 저장 ­ 셀은 주소에 의해 참조됨 · 셀이 K비트 일 경우 2K값을 저장  · n비트일 경우 참조 주소 범위는 0~2n
-1 프로세서 주소 데이터 메모리[ ] 0×00 0×01 0×02 0×03 0×04 0×05 0×06 0×07 메모리 주소 주소의 내용 메인 메모리의 주소 지정 ㆍ 물리적 주소 공간
- 컴퓨터에 주어진 주소 공간
- 프로그래머는 직접 사용하지 않고 수식, 변수를 이용 ㆍ 논리적 주소 공간
- 컴파일러에 의해 기계어로 변환된 변수와 명령어에 할당되는 주소 
- 별도의 주소 공간에 나타남 ㆍ 컴파일
- 원시 프로그램을 기계 명령어로 변환하는 처리 과정 
- 컴파일러가 논리적 주소를 물리적 주소로 변환 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 메모리 속도는 어떤 동작의 시작과 종료 사이의 경과 시간으로 메모리 접근 시간과 메모리  사이클 시간으로 표현 · 메모리 접근 시간 : 명령 발생 후 목표 번지를 검색하여 데이터 쓰기 읽기)를 시작할 때 까지의 시간 · 메모리 사이클 시간 : 두 번의 연속적인 메모리 동작 사이에 필요한 최소 지연 시간 · 일반적으로 사이클 시간이 접근 시간보다 약간 크며 메모리의 세부 구현 방법에 따라 달 라짐 메모리 사이클 시간 메모리 접근 시간 시간 메모리 접근 시간과 메모리 사이클 시간 ­ 프로세서와 메모리 사이의 접근 속도 차가 커짐에 따라 메인 메모리의 부담을 줄이기 위해  프로세서 칩 안이나 외부에 별도의 캐시를 구현 프로세서 보조기억장치 제어장치 디스크 메인 메모리 레지스터 원격 메모리 캐시 프로세서, 메인 메모리, 보조기억장치의 관계

3) 가상 메모리(Virtual Memory)
- 메인 메모리의 유효 크기를 늘리는 기법
- 보조기억장치에  프로그램이나 데이터를 저장했다  필요  시 다시 메인 메모리로  이동시키 는 기술 · 메인  메모리의  공간  부족으로  현재  실행  중인  프로그램이나  데이터를  저장  할  수  없 을 때 가상 메모리를 이용 · 프로그램과 데이터를 보조기억장치에 일부 저장한 후 필요 시 다시 메인 메모리로 옮 겨 실행
- 가상 메모리의 특징을 활용하기 위해 실행 중인 프로세스가 참조하는 주소와 메인 메모 리에서 사용하는 주소를 분리해야 함 Ø 매핑(사상, Mapping), 메모리 맵(Memory Map) 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ⋅ 논리적 주소를 물리적 주소로 변환하는 과정 주소 공간 메모리 공간 매핑(사상) 논리적 주소 물리적 주소 (가상 주소) 프로그램에 의한 가상 주소 생성 메인 메모리 실제 주소 메모리 매핑
- 메인 메모리보다 큰 저장 용량의 주소를 지정 가능 · 프로그램을 부분 적재하여 실행할 수 있음 · 실제 수행 중인 부분만 실제 메인 메모리로, 그 외 보조기억장치로 매핑 가상 주소 물리적 주소 0 A 0 4K B 4K C 8K C 8K 12K D 12K 물리적 기억  16K A 가상 메모리 장소 20K 24K B 28K 디스크 D 물리적 메모리로의 매핑

4) 캐시(Cache)
- 처리  속도가  빠른  프로세서와  상대적으로  느린  메인  메모리  사이에서  데이터나  정보를  저장하는 고속 버퍼
- 메인 메모리에서 일정 블록의 데이터를 가져와 워드 단위로 프로세서에 전달하여 정보를  빠르게 제공
- 데이터가 이동할 수 있는 통로(대역폭)을 확대하여 프로세서와 메인 메모리의 속도 차를  줄임
- 보통 크기가 8~64바이트 정도인 블록 여러 개로 구성
- 각 블록의 크기는 메인 메모리의 블록 크기와 같음 · 메모리에 캐시를 결합한 캐시 메모리 시스템은 메모리 가격과 성능을 절충하고 메모리  때문에 발생하는 성능 저하를 줄여줌 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세서 높은 대역폭 고속 : 워드 캐시 메모리 낮은 대역폭 저속 : 블록 메인 메모리 캐시 메모리
- 캐시의 동작 · 일반적으로 메인 메모리의 주소는 태그(Tag) 영역과 주소 영역 등을 나타내는 연속된  값으로 구성 · 캐시는  메인  메모리  주소  영역을  한  번  읽어  들일  수  있는  라인  크기로  나눈  후  각  블록에 번호를 부여한 후 태그로 번호를 저장 · 프로세서가 메인 메모리 접근이 필요할 때 먼저 캐시를 조사하여 캐시 태그와 메모리  주소의 태그 영역을 비교, 원하는 블록을 찾음 Ø 읽기 연산일 경우
① 캐시 적중(Cache Hit) 시 캐시는 데이터 라인에서 요청한 데이터를 읽어 프로세 서로 전송
② 캐시 실패(Cache Miss) 시 캐시 제어기는 메인 메모리에서 해당 블록을 읽어 캐 시에 넣고 프로세서로 전송 16339C 메인 메모리 주소 태그 주소 0000 1011 0001 1001 1100 태그 번호 비교검색 태그 데이터 라인 00 0010 1100 0110 0111 00 캐시 058CE7 캐시 메인 메모리 데이터 프로세서로 전송 검색 캐시의 기본 동작 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 주변장치 ­ 컴퓨터의 기능을 향상시키기 위한 추가 장비 ­ 입력 장치, 출력 장치, 보조기억장치, 스캐너, 모뎀 등 · 보조기억장치 ­ 플로피 디스크, 하드 디스크, CD/DVD, 테이프 드라이브 등 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 운영체제의 개요(2)

1. 운영체제의 역할과 목적에 맞는 기능을 알 수 있다. 1주차  수업목표  
2. 운영체제의 유형별 특징을 비교 할 수 있다. 2교시 
1. 운영체제의 역할과 목적 세부내용 
2. 운영체제의 유형별 특징 1. 운영체제의 역할과 목적 ▶ 운영체제 역할 ­ 운영체제는 컴퓨터 하드웨어와 응용 프로그램 간의 인터페이스 역할을 하며 CPU, 메모리와  같은 컴퓨터 자원을 관리하고 사용자에게 편의를 제공한다. ­ 컴퓨터 시스템은 일반적으로 사용자, 소프트웨어, 하드웨어 세 가지 요소로 구성된다.
① 컴퓨터 사용자 : 어떤 일을 수행하기 위해 컴퓨터를 사용하는 사람, 장치, 다른 컴퓨터를 의미한다.
② 하드웨어 :  연산을  위한  기본  자원을  제공하는  프로세서(중앙처리장치,  CPU),  메모리(기억장치),  다양한 장치(입출력장치 등)로 구성
③ 소프트웨어 : 컴퓨터가 기능을 수행하는데 필요한 프로그램을 총칭(ex: 운영체제, 각종 응용 프로그 램 유틸리티 등)
④ 응용 프로그램 :  어떤  문제를  해결하기  위해  사용자나  전문가에  의해  만들어진  프로그램(ex:  웹  브라 우저, 한글 등의 워드 프로세서, 데이터베이스 관리 프로그램, 비디오 게임 등) 컴퓨터 사용자 유틸리티 응용 프로그램 소프트웨어 운영체제 장치 장치 장치 하드웨어 CPU 메모리 컴퓨터 시스템 구성요소와 운영체제 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 운영체제는 다음과 같은 기능을 제공한다. · 하드웨어와 사용자 간의 인터페이스를 정의한다. · 사용자들이 하드웨어를 공동으로 사용할 수 있도록 해준다. · 사용자 간의 자원 스케줄링, 즉 자원 할당자 역할을 수행한다. · 입출력 보조 역할을 한다. · 오류를 처리한다. 사용자 운영 체제 응용 프로그램 하드웨어 네트워크로 연결된 다른 하드웨어 운영체제 역할 v 시스템 소프트웨어(System Software)
- 시스템  전체를 작동시키며,  프로그램을  주기억  장치에  적재하거나,  인터럽트  관리,  장치  관리, 언어 번역등의 기능을 담당하는 소프트웨어 ex) OS v 커널(Kernel)
- 운영체제의 핵심으로 메모리에 상주하며 운영체제의 다른 부분 또는 응용 프로그램 수행 에 필요한 환경을 설정하는 소프트웨어
- 응용  프로그램  실행에  필요한 다양한 서비스를  제공하고  실행되는 프로세스를  스케줄링 하는 역할 ▶ 운영체제의 목적 ­ 운영체제는 두 가지 주요 목적을 달성하기 위해 발전해왔다. ㆍ 편리성
- 사용자가 프로그램을 개발하고 사용하는 데 좀 더 편리한 환경 제공 ex: 개인용 컴퓨터(PC, Personal Computer)의 GUI 환경 ㆍ 효율성
- 자원을 효과적으로 사용하기 위해 각 프로그램을 유기적으로 결합하여 시스템 전체 성능 을 향상시키는 방향으로 설계된다.
① 처리 능력(Throughput) : 시스템의 생산성을 나타내는 대표 지표로 단위 시간당 처 리하는 작업량
② 신뢰도(Releability) : 하드웨어(펌웨어), 소프트웨어가 실패 없이 주어진 기능을 수행 할 수 있는 능력 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
③ 응답 시간(Turn Around Time) : 사용자가 시스템에 작업을 의뢰한 후 반응을 얻을  때까지의  시간(시분할  방식  시스템과  온라인  시스템에서  사용하는  용어,  일괄  처리  시 스템에서는 Turn Around Time)
④  사용가능도(Availability)  :  가동률,  사용자가  일정  기간  동안  컴퓨터를  실제로  사용 한 시간(비율) 운영체제의 목적 사용자에게 편리한 환경 제공(편리성) 시스템 성능 향상(효율성) · 처리 능력 향상 사용자가 프로그램을 개발하고  · 신뢰도 향상 사용하는데 편리한 환경 제공 · 응답 시간 단축 · 사용가능도 향상 운영체제 목적 ▶ 운영체제 기능의 발전 ㆍ 초기의 컴퓨터 시스템
- 작업별 처리 시스템 · 속도가 느리고  온라인  판독기와 프린터에만  의존하여 작업을  수행,  많은  시간이  소요 되었다. · 컴퓨터에는  하드웨어만  있어  프로그래머가  콘솔(Console)용으로  작성한  프로그램을  종이  테이프나  펀치  카드에서  메모리로  적재한  후,  시작  주소를  설정하고  실행,  실행  과정은 콘솔을 통해 살펴보았다. · 대부분 2진수나 8진수 기계어로 작성, 절대 주소를 사용하였고 라이브러리 루틴이 없 었다. · 로더는 용량이 작고, 메모리 내용은 대부분 사용자 자신이 작성한 프로그램이며, 수동  대화  방식으로  진행하여  프로그래머가  시스템  오퍼레이터(System  Operator)가  되고  시스템 사용을 위해 신청을 예약하는 예약제도로 운영됐다. · 예약 시간 안에 작업을 끝마치지 못하면 다른 사용자에게 사용권을 넘겨주고 대기, 작 업을 빠르게 끝마쳐도 남은 시간은 유휴시간이 된다.
- 초기의  컴퓨터  시스템은  작업  하나를  수행하는데  필요한  준비시간  단계가  많아  시간이  낭비되었고, 한 단계서 오류가 발생하면 처음부터 다시 수행해야 하는 불편함이 존재 하 였다. ▶ 운영체제 역할 ­ 운영체제는 다음과 같은 기능을 제공한다. ㆍ 초기의 일괄 처리 시스템
- 진행 과정 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
① 컴퓨터로 카드 판독기와 테이프 드라이브를 작동, 데이터를 테이프에 저장
② 생성한 데이터 테이프의 연산 처리를 위해 컴퓨터의 입력 테이프 드라이브로 사용하 여 입력
③  연산  처리된  데이터는  출력  테이프  드라이브에  의해  출력  테이프에  저장,  컴퓨터에 서 출력을 위해 프린터의 입력 테이프로 사용
- 작업 중  문제 발생 시 오퍼레이터가  콘솔을 조사,  사태 여부를 파악하고 필요한  조치를  취하기 위해 프로세서의 유휴 시간이 생성되는 문제점이 있다. 입력  시스템  출력  테이프  테이프  테이프  테이프  테이프  드라이브 드라이브 드라이브 드라이브 드라이브 카드 프린터 판독기 1401 7094 1401 ㆍ 상주모니터
- 초기의 운영체제 형태로서, 현재 프로그램에서 다음 프로그램으로 제어가 자동으로 넘어 가도록 하는 프로그램

1) 버퍼링(Buffering) ­ 입출력장치의  느린  속도를  보완하여,  유휴  시간이  없도록  프로세서의  연산  과정과  함께  어떤 작업의 입출력을 동시에 수행하는 운영체제의 기능 중 하나이다. ­ 컴퓨터 하드웨어의 일부인 버퍼를 사용하며, 한 작업의 입출력과 그 작업의 계산만 함께  할 수 있다. ­ 데이터 구성 단위는 레코드로, 버퍼링의 성능은 처리되는 레코드 수에 따라 달라진다. ­ 레코드는 응용 프로그램에 의해 정의되는 논리적 레코드와 입출력장치의 특성에 의해 정 의되는 물리적 레코드로 나뉜다. 버퍼 CPU 입출력장치
2) 스풀링(Spooling) ­ 프로세서가 다른 부분을 판독하고 있는 동안 추가로 기록할 수 없는 테이프 시스템의 문 제를 해결하기 위해 추가 기록이 가능한 디스크의 특성을 이용하여 개발되었다. ­ ‘Simultaneous Peripheral Operation On
-Line’라는 의미로 디스크를 매우 큰 버퍼처럼  사용하는, 입력장치에서 미리 읽어 출력 장치가 받을 수 있을 때 까지 출력 파일을 저장 한다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 별개의 오프라인 장치를 사용, 한 작업의 입출력을 수행하면서 다른 작업의 계산이 가능 하고 많은 작업의 입출력과 계산을 함께 할 수 있다. ­ 작업 풀(Job Pool) 데이터 구조를 제공한다. · 디스크에  읽혀져  실행을  위해 다기하는  여러  작업을  수행할  수  있도록  준비,  디스크 에 저장된 작업은 프로세서 이용률 향상을 위해 운영체제가 다음 수행할 작업 선택을  돕는다. 디스크 입출력 라인프린터 카드 판독기 CPU 디스크 : 대단위 버더(Buffer)로 활동 2. 운영체제의 유형별 특징 ▶ 다중 프로그래밍 시스템 ­ 작업 스케줄링에서 가장 중요한 부분은 다중 프로그래밍(Multi Programming) · 프로세서가 항상 수행할 작업을 가지도록 하여 프로세서 이용률을 증진시키는 방법이다. ­ 운영체제는 메모리에 있는 작업 중 하나를 택하여 실행을 시작한다.  ­ 작업이 어떤 일을 기다려야 하는 경우, 비다중 프로그래밍 시스템의 프로세서는 유휴  상태가 되지만 다중 프로그래밍 시스템에서는 운영체제가 간단히 다른 작업으로 전환 하여 수행한다. ­ 작업을 위해 기다리는 것이 끝나면 프로세서를 다시 차지하며, 수행될 작업이 메모리 에 적재되어 있으면 프로세서는 유휴하지 않을 것이다. ­ 인터럽트를  이용하여  수행하는  프로세서  스케줄링의  다중  프로그래밍은  현대  운영체제의  중심 주제이다. · 다중 프로그래밍 운영체제는 아주 복잡하며, 여러 작업을 준비 상태로 두려면 이를 메모 리에 보관해야 하고 일정 형태의 메모리 관리가 필요하다. · 또한 여러 개의 작업이 수행할 준비를 갖추고 있으면 이 중 하나를 선택하기 위한 결정  방법이 필요하다. 0 운영체제 작업 1 작업 2 작업 3 512KB 작업 4 다중 프로그래밍 시스템을 위한 메모리 구조 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 시분할 시스템 (TSS, Time Sharing System) ­ 다중 프로그래밍을 논리적으로 확장한 개념으로 프로세서를 통해 다중 작업을 교대로 수행 한다. · 사용자가 프로그램을 실행하고 있을 동안 자신의 프로그램과 접촉하기 위해 교대가 빈번 히 일어난다. ­ 프로세서  스케줄링과  다중  프로그래밍을  사용해  각  사용자에게  컴퓨터를  시간적으로  분할 하여 나눠준다. · 각  사용자는  메모리에  독립된  프로그램을  갖고,  프로그램은  입출력을  수행하는  아주  짧 은 시간 동안만 실행되어 많은 사용자가 컴퓨터를 공유하도록 한다. · 각 트랜젝션(Transaction)이 짧아 각 사용자는 짧은 시간 동안만 프로세서를 사용한다. ­ 1960년  이전에  제안되었으며,  초기에  개발된  시스템  중  하나가  MIT에서  개발한  CTSS(Compatible Time Sharing System)다. · 1961년 IBM
-709에 탑재되어 사용됨 ­ 1970년대  초까지는  일반화되지  못했으나  오늘날의  시스템은  대부분  일괄  처리  방식과  시 분할 방식을 모두 제공한다. · 여러 작업이 메모리에 저장되어 있는 경우 한 작업이 다른 작업의 데이터를 변경하는 등 의 작업에 대한 보호가 필요하다. · 다수의 사용자가 접근하는 파일은 접근 권한을 두어 특정 권한을 가진 사용자만 접근할  수 있도록 파일 시스템을 보호해야 한다. · 공유 자원의 경우 접근 순서도 조정할 수 있도록 기능을 제공해야 한다. ㆍ 일괄 처리 시스템과 비교
- 일괄 처리 시스템 · 작업을 미리 정의된 각 제어 카드와 함께 읽어 들이고 작업을 완료하면 출력 · 처리  과정  중  발생할  수  있는  모든  경우에  대한  제어  카드를  제공해야  하므로  작업  제출과 완료까지의 반환 시간이 길어질 수 있다. · 오류 수정은 당시의 상태를 그대로 출력해야 가능하며, 오류를 수정한 후 다시 처음부 터 수행해야 한다.
- 시분할 시스템 · 사용자와 시스템  간의  온라인  통신을 제공, 사용자가  운영체제나  프로그램에  직접  명 령을 주고 즉시 응답을 받을 수 있다. LCD 큐 CPU 기억장치 LCD LCD 입출력장치 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 대화식 입출력
- 입출력은 대화식으로 가능하며, 출력은 사용자를 위해 화면에 출력되고 입력은 키보드에 서 읽어 들이는 대화식이 될 수 있다.
- 보통,  사람의  처리와  속도가  같으므로  종료까지  소요  시간이  길며,  이  경우  운영체제는  프로세서를 다른 사용자의 프로그램으로 전환시킨다. ▶ 분산 처리 시스템 (Distributed Processing System) ­ 시스템마다  운영체제와  메모리를  가지고  독립적으로  운영되며  필요할  때  통신하는  시스템 이다. ­ 최근의 컴퓨터는 자원 공유, 연산 속도 향상, 신뢰성과 통신 등의 문제로 여러 개의 물리적  프로세서에 연산을 분산하는 경향이 있다. ㆍ 분산 시스템 구성 방법
- 강결합(단단히 결합된) 시스템 : 프로세서(처리기)가 기억장치와 클록(Clock)을 공유하며,  공유된 기억장치를 통해 통신
- 약결합(느슨하게 결합된) 시스템 : 둘 이상의 독립된 컴퓨터 시스템을 통신선으로 연결 메인 입출력장치 1 프로세서 1 메모리 메인 입출력장치 2 프로세서 2 메모리 분산(약결합) 처리 시스템의 구성 예 ▶ 다중 처리 시스템 ­ 마이크로프로세서 여러 개를 연결해 다중 프로세서를 만든다. · 시스템은  프로세서(처리기)를  많이  사용해  신뢰성,  가용성,  컴퓨터  능력  등을  증가시킨 다. · 하드웨어 비용이 저렴해짐에 따라 단위 시간당 처리량을 증가시키기 위해 사용한다. · 고가의  초고속  프로세서를  사용하지  않고도  대형  컴퓨터에  근접하는,  단일  프로세서  컴 퓨터 시스템의 계산 능력을 증대시킬 수 있다. · 다중 처리를 위한 운영체제 구성 방법은 비대칭(주/종)적 구성과 대칭적 구성이 있다. ㆍ 주/종 다중 처리 시스템(Master/Slave Multi Process System)
- 비대칭적  구성으로 마스터 프로세서가  주가  되어  부가적인  슬레이브 프로세서를  관리하 는 단일 처리 시스템이다.
- 형태가  단순하나 마스터 프로세서에  부하가  많아  신뢰도나  자원  사용에서는  비효율적이 다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 운영체제의 개입이 요구되는 경우, 마스터 프로세서에 인터럽트를 요청해야 하므로 인터 럽트 수가 증가한다. 슬레이브 메인 마스터 프로세서 입출력장치 메모리 슬레이브 분산(약결합) 처리 시스템의 구성 예 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 운영체제의 개요(3)

1. 운영체제 세대별 발전 과정을 알 수 있다. 2주차  수업목표  
2. 운영체제의 주요기능을 알 수 있다.
3. 부트스트래핑, 사용자, 시스템 서비스의 특징을 알 수 있다. 1교시 
1. 운영체제의 발전 과정 세부내용 
2. 운영체제 기능
3. 운영체제 서비스 1. 운영체제의 발전 과정 ▶ 운영체제의 발전 과정 ­ 운영체제와 컴퓨터 구조는 서로 많은 영향을 끼쳤으며, 관찰을  통해 운영체제의 개념을 올 바르게 이해할 수 있다. ­ 하드웨어와 같이 “세대”라고 불리는 발전 단계를 거쳤으며, 그 과정은 아래의 표와 같다. 구분 시대 특징 · 운영체제 없음 제 0세대 1940년대 · 기계어 사용 · IBM701(운영체제 효시) 제 1세대 1950년대 · 작업 간의 원활한 변환 · 버퍼링, 스풀링, 일괄 처리 시스템 · 고급 언어로 운영체제 작성 제 2세대 1960년대 초 · 장치 독립성 · 다중 프로그램밍, 다중처리, 시분할 시스템 · IBM 360 시리즈, 유닉스 제 3세대 1960년대 중반 ~ 1970년대 중반 · 범용 시스템 · 다중 모드 시스템 · 네트워크 시스템 제 4세대 1970년대 중반 ~ 현재 · 가상 머신, 분산 데이터 처리 · 개인 컴퓨터 ▶ 제 0세대 (1940년대) ­ 초기  시스템에는  운영체제가 없었으며,  사용자가  직접 기계어를  사용해  명령문을  작성하였 다. ­ 프로그램을  작성할  때  컴퓨터에  필요한  작업을  모두  포함하고,  모든  명령어를  명시적으로  표현하였다. ­ 모든 작업은 예약을 통해 진행되고 컴퓨터는 프로그래머가 메인 콘솔에서 수동으로 운영하 였다. ▶ 제 1세대 (1950년대) – 버퍼링, 스풀링, 일괄처리 시스템 ­ 1952년  초,  자동차  제조회사  GM의  연구실에서  IBM  701  운영체제  개발,  이것이  운영체 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 제의 효시이다. ­ 1955년, GM과 북아메리가 항공사가 IBM 704 운영체제를 공동으로 개발. ­ IBM  사용자협회  SHARE(Semi
-Automatic  Business  Research  Environment)에서  운영체 제에 대한 토론회를 육성, 1957년까지 IBM 704를 위한 자체 운영체제를 개발 ­ IBM  1400  계열  같은  소형  컴퓨터는  운영체제  없이  작동하며,  입출력  제어  시스템인  IOCS(Input/Output Control System) 패키지를 사용 ㆍ 버퍼링, 스풀링 기법 적용
- 초기  운영체제는 설치  시간(Setup  Time)과 철거 시간(Teardown  Time)  낭비를 줄이는 데 관심을 가짐 · 설치 시간 : 작업을 컴퓨터 시스템에 올리는 필요한 시간 · 철거 시간 : 작업을 컴퓨터 시스템에서 해체하는데 필요한 시간 ㆍ 유휴 기간을 줄이기 위해 작업을 일괄 처리하여 성능 향상
- 운영체제  개발 전의 작업은  카드에서 개별적으로  적재, 실행  중에는 각  작업이 전 시스 템을 차지
- 각 작업은 완료 또는 오류가 발생할  때까지 실행,  작업이 끝나야 오퍼레이터가 기존 프 로그램과 카드를 제거하여 다음 작업을 실행 가능
- 이 과정에서 시스템은 유휴 상태가 되므로, 이를 줄이고 성능을 향상시키기 위해 작업을  소형 보조 컴퓨터의 테이프에 옮긴 다음 나중에 대형 컴퓨터로 처리되는 과정을 채택 ㆍ 하드웨어 장치의 독립성을 위해 시스템 파일명 등장
- 사용자가  하드웨어  장치  번호를  직접  코드화할  필요가  없어졌으며,  카드를  읽는  장치에  대해  표준  시스템  입력  파일,  인쇄  출력  장치에  대해서  표준  시스템  출력  파일을  지정  가능
- 어셈블러와 컴파일러에서 링커(Linker)와 로더(Loader)로의 변환이 원활해 짐 ▶ 제 2세대 (1960년대 초기) – 다중 프로그래밍, 다중 처리, 시분할 시스템 ­ 일괄 처리 형태로 처리량을 향상시키며, 장치 독립성이라는 개념으로 하드웨어 관리가 편리 해 짐 · 사용자  프로그램에서  테이프  드라이브를  지정,  운영체제가  현재  사용되고  있지  않는  테 이프 드라이브를 찾아 오퍼레이터에게 테이프를 드라이브에 걸어줄 것을 지시함 ㆍ 다중 프로그래밍
- 여러 프로그램이 메인 메모리에 공존, 프로세서를 작업 간에 수시로 번갈아 할당 ㆍ 다중 처리 시스템
- 시스템의 처리 능력을 증진시키기 위해 한 컴퓨터 시스템에 여러 개의 프로세서 사용 ㆍ 시분할 시스템
- 사용자가 터미널을 통해 컴퓨터와 직접 접촉하기 위해 개발
- 사용자와  대화  방식으로  작동하며,  사용자가  컴퓨터에  요구  사항을  입력하고  컴퓨터가  요구를 처리하여 사용자의 터미널로 응답 ㆍ 실시간 시스템 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 즉시 응답한다는 점이 특징으로, 컴퓨터가 가솔린 정제 등의 공정을 제어하는 데 사용되 며 발전하기 시작함
- 군용 실시간 시스템은 적의 공중 공격에 대비해 동시에 수천 지점을 감시하기 위해 개발
- 필요할  때  즉시  사용할  수  있고  빠른  응답이  중요하므로  활용도가  높지  못하고  비용이  많이 듬 ㆍ 미항공 회사의 SABRE(Semi
-Automatic Business Research Environment) 예약 시스템
- 제 2세대의 가장 중요한 개발 중 하나로, 멀리 떨어진 사용자가 단말기를 통해 중앙 컴 퓨터 시스템과 통신하는 트랜잭션 처리 시스템의 효시
- 트랜잭션 처리 시스템 : 사용자와 컴퓨터 시스템이 대화를 하되 사용자가 비교적 간단하 게 요구하면 컴퓨터가 빠른 시간 내에 응답
- 사용자 단말기는 컴퓨터의 온라인이라 불림 ▶ 제 3세대 (1960년 중반 ~ 1970년대 중반) – 범용 시스템, 다중 모드 시스템 ­ 1964년 IBM 시스템/360 계열 컴퓨터로부터 시작 ­ 범용 시스템으로 설계, 육중하며 모든 사용자에게 모든 기능을 제공할 수 있도록 제작 · 다량의  컴퓨터가  판매되었으나,  이러한  기능이  필요  없는  사용자에게  실행  시간의  과부 하, 시스템 이해를 위한 기간, 오류 발생 시 수정 시간, 시스템 유지 등에 있어 많은 비 용 부담의 단점을 가짐 ㆍ 다중 모드 시스템
- 일괄 처리, 시분할 처리, 실시간 처리, 다중 처리를 모두 제공
- 고가이며 계획한 시간과 예산을 초과하여 완성되었으며 사용에도 고도의 훈련이 필요
- 사용자와 하드웨어 사이에 소프트웨어 계층 도입 · 하드웨어에 대한 관점 없이 소프트웨어에 의해 형성된 관점을 보게 됨으로 사용이 어 려우며, 간단한 작업 수행에도 복잡한 작업 제어 언어 (JCL, Job Control Language) 의 이해가 필요함 ▶ 제 4세대 (1970년대 중반 이후) – 네트워크, 가상 머신, 분산 처리 시스템, 개인 컴퓨터 ­ 통신 발달과 더불어 컴퓨터 네트워크와 온라인 처리가 사용됨 · 다양한  형태의  단말기를  이용하여  멀리  떨어진  지역의  컴퓨터를  네트워크를  통해  사용  가능 · 마이크로프로세서의 등장으로 개인용 컴퓨터를 가짐 ㆍ 개인용 컴퓨터
- 데이터 통신 인터페이스를 갖추어 터미널로 사용
- 시분할 모드로 한정된 컴퓨터만 사용해야 하는 제약 없이 지역적으로 멀리 떨어진 여러  시스템과 통신이 가능하다
- 통신선을  통과하는  정보의  안전한  관리  문제가  대두되며  정보  보호가  중요한  관심사로,  교신 내용 유출 시에도 지정한 수신자 외에 데이터 사용이 불가능하도록 하는 부분이 주 요 이슈다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 1980년대, 메뉴 지향적 시스템
- 컴퓨터를  사용하는  인구가  급증하며,  일반  사용자에게  컴퓨터를  쉽게  사용할  수  있도록  “사용자에게 친숙한 시스템”이란 문구 등장
- 1960년대와 1970년대의 텍스트(명령) 중심의 시스템 사용법이 메뉴 지향적 시스템으로  대치됨 ㆍ 1990년대, GUI(Graphical User Interface) 시스템
- 도형(아이콘)과 마우스를 기반으로 한 시스템 ㆍ 가상 머신 (Virtual Machine) 개념 출현
- 더  이상  컴퓨터  시스템의  물리적인  부분을  신경  쓰지  않고,  운영체제에  의해  만들어진  가상 머신의 관점으로 이해한다.
- 오늘날의 사용자는 머신 내부의 기능보다 실제로 컴퓨터 작업을 수행하는 데 관심을 가 진다. ㆍ 데이터베이스 시스템의 중요성
- 정보를 제공받을 권리가 있는 사람에게만 일정한 통제 하에서 정보를 제공한다.
- 수많은 온라인 데이터베이스를 통신 네트워크의 터미널을 통해 사용 가능하다. ㆍ 분산 처리의 개념 확립
- 컴퓨터가  있는  곳으로  데이터를  가져가기  보다,  데이터가  발생하는  곳으로  컴퓨터의  능 력을 가져온다. 2. 운영체제 기능 ▶ 운영체제의 기능 ­ 운영체제는  프로그램을  실행하는  데  필요한  환경과  자원을  제공하고  관리하기  위한  크고  복잡한 시스템이다. ­ 논리적으로 작은 모듈로 구성되며 각 부분은 명확하게 정의된다. ­ 대부분의 시스템은 자원 관리와 프로그램을 위한 인터페이스 역할을 수행한다. ▶ 자원 관리 기능 ­ 대부분 메모리, 프로세스, 장치, 파일 등의 시스템 구성 요소를 제공하며 이를 자원이라 하 며, 운영체제는 이런 자원을 관리하는 역할을 수행한다. 운영체제 메 프 장 파 모 로 치 일 리 세 관 관 관 스 관 리 리 리 리 하드웨어 운영체제의 자원 관리 기능 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
① 메모리 관리 ­ 메인 메모리와 보조 기억장치로 구분한다. · 메인  메모리는  컴퓨터  시스템에서  핵심  역할을  수행하며,  프로세서가  직접  주소로  지 정할 수 있는 유일한 메모리다. · 프로세서가 명령어를 수행하기 위해 메인 메모리에 명령어를 저장하며, 프로그램 수행 을 위해 프로그램이 절대주소로 맵핑되어 메모리에 저장되어야 한다. ­ 프로세서 이용률과 컴퓨터 응답 속도 향상을 위한 다양한 메모리 관리 기법이 존재한다. ­ 운영체제는 메인 메모리 관리를 위해 다음 기능을 담당한다. · 현재 메모리의 어느 부분이 사용되고, 누가 사용하는 지를 점검 · 기억 공간에 어떤 프로세스를 저장할 지를 결정 · 기억 공간을 할당하고 회수하는 방법 결정
② 보조기억장치 관리 ­ 메인  메모리의  공간이  제한적이므로  컴퓨터  시스템은 보조기억장치를  이용해  메인  메모 리의 내용을 저장한다. · 대부분의 시스템은 온라인 저장  매체로  디스크를  이용하므로 디스크에서의  저장 기법 이 매우 중요하다. ­ 운영체제는 디스크 관리를 위해 다음 기능을 담당한다. · 비어 있는 공간 관리 · 저장 장소 할당 · 디스크 스케줄링
③ 프로세스 관리 ­ 프로세스 하나는 자신의 업무를 수행하기 위해 프로세서 점유, 메모리, 파일, 입출력장치  같은 다양한 자원이 필요하다. ­ 자원은 프로세스가 생성될 때 또는 실행 중에 할당될 수도 있다. ­ 하나의 프로세스는 한 시스템에서 작업 단위이며, 시스템은 프로세스의 집합으로 구성된 다. ­ 모든 프로세스는 프로세서를 분할하여 사용함으로써 병행하여 수행할 수 있다. ­ 운영체제는 프로세스 관리를 위해 다음 기능을 담당한다. · 프로세스와 스레드 스케줄링 · 사용자와 시스템 프로세스 생성과 제거 · 프로세스의 중지와 재수행 · 프로세스 동기화와 통신을 위한 기법 제공 · 교착 상태(Deadlock)를 방지하는 기법 제공
④ 장치 관리(입출력 관리) ­ 운영체제는  사용자가  특정  하드웨어  장치(입출력장치  등)를  포괄적  기계로  인식하게  하 여 장치의 특성을 숨긴다. ­ 운영체제는 입출력 시스템을 관리하기 위해 다음의 기능을 제공한다. · 임시 저장(Buffer
-aching) 시스템 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 일반적인 장치 드라이버 인터페이스 · 특정 하드웨어 장치를 위한 드라이버
⑤ 파일 관리 ­ 가장 많이 사용되는 운영체제 구성 요소 중 하나로, 컴퓨터는 물리적으로 다양한 형태로  정보를 저장할 수 있으며, 효율적인 사용을 위해 단일화된 정보 저장 형태를 제공한다. ­ 운영체제는  파일의  추상적인  개념을  운영하고  쉽게  사용하기  위해  디렉터리로  구성,  다 수의 사용자에 의한 파일 접근을 제어한다. ­ 운영체제는 파일 관리를 위해 다음 기능을 담당한다. · 파일과 디렉터리의 생성과 제거 · 보조기억장치에 있는 파일의 맵핑 · 안전한(비휘발성) 저장 매체에 파일 저장 ▶ 운영체제 기타 기능
① 시스템 보호 ­ 운영체제에 있는 프로세스를 다른 사용자의 프로그램으로부터 보호한다.
② 네트워킹 ­ 시스템에 있는 프로세서는 다양한 방법으로 구성될 수 있는 통신 네트워크를 운영한다. ­ 네트워크는 완전  접속과  부분 접속으로 연결되며, 설계 시  경로 설정, 접속  정책, 충돌,  보안 등의 문제를 고려해야 한다.
③ 명령어 해석기와 시스템 관리 ­ 명령어  해석기(Command  Interpreter)는  운영체제를  위한  중요한  시스템  프로그램  중  하나이다. ­ 초소형 컴퓨터에는 커널이, 대형 시스템에서는 특수 목적 프로그램으로 명령어 해석기를  가지고 있다. 3. 운영체제 서비스 ▶ 부트스트래핑 서비스 ­ 운영체제가 적재되는 과정을 부트스트래핑(Bootstraping) 또는 부팅(Booting)이라 한다. · 부트스트랩  로더(Bootstrap  Loader)는  디스크  트랙  0,  나머지는  디스크의  다른  부분에  적재된다. · 부트스트랩  로더의  목적은  운영체제를  적재하는  것이며,  운영체제를  적재하면  시스템이  초기화된다. · 초기화의  목적은  운영체제  정리,  사용자와의  대화를  통한  시간  등의  설정,  명령  해석기 의 적재와 준비 등이다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ROM 1. 컴퓨터 작동 시작, ROM에 저장된  부트스트랩 로더 부트스트랩 로더 실행 2. 부트스트랩 로더는 디스크의  고정 트랙에 저장된 운영체제를  주기억장치에 적재시킴 RAM 3. RAM에 적재 4. JMP 명령 이용,  운영체제 시작 부트스트래핑 과정 ▶ 사용자 서비스 ­ 프로그래머가 프로그래밍 작업을 쉽게 수행할 수 있도록 제공되는 서비스로 운영체제는 다 음과 같은 역할을 수행한다.
① 사용자 인터페이스 ­ 운영체제와 사용자의 연결을 위해 사용자가 제어 가능한 부분, 이를 통해 운영체제와 통 신, 대화할 수 있다. ­ 구현  방법  :  명령  라인  인터페이스(Command
-Line  Interface),  GUI(Graphical  User  Interface)
② 프로그램 수행 ­ 시스템은  프로그램을  메모리에  적재하여  실행,  실행을  정상적  혹은  비정상적으로  끝낼  수 있어야 한다.
③ 입출력 동작 ­ 수행 중인 프로그램이 입출력을 요구, 파일이나 입출력 장치를 지정할 수 있다. ­ 특수한 기능이 필요한 입출력장치는 운영체제가 입출력 동작을 위한 방법을 제공한다.
④ 파일 시스템 조작 ­ 프로그램은 파일을 정확히 읽고 기록, 파일 이름으로 파일을 생성하고 삭제해야 한다.
⑤ 통신 ­ 프로세스간  정보  교환  방법은  크게  두  가지로  동일한  컴퓨터  또는,  컴퓨터  네트워크에  의해 함께 묶인 다른 컴퓨터 시스템에서 수행되는 프로세스 간에 일어난다.
⑥ 오류 탐지 ­ 운영체제는  가능한  모든  오류를  항상  탐지하고,  올바르고  일관성  있는  계산을  보장하기  위해 오류 유형별로 적절히 조치해야 한다. ­ 오류는 프로세스, 메모리, 하드웨어, 입출력장치, 사용자 프로그램에서 발생 가능하다. ▶ 시스템 서비스 ­ 사용자가 아닌 시스템 자체의 효율적인 동작을 보장하는 기능이다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 다수의 사용자를 위해 컴퓨터 자원을 공유하여 효율성을 높인다.
① 자원 할당 ­ 다수의 사용자나 다수의 작업이 동시에 실행 시 운영체제는 자원을 작업에 할당, 관리한 다.
② 계정 ­ 계정 정보를 이용해 각 사용자의 시스템 이용 정보를 알 수 있다.  ­ 시스템 청구, 시스템 사용 통계를 수집하기 위해 보관, 사용자 서비스 개선을 위한 연구  자료로 이용 가능하다.
③ 보호 ­ 시스템 호출을 위해 전달된 모든 매개변수의 타당성을 검사, 시스템 자원에 모든 접근을  제어하도록 보장한다. ­ 다중 사용자 컴퓨터 시스템에서 저장된 정보의 소유자는 정보 사용을 제한할 수 있다. ▶ 시스템 호출 서비스 ­ 운영체제가 제공하는 일반적인 시스템 호출은 다음과 같다.
① 프로세스 제어 ­ 종료, 취소, 적재(로드, Load), 수행   ­ 프로세스 생성, 종료, 속성 획득, 속성 지정  ­ 대기, 대기 이벤트(Event), 신호 이벤트 ­ 기억장치 할당 및 해제
② 파일 조작 ­ 파일 생성, 삭제, 오픈(Open), 폐쇄(Close), 속성 획득 및 지정 ­ 읽기, 쓰기, 재배치(Reposition) ­ 논리적 부착(Logically Attach)
③ 장치 조작 ­ 장치 요구, 해제, 속성 획득 및 설정  ­ 읽기, 쓰기, 재배치 ­ 논리적 부착 또는 장치 제거
④ 정보 관리 ­ 시간과 일자, 데이터의 설정과 획득 ­ 프로세스, 파일, 장치 속성의 설정과 획득
⑤ 통신 ­ 통신 연결의 생성, 제거, 메시지 송수신 ­ 상태 정보 전달 ­ 원격 장치의 부착 및 제거 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세스의 개요

1. 프로세스의 개념을 알 수 있다.  수업목표  
2. 프로세스의 종류와 상태변화를 알 수 있다. 2주차 
1. 프로세스의 개념
2. 프로세스의 종류 2교시 
3. 프로세스의 상태 세부내용 
4. 프로세스의 상태 변화
5. 프로세스의 제어 블록(PCB, Process Control Block)
6. 프로세스의 교환 1. 프로세스의 개념 ▶ 프로세스(Process) 개념 ­ 1960년대 멀틱스 시스템(Multics System) 설계자 처음 사용 · 이후 작업(Task)이란 용어와 함께 사용되며, 다양한 정의를 가짐 · 가장 일반적인 정의는 “실행 중인 프로그램” ­ 디스크에 저장되어 있던 실행 가능한 프로그램이 메모리에 적재되어 운영체제의 제어 를 받는 상태 ­ 해당 프로세스가 사용하고 있는 메모리 영역(자신의 주소 공간)이 존재함을 의미 ­ 프로세서 할당(점유) 시간과 메모리, 파일, 입출력장치 등의 자원이 필요하며, 자원은  프로세스 생성 및 실행 시 할당됨 ­ 현재의  활동  상태를  나타내는  프로그램  카운터와  프로세서의  현재  활동(레지스터  내 용) 포함 ­ 프로그램과 달리 프로세서는 메모리에 주소 공간을 갖는 능동적인 개체 0xex)ex)ex)ex) 실행스택(Stack) 실행 힙(Heap) 데이터(정적 변수) 텍스트(코드) 0x0000 메모리에 존재하는 프로세스 주소  공간 구조 ㆍ 실행  스택(Stack)  :  호출된  프로시저(함수)의  복귀  주소와  지역  변수  등의  일시적인  데이 터를 저장하는 영역 ㆍ 실행 힙(Heap) : 텍스트(코드) 영역과는 별도로 유지되는 자유 영역 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 데이터(정적 변수) : 프로세스 실행 중 동적으로 할당 받는 영역, 전역 또는 정적 변수 저 장 ㆍ 텍스트(코드) : 프로세서가 실행하는 코드 저장 ­ 재진입 프로그램(재진입 코드) · 메모리 내에 동일한 사본을 여러 사용자가 공유할 수 있도록 작성된 프로그램 또는 루틴 ­ 실행 중  사용할  데이터를  보관하는  실행  스택과  공통적인  데이터를  보관하는 데이터  영역을 가짐 ­ 프로세서가  동일한  프로그램을  사용하여도  텍스트(코드)  영역은  같으나  별도의  스택 에 서로 다른 데이터를 가지므로 별개의 프로세스로 인식됨 ­ 데이터베이스, 문서 편집기 등 ­ 프로세스는 사용자 관점에서 세그먼트(코드, 데이터, 스택 등)의 가상 주소 공간을 갖는 상 태를 의미, 시스템 관점에서 실행중인 프로그램을 의미 · 처리 상태에 있는 데이터 구조로 표현 가능   ­ 스케줄러(디스패칭)에 의해 프로세서 할당 ­ 파일에 관련된 자원에 대한 참조(장치 관리, 메모리 관리) ­ 프로세스 지원과 협력에 관한 정보(교착상태, 보호, 동기화) 교환 ­ 프로세스 관련 연산은 생성, 종료, 보류, 자원 할당, 해제 등 프로그램 프로세스 컴퓨팅 환경 교착상태 프로세스 기술 파일 관리 보호 동기화 장치 관리 메모리 관리 스케줄러 지원관리 장치 메모리 프로세서 다른 하드웨어 시스템 관점에 본 프로세스 2. 프로세스의 종류 ▶ 프로세스 종류 ­ 실행 유형에 따라 크게 3가지로 구분
1) 운영체제 프로세스 ­ 커널 프로세스 또는 시스템 프로세스라 부름 ­ 프로세스 실행 순서 제어, 사용하고 있는 프로세스가 다른 사용자나 운영체제 영역을 침 범하지 못하게 감시하는 기능 담당 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 사용자 프로세스 생성, 입출력 프로세스 등 시스템 운영에 필요한 작업 수행
2) 사용자 프로세스 ­ 사용자 코드 수행
3) 병행 프로세스 ­ 프로세스 여러 개가 동시에 실행되며, 독립 프로세스와 협동 프로세스로 구분
① 독립 프로세스 · 프로세스 여러 개가 병행하여 수행 시 주어진 초기값에 따라 항상 같은 결과를 보여 줌 · 서로 독립적으로 실행되어 다른 프로세스에 영향을 받지 않고, 데이터를 공유하지 않 음
② 협동 프로세스 · 다른 프로세스에 영향을 주거나 다른 프로세스에 의해 영향을 받음 · 컴퓨터 시스템의 제한된 자원을 공유하는 프로세스들이 통제되어 상호 작용해야 하는  경우 발생 · 서로 협동해야 하는 경우, 통신을 위한 수단과 동기화 기능이 필요 3. 프로세스의 상태 ▶ 프로세스 상태 ­ 실행과 비실행 프로세스로 구분 · 프로세스는 실행되며 상태가  변하므로  운영체제는 프로세스  제어에  필요한  프로세스 상 태를 점검해야 함 ­ 운영체제가 프로세스를 새로 생성하면 비실행 상태로 초기화되어 실행을 기다림 ­ 실행 중인 프로세스 종료 또는 인터럽트 발생 시 비실행 프로세스 중 선택된 프로세 스가 실행 상태로 변하고(디스패치) 인터럽트 된 프로세스는 비실행 상태로 변경 · 실행 상태 프로세스 ­ 실행 : 명령어가 실행되는 상태, 즉 프로세스가 프로세서를 점유한 상태 ­ 대기  또는  보류  :  프로세서가  이벤트(입출력  종료와  같은  외부  신호)가  일어나길  기 다리는 상태 ­ 준비 : 프로세스가 프로세서를 할당 받기 위해 기다리는 상태 · 대부분의  프로세스는  준비나  대기(보류)  상태이며,  어느  한  순간에  한  프로세스만  실행 상태가 됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 디스패치 생성 종료 비실행 실행 인터럽트 프로세스 상태 구분 프로세스  프로세스  준비 실행 생성 종료 대기 (보류) 프로세스 상태 4. 프로세스의 상태 변화 ▶ 프로세스 상태 변화 ­ 시스템의  모든  프로세스는  종료되어  시스템을  떠날  때까지  준비,  실행,  대기(보류)  상태로  변화되며 실행되는 과정을 반복 ­ 운영체제는 프로세서 스케줄러를 이용해 프로세스 상태 변화를 관리 ㆍ 작업 스케줄러
- 스풀러가 디스크에 저장한 작업들 중 실행할 작업을 선정, 준비 리스트에 삽입
- 이를 통해 다중 프로그래밍의 정도를 결정하는 핵심적인 역할 수행
- 선정한  작업에  대한  프로세스의  생성에서  종료까지의  과정  수행을  위해  [프로세스  상태  변화]그림과 같은 상태 변화를 일으킴 [프로세스 상태 변화] · 실행 프로세스가 자발적으로 프로세서 반환 전 할당된 시간이 경과하면 준비상태로 변 경 · 실행 프로세스가 실행하다 입출력 명령이 발생 시 대기(보류) 상태로 변경 · 대기 프로세스는 보류 이유가 제거되면 준비 상태로 변경 · 준비 프로세스는 디스패처(Dispatcher)가 프로세서를 할당하면 다시 실행상태로 변경 종료 실행 디스패처 입출력 발생 시간 종료 대기 준비 (보류) 조건만족 프로세스 상태 변화 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 준비 → 실행
- 디스패치(Dispatch)  :  준비  리스트  맨  앞에  있던  프로세스가  프로세서를  선택(배당되어  실행)하는 것 dispatch(프로세스명) : 준비 → 실행
- 시간 할당 · 실행 프로세스가 프로세서를 일정 시간만 사용할 수 있도록 시간을 제한 · 특정 프로세스가 프로세서를 계속 독점하는 것을 방지함 프로세스 1 프로세스 1 프로세스 n 프로세스 운영체제 디스패처 준비 큐 프로세스와 디스패처 ㆍ 실행 → 준비
- 프로세스가 프로세서를 점유한 상태를 “프로세스가 실행 상태에 있다” 라고 함
- 운영체제는 프로세스의 독점을 방지하기 위해 인터럽트 클록(Interrupt Clock)을 둠 · 특정  프로세스가  일정  시간이  지나도(타임아웃)  프로세서를  반환하지  않으면  클록 (Clock)이 인터럽트를 발생, 운영체제가 프로세서 제어권을 가짐
- 운영체제가 제어권을 가지면 실행 중인 프로세스는 준비 상태로 변화, 준비 리스트의 첫  프로세스가 실행 상태로 변경 timeout(프로세스명) : 실행 → 준비 ㆍ 실행 → 대기(보류)
- 실행  프로세스가  지정  시간  전에  입출력  연산  등이  필요하거나  새로운  자원  요청  등의  문제 발생 시 스스로 프로세서를 양도하고 대기 상태로 변경 block(프로세스명) : 실행 → 대기(보류) ㆍ 대기(보류) → 준비
- 깨움(Wake up) : 프로세스의 마지막 상태 변화로 입출력 작업이 끝났을 때 발생 wakeup(프로세스명) : 대기(보류) → 준비 v 프로세스  상태  변화  중  프로세스  스스로  하는  것은  보류뿐,  나머지는  외부  조건에  의해  발생 5. 프로세스의 제어 블록(PCB, Process Control Block) ▶ 프로세스 제어 블록 (PCB, Process Control Block) ­ 프로세스는 운영체제 내에서 프로세스 제어 블록이라 표현하며, 작업 제어 블록이라고도 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 프로세스를 관리하기 위해 유지되는 데이터 블록 도는 레코드의 데이터 구조 · 프로세스 식별자, 프로세스 상태, 프로그램 카운터 등의 정보로 구성  · 프로세스  생성  시  만들어지고  메인  메모리에  유지,  운영체제에서  한  프로세스의  존재를  정의 · 프로세스 제어 블록의 정보는 운영체제의 모든 모듈이 읽고 수정 가능 ㆍ 프로세스 제어 블록[프로세스 제어 블록(PCB)] 그림
- 프로세스 식별자 : 각 프로세스에 대한 고유 식별자 지정  
- 프로세스 상태 : 생성, 준비, 실행, 대기, 중단 등의 상태 표시
- 프로그램 카운터 : 프로그램 실행을 위한 다음 명령의 주소 표시
- 레지스터 저장 영역 : 누산기, 인덱스 레지스터, 범용 레지스터, 조건 코드 등에 관한 정 보로 컴퓨터 구조에 따라 수나 형태가 달라짐
- 프로세서 스케줄링 정보 : 프로세스의 우선순위, 스케줄링 큐에 대한 포인터, 그 외 다른  스케줄 매개변수를 가짐
- 계정 정보 : 프로세서 사용시간, 실제 사용시간, 사용상한시간, 계정 번호, 작업 또는 프 로세스 번호 등
- 입출력  상태  정보  :  특별한  입출력  요구  프로세스에  할당된  입출력장치,  개방된 (Opened) 파일의 목록 등
- 메모리  관리  정보  :  메모리  영역을  정의하는  하한  및  상한  레지스터(경계  레지스터)  또 는 페이지 테이블 정보 ㆍ 프로세스 제어 블록 프로세스 식별자 프로세스 상태 프로그램 카운터 레지스터 저장 영역 프로세서 스케쥴링 정보 계정 정보 입출력 상태 정보  메모리 관리 정보 … 프로세스 제어 블록(PCB) 6. 프로세스의 교환 ▶ 프로세스 교환 ­ 프로세스의 교환은 인터럽트와 트랩, 시스템 호출로 나타냄 · 실행  중인  프로세스가  인터럽트되어  운영체제가  다른  프로세스를  실행  상태로  변경,  제 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 어를 넘겨줄 때, 프로세서의 레지스터 내용은 저장해야 함 · 프로세스는  현재  사용되는  자원에  대한  정보를  가지며,  실행되는  과정에서  여러  프로세 스가 파생될 수 있는 능동적인 개체 ­ 프로그램은 프로세스 여러 개로 생성될 수 있는 디스크에 저장된 파일 내용으로 정적  단위 · 즉, 자원을 할당 받은 상태의 프로그램 프로세스 P 운영체제 프로세스 P   실행 인터럽트나 시스템 콜 PCB 에 P 문맥 저장 유휴   PCB 에 P 문맥 저장   유휴 실행 인터럽트나 시스템 콜 PCB 에 P 문맥 저장   유휴 PCB 에 P 문맥 저장   실행 프로세스 간 교환(프로세스 사용을 전환하는 P1, P2 간의 교환) 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세스 관리

1. 프로세스의 구조를 이해하고 프로세스 생성·종료 과정을 정리할  수업목표   수 있다.
2. 프로세스의 중단과 재시작, 제거 과정에 대해 알 수 있다. 3주차 
1. 프로세스의 구조 1교시 
2. 프로세스의 생성
3. 프로세스의 종료 세부내용 
4. 프로세스의 제거
5. 프로세스의 중단과 재시작
6. 프로세스의 우선 순위 변경 1. 프로세스의 구조 ▶ 프로세스 구조 ­ 실행 중 프로세스 생성 시스템을 호출, 새로운 프로세스를 생성 가능 ­ 이때 프로세스 생성 순서 저장, 부모/자식 관계를 유지하며 계층적으로 생성됨 · 부모 프로세스(Parent Process) : 생성하는 프로세스 · 자식 프로세스(Child Process) or 서브 프로세스(Sub Process) : 생성되는 프로세스 ㆍ 유닉스 시스템의 일반적인 프로세스 계층 구조
- 처음 부팅 시 식별자(PID, Process ID)가 0인 첫 번째 프로세스 Swapper 생성
- 이어서 Init(PID=1), Pagedeamon(PID=2) 생성
- Swapper(PID=0),  Pagedeamon(PID=2)를  운영체제(커널)  프로세스라  하며  운영체제  모드에서만 실행
- 모든 사용자 프로세스는 fork() 명령을 통해 계층적으로 Init의 자식 프로세스로 생성됨 루트 Swapper Pagedeamon Init (PID = 0) (PID = 2) (PID = 1) 사용자 1 사용자 2 사용자 3 (PID = 4) (PID = 5) (PID = 6) 프로세스 계층 구조 예(유닉스 시스템) 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 2. 프로세스의 생성 ▶ 프로세스 생성 ­ 프로세스는 운영체제 또는 다른 사용자의 응용 프로그램 요청에 의해 생성 · 운영체제가  새로운  프로세스를  생성,  추가하려면  프로세스  관리를  위한  프로세스  제어  블록을 만든 후 프로세스에 주소 공간을 할당해야 함 ­ 일괄 처리 환경에서는 실행을 위해 작업이 준비 큐에 도착할 때 생성 ­ 대화형 환경에서는 새로운 사용자가 로그온(Log
-on)할 때 생성 · 프로세스 생성을 위해 다음과 같은 작업이 필요함 ­ 프로세스 식별자 결정 ­ 시스템에 알려진 프로세스 리스트에 식별자 삽입 ­ 프로세스에 초기 우선 순위 부여 ­ 프로세스 제어 블록 생성 ­ 프로세스에 초기 자원 할당 ㆍ 프로세스 생성 과정
① 1단계 : 새로운 프로세스에 프로세스 식별자 할당
② 2단계 : 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간, 프로세스 제어 블록  공간 할당
③ 3단계 : 프로세스 제어 블록 초기화 · 프로세스의  상태  정보/프로그램  카운터/스택  포인터  등의  초기화,  자원  요청,  프로 세스 제어 정보(우선 순위) 등
④ 4단계 : 링크(해당 큐에 삽입) ­ 프로세스가 작업을 수행하기 위해 자원 필요 · 자식 프로세스 생성 시 필요한 자원을 운영체제로부터 직접 또는 부모 프로세스의 자원  일부 사용 가능 · 부모 프로세스는 자식 프로세스에 자원을 나눠주거나 일부 자원 공유 가능 ­ 자원의 일부만 사용하도록 제한하면 시스템에 부담을 주는 것을 방지 가능함 ­ 프로세스  생성  시  획득하는  다양한  물리적,  논리적  자원  외에도 약간의  초기화  데이 터가 부모 프로세스에서 자식 프로세스로 전달되는 경우도 있음 ­ 새로운 프로세스 생성 시 실행과 관련해 다음 두 가지 경우가 가능함 · 부모 프로세스와 자식 프로세스가 동시에 실행됨 · 부모 프로세스는 자식 프로세스들이 모두 종료될 때까지 기다림 ­ 새로운 프로세스의 주소 공간은 다음 두 가지 경우가 가능함 · 자식 프로세스가 부모 프로세스의 주소 공간을 복사 ­ 유닉스는 각 프로세스마다 정수로 된 고유한 프로세스 식별자를 가짐 ­ 새로운 프로세스는 fork() 명령에 의해 생성, 주소 공간은 부모 프로세스의 주소 공간 을 복사함 ­ 부모 프로세스와 자식 프로세스의 정보 교환이 쉬움 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 자식 프로세스가 별도의 프로그램을 적재 v 윈도우 NT 계열은 새로운 프로세스의 주소 공간을 두 가지 방식을 모두 지원 3. 프로세스의 종료 ▶ 프로세스 종료 ­ 프로세스가 명령 실행 후 종료되고 운영체제에 프로세스 삭제 요청 · 일괄 처리 환경 : 작업 종료를 의미하는 신호로 인터럽트 발생 또는 시스템 호출로 중지  명령 전달, 프로세스 완료 · 대화형  환경  :  사용자가  로그오프(Log
-off)하거나  터미널을  닫을  때  또는  오류에  의해  프로세스 종료 · abort 시스템 호출을 이용한 프로세스 종료 ­ 종료되는 프로세스를 생성한 부모 프로세스만 호출 가능 ­ 부모 프로세스가 자식 프로세스의 생존권을  가져 다른 프로세스가 임의로 작업을 중 단시킬 수 없음 ­ 자식 프로세스 종료 시 자식 프로세서의 신원(Identity)이 부모 프로세스로 전달 ­ 부모 프로세스는 아래의 이유로 자식 프로세스 종료 가능 · 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때 · 자식 프로세스에 할당된 작업(Task)이 더 이상 없을 때 ­ 연속 종료 · 시스템이 부모 프로세스 종료 시 자식 프로세스의 존재를 허용하지 않아 종료시키는 현 상으로 운영체제가 수행함 ­ 유닉스에서 exit 명령으로 프로세스 종료, 부모 프로세스는 wait 명령을 사용하여 자 식 프로세스의 종료를 기다림 ­ wait 명령 : 종료된 자식의 프로세스 식별자를 부모 프로세스에 전달함 ­ 프로세스를 종료하는 경우와 그 예 · 정상 종료 : 프로세스가 운영체제의 서비스를 호출한 경우 · 시간 초과 : 프로세스가 명시된 전체 시간을 초과하여 실행되거나 명시된 시간을 초과하 면서 어떤 이벤트 발생을 기다리는 경우 · 실패 : 파일 검색 실패, 명시된 횟수를 초과하여 입출력이 실패한 경우 · 산술 오류, 보호 오류, 데이터 오류 등 · 메모리 부족, 접근 위반 등 4. 프로세스의 제거 ▶ 프로세스 제거 ­ 프로세스를 파괴하는 것 · 제거  시  프로세스에  속한  자원을  시스템에  돌려주고  해당  프로세스는  시스템  리스트나  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 테이블에서 사라지며, 프로세스 제어 블록 회수 · 프로그램은 디스크에 저장됨 5. 프로세스의 중단과 재시작 ▶ 프로세스 중단과 재시작 ­ 프로세스 중단(일시 정지) · 프로세서의 동작 시간과 입출력 동작 시간의 차이로 시스템의 활동 시간이 유휴 상태로  되는 것을 해결 가능 · 장시간 중단되는 경우 해당 프로세스에 할당된 자원을 다시 풀어주어야 하며, 풀어줄 자 원의 결정은 자원의 성질에 따라 결정 · 다중 프로그래밍에서 중단은 자원 부족(대기) 상태를 의미하기도 함 ­ 다중 프로그래밍 환경에서는  자원의  이용률과  시스템  효율 향상을 위해 자원을 동적 으로 할당 ­ 교착상태 발생 시 문제 생김 ­ 중단 : 할당된 자원을 기다리는 상태 ­ 대기 : 자원을 할당 받기 위해 기다리는 상태 ­ 운영체제는 다음 두 가지 방법으로 프로세스를 실행 가능 · 새로운 프로세스를 생성하여 실행 · 이미 실행 중인 프로세스를 중단시켰다가 다시 실행 ­ 시스템 전체의 부하를 증가시키지 않으면서 프로세스에 서비스 제공 가능 ­ 특정 이벤트 발생을 기다리며 대기 상태가 되므로 해당 이벤트 발생 시 즉시 실행 상 태로 변화 가능 ­ 프로세스 재시작 · 중단 원인이 제거되어 프로세스가 다시 실행되는 것 · 중단되었던 프로세스는 중단되었던 지점부터 다시 시작 ­ 프로세스 중단과 재시작은 다음과 같은 경우에 발생함 입출력이나 이벤트 완료 준비상태 대기상태 디스패치 입출력 대기  타임아웃 또는 사건 대기 중단 실행상태 재시작 재시작 중단 활동 상태 중단 상태 중단된 중단된 준비상태 대기상태 입출력이나 이벤트 완료 중단과 재시작을 추가한 프로세스 상태 변화 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 6. 프로세스의 우선 순위 변경 ▶ 프로세스 우선 순위 변경 ­ 프로세스 제어 블록의 우선 순위 값 변경 가능 · 준비 리스트의 프로세스는 프로세서 중심 프로세스(낮은 우선 순위)와 입출력 중심 프로 세스(높은 우선 순위)로 구분 ­ 우선 순위가 낮은 프로세스 : 시간 할당량을 크게 제공 ­ 우선 순위가 높은 프로세스 : 시간 할당량을 적게 제공 v 입출력  중심의  프로세스를  자주  짧게  사용, 프로세서 중심 프로세스는  사용 횟수는 적 으나 한번에 오래 사용하게 하여 균형을 유지함 · 입출력 프로세스 ­ 높은 우선 순위 : 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스 ­ 낮은 우선 순위 : 속도가 빠른 디스크 입출력 프로세스 ­ 프로세스 스케줄러는 준비 리스트의 우선 순위를 이용해 프로세스를 처리 ­ 할당 시간을 초과할 경우 프로세스 실행 상태에서 준비 상태로 변경 ▶ 문맥 교환(Context Switching) ㆍ 프로세스 교환
- 실행  중인  프로세스가  인터럽트되면  운영체제가  다른  프로세스를  실행  상태로  변경,  해 당 프로세스에 제어를 넘겨주는 과정에서 실행 중인 프로세스로부터 제어를 인수한 운영 체제가 또 다른 프로세스에 제어를 넘겨주기 위해 발생 · 인터럽트  처리  루틴을  실행한  후  현재  실행  중인  프로세스가  재실행될  수  있으므로  대부분의 운영체제는 프로세스 교환으로 인터럽트가 발생하지 않음 · 트랩은 시스템이 치명적인 오류인지를 판단, 치명적 오류일 경우 프로세스를 종료하면 서 프로세스 교환 발생 ㆍ 문맥 교환
- 프로세스를 다른 프로세스로 교환하기 위해 이전 프로세스의 상태 레지스터 내용을 보관 하고 다른 프로세스의 레지스터를 적재하는 일련의 과정 · 프로세스가 “준비→실행”, “실행→준비”, “실행→대기” 상태로 변할 때 발생 · 오버헤드가 발생하며 오버헤드는 메모리 속도, 레지스터 수, 특수 명령어의 존재에 따 라 다르므로 시스템마다 다름 사용자 공간 운영체제 공간 운영체제모드로 전환 P 실행 i · P 의 하드웨어 상태를 PCB 에 저장 i i · P 를 다음에 실행할 프로세스로 선택 k · PCB 로부터 P 프로세스의 정보를 얻어 CPU에 재저장 k k P 실행 사용자모드로 전환 k 문맥 교환 과정 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 인터럽트(Interrupt)
- 현재 실행되는 프로세스와 별도로 외부에서 발생되는 여러 종류의 이벤트(입출력 동작의  종료 등)에 의해 발생
- 제어가 인터럽트 처리 루틴으로 넘어간 후에도 기본 시스템 관리 작업을 처리, 인터럽트  형태에 따라 관련된 운영체제 루틴으로 분기 
- 대표적인 인터럽트 예 · 입출력 인터럽트 : 입출력 동작이 발생한 사실을 확인 후 이벤트를 기다리는 프로세스 를 준비 상태로 변경, 실행할 프로세스를 결정 · 클록 인터럽트 : 현재  실행 주인 프로세스의 할당 시간을 조사하여 실행 중인 프로세 스를 준비 상태로 변경, 다른 프로세스를 디스패치하여 실행 상태로 변경 ㆍ 트랩(Trap)
- 부적절한 파일 접근 또는 현재 실행 중인 프로세스에 의해 발생되는 오류나 예외 상황으 로 인해 발생 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 스레드

1. 스레드의 개요에 대해 알 수 있다. 수업목표  
2. 스레드의 상태를 정리 할 수 있다. 3주차 
3. 스레드의 구형에 대해 알 수 있다.
1. 스레드의 개요 2교시 
2. 단일 스레드와 다중 스레드 세부내용 
3. 스레드의 용법
4. 스레드의 상태변화
5. 스레드의 구현 1. 스레드의 개요 ▶ 스레드 개요 ­ 프로세스에서 실행 제어만 분리한 실행 단위 · 경량 프로세스(LWP, Light Weight Process)라고도 부름 ­ 중량 프로세스(HWP, Heavy Weight Process)는 스레드를 하나 가진 작업 · 프로세서를  사용하는  기본  단위이며,  명령어를  독립적으로  실행할  수  있는  하나의  제어  흐름 · 작업 : 스레드의 그룹 환경 ­ 같은 그룹의 스레드와 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등을 공유 v 작업에 스레드가 없으면 아무 일도 할 수 없으므로 반드시 스레드가 있어야 함 ­ 프로세스는 스레드를 하나 이상 가지며, 각 스레드는 아래 내용을 포함 · 스레드 실행 시의 상태(실행, 준비 등) · 실행 스택 · 지역 변수와 스레드의 특정 데이터를 저장하기 위한 스레드별 정적 저장소 · 프로세스의 다른 스레드가 공유하는 프로세스의 메모리와 자원에 대한 접근 등의 스레드  실행 환경 정보(문맥 정보) 스레드 실행 정보 스레드   (SP, SR, PC, 지역 스레드 상태,  실행 스택 스레드 우선 순위) 데이터 텍스트(코드) 스레드 실행 정보  스레드  전역 데이터 (SP, SR, PC, 지역 스레드 상태,  실행 힙 스레드 우선 순위) 데이터 실행 스택 스레드 실행 정보  스레드  · SP: 스택 포인터(Stack Pointer) (SP, SR, PC, 지역 · SR: 순서열 레지스터(Sequence Register) 스레드 상태,  스레드 우선 순위) 데이터 실행 스택 · CP: 프로그램 카운터(Programe Counter) 스레드 구조 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 스레드의 장점
- 프로세스에 포함된 스레드들은 공통의 목적 달성을 위해 병렬로 수행  · 자원을 공유하여 한 프로세스에서 동시 작업 가능
- 시스템 성능과 효율 향상 · 하나의 프로세스가 서로 다른 프로세서에서 프로그램의 다른 부분을 동시에 실행 가능 · 응용 프로그램 하나가 비슷한 작업들을 여러 개 수행
- 스레드를 이용하여 다음과 같은 이점을 얻을 수 있음 
① 사용자에 대한 응답성 증가 : 응용 프로그램의 일부분이 봉쇄 또는 긴 작업 수행 시 에도 프로그램 실행을 계속 허용하여 사용자에 대한 응답성이 증가
② 프로세스의 자원과 메모리 공유 가능 : 스레드는 그들이 속한 프로세스의 자원과 메 모리를  공유하므로,  응용  프로그램  하나가  같은  주소  공간에서  여러  개의  스레드를  실 행, 시스템 성능 향상과 편리함 제공
③ 경제성 : 한 프로세스의 자원을 공유하므로 프로세스를 생성하는 것보다 오버헤드를  줄일 수 있음
④ 다중  프로세서  구조 활용 가능  : 다중  프로세서  구조에서  각 스레드는 다른 프로세 서에서 병렬로 실행될 수 있음 스레드 2 스레드 1 스레드 3 프로세스 스레드 1의 스택 스레드 2의 스택 커널 프로세스와 다중 스레드    2. 단일 스레드와 다중 스레드 ▶ 단일 스레드와 다중 스레드 ­ 운영체제는 단일 프로세스에서 단일 스레드 실행과 다중 스레드 실행을 지원 ㆍ 단일 스레드 프로세스
- 프로세스 하나에 스레드 하나가 실행되는 전통적인 방식으로 스레드의 개념이 불확실함
- MS
-DOS ㆍ 다중 스레드 프로세스
- 프로세스 하나에 여러 스레드를 실행하는 것을 지원
- 윈도우 NT/XP, 솔라리스 등 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세스 프로세스 프로세스 프로세스 사용자  영역 스레드 스레드 커널영역 커널 커널 (a)단일 스레드 프로세스 (b)다중 스레드 프로세스 단일 스레드 프로세스와 다중 스레드 프로세스 ㆍ 다중 스레드의 특징
- 각 스레드를 별도의 프로세서에서 실행하는 측면 다중 프로세싱(프로세서)와 같은 의미
- 동일  프로세스  내의  스레드는  메모리와  파일을  공유하므로,  프로세스  하나에  다수의  실 행 단위로 구분된 자원을 공유
- 자원 생성과 관리의 중복성을 최소화하여 실행 능력 향상
- 각 스레드는 커널 개입 없이 서로 통신이 가능하여 독립적으로 실행
- 서버에서 많은 요청을 효과적으로 처리할 수 있는 환경
- 프로세스를  새로  생성하는  것보다  기존  프로세스에서  스레드를  생성하는  것이  빠르고,  같은 프로세스 내 스레드 간 교환이나 스레드 종료 역시 빠름
- 프로세스의 상대적인 무게를 줄여 효율을 극대화하는 것이 목표
- 프로그램 변경 없이 프로세서의 개수에 따라 스레드를 병렬로 처리 가능
- 같은 그룹의 스레드에 프로세서를 할당 또는 스레드 생성 시 중량 프로세서들 사이의 문 맥 교환과 비교하여 더 경제적임 ㆍ 단일 스레드와 다중 스레드 모델
① 단일 스레드 프로세스 모델 · 프로세스를 하나의 스레드, 스레드가 가진 레지스터와 스택으로 표현
② 다중 스레드 프로세스 모델 · 프로세스를 각각의 스레드와 고유의 레지스터,  스택으로  표현, 프로세스 주소 영역 을 모든 스레드가 공유 · 프로세스의 모든 스레드는 해당 프로세스의 자원과 상태를 공유, 같은 주소 공간에  존재하며 동일한 데이터에 접근 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 코드 데이터 파일 코드 데이터 파일 레지스터 레지스터 레지스터 레지스터 스택 스택 스택 스택 스레드 스레드 (a)단일 스레드 프로세스 (b)다중 스레드 프로세스 프로세스 관리 면에서 살펴본 단일 스레드와 다중 스레드 프로세스 3. 스레드의 용법 ▶ 스레드 용법 ­ 단일 사용자 다중 처리 시스템 환경 · 시스템 호출이 아닌 사용자 라이브러리 수준에서 스레드 개념을 제공, 빠른 속도 · 프로그램에 비동기적 요소를 구현 가능 · 실행  중인  스레드를  대기  상태로  변경,  다른  스레드로  제어를  이동시키는  상태  변화는  하나의 서버가 많은 요청을 받아들여 처리하는 효과적인 방법 ­ 공유 메모리 형태의 다중 프로세서 시스템 환경 · 프로그램을 공유 메모리에 저장, 스레드를 각 프로세서에 할당, 병렬 처리하여 프로세서  성능을 매우 향상시킬 수 있음 ㆍ 스레드의 단점
- 사용자 수준 스레드는 커널 자체가 스레드 하나로 구성, 시스템 호출 실행 시 해당 스레 드가 포함된 전체 작업이 시스템 호출 결과가 돌아올 때까지 대기 워드 프로세서 키보드 디스크 커널 다중 스레드 환경의 워드 프로세서 실행 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 웹 서버 프로세스 디스패처 스레드 네트워크  사용자 영역 연결 직업 스레드 웹 페이지 캐시 커널 커널 영역 다중 스레드 환경의 웹 서버 프로세스 4. 스레드의 상태변화 ▶ 스레드의 상태 변화 ㆍ 스레드의 특징
- 준비, 실행,  대기, 종료 상태로 구분,  프로세서를 함께  사용하며  항상  스레드 하나만 실 행됨
- 한  프로세스에  있는  스레드는  순차적으로  실행,  자신의  정보를  위한  프로그램  카운터와  스택을 가짐
- 스레드 생성 시 운영체제는 부모 프로세스와 공유할 자원을 초기화하지 않음
- 프로세스 내 스레드는 해당 프로세스에서 다른 스레드를 생성, 새로 형성된 스레드를 위 한 스택과 레지스터를 제공함으로 프로세스의 생성 및 종료 과정 보다 오버헤드가 적음
- 하나의 스레드가 대기 상태로 변할 때 전체 프로세스를 대기 상태로 변화시키지 않음 · 하나의 스레드가 대기 상태일 경우 다른 스레드 실행 가능
- 서로 독립적이지 않다. · 한 작업에 있는 모든 스레드는 작업의 모든 주소에 접근 가능
- 보호 문제 · 프로세서는 다수의 사용자에게서 발생, 경쟁적인 자원 요구와 서로 다른 관계 유지 · 스레드는 한 명의 사용자가 여러 스레드를 가진 작업 하나를 소유 ㆍ 스레드의 상태
① 대기 · 스레드가 이벤트를 기다릴 때, 즉 입출력 작업 등이 완료될 때까지 대기(보류) 상태 · 자신의 정보(프로그램 카운터, 스택 포인터 등)를 실행 스택에 저장
② 준비 · 스레드가 프로세서에 의해 실행될 수 있는 상태 · 스레드를 대기시킨 이벤트 발생 시 해당 스레드는 준비 리스트에 삽입됨
③ 실행 · 스레드가 프로세서를 점유하여 실행 중인 활성화 상태
④ 종료 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 스레드가 작업을 종료하면 자원을 해제, 레지스터 문맥과 스택 할당 제거 준비 실행 종료 대기 스레드 상태 변화     5. 스레드의 구현 ▶ 스레드 구현 ­ 사용자 수준 스레드 · 커널 스레드를 지원하지 않는 운영체제에서 사용 · 사용자 수준 스레드 여러 개가 커널 스레드(프로세스) 하나로 매핑되는 방식 · 다중 스레드 프로세스에 대해 프로세서(실행 문맥) 하나를 할당하므로 다대일 스레드 매 핑이라 칭함 · 사용자  수준(공간)에서  스레드  관리가  효율적으로  이루어지므로  스레드와  관련된  모든  과정을 응용 프로그램이 수행 · 응용  프로그램은  사용자  수준  스레드  관리를  위한  루틴으로  구성된  스레드  라이브러리 (스레드 패키지)를 이용, 다중 스레드로 프로그래밍 가능 · 응용 프로그램은 기본적으로 스레드 하나에서 시작, 해당 스레드에서 실행을 시작함 프로세스 스레드 사용자  스레드 사용자 영역 커널 커널 영역 커널 스레드 스레드 프로세스  실행(Run Time)  테이블 테이블 시스템 (a)다대일 스레드 매핑 (b)사용자 수준 스레드 다대일 스레드 매핑과 사용자 수준 스레드 ­ 스레드 라이브러리 · 스레드  생성,  종료,  문맥  교환을  위한  코드,  동기화,  메모리  할당,  스레드  간  메시지 전 달, 스레드 실행 스케줄링 등의 정보를 포함 · 생성 유틸리티를 통해 스레드가 생성, 제어는 프로시저 호출을 통해 해당 유틸리티로 이 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 동하여 수행 ㆍ 사용자 수준 스레드의 장점
- 커널 도움 없이 사용자 주소 공간에 구현된 스레드 패키지로 스레드 연산 실행
- 커널은 연산 과정은 모르고 프로세스를 계속 하나의 단위로 스케줄하고 하나의 실행 상 태를 할당
- 커널과  상관  없이  다양한  목적의  응용  프로그램이나  언어  인터페이스의  요구에  적용할  수 있는 융통성을 가짐 ­ 여러 수준에서 스레드 구현 가능 · 운영체제에 따라 다르며 일반적으로 사용자 수준과  커널 수준,  혹은 혼합한 방식  중 하 나를 사용 · 윈도우  2000/XP,  Mach,  OS/2, 솔라리스  운영체제는 커널 수준 지원, 시스템 호출  제 공 · 사용자 수준에서 라이브러리 호출을 통한 지원 가능 ㆍ 사용자 수준 스레드 이용 시 시스템의 장점
① 높은 이식성 · 기본 커널 변경 없이 모든 운영체제에 적용 가능
② 오버헤드 감소 · 스레드 관리를 위한 모든 데이터 구조가 프로세스의 사용자 주소 공간에 있어 커널 의 도움 없이 스레드 교환 가능
③ 스케줄링의 유연성 · 스레드 라이브러리에서 스레드 스케줄링을 제어하므로 스케줄링이 응용 프로그램에  맞게 적절히 구성됨 ㆍ 사용자 수준 스레드 이용 시 시스템의 단점
① 시스템의 동시성 지원 불가 · 한 번에 하나의 스레드만 커널에 접근 가능하므로 여러 스레드가 시스템 호출을 동 시에 사용할 수 없음
② 시스템 규모 확장 제약 · 커널이 프로세서 내부의 다중 스레드를 프로세스 하나로 관리, 다중 처리 환경에서  여러 프로세스를 이용한 분산 처리를 할 수 없음
③ 스레드 간 보호가 어려움 · 스레드  간의  보호에  커널의  보호  기법을  사용할  수  없고,  스레드  라이브러리에서  스레드 간 보호를 제공해야 프로세스 수준에서 보호됨 ­ 커널 수준 스레드 · 사용자  수준  스레드의  한계를  해결하기  위해  사용자  스레드마다  프로세서(실행  문맥)를  매핑하는 일대일 스레드 매핑을 지원 · 커널에  의해  생성,  삭제되고  커널의  텍스트와  전역  데이터를  공유,  자신만의  커널  스택 을 가짐 · 사용자 영역에는 스레드 관리를 위한 코드가 없음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 모든 응용 프로그램은 다중 스레드로 지원, 응용 프로그램의 스레드는 하나의 프로세 스에서 지원 ­ 스레드 관련 모든  작업은 커널(운영체제)이 지원, 프로세스와 스레드에 대한 실행 문 맥 정보 유지 · 일대일  모델  구현  운영체제  :  윈도우  NT/XP/2000,  리눅스,  솔라리스  9  이상  버전,  OS/2 프로세스 스레드 사용자  사용자 영역 스레드 커널  커널 커널 영역 k k k k 스레드 프로세스  스레드  테이블 테이블 (a)일대일 스레드 매핑 (b)커널 수준 스레드 일대일 스레드 매핑과 커널 수준 스레드 ­ 커널 지원 부족 문제 해결 · 커널에 의한 직접적인 스케줄링과 실행으로 사용자 수준 스레드의 문제를 해결하여 시스 템 성능 향상 ­ 병렬 실행 가능 · 하나가  시스템  호출  시  다른  스레드가  중단되는  다대일  방식의  문제를  해결할  수  있어  다중 프로세서에서 다중 스레드를 병렬로 실행 가능 · 시스템 규모 확장이 쉬우며 처리량을 늘릴 수 있음 ­ 커널 모드 전환 오버헤드 · 커널 스레드 생성으로 인한 오버헤드 증가로 응용 프로그램의 성능 저하를 막기 위해 시 스템이 지원 스레드 수를 제한해야 함 · 사용자 수준 스레드보다 스케줄링과 동기화를 위해 자원이 더 필요함 · 시스템이 모든 스레드를 관리하므로 오버헤드 증가 ­ 이식성이 떨어짐 · 시스템 변경 시 제공된 스레드 API(Application Program Interface)를 사용하여 프로그 램을 수정 · 제한적인 자원으로 인해 사용자 수준 스레드 생성에 따라 커널 스레드를 무한정 생성할  수 없음 ­ 혼합형 스레드 지원 · 스레드 생성은 사용자 영역에서,  여러 개의 사용자  수준 스레드에 여러  개의 커널 스레 드가 매핑되는 다대다 스레드 모델 · 사용자 수준 스레드 생성 시 커널 수준 스레드를 생성, 성능 감소 · 시스템 호출 시 다른 스레드가 중단되는 문제를 해결하기 위한 방법 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 다대다 모델 구현 운영체제 : 솔라리스(Solaris) ※ 정리하기 ▶ 프로세스 개념 ­ 운영체제의 주 기능은 프로세스의 생성과 종료 ­ 프로세스는 실행 중인 프로그램으로, 실행되는 프로세스는 독립적 혹은 협조적일 수 있음 ­ 협조적 프로세스는 논리적 주소 공간을 직접 공유 또는 파일을 통해서만 데이터 공유 가능 ▶ 프로세스 상태 ­ 프로세스 상태는 프로세스의 현재 활동에 의해 정의되며, 각 프로세스는 생성, 준비, 실행,  대기, 종료 상태로 구분, 실행하면서 상태 변경 ­ 프로세스  제어  블록(PCB)에  의해  운영체제에서  표현되며,  프로세스의  일시  정지(서스펜드)  상태를 이용하여 다중 프로그래밍 환경에서 프로세스 유휴 시간 발생을 해결 가능함 ▶ 문맥 교환 ­ 프로세스 전환 시 이전 프로세스 상태 레지스터 내용을 보관, 또 다른 프로세스의 레지스터 를 적재하는 문맥교환 과정을 거침 ▶ 프로세스와 스레드 ­ 운영체제는 프로세스를 자원의 소유, 스레드를 실행 단위로 개념을 분리 ­ 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유,  자원의 생성과 관리의 중복 성을 최소화하여 수행 능력 향상 ▶ 스레드 상태 ­ 준비, 실행 대기, 종료 상태로 구분 ­ 한 프로세스에 있는 스레드는 순차적으로 실행, 자신의 정보를  위한 프로그램 카운터와 스 택을 각각 가짐 ▶ 사용자 수준 스레드와 커널 수준 스레드 ­ 사용자 수준 스레드 : 스레드 사이에 이전의 커널이 개입하지 않아 빠름 ­ 커널  수준 스레드 :  같은 프로세스의  스레드를  동시에  스케줄링  가능, 한  프로세스의 스레 드가 대기 상태가 되면 커널이 같은 프로세스에서 다른 스레드를 스케줄할 수 있음 ▶ 혼합형 스레드 ­ 사용자 수준 스레드 생성 시 커널 수준 스레드를 생성 ­ 성능 감소, 스레드 수가 제한되는 일대일 방식(커널 수준)과 어떤 스레드가 시스템 호출 시  다른 스레드가 중단되는 다대일 방식(사용자 수준)의 문제를 해결하기 위한 방법 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 병행프로세스와 상호배제(1)

1. 병행 프로세스의 개념에 대해 알 수 있다.
2. 선행 그래프에 대해 정리 할 수 있다. 수업목표  
3. 병행 문장의 언어 구조 fork와 join에 대해 알 수 있다. 4주차 
4. 병행 프로세스 간 상호작용에 대해 설명할 수 있다.
1. 병행 프로세스의 개념 1교시 
2. 병행 프로세스의 과제
3. 선행 그래프 세부내용 
4. 언어적 표현과 병행 문장
5. 상호배제와 동기화
6. 생산자/소비자 프로세스 1. 병행 프로세스의 개념 ▶ 병행 프로세스 개념 ­ 프로세스 여러 개가 동시에 실행되는 것 · 독립적으로 작업을 수행, 다른 프로세스와 협력하며 특정 기능 수행 · 프로세스 간 교신이 필요 ­ 비동기적 병행 프로세스 · 프로세스 간 교신 시 동기화되어야 하는 프로세스 ­ 상호 작용 · 제한된  자원을  공유하기  위함이며,  상호  작용하는  프로세스는  순서에  맞게  실행되도록  동기화되어야 함 2. 병행 프로세스의 과제 ▶ 병행 프로세스의 과제 ­ 병행성 · 다수의  프로세서를  이용하여  작업을  수행하며,  다중  프로세싱  시스템,  분산  처리  환경,  다중 프로그래밍 운영체제에서 매우 중요함 · 시스템의 신뢰도 향상과 처리 속도 개선을 통한 처리 능력 증대에 매우 중요함 · 다중 프로세싱 시스템 ­ 각 프로세서가 갖는 오버헤드를 감소시키면서 프로세서의 유효성을 증대시킴 ­ 여러  개의  명령어를  세분화하여  동시에  처리하기  위해  프로세서들을  연결,  상호작용 을 제어 ­ 다중 프로세싱 시스템의 성공적인 구현을 위한 해결 문제 · 공유 자원을 상호 배타적으로 사용해야 함 ­ 프린터, 통신망 등은 한 순간에 한 프로세스만 사용해야 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 병행 프로세서들 사이는 협력 또는 동기화되어야 함 ­ 상호 배제도 동기화의 형태임 · 두 프로세스 사이에 데이터 교환을 위한 통신이 이루어져야 함 · 프로세서는 결정성(Determinacy)을 확보해야 함 ­ 동시에  수행되는  다른  프로세스들의  실행  속도와  관계  없이  항상  일정한  실행  결과  보장 · 교착 상태를 해결하고 병행 프로세스들의 병렬 처리 능력 극대화 · 실행 검증 문제 해결 · 병행 프로세스 수행 과정에서 발생하는 상호 배제를 보장해야 함 ­ 어떤 프로세스가 작업을 실행 중일 때 나머지 프로세스들이 그 작업에 관련된 작업을  수행할 수 없음 ­ 다중 프로세싱 시스템은 프로세스 동기화 알고리즘이 필요 · 프로세서들이 모든 입출력 장치와 메모리를 참조 가능 · 동시에 동일한 자원에 접근할 경우 충돌이 발생하므로 이를 해결 3. 선행 그래프 ▶ 선행 그래프 ­ 프로세스는 프로세스 집합과 이들의 선행 제약(Precedence Constraint)의 두 가지 요소로  정의 ㆍ 선행 제약
- 프로세스가 순서대로 다른 상태로 옮겨감
- 프로세스 ‘P , P , …, P ’가 있을 때, 선행 순서는 P ＜ P로 표시, 상태는 P에서  P로    ■ i j i j 옮겨감
- 따라서 P ＜ P 이고  P ＜  P 이면 P ＜ P i j j k i k
- 두 프로세스 간에 선행 관계가 없으면 이들은 독립적이라 병행 실행이 가능함 ㆍ 선행 그래프(Precedence Graph)
- 제약을 규칙적(논리적)으로 표현한 것
- 각 문장에 대응되는 노드가 비순환 그래프를 이룸 · 노드  S에서 노드  S로 가는 연걸선(Edge)은 문장 Si가 완전히 수행된 다음에 문자  S i j j 가 수행됨을 의미함 ㆍ 산술 연산 수행 알고리즘
- 병행 수행을 하기 위해 프로세서 안의 기능 단위(가산기 등)를 여러 개 두거나 프로세서 를 여러 개 사용해야 함
- 프로세서를 여러 개 사용 시 여러 문장이 동시에 수행되어 총 수행시간을 줄일 수 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 간단한 산술 연산을 수행하는 알고리즘 S S   01  a := x + y → S  S 02  b := z + 1 → S   03  c := a ­ b → S  04  w := c + 1→ S S   간단한 산술 연산을 수행하는  알고리즘에 대한 선행 그래프
① c := a ­ b; 
- a와 b가 값을 할당받기 전에 수행하면 안 된다.
② w := c + 1; 
- c 값을 계산하기 전에 수행할 수 없다.
③ a := x + y, b := z + 1; 
- 서로 독립적이므로 동시에 수행할 수 없다.
- 선행 그래프 · S 와 S 은 S 이 끝난 후에 수행 된다.    · S 는  S 가 끝난 후에 수행된다. S 와 S 은 S 가 끝난 후에 수행 된다.      · S 은  S ,  S , S 이 끝난 후에만 수행된다.     · S 은  S , S , S ,  S 과 병행하여 수행될 수 있다.      S  S  S  S  S  S S   선행 그래프 1 · S 은  S 가 끝난 후에만 수행할 수 있다.   S · S 는 S 이 끝난 후에만 수행할 수 있다.    → 이 제약은 동시에 만족할 수 없음 → 실행 우선 순위를 정의할 수 없어 모순이 발생 S  S  선행 그래프 2 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 4. 언어적 표현과 병행 문장 ▶ 언어적 표현과 병행 문장 ­ 프로그램의 여러 문장의 선행 관계 명시를 위해 두 가지 언어구조 제시 ㆍ fork와 join 구조
- 선행  그래프는 연산 부분의  선행  제약을  정의하는데  유용하나,  2차원이므로  프로그래밍  언어에서 사용하기에 어려움
- 콘웨이(Conway,  1963년)와  데니스(Dennis,  1966년),  호른(Van  Horn,  1966년)이  소 개
- 병행을 최초로 언어적 표현으로 명시
- fork L 명령 · 프로그램에서 두 개의 병행 수행을 만듦 · 단일 연산을 두 개의 독립적인 연산으로 분할
① 레이블이 L인 문장에서 수행을 시작
② fork 명령 바로 다음 문장에서 시작
- join 명령 · 여러 개의 병행 연산을 하나로 결합하는 방법 제공하며, 단위적으로 수행해야 함 · 합칠 연산의 수를 명시하는 매개변수를 가짐
① 연산들은 서로 다른 속도로 진행되므로 둘 중 하나가 join을 먼저 수행하게 됨
② join 연산 수행 후 다른 연산 수행
③ 세 개의 연산을 합칠 경우 두 개의 연산이 끝나고 join 연산을 수행한 다음 이들 의 결과와 나머지 연산을 join 함 ㆍ fork와 join 구조 설명 알고리즘
- ‘fork L’문장이 수행되면 새로운 연산이  S 에서 실행 
- 새로운 연산은 S 에서 시작되는 연산과 병행하여 수행됨  fork와 join 구조를 설명하는 알고리즘 S  01  S ;  02  fork L; fork 03  S  04  … S S   05  L : S  fork 구조의 선행 그래프 ㆍ count를 매개변수로 가지는 join 명령 예
- count는 0이 아닌 정수값, quit는 count의 계산 수행을 종료시키는 명령 · join할 연산이 2개라면 매개변수 count의 초기값은 2 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr … … count := count 
- 1; if count = 0 then quit; ㆍ 임의의 순서로 순차 수행되는 것과 동일한 알고리즘
- 두 개의 join 문장의 병행 수행은 두 문장을 임의의 순서로 순차 수행하는 것과 동일함 임의의 순서로 순차 수행되는 것과 동일한 알고리즘 S S   01  Count := 2; 02  fork L1; 03  … 04  … join 05  S ;  06  Go to L2; 07  L1 : S ;  S  08  L2 : join count; 09  S ;  join 구조의 선행 그래프 ㆍ 산술식에 대한 선행 그래프와 fork
-join 구조
- [간단한  산술  연산을  수행하는  알고리즘]  중  두  개의  read  문장을  병행  수행하기  위한  fork
-join 명령 count := 2; fork   fork L1; a:=x+y; b:=z+1;   a := x + y;    go to L2; join L1 : b := z + 1; L2 : join count; c:=a­b;   c := a ­ b;   w := c + 1; w:=c+1; 산술식에 대한 선행 그래프와 fork
-join 구조 ㆍ [선행그래프 1] 그림에 대한 fork, join 명령을 이용한 알고리즘
- [선행그래프 1] 그림에는 유일한 join 노드 S7이 있으며, 유입 정도(In
-degree)는 3
- 따라서 join 문장이 하나 필요하며 join에 대한 count의 초기값은 3 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 01  S  ; S  02  count := 3; S 03  fork L1; S   04  S ;  05  S ;  S 06  fork L2;  07  S ;  S  08  go to L3; 09  L2 : S  ; S S   10  go to L3; 11  L1 : S ;  선행 그래프 1 12  L3 : join count; 13  S ;  ㆍ 병행 문장
- 프로세스 하나가 여러 가닥의 병렬 프로세스로 퍼졌다가 다시 한 가닥으로 뭉쳐지는 것 을 나타내는 고급언어 구조 · 대표적인 예 : 다익스트라(Dijkstra, 1965년)가 제안한 ‘parbegin/parend’
- 일반적인 형태는 아래와 같음 parbegin S ; S ; ……; S ; parend;   ■
- 각 S는 단일 문장(명령어), parbegin과 parend 사이의 모든 문장은 병행 수행 가능 i
- 보다 효과적인 병행 문장은 S 과  S 문장을 추가하여 아래와 같이 정의 가능  n · S 은 모든 S(i=1, 2,…, n)가 끝난 후에만 실행 가능 n · 모든  문장이  ‘S ;  S ;  …;S ;’과 같이  실행  후  S 결과가  된다면  [복잡한 구조의 선   ■ n 행 그래프]그림으로 표현 S ; parbegin S ; S ; ……; S ; parend; S ;    ■ n S S ; S    PARBGIN S ;  S S S S BEGIN    ■ S  ;  S  S S S  PARBGIN   S ; S ; PAREND; S ;    S END;  S ;  S  n PAREND;  S S ;   병행문장의 일반 형태와 선행 그래프 복잡한 구조의 선행 그래프 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ [간단한 산술 연산을 수행하는 알고리즘]의 처음 두 문장을 동시에 수행
- parbegin/parend 구조 이용, [선행 그래프 1]의 대한 알고리즘과 같이 표기 S S parbegin     a := x + y;    b := z + 1; S  parend;   c := a ­ b;    w := c + 1; S  [간단한 산술 연산을 수행하는 알고리즘]에  대한 선행 그래프 [선행 그래프 1]에 대한 알고리즘 S  01   S ;  02  parbegin S S   03   S ;  04   begin 05    S ;  S 06    S ;   07    parbegin S 08     S ;   09     S ;  S S 10    parend;   11   end; 12  parend; 13  S ; 선행 그래프 1  5. 상호배제와 동기화 ▶ 상호배제와 동기화 ㆍ 상호배제(Mutual Exclusion)
- 특정  공유  자원을  한  순간에  한  개의  프로세스만  사용할  수  있을  때,  프로세스  하나가  공유 데이터에 접근하는 동안 다른 프로세스가 해당 데이터를 접근할 수 없게 하는 것 ㆍ 프로세스 간 동기화
- 공유자원을 동시에 사용하지 못하게 실행을 제어하는 기법
- 순차적으로 재사용 가능한 자원을  공유하기  위해  상호작용하는 프로세스  사이에서  나타 남 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 병행 프로세스 간 상호작용 ­ 프로세스는 아래 세 가지 형태로 상호작용 함 · 프로세스들이 서로 인식하지 못하는 경쟁관계 유지 ­ 다중 프로그래밍 환경에서 운영체제는 자원에 대한 경쟁을 고려, 동일한 디스크나 프 린터로의 접근 조절 · 프로세스들은 입출력 버스를  비롯한  개체를  공유하는 단계에서 간접적으로  서로의  관계 를 인식함 ­ 프로세스들은 공동 개체를 공유하는데 따른 협력이 필요함 · 프로세스들은 서로를 인식하고 프로세스끼리 통신할 수 있는 기본 함수를 가짐 ­ 프로세스들이  협력관계일  때,  프로세스  간  직접  통신이  가능,  병행해서  함께  동작할  수 있음 6. 생산자/소비자 프로세스 ▶ 생산자/소비자 프로세스 ­ 생산자/소비자, 판독자/기록자(입력기/출력기) 문제 · 여러 프로세스가 공통 작업 수행을 위해 서로 협동하고, 병행 처리되는 대표적인 예 · 상호배제와 동기화가 필요하며 세마포어를 이용해 구현 · 운영체제에서 비동기적으로 수행하는 모델로 생산자 프로세스는 소비자 프로세스가 소비 하는 정보를 생산 생산 소비 라인 프린터 드라이버 문자 라인 프린터 생산 소비 컴파일러 어셈블리 코드 어셈블러 생산 소비 어셈블러 적재 모듈 로더 생산자/소비자 프로세스 관계 ­ 생산자와 소비자 프로세서들을 병행 실행하기 위해 공유 버퍼가 필요함 · 생산자의  데이터  생산  속도와  소비자의  데이터  소비  속도는  서로  독립적이므로  버퍼가  필요함 ­ 생산자와 소비자는 같은 버퍼에 접근하므로 동시에 사용할 수 없음 · 생산자가  이미 채워진 버퍼에  더 채우거나, 소비자가 빈 버퍼에서 데이터를 꺼낼  때 문 제 발생 · 속도가 다른 생산자와 소비자가 데이터를 일시 저장할 수 있는 버퍼 사용 시 버퍼는 [전 형적인 버퍼의 세 가지 상태]그림의 세 가지 상태 중 하나 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 생산자 소비자 (a) 가득찬 버퍼 생산자 소비자 (b) 부분적으로 빈 버퍼 생산자 소비자 (c) 모두 빈 버퍼 전형적인 버퍼의 세 가지 상태 ㆍ 프로세스 간 통신의 예
- 생산자/소비자  관계에서  한  프로세스가 정보를 생산하면  다른  프로세스는 그  정보를 소 비함
- 버퍼가 비었거나 꽉 차 있을 때 버퍼에 접근하는 것을 막기 위해 생산자와 소비자가 동 기화 되어 있어야 함 버퍼 (선입 선처리) 1 생산자 생산자 2 3 데이터 데이터 데이터 데이터 데이터 ■
-2 데이터 ■
-1 ■ 유한 버퍼 시나리오 ㆍ 무한 버퍼 생산자/소비자 문제
- 버퍼의 크기에 제한을 두지 않으며 항상 버퍼에 빈자리가 존재함 ㆍ 유한 버퍼 생산자/소비자 문제
- 크기가 고정된 버퍼를 사용, 버퍼가 비었을 시 소비자가 대기, 버퍼가 가득 차면 생산자 가 대기함
- 공유  버퍼의  저장소를  두  개의  논리적  포인터  in과  out을  사용한  순환  배열로  해결 가 능 · in과 out은 0으로 초기화 · 변수 in은 비어있는 다음 버퍼를 가리킴 · 변수 out은 채워진 버퍼의 맨 처음을 가리킴 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 소비자는 버퍼에서 데이터를 읽기 전 생산자가 앞서 가는 지, 즉 in＞out 인지 확인함 ㆍ 경쟁 상태(Race Condition)
- 공유 데이터에 최종적으로 남는 데이터의 결과를 보장할 수 없는 상황을 의미
- 여러 프로세스가 공유 데이터를 동시에(병행적으로) 접근(읽기나 쓰기)할 때 공유 데이터 에 대한 접근 순서에 따라 실행 결과가 달라지는 상황
- 장치나 시스템이 둘 이상의  연산을 동시에 수행하려 할 때,  어느 프로세서가 제일 마지 막에 수행된 후 결과를 저장했느냐에 따라 발생하는 오류
- 접근 순서화가 필요
- 이를 방지하기 위해 병행 프로세서들은 반드시 동기화되어 실행되어야 함 ㆍ 동기화 실행 방법
① 임계 영역
- 공유 변수를 어느 한 순간에 한 프로세스만 조작할 수 있도록 함
② 상호 배제
- 예에서 counter를 조작하는 부분을 임계영역으로 설정, 상호 배제 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 병행프로세스와 상호배제(2)

1. 임계 영역의 개념과 임계 영역 문제를 해결하기 위한 조건에  대해 알 수 있다. 4주차  수업목표  
2. 세마포어의 정의를 알고, 특징에 대해 설명할 수 있다. 2교시 
3. 모니터의 개념과 구조에 대해 알 수 있다.
1. 임계 영역 세부내용 
2. 세마포어
3. 모니터 1. 임계 영역 ▶ 임계 영역(Critical Section) ­ 둘 이상의 프로세스가 공유할 수 없는 자원을 임계자원이라  하며, 프로그램에서 이를 이용 하는 부분 · 공유 메모리가 참조되는 프로그램의 부분(데이터나 데이터 구조)으로 다수의 프로세스가  접근 가능한 영역이면서 한 순간에 하나의 프로세스만 사용할 수 있는 영역(공유 자원의  독점을 보장하는 코드 영역)을 의미 · 프로세스들이 공유 데이터를 통해 협력 시, 한 프로세스가 임계영역에 들어가면 다른 모 든 프로세스는 임계영역으로의 진입 금지 · 다중  처리  시스템과  단일  처리  시스템(시분할)환경에  적용되는  하나의  실행단위,  실행  구간을 의미 ­ 임계영역 내에서 빠른 속도로 작업을 수행, 한 프로세스가 오랫동안 머무르면 안됨 ­ 프로세스가 무한 루프 등에 빠지지 않도록 관리 입력 프로세서 출력 프로세서 입력 저장 꺼냄 출력 입력 장치 버퍼 출력장치 임계영역 임계영역 ­ 진입 상호 배제 · 프로세스 하나가 임계 영역에 있으면 다른 프로세스가 임계 영역에 들어가지 못하게 하 는 것 · 임계 영역에 들어가기를 원하는 프로세스는 진입 상호배제를 수행해야 함 ­ 프로세스가 접근하지 않은 임계 영역은 잠금 상태 ­ 프로세스는 임계 영역에서 작업을 수행하기 전에 키를 얻어 임계 영역의 잠금 상태를  해제해야 함 ­ 프로세스가 키를 반환할 때까지 다른 모든 프로세스에 대해 잠김 상태 유지 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 임계 영역을 떠나는 프로세스는 출구 상호배제를 수행함으로써 다른 프로세스가 임계 영역 에 들어갈 수 있도록 함 A 임계영영에 진입 B 임계영영에 진입 프로세서 A B는 임계영역에  B는 임계영역에  B는 임계영역에  진입하기 위해 시도 진입 나옴 프로세서 B T  T  B 보류 T  T  시간 임계 영역을 이용한 상호 배제 ­ 프로세스들이 서로 협력하여 자원을 사용할 수 있도록 프로토콜을 설계하여 임계영역 문제 를 해결 가능
①  진입영역(진입코드)  :  각  프로세스는  접근하려는  자원의  임계영역에  들어갈  수  있는지  여부를 미리 요청해야 하며, 이를 코드로 구현한 부분
② 출구영역 : 임계영역에서 수행을 마치고 나갈 프로세스를 선택
③  잔류영역  :  진입영역과  출구영역을  제외한  나머지  영역으로,  임계영역을  마치고  나와  수행함 while(TRUE) { 진입영역 임계영역; 출구영역 잔류영역; } 병행 프로세스에서 영역 구분 ­ 임계영역을 해결하기 위해 아래 세 가지 요구를 만족시켜야 함 · 상호 배제 ­ 프로세스  P가 임계영역에서  수행  중일  때 다른 프로세스는  임계영역에서 수행할 수  i 없다. · 진행 ­ 임계영역에서  수행하는  프로세스가  없고  여러  개의  프로세스가  임계영역으로  들어가 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 려고 하면  프로세스  선정  알고리즘에 따라  다음  임계영역에서 수행할 대상을 선정한 다. ­ 다음 임계영역으로 들어갈 프로세스 선택은 무한정 미룰 수 없다. · 제한된 대기 ­ 한 프로세스가 임계영역을 요청한 후 요청이 수락되기까지 다른 프로세스가 임계영역 에 진입할 수 있는 회수를 제한해야 한다. ▶ 소프트웨어적인 임계영역 문제 해결 ­ 단일 프로세서 또는 메모리를 공유하는 다중 처리 환경의 프로세서가 존재 ㆍ 알고리즘 1 (상호배제 단계 1 알고리즘)
- 두 개의 프로세스(P1, P2)에 대한 상호배제를 보장
- 현재 parbegin/parend 때문에  P1과 P2가 동시에  수행되며, 임계영역의 진입여부를 확 인하기 위해 while 문 구현
- 구현 방식 · 한 개의 공유변수(processnumber)를 사용하여 해결 · 두 개의 프로세스(P1, P2)가 교대로 실행됨
- 임계영역  진입 :  processnumber  값에 따라  진입  여부(P1  =  processnumber  ← 

1)가  결정 · 임계영역 진입을 위해 반드시 상대 프로세스의 processnumber 값 확인이 필요함
- 상호배제가 보장되지만 반드시 P1이 먼저 시작해야 함 · P2가 준비되어도 P1이 먼저 들어갔다 나와야 하므로 대기 시간이 길어질 수 있음
- 프로세스는 반드시 한 번씩 번갈아 들어갔다 나와야 함 · 프로세스 수행 속도가 느려질 수는 있으나 시스템은 교착상태에 빠지지 않음
- 공유변수 processnumber를 한 개 사용하였으므로, 두 프로세스 중 하나가 중지되면 다 른 프로세스도 중지됨 ㆍ 데커 알고리즘
- 하드웨어의 도움 없이 프로세스 두 개의 상호배제 문제를 해결
- 아래와 같은 특징을 가짐 · 특별한 하드웨어 명령문을 필요로 하지 않는다. · 임계영역  바깥에서  수행  중인  프로세스가  다른  프로세스들이  임계영역에  들어가려는  것을 막아서는 안 된다. · 임계영역에 들어가기를 원하는 프로세서로 하여금 무한정 기다리게 해서는 안 된다. ▶ 하드웨어적인 임계영역 문제 해결 ­ 특별한 하드웨어 명령을 사용, 임계영역 문제를 해결 가능 · 기계를 비교하거나 단어 내용을 검사 및 수정 또는 내용을 바꾸는(Swap) 명령을 사용하 여 임계영역 문제 해결 · 하나의 기억장치 사이클에서 수행되므로 생산자/소비자 문제에서 예로 든 counter 변수  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 수정에 발생하는 문제 해결 가능 ­ testandset을 이용한 상호배제 알고리즘 · testandset(a, b);는 논리변수 b를 읽어 a에 복사하고 b를 참으로 하는 명령 · 단일  프로세서  또는  메모리를  공유하는  다중  처리  환경과  관계없이  적용되며,  간단하여  쉽게 적용된다는 장점을 가짐 · 임계영역에 진입하려는 프로세스에 바쁜 대기가 발생 · 무한 연기 가능성이 발생할 수는 있지만 프로세스 수가 많으면 거의 발생하지 않음 2. 세마포어 ▶ 세마포어 (Semaphore) ­ 음이 아닌 정수값을 갖는 플래그 변수 · 다익스트라(Dijkstra)가 상호배제의 문제를 극복하기 위해 제안함 · 세마포어의 유명한 예 ‘열차의 진행 가능 여부’를 나타내는 차단기 ­ 차단기 올라감 : 정지/대기 (운영체제는 자원이 없어 기다리는 경우) ­ 차단기 내려감 : 진행 (프로세스가 해당 자원을 사용할 수 있는 자유 상태) 정지 진행 생산자/소비자 프로세스 관계 ㆍ 세마포어 정의
- 프로세스 동기화 문제 해결을 위한 두 가지 연산(P, V) · P : 네덜란드어로 검사(Proberen)를 나타내며, 프로세스를 대기시키는 wait 동작으로  임계 영역에 진입하기 위한 연산 · V : 네덜란드어로 증가(Verhogen)를 나타내며, 대기 중인 프로세스를 깨우는 신호를  보내는 signal 동작으로 임계 영역에서 나오기 위한 연산 · S : 세마포어를 나타내며 표준 단위 연산 P와 V에 의해서만 접근되는 정수 변수
- P와 V 연산은 다음과 같이 정의함 P(S) : while S ≤ 0 do no
-op; S := S ­ 1; V(S) : S := S + 1; · P와 V 연산에 있는 세마포어 정수값은 개별적으로 실행됨 · wait 인 경우 S 값 검사하고, 가능한 수정은 인터럽트 없이 실행해야 함 · S와 V의 동작은 세마포어를 인자로 명명한 임의의 프로세스가 요청한 시스템을 호출 함으로써 운영체제에 의해 실행됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 프로세스  제어를  용이하게  하며  P  연산을  요구하는  프로세서는  그  동작이  수행  가능한  상태가 될 때까지 대기해야 함
- P와 V 연산은 세마포어 변수 S를 수정하는데 사용되나, 표시한 프로세스가 변수 S를 수 정하면 다른 프로세스를 수정할 수 있음 ㆍ 세마포어 사용
- 세마포어는 프로세스 n개의 임계 영역 문제를 다루는 데 사용 · 세마포어 S에 적용된 두  연산  P, V는  동시에  두 가지 동작이 실행되는 것을 예방하 는 상호 배제를 의미함 · n개의 프로세스는 1로 초기화된 공통 세마포어인 mutex(Mutual Exclusion)를 공유 · 각 프로세스 Pi의 구조는 아래와 같음 repeat P (mutex); 임계영역 V (mutex); 잔류영역 until false;
- 세마포어는 여러 가지 동기화 문제를 다루는 데 사용 ex: 수행 중인 두 개의 프로세스, 문장 S1을 가진 P1과 문장 S2를 가진 P2의 경우 · 조건 : S2는 S1이 끝난 후에만 수행되도록 구현함 · 구현 방법 : P1과 P2가 0으로 초기화되는 공통 세마포어 synch를 공유하며, P1에는 
① 명령을 삽입, P2에는 
② 명령을 삽입하여 구현 가능
① S1 ;
② V(synch);  P(synch); S2; ­ 세마포어의 중요 특징은 단위적으로 수행된다는 점임 · 단위적 수행은 세마포어의 중요 특징이며, 임계영역 문제의 한 예임 · 단일 프로세서인 경우 P와 V 연산을 수행하는 중에 인터럽트를 금지함으로 해결 가능 ­ 인터럽트를 금지하면 다른 프로세서의 명령어 실행이 중간에 끼어들지 않음 · 다중 프로세서인 경우 인터럽트 금지가 허용 불가능 ­ 하드웨어가 특별한 명령을 제공하지 않으면, 소프트웨어적 해결 방법을 사용해야 함 ­ 임계 영역은 P와 V 프로시저로 구성됨 · P, V 연산은 짧은 시간 동안만 임계영역을 제한할 수 있음 ­ P,  V  연산으로  바쁜  대기를  완전히  제거  불가능하므로  응용  프로그램의  진입점에서  임계영역까지 바쁜 대기를 제거, 바쁜 대기의 시기를 이동시킴 ­ 임계영역이 길거나 항상 점유된 상황 시 비효율적임 · P연산과  V연산이  빠지면  상호배제  문제와  P  연산  때문에  대기하고  있는  프로세서들이  교착 상태에 빠질 수 있음 ­ P 연산이 시작되면 프로세스는 다른 경로를 선택할 수 없음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 프로세스는 한 번에 한 세마포어만 대기 가능해 자원을 할당하는 상황에서 교착 상태  발생 가능 3. 모니터 ▶ 모니터 (Monitor) ­ 프로그래밍 언어에서 제공되는 프로그래머 정의 연산자들의 집합으로 구성 · 세마포어의 P, V 연산이 프로그램 전체에 퍼져 있으며, 이들 연산이 미치는 영향을 전체 적으로 파악하기 쉽지 않아 프로그램 작성이 어려운 단점을 극복하기 위함 · 핸슨(Brich Hansen)과 호(Hoare)가 개발 · 모니터의 형태 표현은 변수 선언으로 구성, 변수 값이 형태를 정의함 · 모니터의 문법 구조는 아래와 같음 Type monitor
-name = monitor 변수 선언 procedure entry P1(…);  begin … end; procedure entry P2(…);  begin … end; … procedure entry Pn(…);  begin … end; begin 코드 초기화 end. ㆍ 모니터의 구조
- 하나  이상의  프로시저와  초기화  코드,  공유  데이터로  구성된  소프트웨어  모듈로  이루어 진 객체
- 모니터 안에 정의된 프로시저는 모니터 내에서 지역적으로 정의된 변수와 형식 매개변수 들만 접근 가능 · 모니터 밖에 있는 프로세스는 모니터에 있는 데이터에 접근 불가능
- 모니터 경계에서 한 번에 한 프로세스만 진입하도록 제어되므로 상호 배제 원칙을 지킴 · 자원을 대기하는 프로세스 또는 모니터가 사용 중이면 진입을 원하는 프로세스는 대기 해야 함 · 모니터 내의 프로세스는 자원이 다른 프로세스에 할당되어 대기할 수 있음 · 프로그래머는 동기화 제약 조건을 명시적으로 코드화할 필요 없음
- 자원 반납 시 모니터 진입 루틴 호출 · 호출된 루틴은  대기  중인  프로세스에게  신호를  보내고,  모니터는  대기  중인  프로세스 에 자원 할당 · 대기가  무기한  연기되는  것을  막기  위해  대기  중인  프로세스에  더  높은  우선순위를  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 부여함 연산 동작들  모니터 프로시저 1 지역(공유)  초기화 DATA 코드 진입 큐 프로시저 2 프로시저 n 보류된 프로세스 모니터의 일반 구조 ㆍ 모니터의 조건 변수
- 임계영역과 유사하며, 프로세스가 실행되는 동안 상호배제와 동기화를 제공
- 조건 임계영역으로 확장되었으며, 동기화를 위한 부수 기법이 필요함
- 모니터 밖의 프로세스가 대기 시 조건 변수에 의해 수행 재개가 결정됨   · 아래와 같이 한 개 이상, 조건 형태의 변수 정의 var x, y: condition;
- wait와 signal 연산만이 호출 가능 · 이러한 두 가지 연산을 제공하는 추상적인 데이터 형태로 볼 수 있음
- 모든  조건  변수는  관련된  큐가  있기  때문에  wait를  호출하는  프로세스는 해당  조건  변 수와 연관된 큐에 놓임 연산 동작들  모니터 프로시저 1 지역(공유)  초기화 DATA 코드 보류된 프로세스 프로시저 2 조건변수(x)  프로시저 n 조건변수(x)  진입 큐 조건 변수들을 가진 모니터 ⋅ x.wait 연산 ­ 어떤 프로세스가 x.signal을 호출할 때까지 x.wait를 호출한 프로세스는 연기/중단된다 는 의미 ⋅ x.signal 연산 ­ 중단된 프로세스 중에서 한  개만 재개하며, 호출 시  해당 조건 변수와  연관된  큐에서  대기 중인 프로세스 하나를 큐에서 꺼내 모니터로 진입할 수 있도록 함 ­ 중단된 프로세스가  없으면  효과가  없으며,  x의  상태는 연산이 전혀 실행되지 않는 것 과 같음 ✔ 여러 개의 프로세스가 조건 x에서 중단되고 x.signal 연산이 어떤 프로세스에 의해 실행된 다면, 어느 프로세스를 다음에 재개할 것인가?
- 단순한 해결 방법으로 선입 선처리 기법을 이용하여 가장 오래 대기한 프로세스를 먼저  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 재개시킴
- 단순 스케줄링 기법 적용이 어려울 시 아래 형식의 조건 대기 구조 사용 x.wait(c); · 조건  c가 만족될 때까지 모니터를 호출한 프로세스의 수행이 일시 정지됨,  또한 모니 터를 다른 프로세스들이 사용 가능 · c는 정수 식으로, wait 연산이 실행될 때 평가됨 · c 값은 우선순위 번호로 중단된 프로세스의 이름과 같이 기억되며, 값이 가장 작은 우 선순위를 가진 프로세스가 다음으로 실행됨 ※ 정리하기 ▶ 병행 프로세스 ­ 프로세스 여러 개가 동시에 실행 ­ 독립적으로 수행 가능하며, 다른 프로세스와 협력하면서 기능을 수행하기도 함 ▶ 선행 제약 ­ 프로세스가 순서대로 다른 상태로 옮겨가는 것 ­ 선행 그래프는 이러한 제약을 형식적으로 표현하는데 사용됨 ­ 프로그래머는 순차 프로세스의 개념을 이용하여 프로그램에서 여러 명령문 사이의 선행 관 계를 기술 가능 ▶ 상호배제 ­ 어떤 프로세스가 작업을 실행 중일 때 나머지 프로세스들이 그 작업에 관련된 작업을 수행 할 수 없도록 함 ­ 어떤 데이터를 공유하면서 협조 관계에 있는 순차 프로세스 집합체에서 상호배제는 필수적 임 ▶ 병행 명령 ­ 선행 제약을 위해 fork와 병행명령(parbegin/parend)이라는 언어 구조 두 개가 제안됨 ­ 병행 실행의 개념은 순차 프로세스 개념과 선행 그래프를 이용, 형식화됨 ▶ 동기화 문제점 ­ 상이한 동기화 문제점들(유한 버퍼문제, 생산자/소비자 문제)은 병행 제어 문제들의 실례들 이므로 중요함 ­ 새롭게 제안된 거의 모든 동기화 기법들은 검사를 위해 이 문제를 이용 ▶ 세마포어 ­ 상호배제의 해결책에 대한 주요 단점으로 이들은 모두 바쁜 대기를 요구한다는 점임 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 다양한 동기화 문제들을 해결하기 위해 사용 가능하며 효과적으로 구현됨 ▶ 임계영역과 모니터 ­ 운영체제는 타이밍 오류에 대처할 수 있는 수단을 제공해야 함 ­ 임계영역은 상호배제와 임의의 동기화 문제들을 안전하고 효과적으로 구현하기 위해 사용 ­ 모니터는 추상 데이터 형태를 공유하기 위한 동기화 메커니즘을 제공 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 교착상태와 기아상태(1)

1. 교착상태의 개념과 교착상태 발생 조건에 대해 알 수 있다. 수업목표   5주차 
2. 교착상태 해결 기법으로 예방에 대해 정리할 수 있다. 
1. 교착상태의 개념 1교시 
2. 교착상태의 발생 세부내용 
3. 교착상태의 발생 조건
4. 교착상태의 해결 기법 
- 예방 1. 교착상태의 개념 ▶ 교착상태(Deadlock)의 개념 ­ 시스템 측면에서 자원의 요구가 뒤엉킨 상태 · 한 프로세스 집합  내의 프로세스들에 의해 발생할  사건(Event)을  프로세스들이 서로 기 다리고 있는 상태 · 둘 이상의 작업이 보류 상태에 놓여 중요한 자원을 이용하기 위해 기다릴 때 발생함 · 제한된 자원 이용률을 높이고 시스템 효율성을 증가시키기 위해 사용하는 병행 처리 기 술과 자원 공유에 따른 부작용임 교착상태의 예: 교통마비 상태 ㆍ 초기 일괄처리 시스템
- 사용자들이 작업 제어카드에  작업을  완료하기  위해  필요한  자원을 명시하여  교착상태가  자주 발생하지 않음
- 운영체제가 요청한 자원이 준비 큐로 이동하기 전 사용 가능 여부를 확인하여 할당
- 자원이 확보되지 않으면 작업이 준비 큐로 이동할 수 없어 교착상태가 발생하지 않음 ㆍ 대화식 시스템
- 동적 자원 공유로 자원의 이용도를 높이는 과정에서 교착상태 발생
- 예 1 : DVD 드라이브와 프린트가 각각 하나씩 존재하고 다음과 같은 경우 · 프로세스 P : DVD 드라이브 점유 → 프린터 요청 · 프로세스 Q : 프린터 점유 → DVD 드라이브 요청
- 예 2 : 테이프 드라이브가 3개 존재하고 다음과 같은 경우  · 프로세스 P : 테이프 드라이브 점유 · 프로세스 Q : 테이프 드라이브 점유 또 다른 테이프 드라이브 요청 · 프로세스 R : 테이프 드라이브 점유 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr Q 요청 점유 DVD 드라이버 프린터 점유 요청 P 교착상태 예 ­ 프로세스는 다음 순서로 자원을 이용
① 요청
- 프로세스가 필요한 자원을 요청함
- 요청이 즉시 받아들여지지 않으면 다른 프로세스가 사용 중이므로 할당 받을 때까지  대기함
② 사용
- 프로세스가 요청한 자원을 사용
③ 해제
- 프로세스가 자원 사용을 마친 후, 할당 받은 자원을 되돌려 줌 · 자원의 요청과 해제 그리고 파일이나 입출력 장치를 읽거나 쓰는 자원의 사용도 시스템  호출에 의해 이루어짐 · 운영체제는 프로세스가 자원 요청 시, 할당 받을 수 있도록 항상 확인하고 기록함 2. 교착상태의 발생 ▶ 교착상태 발생

1) 파일을 요청할 때의 교착상태 ­ 파일을  이용해  작업이  실행되는  동안,  파일에  대한  다른  작업의  점유  요청이  인정되면  교착 상태 발생 ­ 파일 요청 시 발생하는 교착상태 예 · 두  개의  프로세스(판매,  재고)와  두  개의  파일(공급자  파일,  재고  파일)  자원을  이용 한 교착상태 표현 · 할당 요구 순서는 아래와 같음
① 프로세스 1(판매)은 판매 계획을 위해 공급자 파일을 요청해서 얻는다(할당)
② 프로세스 2(재고)는 재고 확인을 위해 재고 파일을 요청해서 얻는다(할당)
③  프로세스  1은  주문  요청한  판매를  위해  재고  파일을  요청하지만  허용되지  않는 다.
④ 프로세스 2는 주문을 위해 공급자 파일을 요청하지만 허용되지 않는다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 요청 할당 재고 파일 프로세스 프로세스 1 2 할당 공급자 파일 요청 파일을 요청할 때의 교착상태

2) 전용장치를 할당할 때의 교착상태 ­ 전용장치 할당 시 발생하는 교착 상태 예 · 두  사용자(프로세스  1,  프로세스 
2)가  각각  테이프  드라이브  한  대를  사용하고,  한  테이프에서 다른 테이프로 복사하는 작업을 할 경우 · 할당 요구 순서는 다음과 같이 이루어진다 가정함
① 프로세스 1은 테이프 드라이브 1을 요청해서 얻는다(할당)
② 프로세스 2는 테이프 드라이브 2를 요청해서 얻는다(할당)
③ 프로세스 1은 테이프 드라이브 2를 요청하지만 허용되지 않는다.
④ 프로세스 2는 테이프 드라이브 1을 요청하지만 허용되지 않는다.

3) 다중 주변 장치를 할당할 때의 교착 상태 ­ 다중 주변 장치 할당 요구에 의한 교착 상태 예 · 세 개의 프로그램(프로세스 1, 프로세스 2, 프로세스 3)과 세 개의 전용 장치(테이프  드라이브, 프린터, 플로터)를 사용하는 경우 · 할당 요구 순서는 아래와 같다 가정함
① 프로세스 1은 테이프 드라이브를 요청해서 얻는다(할당)
② 프로세스 2는 프린터를 요청해서 얻는다(할당)
③ 프로세스 3은 플로터를 요청해서 얻는다(할당)
④ 프로세스 1은 프린터를 요청하지만 허용되지 않는다.
⑤ 프로세스 2는 플로터를 요청하지만 허용되지 않는다.
⑥ 프로세스 3은 테이프 드라이브를 요청하지만 허용되지 않는다. ㆍ 전용장치를 할당할 때의 교착상태 할당 프로세스 요청 1 테이프 드라이버 프린터 프로세스 프로세스 3 2 할당 공급자 파일 요청 장치 할당 요구에 의한 교착상태 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr

4) 스풀링 시스템에서의 교착상태 ­ 스풀링  시스템에서  디스크에  할당된  스풀  공간의  출력이  완료되지  않은  상태에서  다른  작업이 스풀 공간을 모두 차지하면 교착상태가 발생 ­ 스풀링  처리부(Input  Spooler)에  필요량보다  많은  공간을  배당하여  교착상태  발생률을  줄일 수 있으나 비용이 많이 듬 ­ 스풀링  파일의  ‘일정  포화  임계치(Saturation  Threshold)’를  설정하여  교착  상태  예방  가능하나 시스템의 처리량이 줄어들 수 있음 · 예  : 약 75%  정도에  이르면  새로운  작업을  읽어  들이지 못하도록 하여 교착상태를  예방
5) 디스크를 공유할 때의 교착상태 ­ 디스크는 대표적인 공유 자원으로, 사용에 대한 제어가 없다면 교착상태가 발생할 수 있 음 ­ 디스크 공유 시 발생하는 교착상태 예 · 프로세스 P 이 실린더 55의 내용을 읽도록 명령함  · 디스크 헤드는 실린더 55로 이동,  P 은 중지상태가 되고 입출력 채널은 다음 입출력  을 요구함 · 프로세스  P 가 입출력 채널 제어권을 넘겨받아 실린더 245에 위치한 레코드에 쓰기  를 명령함 · 디스크 헤드는 실린더 245로 이동, P 는 중지상태  · 입출력 채널 제어권은 다시 P 으로 이동, P 은 실린더 55의 코드 읽기를 명령함   · 디스크 헤드는 실린더 55로 이동, P 는 입출력 채널 제어권을 넘겨받아 다시 명령함  실린더 245 실린더 55 P1 입출력 디스크 채널 제어기 P2 디스크 헤더  이동 경로 디스크 제어기가 프로세서와 독립적으로 작동할 때의 교착상태
6) 네트워크에서의 교착상태 ­ 네트워크가 붐비거나 입출력(I/O) 버퍼 공간이 부족한 네트워크 시스템이 메시지 흐름을  제어하는 적절한 프로토콜을 가지지 못한 경우 교착상태 발생 ­ 네트워크에서 발생하는 교착상태 예 · 화살표는 메시지 흐름을 나타냄 · 노드 N6, N7에서 출발하여 목적지가 N2인 메시지는 N1의 출력 큐에 임시 저장됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · N3, N4에서 출발하여 N1이 목적지인 메시지는 N2의 출력 큐에 임시 저장됨 · N1의 버퍼 공간이 부족할 때 N1은 N2로부터 메시지를 수신할 수 없음 · N2의  버퍼  공간이  부족할  때  N1이나  다른  노드로부터  메시지를  수신할  수  없다면,  N1과 N2 사이의 통신 선로는 교착상태에 빠짐 · N1은 N6,  N7로부터  메시지를 전송  받을  수  있으나,  N2로  전송이  불가능하므로  교 착상태에 빠짐 N2 N3 N1 N6 N4 N7 N5 네트워크에서의 교착상태 3. 교착상태의 발생 조건 ▶ 교착상태 발생 조건 ­ 다음 네 가지 조건이 동시에 발생할 때, 즉 필요충분조건이 성립될 때 발생
① 상호배제 · 자원이 최소 하나 이상 비공유, 즉 한 번에 한 프로세스만 해당 자원을 사용할 수 있 어야 함 · 사용 중인  자원을  다른  프로세스가  사용하려면 요청한 자원이 해제될 때까지 대기해 야 함
② 점유와 대기 · 최소한 자원 하나를 보유하고 다른 프로세스에 할당된 자원을 얻기 위해 기다리는 프 로세스가 있어야 함
③ 비선점 · 자원은 선점될  수 없음. 즉  자원을 강제로 뺏을 수 없으며 자원을 점유하고 있는 프 로세스가 끝나야 해제됨 v 위의  세  가지  조건으로 발생할  수  있으나,  발생하지  않을  수도 있으며,  교착상태  발생 에는 반드시 아래의 조건이 요구됨
④ 순환대기 · 대기  프로세스  집합  {P ,  P ,  …,  P }이  있을  때,  P 은  P 이  보유하고  있는  자원을,    ■   P 은  P ,  P 는  P ,  P 은  P ,  P 은  P 이  보유하고  있는  자원을  각각  얻기  위해      n ■ ■  대기하는 경우 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr P P P P     요청 점유 R R R R     순환대기의 교착상태 ㆍ 강 건너기 교착상태 예 (강 건너기 교착상태)
- 여러 개의 돌로 된 징검다리가 있는 강을 건너는 경우
- 징검다리의 돌 하나는 한 쪽에서 한 사람만 디딜 수 있음(상호배제 성립)
- 강을 건너는 사람을 프로세스, 징검다리의 돌을 자원이라 가정함 · 두 사람이 동시에 서로 다른 방향에서 출발, 강  중간에서 만나면 교착상 태가 발생했 다 할 수 있음 · 돌을 딛는 것을 자원 할당, 발을 떼는 것을 자원 해제로 볼 때 동시에 같은 돌을 디디 려 하면 교착상태가 발생함 · 각 사람은 돌 하나를 딛고 다음 돌을 요구함(점유와 대기 조건 만족) · 사람이 딛고 있는 돌을 강제로 제거할 수 없음(비선점 조건 만족) · 왼쪽에서 오는 사람은 오른쪽 사람을, 오른쪽에서 오는 사람은 왼쪽 사람을 기다림(순 환대기 조건 만족)
- 해결 방법
① 둘 중 한 사람이 되돌아간다(복귀)
② 강을 건너기 전에 상대편 강 쪽을 확인하고 출발한다.
③ 강의 한쪽 편에 우선권을 부여한다. 강 건너기 교착상태 4. 교착상태의 해결 기법 
- 예방 ▶ 교착상태 해결 기법 ­ 교착상태를 해결하는 기법은 크게 3가지로 나뉨
① 시스템이 교착상태가 되지 않도록 예방(방지)하는 것 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
② 가능한 교착상태를 회피하는 것
③ 교착상태를 허용하되 교착상태에서 다시 회복할 수 있게 하는 것  · 사용하기 어렵고 오버헤드가 증가하므로 교재에서 살펴보지 않음 ▶ 교착상태 예방 기법 ­ 4가지의 교착상태 조건 중 하나라도 발생하지 않도록 함 · 상호배제 문제는 고려해야 함 ­ 전용자원에서는 교착상태가 발생하지 않으므로 프로세스가 원하는 자원을 배타적으로  사용하려는 것은 제외시켜야 함 ­ 하벤더(Havender, 1986년)가 상호배제를 제외한 세 가지 기본 방법 제안
① 각 프로세스는 한 번에 필요한 모든 자원을 요구해야 하며, 요청한 자원을 모두 제공받 기 전까지는 작업을 진행할 수 없음
② 어떤 자원을 점유하고 있는 프로세스의 요구가 더 이상 허용되지 않으면 점유한 자원을  모두 반납하고 필요할 때 다시 자원을 요구해야 함
③  모든 프로세스에  자원을  순서대로  할당해야 함.  모든 프로세스에  각 자원 유형별로 할 당 순서를 부여한 후, 순서에 따라 자원을 요구

1) 상호배제 조건 방지 ­ 상호배제 조건은 자원의 비공유를 전제로 함 · 공유 가능한 자원들은 배타적인 접근을 요구하지 않으므로 교착상태가 발생하지 않음 ­ 일반적으로 상호배제 조건을 거부하면 교착상태를 예방하는 것이 불가능함 · 어떤 자원은 공유 자체가 불가능한 것도 있음 ­ 파일 쓰기는 배타적인 접근만이 허용되어야 함 · 하나 이상의 프로세스가 쓰기 권한을 가지면 교착상태가 발생할 가능성이 있음
2) 점유와 대기 조건 방지 ­ 최대 자원 할당 · 프로세스가 작업을 수행하기 전에 필요한 모든 자원을 요청하고 획득해야 함 · 보류 상태에서는 프로세스가 자원을 점유할 수 없으므로 대기 조건이 성립하지 않음 ­ 점유와 대기 조건 방지를 위한 두 가지 방법 · 모든 프로세스는 자원을 요청하고 사용할 수 있음 · 프로세스가 자원을 더 요청하려면, 먼저 자신에게 할당된 자원을 해제해야 함
①  자원  할당  시  시스템  호출된  프로세스  하나의  실행에  필요한  모든  자원을  먼저  할당하여 실행시킨 후 다른 시스템 호출에 자원을 할당함
② 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용함 ⋅ 단점
① 자원의 효율성이 낮음 ­ 많은 자원이 사용되지 않으면서 오랜 시간 할당되기 때문
② 기아상태 발생이 가능함 ­ 자주 쓰는(이용하는) 자원이 다른 프로세스에 할당된 경우, 자원을 요청한 프로세 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 스는 무한히 기다려야 하는 경우가 발생 ­ 적은 수의 자원을 요청한 프로세스의 우선순위가 높으므로, 많은 수의 자원을 요 청한 프로세스의 대기 시간이 길어질 수 있음

3) 비선점 조건 방지 ­ 이미 할당된 자원에 대한 선점권이 없어야 한다는 전제 조건을 가짐 · 어떤 자원을  가진  프로세스가 자원  요청  시  기다려야  한다면,  프로세스는  현재  가진  자원을 모두 해제함 · 프로세스가 작업을 시작하려면 요청한 새로운 자원과 해제한 자원을 확보해야 함 · 작업  상태를  쉽게  저장  및  복구  가능할  때  또는  빈번하게  발생하지  않을  때만  좋은  수단으로 이용 가능 ­ 두 가지 대안 제시됨
① 프로세스가 어떤 자원을 요청할 때, 요청한 자원이 사용 가능한지 검사  · 사용 가능하다면 자원 할당, 사용 불가능한 경우 대기 프로세스가 요청한 자원을  점유하고 있는지 검사 · 요청한  자원을  대기  프로세스가  선점하고  있다면,  자원을  해제하고  요청  프로세 스에 할당 · 요청한  자원을  사용할  수  없거나,  실행  중인  프로세스가  점유하고  있으면  요청  프로세스는 대기
② 두 프로세스에 우선순위를 부여하여, 높은 우선순위의 프로세스가 그보다 낮은 순위 의 프로세스가 점유한 자원을 선점하여 해결 · 프로세서 레지스터나 기억장치 레지스터와 같이 쉽게 저장되고 이후 복원이 쉬운  자원에 이용

4) 순환대기 조건 방지 ­ 계층적 요구 기법 · 모든  자원에  일련의  순서를  부여,  각  프로세스는  오름차순으로만  자원을  요청할  수  있게 함 · 순환대기의 가능성을 제거하여 교착상태를 예방 · 예상된 순서와 다르게 자원을 요구하는 작업은 자원 낭비를 초래함 ­ R = {R ,  R , …,  R }을 자원 형태 집합이라 가정하고, 각 자원 형태에 고유 숫자를 부   ■ 여 ­ 1:1 함수인 ‘ex):R → N’으로 정의 가능하며, N은 자연수 집합을 의미함
①  프로세스는  임의의  자원  R을  요청할  수  있지만  그  다음부터는  ‘ex)(R)  ＞  ex)(R)’인  i j i 경우에만 자원 형태  R를 요청할 수 있음 j · 각  프로세스는  오름차순으로만  자원들을  요청할  수  있으며,  데이터  형태  자원이  여러 개 필요한 경우 우선 요청할 형태 자원 하나를 정해야 함
② 프로세스가 자원 형태  R을 요청할 때마다 ‘ex)(R) ≥ ex)(R)’가 되도록  R의 모든 자원 j i j j 을 해제 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 교착상태와 기아상태(2)

1. 교착상태 해결 기법 중 회피에 대해 정리할 수 있다. 5주차  수업목표  
2. 교착상태 회피 방법 중 은행가 알고리즘에 대해 알 수 있다.  2교시 
1. 교착상태 회피 기법 세부내용 
2. 교착상태 회피 시스템 상태 변화
3. 은행가 알고리즘 1. 교착상태 회피 기법 ▶ 교착상태 회피 기법 ­ 교착상태의  예방보다  덜  엄격한  조건을  요구함으로써  자원을  좀  더  효율적으로  이용하는  것을 목적으로 함 ­ 교착상태가  일어날  가능성을  인정하고(세  가지  필요조건  허용)  교착상태가  일어나려고  할  때 적절히 회피하며, 이는 예방보다 더 병행성을 허용함 ㆍ 회피 기법은 크게 두 가지 방법 제시됨
① 프로세스의 시작 거부 · 프로세스의 요구가 교착상태를 일으킬 수 있다면 프로세스 시작을 중지함 ex: 현재 수행 중인 모든 프로세스의 최대 자원 요구량과 새로운 프로세스의 최대  요구량을 합한 자원 요구량을 수용할 수 있으면 새로운 프로세스를 수용
② 자원 할당의 거부 · 프로세스가 요청한 자원을 할당했을 때, 교착상태가 발생할 수 있다면 요청한 자원 을 할당하지 않음 · 일반적으로 은행가 알고리즘(Banker`’s Algorithm)이라 부름 · 교착상태 회피를 위해 자원이 언제 요구되는지에 대한 추가정보가 필요함 ­ 각 프로세스마다 요청과 해제에 대한 정확한 순서를 파악하고 있다면 요청에 따 른 프로세스 대기 여부를 결정 가능함 · 요구를  받아들일지 또는 기다리게  할지를  결정하기 위해  각  프로세스에 대한 요구 와 해제를 미리 알고 있어야 함 ­ 필요한  정보의  양과  종류에  따라  다양한  교착상태  회피  알고리즘을  적용할  수  있음 ­ 프로세스가 요청할 자원마다 최대치 정보를 미리 파악할 수 있다면 시스템이 교 착상태가 되지 않을 확실한 알고리즘을 만들 수 있음 ㆍ 안정상태와 불안정상태
- 교착상태  회피  알고리즘은  시스템이  순환
-대기  조건이 발생하지  않도록  자원  할당  상태 를 검사함
- 자원  할당  상태는  사용  가능한  자원의  수,  할당된  자원의  수,  프로세스들의  최대  요구  수에 의해 정의됨
① 안정한 상태 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 각 프로세스에 자원을 할당할 수 있고(최대치까지), 교착상태를 방지할 수 있음 · 프로세스의  순서  <P ,  P ,  …,  P
>이  안정  순서란  의미는  모든  P가  요청하는  자   ■ i 원이 현재 사용 가능한 자원과 j ＞ i인 모든  P가 점유하고 있는 자원들로 충족될  j 수 있음을 나타냄 · 프로세스  P가 필요한 자원을 즉시 사용할 수 없다면,  P는 모든  P가 끝날 때까지  i i j 기다렸다가  자원을  확보,  필요한  모든  자원  확보  시  지정된  작업을  끝내고  자원을  반납함 · P가  종료하면  P 은  필요한  자원을  확보할  수  있으므로  처리를  계속  진행할  수  i i 있음
② 불안정한 상태 · 안정한 상태처럼 프로세스의 자원 할당 및 해제의 순서가 명확히 존재하지 않는 경 우 v 교착상태는 불안정상태이나, 모든 불안정상태가 교착상태인 것은 아님 교착상태 불안정상태 안정상태 안정상태, 불안정상태와 교착상태의 공간 2. 교착상태 회피 시스템 상태 변화 ▶ 시스템 상태 변화 ­ 동일한 자원 12개와 프로세스  P ,  P ,  P 를 가진 시스템의 경우를 예를 들어 시스템 상태     변환을 설명함 ㆍ 시스템의 안정 상태
- 프로세스  P 은 자원을 10개 요구, P 은 4개, P 는 9개 요구함   
- t 시간에  프로세스  P 가  자원을  5개  점유,  프로세스  P 은  2개,  프로세스  P 는  2개를      점유할 경우 사용 가능한 자원은 3개임 안정상태의 자원 예(1) 구분 현재 사용량 최대 사용량 P 5 10  P 2 4  P 2 9  사용 가능한 자원 수 3 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 실행 과정 · t 시간에 시스템은 안정상태이며, <P , P , P
> 순서는 안정 조건을 만족함     · 프로세스  P 은 사용 가능한 자원을 2개 할당 받아 실행한 후 반납 가능하므로 시스템  의 여분 자원은 5개임 · P 은 사용 가능한 자원 5개를 할당 받아 실행한 후 반납 가능함    · 프로세스 P 가 필요한 자원을 할당 받고 실행한 후 반납 가능함  안정상태의 자원 예(2) 구분 초기 P P 실행 후 P P 실행 후 P P 실행 후       현재 사용량
- 2 0 5 0 2 0 할당량
- 2 0 5 0 7 0 최대 사용량
- 4 0 10 0 9 0 사용 가능한 자원 3 1 5 0 10 3 12 ㆍ 불안정상태
- 사용 가능한 자원 1개를 어느 프로세스에 할당해도 프로세스를 만족시킬 수 없음
- 프로세스  P 에 남은 장치를 할당하고 반납 전까지 다른 프로세스가 자원을 요구하지 않  는 경우 교착상태를 피할 수 있음 불안정상태의 자원 예(1) 구분 현재 사용량 최대 사용량 P 8 10  P 2 4  P 1 9  사용 가능한 자원 수 1 ㆍ 안정상태에서 불안정상태로의 변환
- [불안정상태의 자원 예(2)]표에서 프로세스 P 가 자원을 1개 더 요구할 경우, 이를 허용   시 불안정상태로 변함 불안정상태의 자원 예(2) 구분 현재 사용량 최대 사용량 P 5 10  P 2 4  P 3 9  사용 가능한 자원 수 2
- 실행 과정 · 프로세스 P 은 사용 가능한 자원 2개를 할당 받아 실행한 후 장치를 반환  · 프로세스  P 는  자원 5개를 할당 받았지만 최대 10개가  필요하므로 5개를  더  요청하  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 나, 최대 사용량만큼 자원을 할당할 수 없으므로 대기 · 프로세스 P 는 추가로 자원을 6개 요청하므로, 시스템은 교착상태가 됨 
- 해결 방법 · 다른 프로세스들이 처리를 종료하고 자원을 반납할 때까지 프로세스  P 를 대기시키면   교착상태를 회피할 수 있음 v 시스템이 항상 안정상태에 머무르도록 안정상태 개념에서 교착상태 회피 알고리즘을 정 의  가능  :  초기  시스템은  안정상태이므로,  프로세스가  현재  사용  가능한  자원을  요청  시 시스템은 자원 할당/대기 여부를 결정, 자원을 할당한 이후에도 시스템이 항상 안정 상태일 경우에만 할당을 허용함 3. 은행가 알고리즘 ▶ 교착상태 회피 예 : 은행가 알고리즘 ­ 다익스트라의 은행가 알고리즘(Banker’s Algorithm)을 이용 · 각 프로세스가 요청하는 자원 종류의 최대수를 알아야 함 · 각  프로세스에  자원을  어떻게  할당(자원  할당  순서  조정)할  것인가의  정보가  필요하며,  이를 이용하여 교착상태 회피 알고리즘을 정의함 · 은행에서 모든 고객이 만족하도록 현금을 할당하는 과정과 동일함 ㆍ 구현 방법
- 구현을 위해 여러  가지 자료구조를 유지해야 하며,  이는 자원 할당 시스템의 상태를 나 타냄
- n은 시스템의 프로세스  수, m을 자원 형태의 수라 가정할 때,  다음과  같은 자료구조가  필요함
① Available · 각 형태별로 사용 가능한 자원의 수를 표시하는 길이가 m인 벡터
② Max  · 각 프로세스의 최대 자원의 요구를 표시하는 n ⅹ m 행렬
③ Allocation  · 현재 각 프로세스에 할당되어 있는 각 형태의 자원 수를 정의하는 n ⅹ m 행렬
④ Need  · 각 프로세스에 남아 있는 자원 요구를 표시하는 n ⅹ m 행렬 ㆍ 구현을 위한 제약
- 간단한 구현을 위해 다음과 같은 제약을 둠
① 시간이 진행하면서 벡터의 크기와 값이 변한다.
② x와 Y의 길이가 n인 벡터이다.
③ X[i] ≤ Y[i] 이고, i = 1, 2, …, n일 경우에만 X ≤ Y다.
④ X = (0, 3, 2, 1)이고 Y = (1, 7, 3, 2)이면 X ≤ Y다.
⑤ X ≤ Y 이고 X ≠ Y 이면 X ＜ Y다. 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 행렬  Allocation과  Need에  있는  각  행을  벡터로  취급하며  이들을  각각  Allocationi와  Needi로 참조함 · Allocationi는 프로세스 Pi에 현재 할당된 자원 · Needi는 프로세스 Pi가 자신의 작업을 종료하는데 필요한 추가 자원 ㆍ 은행가 알고리즘
- Request 를 프로세스 P를 위한 요청 벡터라 가정함 i i
- 만약 ‘Requesti[j] = k’라면, 프로세스 P는 자원 형태 R를 k개 요구함 i j
- 프로세스  P가 자원을 요청 시 다음 동작이 일어남 i
① 1단계 :  Request ≤  Need 면 2단계로 가고, 그렇지 않으면 프로세스가 최대 요구 i i 치를 초과하기 때문에 오류 상태가 됨
② 2단계 : Requesti ≤ Available면 3단계로 가고, 그렇지 않으면 자원이 부족하기 때 문에 P는 대기 i
③ 3단계 : 시스템은 상태를 다음과 같이 수정하여 요청된 자원을 프로세스 P에 할당 i · Available := Available ­ Requesti; · Allocation := Allocation + Request ; i i i · Need := Need ­ Request ; i i i
- 자원 할당 상태가 안정이라면 처리가 이루어지고 프로세스 P는 자원을 할당 받음 i
- 불안정 상태이면 P는 Request 를 대기하고 이전 자원 할당 상태로 복귀함 i i ㆍ 안전 알고리즘
- 시스템이 안정상태인지, 불안정상태인지를 검사하며, 다음과 같은 과정으로 수행됨
① 1단계 : Work와 ex)inish를 각각 길이가 m과 n인 벡터라 가정할 때, 다음과 같이 초 기화함 · Work := Available, ex)inish [i] := false, i=1, 2, …, n
② 2단계 : 다음과 같은 조건을 만족하는 i값을 찾으며, i값이 없으면 4단계로 이동 · ex)inish[i] = false · Needi ≤ Work
③ 3단계 : 다음을 수행하고 2단계로 이동 · Work := Work + Allocation · ex)inish[i] := ture
④ 4단계 : 모든 i에 대하여 ex)inish[i] = true이면 시스템은 안정상태임
- 안전 알고리즘의 예 · P 부터  P 까지  5개의  프로세스와  자원  형태  3개(A,  B,  C)를  가진  시스템에서,  자원    형태 A는 10개, 자원 형태 B는 5개, 자원 형태 C는 7개가 있다고 가정함 · 시간  t 에 시스템의 상태는 다음 [시간 t 일 경우 시스템의 상태]표와 같다 가정함   학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 시간 t 일 경우 시스템의 상태  Allocation Max Need Available ABC ABC ABC ABC P 010 753 743 332  P 200 322 122  P 302 902 600  P 211 222 011  P 002 433 431 
- 진행 과정 · 시스템은 현재 안정상태이며, <P , P , P , P , P
> 순서는 안정 조건에 해당함      · 현재 Available 자원은 (3, 3, 2)이며, 프로세스 P 에 할당 가능  · Need ≤ Available 조건의 참, 거짓 여부는 (1, 1, 2) ≤ (3, 3, 2)이므로 참 i · 프로세스 P 실행 후 할당된 자원 해제 시 Available 자원은 (5, 3, 2)  · P 요구는 (0, 1, 1)이므로 할당이 가능하며, 동일한 과정으로 P , P ,  P 의 안정상태      조건은 만족됨
- 프로세스  P 은  자원  형태  A의  자원  1개와  C의  자원  2개를  더  요청하여  Request =    (1, 0, 2)라 가정함 · 요청의 허용 여부를 결정하기 위해 Request1 ≤ Available 여부 ((1, 0, 2) ≤ (3, 3, 

2))를 확인해야 함 · 요청이 충족되어 새로운 상태에 도달했다 가정할 경우, · 새로운 시스템 상태가 안정한지 판별하기 위해 안전 알고리즘 실행, <P ,  P ,  P , P ,      P
> 순서가 안전요구 충족함을 확인함  · 프로세스 P1의 요청을 허락 · 프로세스 P4가 (3, 3, 0) 요청 시 자원이 부족하므로 허용할 수 없음 · P 이 (0, 2, 0)을 요청하면 Available 자원이 충분하여 할당하더라도  · P 은  실행되지  않고  대기상태가  되어,  결과가  불안정상태이므로  자원  요청을  허용할   수 없음 시간 t 일 경우 시스템의 새로운 상태  Allocation Need Available ABC ABC ABC P 010 743 332  P 302 020  P 302 600  P 211 011  P 002 431  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 은행가 알고리즘의 단점
- 교착상태를 회피하기 위해 교착상태가 일어나지 않을 때만 작업을 진행
- 다음과 같은 단점이 있어 항상 실용적이지 못함
① 할당할 수 있는 자원의 일정량을 요구함 · 자원은  수시로  유지보수가  필요하며  고장이나  예방보수를  함으로써  일정하게  남 아있는 자원 수의 파악이 어려움
② 사용자 수가 일정해야 함 · 현재의 다중 프로그래밍 시스템에서는 사용자의 수가 항상 변함
③ 교착상태 회피 알고리즘을 실행하면 시스템 과부하가 증가함
④ 프로세스는 자원을 보유한 상태로 끝낼 수 없음 · 시스템에서는 이보다 더 강력한 보장이 필요함
⑤ 사용자가 최대 필요량을 미리 알려주도록 요구하지만 자원 할당 방법이 점점 동적으 로 변함에 따라 사용자의 최대 필요량을 파악하기 어려워 짐 · 최근의  시스템은  편리한  인터페이스  제공으로  사용자가  필요로  하는  자원을  알  필요가 없음
⑥ 항상 불안정상태를 방지해야 하므로 자원 이용도가 낮음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 교착상태와 기아상태(3)

1. 교착상태 탐지 알고리즘에 대해 알 수 있다. 6주차  수업목표  
2. 교착상태 회복 기법을 이해하고 기법에 대해 정리할 수 있다.
3. 기아상태의 개념을 알고, 해결 방안에 대해 정리할 수 있다.  1교시 
1. 교착상태 탐지 알고리즘  세부내용 
2. 교착상태 회복 기법 
3. 기아상태 1. 교착상태 탐지 알고리즘 ▶ 교착상태 탐지 알고리즘 ­ 쇼사니(Shoshani)와 포크만(Coffman)이 제안 ­ 다음과 같은 자료구조들을 사용함 · Available : 자원 형태마다 사용 가능한 자원 수를 표시하는 길이가 m인 벡터 · Allocation : 각 프로세스에 현재 할당된 각 형태들의 자원 수를 표시하는 n ⅹ m 행렬 · Request : 각 프로세스의 현재 요청을 표시하는 n ⅹ m 행렬 · Request[i, j] : 프로세스  P가 필요한 자원 수가 k 개라면 프로세스  P는 자원 형태  R i i j 의 자원을 k개 더 요청함 ­ 남아있는 프로세스들에 대한 할당 가능 순서를 모두 찾음
① 1단계 : Work과 ex)inish는 각각 길이가 m과 n인 벡터로, ‘Work := Available’로 초기 화 함 · (i = 1, 2, …, n)일 때 ‘Allocationi ≠ 0’이면 ‘ex)inish[i] := false’이고, 아니면 ‘ex)inish[i]  := true’
② 2단계 : 다음과 같은 조건을 만족하는 색인 i를 찾으며, 조건에 맞는 i가 없으면 4단계 로 이동 · ex)inish[i] = false,  Request ≤ Work i
③ 3단계 : 다음이 일치하는지 여부를 판단하여 2단계로 이동 · Work := Work + Allocation i · ex)inish[i] := true
④ 4단계 : ex)inish[i] = false라면, 1 ≤ i ≤ n인 범위에서 시스템과 프로세스  P는 교착상 i 태임 ­ 교착상태 탐지 알고리즘 예 · P 에서  P 까지의 프로세스 5개와  자원  형태 3개, A, B, C를 가진 시스템이 있다 가정   함 · 자원 형태 A는 자원을 7개, 자원 형태 B는 2개, C는 6개를 가지고 있음 · t 시간에 다음과 같은 자원 할당 상태가 된다 가정함  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 시간 t 일 경우 시스템의 새로운 상태  Allocation Reauest Available ABC ABC ABC P 010 000 000  P 200 020  P 302 000  P 211 100  P 002 002  · 현재  시스템은  교착상태가  아니며,  <P ,  P ,  P ,  P ,  P
>는  모든  i에  대하여  ‘ex)inish[i]       = ture’임 · 프로세스  P 가 자원 형태 C의 자원을 1개 더 요청한다 가정함  · Request 행렬은 다음과 같이 수정됨 · 현재 시스템은 교착상태임 · 프로세스  P 이  점유하고  있는  자원을  요청하더라도  가용한  자원  수는  다른  프로세스들  의 요청을 충족시킬 만큼 충분하지 않음 · 따라서 프로세스 <P , P , P , P
>로 구성된 교착상태가 존재함     시간 t 일 경우 시스템의 새로운 상태  Reauest ABC P 000  P 020  P 000  P 100  P 002      ▶ 교착상태 탐지 알고리즘 사용 횟수 ­ 탐지 알고리즘 호출 문제는 교착상태 발생 빈도수와 교착상태 발생 시 영향을 받는 프로세 스의 수에 따라 결정 · 교착상태가 자주 발생하면 탐지 알고리즘도 자주 호출됨 · 요청을 할 때마다 교착상태 탐지 알고리즘 호출 시 연산 시간 부담이 큼 · 경제적인  방법은  호출 빈도를 줄이는 것으로, 한  시간마다  또는 CPU  이용률이  40%로  저하될 때마다 호출 2. 교착상태 회복 기법 ▶ 교착상태 회복 기법 ­ 교착상태에서 회복한다는 것은 순환대기에서 탈피한다는 것을 의미함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 이를 위해 프로세스를 한 개 이상 중지시키는 방법과 교착상태의 프로세스들로부터 자원을  선점하는 방법이 있음 ▶ 프로세스 중지 ­ 두 가지 방법이 있으며, 모두 시스템이 정지된 프로세스에 할당된 모든 자원의 해제를 요구 함
① 교착상태 프로세스를 모두 중지 · 교착상태의 순환대기를 확실히 해결하지만 자원 사용과 시간 면에서 비용이 많이 듬 · 오랫동안 연산했을 가능성이 있는 프로세스의 부분 결과를 폐기하여 나중에 다시 연 산해야 함
② 한 프로세스씩 중지 · 한  프로세스가  중지될  때마다  교착상태  탐지  알고리즘을  호출하여  프로세스가  교착 상태에 있는지 확인 · 교착상태 탐지 알고리즘 호출에 대한 부담이 큼 ­ 부분 종료 방식을 사용하여 교착상태 회복 · 어느 프로세스를 중지시킬 지 결정해야 하며, 이는 프로세서 스케줄링과 유사한 정책 결 정 문제임 · 경제적인  문제로,  프로세스들을  중지시키는  데  최소비용으로  중지시키는  방법을  찾아야  함 · 일반적으로 다음과 같은 기준으로 프로세스를 선정함 ­ 프로세스들의 우선순위 ­ 프로세스가 수행된 시간과 앞으로 종료하는 데 필요한 시간 ­ 프로세스가 사용한 자원 형태와 수(ex: 자원을 선점할 수 있는지의 여부)   ­ 프로세스 종료를 위해 필요한 자원 수 ­ 프로세스를 종료하는 데 필요한 프로세스의 수  ­ 프로세스가 대화식인지 일괄식인지 여부 ▶ 자원 선점 ­ 프로세스의 자원을 선점하여 교착상태가 해결될 때까지 선점한 자원을 다른 프로세스에 할 당하여 이용 ­ 다음 세 가지 사항을 해결해야 함
① 선점 자원 선택 · 프로세스를 종료할 때, 비용을 최소화하기 위해 적절한 선점 순서를 결정해야 함 · 비용  요인은  교착상태  프로세스가  점유하고  있는  자원  수,  교착상태  프로세스가  지 금까지 실행하는 데 소용한 시간과 같은 매개변수가 포함됨
② 복귀 · 필요한 자원을 읽은 프로세스는 정상적으로 실행할 수 없으므로, 프로세스를 안정상 태로 복귀시키고 다시 시작해야 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 단순한  방법은  완전히  복귀시키고(프로세스를  중지)  재시작하는  것이며,  프로세스를  교착상태에서 벗어날 정도로만 복귀시킬 수 있다면 더 효과적임 · 시스템이 실행하는 모든 프로세스의 상태 정보를 유지해야 하는 부담이 존재함
③ 기아 · 동일한  프로세스가  자원들을  항상  선점하지  않도록  보장할  때,  비용에  근거한  시스 템은 동일한 프로세스가 희생자로 선택되기 쉬움 · 이는 프로세스가 자신의 작업을 완료하지 못하는 기아상태가 되어 시스템 조치를 요 구함 · 프로세스가 짧은 시간 동안만 희생자로 지정됨을 보장해야 함 · 일반적인 해결 방법은 비용 요소에 복귀 횟수를 포함시키는 것 3. 기아상태 ▶ 기아상태(Starvation) ­ 프로세스가 자신의 작업을 완료하지 못하는 상태 · 교착상태를 예방하기 위해 자원을 할당할 때 발생(기다림)되는 결과 ­ 다익스트라가 제안한 ‘식사하는 철학자 문제’ · 문제의 실질적인 중요성 때문이 아닌 대부분의 병행 문제인 교착상태와 기아상태의 예기  때문에 고전적인 동기 문제로 취급됨 · 문제 설명 ­ 철학자 5명은 대부분의 시간을 생각하고 먹는데 소비하며, 철학자들은 의자 5개로 둘 러 쌓인 원형 테이블을 공유함 ­ 테이블 중앙에 음식이 있으며 포크가 5개 놓여있음 ­ 지역  풍습에  따라  철학자들은  포크  2개로  식사하며,  5명의  철학자가  동시에  식사할  수 없고, 2명만 동시에 식사 가능 ­ 철학자가 생각 중일 때는 다른 철학자가 간섭하지 않음 ­ 배고픈 철학자가 식사를 위해 왼쪽과 오른쪽의 포크 2개를 든 다 가정할 때, ­ 철학자는 한 번에 포크 하나만 들 수 있으며, 왼쪽 포크를 먼저 집은 후 오른쪽 포크 를 집음 ­ 이웃 철학자가 이미 들고 있는 포크는 집을 수 없음 ­ 배고픈 철학자는 두 포크를 동시에 갖게 되면 식사를 시작함  ­ 식사를 마치면 포크 2개를 내려놓고 계속 생각함 ­ 모든 철학자가 동시에 식사를 한다면 교착상태에 빠짐 ­ 포크를 세마포어로 표시하여 교착상태 해결 · 철학자는 포크에 해당하는 세마포어에 대한 P 연산을 수행하고 나서 포크를 집음 · 포크는 해당 세마포어에 대한 V 연산을 수해함으로써 내려 놓음 · 공유 데이터는 다음과 같음 var chopstick : array [0…4] of semaphore (:=1); 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ chopstick의 모든 요소는 1로 초기화되며, 철학자 i의 구조는 다음과 같이 서술 가능 함 철학자 i의 구조 01  repeat 02    P(chopstick[i]); 03    P(chopstick[i+1 mod 5]; 04    ... 05      식사한다. 06    ... 07    V(chopstick[i]); 08    V(chopstick[i+1 mod 5]); 09    ... 10      생각한다. 11    ... 12  until false; v 이 해결방법은 두 이웃 철학자가 동시에 식사할 수 없으나, 교착상태가 발생함 ­ 교착 상태 발생 해결 방안 · 철학자 4명만 테이블에 동시에 앉도록 함 · 철학자가 양쪽 포크 모드를 사용 가능할 때 포크를 집을 수 있도록  허용(임계영역 내에 서)함 · 비대칭  해결법을  사용하여,  홀수  번째  철학자는  왼쪽  포크를  집은  후에  오른쪽  포크를,  짝수 번째 철학자는 오른쪽 포크 다음에 왼쪽 포크를 집도록 함 식사하는 철학자 문제의 해결방안 01  var chopstick : array[0...4] of semaphore (:=1); 02    room : semaphore (:=4) 03  repeat 04    P(room); 05    P(chopstick[i]); 06    P(chopstick[i+1 mod 5]; 07    ... 08      식사한다. 09    ... 10    V(room); 11    V(chopstick[i]); 12    V(chopstick[i+1 mod 5]);  13    ... 14      생각한다. 15    ... 16  until false; 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ ‘식사하는 철학자 문제’는 철학자 중 한 명이라도 굶어 죽는 일이 없어야 함 · 교착상태에 대한 해결책은 기아상태의 가능성을 제거할 수 없음 · 해결을  위해  먼저  기다리는  작업을  발견하고  각  작업이  기다린  시간을  조사,  추적해야  함 · 시스템은 기아상태를 발견하면 즉시 새로운 작업의 시작을 보류하도록 조치해야 함 · 빈번한 시스템 보류로 처리량이 감소할 수 있으므로 신중한 접근이 요구됨 ※ 정리하기 ▶ 교착상태 ­ 대기  중인  프로세스  중  한 프로세스에  의해서만 발생할 수  있는  사건을  둘  이상의  프로세 스가 무한히 대기할 때 발생함 ­ 근본적인 해결 방법은 세 가지
① 시스템이 절대 교착상태가 되지 않음을 보장하는 방법(예방)
② 교착상태를 회피하는 방법
③ 시스템이 교착상태가 되는 것을 허용하고 다시 회복시키는 방법 ▶ 교착상태의 필요충분조건 ­ 교착상태는  파일  요청,  전용장치  할당,  다중  주변장치  할당,  스풀링  시스템,  디스크  공유,  네트워크 시스템 등에서 발생함 ­ 교착상태  발생의  네  가지  필요  조건(상호배제,  점유  및  대기,  비선점,  순환대기)이  시스템  내에서 동시에 충족되어야 함 ▶ 교착상태를 예방하는 세 가지 기본 방법 ­ 필요충분조건 중 최소 하나만이라도 발생하지 않도록 함 · 점유 및 대기 : 프로세스의 실행에 앞서 필요한 자원을 모두 확보 · 비선점  :  프로세스가  일부  자원을  점유하고  있으면서  다른  자원  요청  시,  즉시  할당할  수 없으면 프로세스가 현재 점유하고 있는 모든 자원을 해제한 후 대기 · 순환대기 : 모든 자원 형태에 선형으로 순서를 부여하며, 각 프로세스는 오름차순으로만  자원을 요청할 수 있음 ▶ 교착상태 회피 ­ 교착상태 예방 알고리즘보다 덜 엄격하며, 각 프로세스가 자원을 이용하는 방법에 대한 정 보를 가짐 ­ 교착상태를 안정상태와 불안정상태로 구분하여 회피할 수 있음 ­ 교착상태 발생 여부 확인을 위해 교착상태 탐지 알고리즘을 호출함 ­ 교착상태 탐지 시 시스템은 교착상태의 프로세스를 중지시키거나, 교착상태의 프로세스로부 터 자원을 선점하여 회복하며, 희생자를 최소한 하나 선택해야 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 은행가 알고리즘(Banker’s Algorithm) ­ 교착상태를 회피하기 위한 방법으로 다익스트라가 제안함 ­ 각 프로세스에 자원을 어떻게 할당할 것인가라는 정보가 필요하므로, 각 프로세스가 요청하 는 자원 종류의 최대수를 알아야 함 ▶ 교착상태 회복 기법 ­ 교착상태에서 회복을 위해 순환대기를 탈피하는 방법으로, 프로세스를 한 개 이상 중지시키 거나 교착상태에 있는 프로세스들의 자원을 선점하는 방법이 있음 ▶ 기아상태 ­ 작업이 결코 사용할 수 없고 계속 기다려야 하는 자원을 할당할 때 발생되는 결과 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 단일 프로세스 스케줄링(1)

1. 스케줄링 개념 및 기본 요소에 대해 알 수 있다.
2. 스케줄링 단계에 관해 정리할 수 있다. 수업목표  
3. 스케줄링 시 고려사항에 대해 알 수 있다.
4. 스케줄링 알고리즘 선택 시, 고려해야 할 특성에 대해 알 수  6주차  있다.  2교시 
1. 스케줄링의 개념
2. 스케줄링의 기본 요소
3. 스케줄링의 단계 세부내용 
4. 스케줄링의 시 고려사항
5. 스케줄링의 구성
6. 선점 스케줄링과 비선점 스케줄링 1. 스케줄링의 개념 ▶ 스케줄링 개념 ­ 스케줄링은 시스템의 목표를 달성할 수 있도록 프로세서를 할당하는 일련의 과정 · 프로세서의 효율성을 높이고 시스템의 작업 처리 능력을 향상시키며 작업의 응답 시간을  최소화함 · 각 프로세스의 실행 여부를 결정하므로 시스템 성능에 영향을 미침 ㆍ 다중 프로그래밍
- 운영체제에서 가장 중요한 개념으로 여러 작업을 동시에 처리
- 여러 프로그램을 메인 메모리에 적재, 프로세서를 분할하여 시스템 효율성을 향상시킴 ⋅ 다중 프로그래밍의 장점 ­ 프로세서 이용률을 높일 수 있음 ­ 프로세서 처리율(주어진 시간에만 처리되는 작업량) 증가 ⋅ [프로세스 A와 B의 실행 과정]그림은 프로세스 실행 과정 예 ­ 프로세스 A, B가 각각 1초씩 실행하고 1초를 기다리는 것을 60회 반복한다 가정함 프로세스 A 입력 입력 입력 시작 유휴 유휴 유휴 종료 프로세스 B 입력 입력 입력 시작 유휴 유휴 유휴 종료 프로세스 A와 B의 실행 과정 ⋅ [프로세스 A와 B의 작업 수행시간]그림은  프로세스 작업 수행 시간 예  ­ 프로세스 A를 모두 처리한 후 프로세스 B를 처리하면, 작업에 4분 소요 ­ 컴퓨터가 실제 작업을 처리하는 시간 2분, 쉬는 시간 2분 소요 ­ 프로세서 이용률은 50% 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세스 A 입력 입력 입력 유휴 유휴 유휴 시작 종료 입력 입력 입력 유휴 유휴 유휴 대기 시작 종료 프로세스 B 프로세스 A와 B의 실행 과정 ⋅ [다중 프로그래밍을 이용한 프로세스 A와 B의 작업 수행시간]그림은 다중 프로그래밍을  활용한 프로세스 작업 수행 시간 예 ­ 프로세스 A와 B를 다중 프로그래밍하여 시스템 성능 향상  ­ A를 먼저 실행하고 1초 후에 B를 실행 ­ 작업을 끝내는데 소요한 시간은 2분이며, 프로세서 사용률은 50%에서 100%로 향상 되고 처리율도 증가함 프로세스 A 입력 입력 입력 유휴 유휴 유휴 시작 종료 프로세스 B 입력 입력 입력 유휴 유휴 유휴 시작 종료 다중 프로그래밍을 이용한 프로세스 A와 B의 작업 수행시간 2. 스케줄링의 기본 요소 ▶ 스케줄링 기본 요소

1) 프로세스 실행 ­ 컴퓨터 시스템에서 발생한 다양한 프로세스는 스케줄링 해야 하는 것과 그렇지 않은 것 으로 구분 ⋅ 스케줄링 하지 않고 실행
- 예 : 인터럽트 처리, 오류 처리, 사용자의 시스템 호출 등의 사전 처리 ⋅ 스케줄링 해야 하는 것
- 예 : 사용자 프로세스, 시스템 프로세스 ⋅ 다중 작업(Multi Task)
- 다중 프로그래밍과 상관 없이 여러 개의 프로세스가 동시에 실행되는 경우
- 스풀링 등의 시스템  프로세스에 의해 단일  사용자  시스템에서도 여러 개의  프로세스 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 가 동시에 실행 가능 ­ 프로세스의 실행은  실행(프로세서 버스트)과  입출력  대기(입출력  버스트)의  순환으로  구 성 · 프로세스들은 이들 두 상태 사이에서 교대로 진행 · 프로세서 버스트, 즉 프로세서에서 실행되고 있는 프로세스의 상태로 시작하고 끝남 load store  시작 종료 add store  프로세서 버스트 read from file 입출력 대기 입출력 버스트 store increment   프로세서 index 프로세서 버스트  버스트 write to file 입출력 대기 입출력 버스트 load store add store  프로세서 버스트  read from file 입출력 입출력 대기 입출력 버스트 버스트 [그림 6
-4] 프로세스의 실행(왼쪽)과 버스트 순환(오른쪽)

2) 프로세서 버스트 ­ 프로세서  버스트  지속시간을  측정하면  전체적인  발생  시간은  [프로세스  버스트  시간의  그래프]그림과 같은 빈도 곡선으로 표시됨(프로세스마다 다양함) 160 짧은 프로세서 140 버스트 작업 120 100 80 빈도 60 긴 프로세서  40 버스트 작업 20 0 8 16 24 32 40 버스트 지속 시간 프로세스 버스트 시간의 그래프 ­ [전형적인 프로세스의 입출력 대기시간]그림은 프로세스의 입출력 대기시간 · 긴 프로세서 버스트(a)와 짧은 프로세서 버스트(b)를 갖는 전형적인 입출력 대기시간 을 나타냄 · 입출력  중심의  프로그램은  전형적으로  매우  짧은  프로세스  버스트를  가짐(입출력  중 심 작업) · 프로세서 중심의 프로그램은 매우 긴 프로세서 버스트를 가짐(프로세서 중심 작업) · 이러한 분포는 적절한 프로세서 스케줄링 알고리즘을  선택하는  데 매우 중요한 기준 이 됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr (a) 긴 프로세서 버스트 짧은 프로세서 버스트 입출력 대기 (b) 시간 프로세스 버스트 시간의 그래프    3. 스케줄링의 단계  ▶ 스케줄링 단계 ­ 세 단계를 중요하게 고려함 · 프로세서들을 언제, 어느 프로세서에 할당할 것인가를 결정
① 1단계 : 작업 스케줄링(작업 선택) ­ 승인 스케줄링 ­ 시스템 자원을 실제 사용할 작업을 결정하는 단계 ­ 수행 빈도로 표현하여 장기 스케줄링임 ­ 새로운  프로세스가  생성되면  실행되고,  작업  스케줄링이  수행되면  작업은  프로세스 들로 나누어짐
② 2단계 : 작업 승인과 프로세서 할당(사용권한) ­ 어느 프로세스에 프로세서를 사용할 수 있는 권한을 줄 지 결정 ­ 시스템의 부하가 변동함에 따라 어느 프로세스를 잠정적으로 연기시킬 것인지 결정 ­ 시스템의 작업 승인과 작업들에 대한 프로세서 배당 사이의 완충 역할  ­ 수행  빈도로  표현하여  중기  스케줄링으로  교체(Swapping)  기능의  일부로  이해  가 능 ­ 실행 가능한 프로세스에 어떤 프로세스를 추가할 것인지 결정
③ 3단계 : 준비상태의 프로세서에 프로세스 할당(디스패칭) ­ 디스패처에  의해  준비상태에  있는  프로세스의  프로세서를  어느  프로세스에  할당할  지 결정 ­ 수행  빈도로  표현하여  단기  스케줄링으로,  빈번한  실행을  통해  다음  실행할  프로세 스를 결정 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 큐 헤더 PCB PCB   head 준비 큐 tail 레지스터 레지스터 자기 테이프 head 장치 0 tail PCB PCB PCB 자기 테이프 head    장치 1 tail 디스크 head 장치 0 tail PCB  단말기 head 장치 0 tail 스케줄링 단계                    4. 스케줄링의 시 고려사항 ▶ 스케줄링 시 고려사항 ­ 대기(보류)중인 프로세스 선택과 프로세스에 프로세서를 할당하는 작업으로 다음 사항을 고 려해야 함
① 자원 할당의 공정성 · 모든  프로세스를  공평하게  취급해야  하며  어느  프로세스도  무한정  실행이  연기되어 서는 안됨
② 단위 시간당 처리량 · 단위  시간당  유효시간을  줄이고  프로세서의  처리량을 최대화하여  가능한  많은  프로 세스에 서비스를 제공
③ 응답시간 · 적절한  시간  내에  응답을  하며,  대화식  사용자에게는  적어도  2~3초  이내에  응답해 야 함
④ 예측 가능성 · 시스템 부하에 관계없이 작업은 거의 같은 시간 내에 거의 같은 비용으로 실행 가능 해야 함
⑤ 과부하 · 과부하가 발생하면 자원이 낭비되므로 과부화를 줄여야 함 · 그러나 과부하는 시스템의 전반적인 성능을 향상시킬 수 있음
⑥ 자원사용의 균형 · 시스템 내의 자원들은 가능한 쉬지 않고 사용할 수 있도록 스케줄링 해야 함 · 유휴상태의 자원을 사용하려는 프로세스에 특별한 혜택 부여 가능
⑦ 응답시간과 자원의 활용 간에 균형 유지 · 응답시간(Turn
-around  Time)을  빠르게  하는  방법은  자원들이  필요할  때마다  이용 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 할  수  있도록  충분한  자원을  확보하는  것이나,  자원이  충분할  경우  자원  활용도가  낮아짐 · 실시간 시스템에서는 빠른 응답이 필수라 자원 활용이 덜 중요하나, 다른 형태의 시 스템에서는 경제성으로 인해 효과적인 자원 활용이 중요함
⑧ 실행 대기 · 실행의 무한정 연기는 교착상태만큼 나쁜 영향을 끼치므로 실행이 연기되는 것을 피 해야 함 · 자원을  오래  기다릴  수록  높은  우선순위를  부여하여,  자원을  확보하게  해주는  에이 징(Aging) 방법을 통해 해결 가능
⑨ 우선순위 · 프로세스들에 우선순위를 부여, 우선순위가 높은 프로세스를 먼저 실행시킬 수 있도 록 우선순위 제도를 실행 · 비선점  자원일  경우,  스케줄링  기법은  프로세스에  주요  자원을  넘겨주기  보다  우선 순위에 따라 처리해야 함
⑩ 서비스 사용 기회 · 프로세스에 서비스 사용 기회를 자주 제공해야 함 · 특히 페이지 부재율이 적은 프로세스들에 대해 서비스가 확대되어야 함
⑪ 서비스 수 · 시스템에 부하가 많이 걸린 경우에 갑자기 서비스 수가 감소하면 안됨 · 과부하를 방지하던지, 프로세스들의 서비스를 줄여 과부하에 대처 · 서로 모순되는 면이 많이 있어 스케줄링 문제를 어렵게 만드는 원인 중 하나임 5. 스케줄링의 구성 ▶ 스케줄링 큐 ­ 스케줄링을 위한 데이터베이스는 큐로 구성, PCB가 리스트 형태로 연결됨 · 프로세서 사용의 극대화를 위해 프로세스가 항상 실행될 수 있도록 준비 큐에 프로세스  적재 · 단일 프로세서 시스템에서는 프로세스 하나만 수행되므로 여러 프로세스가 준비 큐에 저 장 ­ 준비 큐 : 프로세스를 선택하는 큐로서 시스템에 하나 존재함 · 일반적으로  준비  큐는  연결  리스트로  머리(Head)와  꼬리(Tail)  부분은  PCB  목록의  첫  번째 항목과 마지막 항목의 포인터를 가리킴 · PCB에는 준비 큐에 있는 다음 프로세스를 가리키는 포인터 필드가 있음 · 시스템에는 장치와 연결된 다른 큐들이 존재 · 프로세스가  프로세서를  할당  받으면  실행을  완료하고  종료  또는  입출력을  요청할  경우  대기함 · 디스크는  동시에 많은 프로세스의 입출력 요청을  받을 수  있으나, 이  경우 프로세스 대 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 기 발생 · 장치 큐 ­ 입출력장치를 사용하기 위해 대기하는 프로세스들의 리스트 ­ 전용장치 일 경우 장치 큐는 프로세스를 한 개 이상 가질 수 없음 큐 헤더 PCB PCB   head 준비 큐 tail 레지스터 레지스터 자기 테이프 head 장치 0 tail PCB PCB PCB 자기 테이프 head    장치 1 tail 디스크 head 장치 0 tail PCB  단말기 head 장치 0 tail 준비 큐와 다양한 입출력 장치 큐 ▶ 큐잉 도표 ­ 프로세서 스케줄링을 설명하기 위해 사용 · 큐잉 도표에서 사각형은 큐로 준비 큐와 장치 큐의 집합을 의미함 · 원은 큐를 서비스하는 자원, 화살표는 시스템에서 프로세스들의 흐름(진행방향)을 표현 · 작업  스케줄러가  작업을  받아들일  때,  작업의  PCB가  생성,  PCB는  작업이  시작되어  종 료될 때까지 내용이 갱신됨 · 실행 준비가 된 PCB, 즉 해당 프로세스는 준비 큐에 놓임 · 프로세스는 프로세서를 할당 받을 때까지 준비 큐에서 대기 일괄처리 장기 스케줄러 단기 스케줄러 작업 준비 큐 프로세서 종료 대화형 사용자 I/O 입출력 큐 입출력 요청 시간 할당 초과 자식 실행 자식 생성 인터럽트 발생 인터럽트 기다림 프로세서 스케줄링 큐잉 도표 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 프로세스에 프로세서가 할당되면 다음과 같은 경우 발행 가능
① 프로세스는 입출력 요청을 발신하고 입출력 큐에 놓임
② 프로세스는 새로운 프로세서를 생성(ex)ork)하고 생성한 프로세스의 종료를 기다림
③  인터럽트에  의해  프로세서에서  강제로  제거된  프로세스는  준비  큐에  다시  놓일  수  있음 ·
①, 
②의 경우 프로세스는 대기상태에서 준비상태로 전환, 다시 준비 큐에 놓임 · 프로세스는 종료되어 시스템을 떠날 때까지 순환을 계속함 ­ [간략한 큐잉 도표]그림은 프로세서 스케줄링 과정 설명 · 입출력장치(I/O) 한 개와 입출력 대기 큐 한 개를 갖는 단순한 구조의 큐잉 도표 장기 스케줄러 단기 스케줄러 준비 큐 프로세서 종료 I/O 입출력 대기 큐 간략한 큐잉 도표 ▶ 스케줄러 ­ 스케줄링 큐에서 프로세스들을 선택하기 위해 스케줄러 사용 · 프로세스는 실행되는 동안 다양한 스케줄링 큐 사이를 이동함 · 운영체제는 많은 스케줄러를 가지며, 주요 스케줄러는 장기 스케줄러와 단기 스케줄러임
① 장기 스케줄러(작업 스케줄러) ­ 스케줄링  원칙에  따라  디스크  내의  작업을  어떤  순서로  메모리에  가져와서  처리할  것인지 결정하는 프로그램 ­ 필요한 정보는 제출시간, 작업 이름, 작업의 길이(용량) 등  ­ 프로세서  스케줄링  :  메인  메모리에  적재되어  있는  프로세스를  할당  받아  실행상태 가 되도록 결정 ­ 프로세스가 실행하는데 필요한 자원의 요청은 만족되어야 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 선점 새로운  준비 큐 스케줄러 프로세서 프로세스 자원 관리자 할당 요청 자원 프로세스 스케줄링 ­ [작업(장기)  스케줄러와  프로세서(단기)  스케줄러]  그림,  일괄처리  시스템에서  장기  스케줄 러와 단기 스케줄러 비교 · 일괄처리 시스템에서는 즉시 처리할 수 있는 양보다 많은 작업이 들어옴 · 작업들은 저장 용량이 큰 저장장치에 저장되어 있음
① 장기 스케줄러 ­ 실행할 작업을 준비 큐(입력 큐)에서 꺼내 메인 메모리에 적재함
② 단기 스케줄러(프로세서 스케줄러) ­ 메인 메모리의 준비 상태에 있는 작업 중에서 실행할 작업을 선택, 프로세서를 배당 함 프로세서 프로세서 스케줄러 작업 도착 준비 큐 메인 메모리 승인(작업)  스케줄러 작업(장기) 스케줄러와 프로세서(단기) 스케줄러 ­ 장기 스케줄러와 단기 스케줄러의 차이점 · 근본적인 차이점은 실행 빈도임
① 단기 스케줄러 ­ 실행할 프로세스를 수시로 선택 ­ 프로세서에서  실행시간은  100만  분의  수초  정도이므로,  최소한  100만  분의  10초  단위로 스케줄러가 실행된다 가정하였을 때, ­ 프로세스를 선택하는데 100만 분의 1초가 걸릴 때, 전체 시간의 9%(≒ 1/(10+1))  정도가 프로세서의 스케줄링에 소비됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
② 장기 스케줄러 ­ 시스템에 새로운 작업이 들어오는 것은 분(Minute) 단위이므로, 단기 스케줄러에 비 해 상대적으로 드물게 수행됨 ­ 다중 프로그래밍의 정도(Multiprogramming Degree, 메인 메모리에 있는 프로세스 의 수)를 결정 ­ 작업이  시스템에  들어오는  정도가  일정할  경우,  작업의  도착률과  작업을  끝내고  나 가는 정도는 같게 됨 ­ 작업이  시스템을  나갈  때만  실행되며  실행  간격이  상대적으로  길어,  실행시간이  길 어도 영향을 별로 받지 않음 v 대부분의 작업들은 입출력 중심 작업과 프로세서 중심 작업으로 구성 v 시스템의 성능을 좋게 하려면 두 종류의 작업을 적절히 혼합하여 선택해야 함 ­ 중기 스케줄러 · 시스템에  장기  스케줄러가  없거나  작은  경우도  있으며,  시분할  시스템은  장기  스케줄러  없이 새로운 프로세스를 메인 메모리에 넣어주기만 함 · 가상 메모리 체제나 시분할 기법을 사용하는 시스템은 중기 스케줄러를 추가로 사용 중기 스케줄러 영역 스왑 인 스왑 아웃 부분적으로 실행되다가  교체되어 나갔던 프로세스 신규 준비 큐 프로세서 종료 I/O 입출력 대기 큐 중간 단계 스케줄링을 큐잉 도표에 추가 · 교체(Swapping) 작업 가능 ­ 프로세스들이  프로세서를  서로  차지하려고  할  때,  프로세스를  기억장소에서  빼낼  수  있어(교체작업) 다중 프로그래밍의 정도를 줄일 수 있음 ­ 빼낸 프로세스는 시간이 흐른 후 다시 메인 메모리에 들어가 수행이 중단되었던 곳에 서부터 계속 수행됨 ­ 중기 스케줄러가 교체되어 나가고 들어오는 스케줄을 결정함  ­ 작업의 혼합을 개선하거나 프로세스가  가지고  있던 메모리를  사용 가능하게  하기 위 해 필요함 ­ 디스패처(Dispatcher) · 프로세서 스케줄러(단기 스케줄러)에 포함된 요소로, 분배기 · 단기 스케줄러가 선택한 프로세스에 실질적으로 프로세서를 할당 · 프로세스의  레지스터를  적재(문맥교환)하고,  사용자  상태(User  Mode)로  전환,  다시  시 작할 때 사용자 프로그램이 올바른 위치를 찾을 수 있도록 도와줌 · 디스패처의 처리 속도는 빠를수록 좋음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 다른 상태로부터 전환 실행 프로세스로부터 이동 준비 프로세서 준비 큐 PCB 디스패치 문맥 교환기 프로세서 스케줄러 : 프로세스 선택 스케줄러(디스패처) ­ 스케줄링과 프로세스 상태 변환
① 장기 스케줄러 · 프로세스의 생성 과정에서 프로세스의 준비상태에 무엇을 추가할 지 결정하고, 메인  메모리의 사용가능 공간 확인과 자원 확인
② 중기 스케줄러 · 교체  기능의  일부로  메인  메모리에  부분적으로  프로세스를  적재,  일시  중지된  프로 세서의 원인이 해결되면 다시 준비 상태로 만듦
③ 단기 스케줄러 · 미리 정해진 정책(알고리즘)에 따라 실행할 프로세스를 선택 v 프로세스의 실행 상태 → 대기, 대기상태 → 준비 : 단기 스케줄러 v 실행 → 종료상태 : 단/장기 스케줄러 생성/보유 장기 스케줄러 단기 스케줄러  단/장기 스케줄러  (알고리즘) 자원 해제 일시중지 준비 실행 종료 중기 스케줄러 단기 스케줄러 (시간 이터럽트, 우선순위 인터럽트) 단기 스케줄러  단기 스케줄러 (장치 관리자로부터 신호   대기 (입출력 요구, 페이지 부재) 또는 페이지 인터럽트 처리) 스케줄링과 프로세스 상태 변환 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 6. 선점 스케줄링과 비선점 스케줄링 ▶ 선점 스케줄링과 비선점 스케줄링 ­ “실행 중인 작업이나 프로세스를 실행 중 중단할 것인가?”의 관점을 기반으로 선점 스케줄 링과 비선점 스케줄링으로 구분 ㆍ 비선점 스케줄링(Nonpreemptive Scheduling)
- 한 프로세스가 자원(프로세서) 선택 시, 다른 프로세스에 할당된 자원을 빼앗을 수 없는  스케줄링
- 모든 프로세서를 공정하게 관리하여 실행시간이 짧은 작업들을 기다리게 되는 경우가 있 음
- 우선순위가 높은 작업들이 중간에 입력되어도 대기중인 작업들은 영향을 받지 않아 응답 시간 예측이 쉬움 ㆍ 선점 스케줄링(Preemptive Scheduling)
- 현재 실행 중인 프로세스를 인터럽트 할 수 있거나 준비상태로 이동시킬 수 있는 스케줄 링
- 하나의 프로세스가 장시간 동안 프로세서를 독점하는 것을 방지
- 우선순위가 높은 프로세스들이 긴급한 처리를 요청할 때 유용함
- 선점을 효과적으로 하기 위해 메인 메모리에 많은 프로세스들이 저장되어 있어야 하므로  많은 오버헤드를 초래함
- 설계 시 우선순위 개념을 반드시 고려하여 의미 있게 배당해야 함 ▶ 알고리즘 성능 평가 기준 ­ 스케줄링 알고리즘 선택 시, 각 알고리즘의 특성을 고려해야 함 ­ 다음과 같은 기준으로 프로세스 알고리즘을 비교
① 프로세서 사용률 · 프로세서를 실행상태로 항상 유지하여 유휴상태가 되지 않도록 함 · 가능한 입출력 중심의 작업보다 프로세서 중심의 작업을 실행
② 처리율 · 단위  시간당 완료되는 작업  수가 많도록 짧은 작업을 우선 처리하거나 인터럽트 없 이 작업을 실행
③ 반환시간 · 작업이 시스템에 맡겨져 메인 메모리에 들어가기까지의 시간, 준비 큐에 있는 시간,  실행시간,  입출력  시간  등  작업  제출  후  완료되는  순간까지의  소요시간이  최소화되 도록 일괄처리 작업을 우선 처리함
④ 대기시간 · 작업의 실행시간이나 입출력시간에는 실제적인 영향을 미치지 못하므로 준비 큐에서  기다리는 시간이 최소화되도록 사용자 수를 제한함
⑤ 반응시간 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 의뢰한 시간에서부터 반응이 시작되는 시간까지의 간격 · 대화형  시스템에  중요한  사항으로,  대화식  작업을  우선  처리하고  일괄처리  작업은  대화식 작업의 요구가 없을 때 처리함 v 스케줄링  시  프로세서  사용률과  처리율을  최대화하고,  반환시간,  대기시간,  반응시간은  최소화하는 것이 바람직함 ­ [프로세스 C의 반환시간, 대기시간, 반응시간] 그림은 프로세스의 반환, 대기, 반응 시간 · 프로세스 A, B, C가 A, B, C 순으로 같은 시간에 도착했다 가정함 반환시간 대기시간 반응시간 A B C A B C A C A C 시간 프로세스 C의 반환시간, 대기시간, 반응시간 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 단일 프로세스 스케줄링(2)

1. 단일 프로세서로 구성된 시스템의 스케줄링 알고리즘을  7주차  수업목표   살펴보고 분류할 수 있다. 1교시 
2. 스케줄링 알고리즘 종류와 특징에 대해 알 수 있다.  세부내용 
1. 스케줄링 알고리즘 1. 스케줄링 알고리즘 ▶ 스케줄링 알고리즘 ­ 대부분의 알고리즘은 대화식 사용자 환경과 빠른 응답시간을 구현하는데 집중 · 프로세스 스케줄러는 프로세스 스케줄링 알고리즘에 따라 프로세서를 할당, 작업을 완료 · 여기서는 단일 프로세서로 구성된 시스템의 스케줄링 알고리즘을 살펴봄 ▶ 알고리즘의 분류 ㆍ 비선점 알고리즘
- ex)Iex)O
- SJex)
- HRN
- 기한부, 우선순위 ㆍ 선점 알고리즘
- SRT
- RR
- MLQ
- Mex)Q ▶ 선입 선처리 스케줄링(ex)Cex)S, ex)irst
-Come
-ex)irst
-Served) 
- 비선점 ­ 프로세서를 요구 순서대로 할당 · 비선점 기법으로 프로세서 스케줄링 알고리즘 중 가장 간단함 · 선입선출(ex)Iex)O, ex)irst
-In ex)irst
-Out) 큐로 구현 · 일괄처리 시스템에서는 효율적이나, 대화식 시스템에서는 사용자의 빠른 응답 요구에 적 합하지 않음 ­ 새로운 작업이 시스템에 들어오면 프로세스의 PCB는 준비 큐의 마지막에 연결됨 ­ 차례가 되면 준비 큐의 앞부분에 있는 프로세스는 프로세서를 할당 받고 준비 큐에서  삭제 ­ 성능이 좋지 않는 경우가 많으며 평균 대기시간이 긴 경우도 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 새로운 프로세스는 큐의 tail(꼬리)에 추가 head tail PCB 프로세서 준비 큐 선입 선처리 스케줄링 ­ 작업의 평균 변환 시간 계산 · 프로세서 버스트 시간을 알고 있는 다음 세 가지 작업의 평균 변환 시간을 계산함 프로세스 실행시간 P 24  P 3  P 3  · 작업이  P ,  P ,  P 의  순서로  들어왔다면,  아래와  같은  간트  도표(Gantt  Chart)로  나타    냄 ­ 반환시간은  P 이 24,  P 가 27,  P 가 30이므로,  평균 반환시간은 27(=(24+27+30)     /3) ­ 대기시간은  P 이  0,  P 가  24,  P 가  27이므로,  평균  대기시간은  17(=(0+24+27)     /3) P P P    24 27 30 P , P , P 의 순서로 들어왔을 경우의 간트 도표    · 작업이 P ,  P , P 의 순서로 들어온 경우 간트 도표는 아래와 같음    ­ 평균 반환시간은 13(=(3+6+30)/3)이 되고, 평균 대기시간은 3(=(0+3+6)/3)으로 단 축됨 P P P    3 6 30 P , P , P 의 순서로 들어왔을 경우의 간트 도표    v 프로세스의 실행시간에 따라 평균 반환시간과 평균 대기시간은 큰 폭으로 변화함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ [호위 효과] 동적 상황에서의 성능 · 프로세서 중심 작업 1개와 입출력 중심 작업 3개가 있다고 가정함
①  프로세서  중심  프로세스가  프로세서를  할당  받아  실행되는  동안,  입출력  프로세스들 은 입출력을 끝내고 준비 큐로 이동하여 프로세서를 기다림, 이때 입출력장치들은 쉼(입 출력장치 비어 있음)
② 프로세서 중심 프로세스는 프로세서 작업을 끝내고 입출력장치로 이동 짧은 프로세서  버스트를  가진 입출력 중심  작업들은  프로세서 작업을 신속히 끝내고 다시 입출력 큐로  이동, 이때 프로세서는 쉼(프로세서 비어 있음)
③ 프로세서 중심 프로세스는 다시 준비 큐로 이동하여 프로세서를 할당 받고 다시 모든  입출력 중심의 프로세스들은 프로세서 중심 프로세스가 처리될 때까지 준비 큐에서 대기 (반복처리) 프로세서 비어있음 프로세서 비어있음 프로세서 입출력 중심 작업  입출력장치 프로세서 중심 작업 호위 효과 · 호위효과(Convoy Effect) ­ 하나의 프로세서 중심 프로세스가 프로세서를 떠나기를 기다리는 현상  ­ 결과적으로 프로세서 중심 작업과 입출력 중심 작업의 불균형 상태를 의미함 v 선입  선처리  스케줄링  알고리즘은  정기적으로  프로세서를  공유하는  시분할  시스템에서  사용하기 힘듦 ▶ 최소 작업 우선 스케줄링(SJex), Shortest Job ex)irst) 
- 비선점 ­ 프로세서 버스트 시간이 가장 짧은 작업에 프로세서를 할당 · 이때 두 프로세스가 다음 순서로 동일한 프로세서 버스트를 가진다면 선입 선처리 스케 줄링을 적용함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 새로운 프로세스 큐에서의 위치 결정 (다음 프로세서 버스트 길이(시간)와 비교하여) 긴 버스트  짧은 버스트   프로세스 프로세서 프로세서 최소 작업 우선 스케줄링 · 다음과 같은 작업들이 준비상태 큐에 있을 때, 최소 작업 우선 스케줄링을 사용하면 아 래 그림과 같은 간트 도표가 이루어지며, 평균 반환시간은 13(=(3+9+16+24)/4) 평균 변환 시간 계산 프로세스 실행시간 P 6  P P P P     P 3  P 8  0 3 9 16 24 P 7  최소 작업 우선 스케줄링을 사용한 간트 도표 · 대기시간은  P 가  0,  P 은  3,  P 는  9,  P 은  16이므로  평균  대기시간은  7(=(0+3+9+     

16)/4) · 선입 선처리 스케줄링 사용 시 간트 도표 P P P P     0 6 9 17 24 선입 선처리 스케줄링을 사용한 간트 도표 · 평균 반환시간은 14(=(6+9+17+24)/4)이며, 평균 대기시간은 8(=(0+6+9+17)/4) · 최소 작업 우선 알고리즘은 주어진 작업 집합에 대해 평균 대기시간이 최소이므로 최적  알고리즘 ­ [짧은  작업  우선  처리]그림에서  실행시간이  짧은  작업(Short)을  실행시간이  긴  작업 (Long) 앞에 놓음 ­ 긴  작업의  대기시간은  증가하였으나,  짧은  작업의  대기시간이  줄어  평균  대기시간은  감소함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr long short short long 선입 선처리 스케줄링을 사용한 간트 도표 · 최소 작업 우선 알고리즘은 주어진 작업 집합에 대해 평균 대기시간이 최소이므로 최적  알고리즘 ­ [최소  작업  우선  스케줄링이  최적임을  증명]그림에서  프로세스  실행시간이  각각  5,  11, 7, 3인 경우 5 11 7 3 W = 0 + 5 + 16 + 23 = 44 5 7 11 3 W = 0 + 5 + 12 + 23 = 40 5 7 3 11 W = 0 + 5 + 12 + 15 = 32 W = 0 + 5 + 8 + 15 = 28 5 3 7 11 W = 0 + 3 + 8 + 15 = 26 3 5 7 11 선입 선처리 스케줄링을 사용한 간트 도표 ­ 일괄 처리 시스템에서 장기 스케줄링 · 작업의 제한 시간이 짧은 경우 빠른  반환을 요구,  사용자는  시간 한계를 정확하게 예상 해야 함 ­ 시간 한계가 너무 짧을 경우 실행시간이 제한시간을 초과, 다시 작업을 입력해야 함 ­ 최소 작업 우선 스케줄링은 작업 스케줄링에서 많이 사용됨 · 단기 스케줄링에서는 다음 프로세스의 프로세서 버스트 시간을 예상할 수 없으므로 하드 웨어 구성이 어려움 · 이를 해결하기 위해 최소 작업 우선 스케줄링 근사치 사용 ­ 비선점 스케줄링 알고리즘은 시분할 시스템에 사용하기 힘듦 · 최소 작업 우선 스케줄링은 선점 또는 비선점이 가능함 · 시분할 시스템에서는 각 사용자들이 일정한 간격으로 프로세서 사용을 원함 · 작업 4개의 평균 변환 시간 계산 프로세스 도착시간 실행시간 P 0 8  P 1 4  P 2 9  P 3 5  · 아래의 간트 도표는 선점과 비선점 최소 작업 우선 스케줄링을 나타냄 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr (a) 선점 선점 P P P P P      0 1 5 10 17 26 (b) 비선점 P P P P     0 8 12 17 26 선점과 비선점 최소 작업 우선 스케줄링을 사용한 간트 도표
① 선점인 경우 ­ 평균 반환시간은 13(=(P +P +P +P )/4=((17
-0)+(5
-1)+(26
-2)+(10
-3))/4=52/4)     ­ 평균 대기시간은 6.5(=(P +P +P +P )/4=(10
-1)+(1
-1)+(17
-2)+(5
-3))/4)     ­ 문맥교환 시간이 소요됨 ­ 최소  잔여시간  우선  스케줄링(Shortest
-Remaining
-Time
-ex)irst  Scheduling)이라고  함
② 비선점인 경우 ­ 평균  반환시간은  14.25(=(P +P +P +P )/4=(8
-0)+(12
-1)+(26
-2)+(17
-3))/4=57/     

4) ­ 평균 대기시간은 7.75(=(P +P +P +P )/4 =(0+(8
-1)+(17
-2)+(12
-3))/4)     ▶ 우선순위 스케줄링(Priority Scheduling) 
- 비선점 ­ 준비 큐에 도착한 프로세스와 현재 실행 중인 프로세스의 우선순위를 비교 · 프로세스들의 우선순위를 비교하여 최고 우선순위를 가진 프로세스에 프로세서를 할당 · 우선순위가 같은 프로세스들은 선입 선처리 순으로 스케줄됨 새로운 프로세스 선택기 (우선순위 비교하여 위치 결정) 프로세서 우선순위 낮음 우선순위 높음 우선순위 스케줄링 ­ 최소 작업 우선 알고리즘은 우선순위 알고리즘에 속함 ­ 우선순위(P)는 예측된 다음 프로세서 버스트의 역(τ), 즉 ‘P = 1/ τ’. ­ 프로세서 버스트가 클수록 우선순위가 낮으며, 그 반대도 성립됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 내부적 또는 외부적으로 우선순위 정의 가능 · 우선순위는 정해진 범위의 수 0~7 또는 0~4,095를 사용  ­ 0이 최상위이거나 최하위라고 정해지지 않음 ­ 내부적으로 정의된 우선순위 · 프로세스의 우선순위 연산을 위해 제한시간, 기억장소 요구량, 사용 파일 수, 평균 프로 세서 버스트에 대한 평균 입출력 버스트의 비율 등이 사용됨 ­ 외부적인 우선순위 · 프로세스의 중요성, 사용료를 많이 낸 사용자, 작업을 지원하는 부서, 정책적인 요인 등  운영체제 외적인 요소에 의해 결정됨 ­ 선점 또는 비선점이 가능함
① 선점 우선순위 스케줄링 알고리즘 ­ 새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높으면  프로세서를 선점함
② 비선점 우선순위 스케줄링 알고리즘 ­ 단순히 준비 큐의 머리 부분에 새로운 프로세스를 넣음 · 아래 그림에서 4단계 우선순위를 갖는 준비 큐에서 실행 가능한 프로세스를 나타냄 실행 가능 프로세스 큐 헤더 우선 순위 높음 우선순위 4 우선순위 3 우선순위 2 우선순위 1 우선 순위 낮음 4단계 우선순위를 갖는 스케줄링 알고리즘 · 아래 표과 같은 프로세스들이 같은 시간에 도착했다 가정함 프로세스 도착 시간 프로세스 도착시간 실행시간 P 10 3  P 1 1  P 2 3  P 1 4  P 5 2  · 우선순위  스케줄링을  이용하여  스케줄링한  결과는  아래의  간트  도표와  같으며,  평균  대 기 시간은 8.2임 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr P P P P P      0 1 6 16 18 19 우선순위 스케줄링을 이용한 간트 도표 ㆍ 문제점
- 주요 문제는 무한정지와 기아 · 우선  순위가  높은 프로세스들이  계속  들어오면  우선순위가 낮은  프로세스들은 무한정  기다려야 함 ㆍ 해결 방법
- 에이징(Aging) · 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 기법 ▶ 순환 할당(Round
-Robin) 스케줄링 
- 선점 ­ 시분할 시스템을 위해 특별히 설계됨 · 규정  시간량(Time  Quantum)  또는  시간  할당량(Time  Slice)라  하는  작은  단위의  시간 을 정의 · 시간 할당량은 일반적으로 10 ⅹ 10 밀리 초에서 100 ⅹ 10 밀리 초 범위로 함 · 준비  큐는  순환  큐(Circular  Queue)로  설계,  프로세서  스케줄러가  준비  큐를  돌아가면 서 한 번에 한 프로세스에 정의된 규정 시간량만큼 프로세서를 제공 · 준비 큐는 ex)Iex)O 큐임 현재 다음 현재 프로세스 프로세스 프로세스 B ex) D G A ex) D G A B 머리 (a) 꼬리 머리 (b) 꼬리 프로세스 B가 실행된 후의 준비 큐 · 프로세서 스케줄러는 준비 큐의 앞부분에 있는 프로세스에 프로세서를 할당(디스패치) · 규정 시간량이 지나면 인터럽트가 발생되며, 다음 두 가지 경우에 발생함
① 규정 시간 내에 일을 끝내는 경우 : 프로세스는 자유로워지며 준비 큐에 있는 다음 프로세스를 진행
② 현재 실행하고 있는 프로세스가 규정 시간량보다 긴 경우   : 운영체제에 의해 인터럽트되며  중단된  프로세스의 레지스터들은  프로세스의 PCB 에 저장, 프로세스는 준비 큐의 마지막 위치에 입력됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 스케줄러는 준비 큐에서 아래의 작업을 가져와 실행시킴 새로운 준비 큐 (ex)Iex)O 큐)  프로세스 꼬리 머리 프로세스 규정 시간량 초과 종료 순환 할당 스케줄링 · 아래 표는 이전의 최소 작업 우선 알고리즘의 작업을 적용한 예 우선순위 알고리즘의 작업 정리 프로세스 도착시간 실행시간 P 0 8  P 1 4  P 2 9  P 3 5  · 규정 시간량을 4로 한 경우 순환 할당 스케줄링의 간트 도표는 아래와 같음 ­ P 은 처음 4만큼의 시간을 실행한 후 아직  4가 남아 있지만  P 가 프로세서를 선점,    실행됨 ­ P 는 시간을 4만큼만 원하므로 4시간 후 종료되며  P 이 들어옴   ­ P 은 4시간을 실행한 후 P 에 프로세서를 넘겨 줌   ­ 이후 앞서 종료되지 않은  P 이 실행됨  P P P P P P P P         0 4 8 12 16 20 2425 26 규정 시간량을 4로 한 순환 할당 스케줄링의 간트 도표 ­ 프로세스 반환시간은 작업 완료 시간에서 도착 시간을 뺀 값 · 평균 반환시간은 18.25(=(20+7+24+22)/4) · 평균 대기시간은 11.75(=(12+3+15+17)/4) ­ 순환 할당 알고리즘은 선점 알고리즘임 · 프로세스가  규정  시간량보다  많은  실행시간  요청  시  스케줄러가  프로세스를  중단,  다음  프로세스로 대치함 ­ 순환 할당 알고리즘의 성능은 규정 시간량의 크기에 영향을 받음 · 준비  큐에 프로세스가  n개 있고 규정  시간량이 q이면,  각 프로세스는  최대로  q시간 단 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 위로 프로세서 시간의 1/n을 얻음 · 각 프로세스는 자신의 다음 규정 시간량이 할당될 때까지 ‘(n
-1)ⅹ q’ 시간 이상을 대기 하지 않음 ex:  규정  시간량  20을  가진  프로세스  5개가  있는  경우,  각  프로세스는  100마다  20의  시간을 할당 받음 ­ 대화식 프로세스는 규정 시간량보다 짧은 시간을 요구함 · 실행을 시작할 때, 입출력 요청을 할 정도만 프로세서를 잠시 사용한 후 보류되고, 다음  프로세스에 프로세서를 양보함 · 규정  시간량이  입출력까지의  계산시간보다 커야 입출력 활용도를  극대화하고  대화식 프 로세스에 빠르게 반응 가능함
① 규정 시간량이 아주 클 경우 ­ 작업을 완료할 충분한 시간을 얻고 순환 할당 방식이 선입 선처리 방식으로 변함 ­ 작업시간이 긴 프로세스들 때문에 작업시간이 짧은 프로세스들이 대기, 평균 대기시 간이 길어짐
② 규정 시간량이 매우 작은 경우(ex: 1μsec) ­ 순환 할당을 프로세서 공유(Processor Sharing)라 부름 ­ 이론적으로  마치  n개의  프로세스가  실제  프로세서  속도의  1/n의  속도로  실행되는  것처럼 보임 ­ 프로세서 공유 방식 · CDC(Control  Data  Corporation)에서  하드웨어  한  세트와  레지스터  10세트로  주변장 치 프로세서 10개를 구현하는데 사용됨 · 빠른 프로세스 하나가 아닌 느린 프로세서 10개를 이용하여 처리하는 것과 같음 · 실제로  프로세서가  메모리보다  빠르고  각  명령어가  메모리  참조  시  프로세서들은  단일  프로세서보다 그리 늦지 않음 ­ 최적의 규정 시간량 결정 · 규정 시간량의 크기는 시스템 특성 및 오버헤드, 프로세스에 따라 다름 ㆍ 문제점
- 프로세서  중심  프로세스에서  대화식  프로세스를  지원,  선점을  통해  대화식  프로세스가  도착할 때 적절한 시간에 반응을 보여주도록 보장하는 것이 중요함
- 소프트웨어 측면에서 문맥교환의 문제 · 문맥교환 때문에 발생하는 오버헤드가 커지면, 시스템 성능 감소와 의미 있는 일의 수 행보다 대부분의 시간을 문맥 전환에 사용
- 문맥교환 시간이 미치는 영향 예 · 시간 10을 소비하는 작업 수행 시, 규정 시간량이 12일 경우, 작업은 규정 시간 내에  끝남 · 규정 시간량이 6일 경우, 작업은 규정 시간량을 2번 요구, 1번의 문맥교환을 요청함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세스 시간 = 0 할당 시간 문맥 교환 횟수 12 0 0 10 6 1 0 6 10 1 9 0 1 2 3 4 5 6 7 8 9 10 문맥교환 횟수를 증가시키는 작은 시간 할당량 ­ 반환시간도 규정 시간량의 크기에 영향을 받음 · 규정 시간량에 따른 반환시간의 변화 ­ 한  프로세스 집합의  평균  반환시간은 규정  시간량의  크기가  증가하더라도 반드시 개 선되지는 않음 ­ 대부분의 프로세스들이  단일  규정 시간량 안에 작업을 끝마치면 평균 반환시간은 개 선됨 평균 반환 시간 프로세스 시간 12.5 12.0 P  6 11.5 P 3  11.0 P 1  10.5 10.0 P  7 9.5 9.0 규정시간량 1 2 3 4 5 6 7 규정 시간량에 따른 반환시간의 변화 · 시간 규정량에 따른 프로세스의 반환 시간 ­ 실행시간이  10인  3개의  프로세스들이  있고  규정  시간량이  1시간일  경우,  평균  반환 시간은 29(=(28+29+30)/3) ­ 규정 시간량이 10인 경우 평균 반환시간은 20(=(10+20+30)/3)으로 떨어짐 ­ 규정 시간이 작을 경우 문맥교환이 많이 일어나므로 평균 반환시간이 좋지 않음 프로세스(10ms) 시간 규정량 = 1 시간 규정량 = 10 P  0 10 20 30 0 10 P  0 10 20 30 10 20 P  0 10 20 30 20 30 시간 규정량에 따른 프로세스의 반환시간 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 단일 프로세스 스케줄링(3)

1. 단일 프로세서 알고리즘 종류와 특징에 대해 알 수 있다. 수업목표  
2. 알고리즘 선택 기준에 대해 알고, 분석적 평가를 할 수 있다. 7주차 
1. 다단계 큐(Multi
-Level Queue) 스케줄링 2교시 

2. HRN(Highest Response
-Rate Next) 스케줄링 세부내용 

3. 다중 처리기 스케줄링
4. 스레드 스케줄링
5. 알고리즘 평가 1. 다단계 큐(Multi
-Level Queue) 스케줄링 ▶ 다단계 큐(Multi
-Level Queue) 스케줄링 ­ 각 작업들을 서로 다른 묶음으로 분류할 수 있을 때 사용 · 분류 예 ­ 작업을  전면작업(대화형,  ex)oreground  Task)과  후면작업(일괄처리형,  Background  Task)으로 분류 시, 두 유형의 요구 반응 시간이 다르므로 서로 다르게 스케줄링해야  함 ­ 전면작업은 후면작업에 비해 높은 우선순위를 가짐 · 준비상태 큐를 종류별로 여러 단계로 분할해 둠 ([다단계 큐 스케줄링]그림 참조) · 작업을 기억장치의 크기나 프로세스의 형태에 따라 어느 한 큐에 지정 · 각 큐는 자신만의 독자적인 스케줄링 알고리즘을 가짐 · 큐 사이에도 스케줄링이 있어야 하며, 이는 고정된 우선순위의 선점식 스케줄링임 · 큐들 사이에 시간을 나누어 사용 가능 ­ 각  큐는  프로세서  시간의  일정량을  받아서  큐에  있는  프로세스들을  스케줄링  할  수  있음 · [다단계 큐 스케줄링]그림에서 큐 5개를 가진 다단계 큐 스케줄링 알고리즘 ­ 각 큐는 순서대로 절대적인 우선순위를 가짐 ­ 앞의 세 가지 큐가 비어있어야, 네 번째 일괄 처리 큐에 있는 프로세스가 실행됨 최고 우선순위 시스템 프로세스 대화식 프로세스 대화식 편집 프로세스  일괄 처리 프로세스  학생 프로세스 최저 우선순위 다단계 큐 스케줄링 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 다단계 피드백 큐 스케줄링 ­ 작업이 시스템에 들어가면 한 큐에서만 고정 · 전면작업과 후면작업에 대한 독립된 큐가 있어도 작업은 한 큐에서 다른 큐로 옮겨지지  않음 · 작업은 그 성격상 전면작업과 후면작업의 성질을 바꿀 수 있는 것이 아니기 때문 · 스케줄링 부담이 적으나 융통성이 떨어짐 ­ 다단계 피드백 큐(Multi Level ex)eedback Queue) · 프로세서 버스트의 특성에 따라 분리하여 구분하며, 작업이 큐 사이를 이동 가능함 · 다단계 피드백 구조 ­ 어떤 작업이 요구하는 프로세서 시간이 너무 길면 작업을 낮은 단계 큐로 옮김 ­ 입출력  중심  작업과  전면작업(대화식  작업)을  높은  우선순위  큐에  놓고  프로세서  중 심 프로세스는 낮은 우선순위 큐에 놓음 ­ 낮음 프로세서 중심 프로세스 높은 우선순위에 따라  프로세서를 기다리는  높음 준비 큐에 프로세스 할당 입출력 중심 프로세스 우선순위에 의해  인덱스된 준비 큐 다단계 피드백 큐 구조 ­ 문제점 및 해결 방법 · 기아상태에 빠질 가능성이 있음 ­ 프로세서 버스트 시간이 작은 프로세스에 우선권을 주어 일찍 종료시키고 다음 입출 력 버스트를 실행하며, 이는 입출력 위주의 프로세스에 우선권을 주는 기법임 ­ 높은 우선순위의 큐가 완전히 비어야 낮은 우선순위의 준비 큐에 있는 작업이 실행될  수 있음 ­ 낮은 우선순위의 큐에 입력된 작업이 기아상태에 빠질 수 있음 · 에이징 방법을 활용 ­ 특정 큐에서  오래  기다린  프로세스를  우선순위가 높은 큐로  이동,  프로세서  점유  시 간이 긴 작업을 우선순위가 낮은 큐로 이동시켜 기아상태 예방 ­ 프로세서를 할당 받을 시 규정 시간량을 더 얻음 · 프로세스들이 더 낮은 수준의 큐로 이동 시, 스케줄러는 해당 프로세스들의 규정 시간량 을 증가시켜 프로세스가 더 오래 작업할 수 있도록 함 · 다단계 피드백 큐 ­ 큐 4개가 있는 다단계 피드백 큐 스케줄러 ­ 각 큐는 0~3까지의 번호를 가짐 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 우선순위 낮음 ex)Cex)S(규정 시간량 = 무한) 선택기 큐0 규정 시간량 = 16밀리 초 (우선 에이징 큐2 순위  규정 시간량 = 4밀리 초 (우선순위 높아짐) 비교) 큐1 규정 시간량 = 2밀리 초 큐0 우선순위 떨어짐 우선순위 높음 다단계 피드백 큐 ­ 다단계 피드백 큐 스케줄링 알고리즘의 우선순위 · 프로세서 버스트가 2 이하인 모든 프로세스에 최고의 우선순위를 부여함  ­ 최고의  우선순위를  부여받은  프로세스는  프로세서를  할당받아  프로세서  버스트를  끝 내고 다음 입출력 버스트로 이동함 · 4 이상 16 이하의 규정 시간량이 필요한 프로세스들은 규정시간이 더 짧은 프로세스들 보다는 낮은 우선순위를 받으나 역시 서비스를 빨리 받을 수 있음 · 규정시간이 긴  프로세스들은 자동적으로  큐 3으로  가며,  큐 1과  큐 2의  프로세서 주기 에 여유가 생기면 선입 선처리 방식으로 처리됨 ­ 다단계 피드백 큐 스케줄링 알고리즘의 정의 · 큐(Queue)의 수 · 각 큐에 대한 스케줄링 알고리즘 · 작업을 좀 더 높은 우선순위의 큐로 격상시키는 시기를 결정하는 방법 · 작업을 좀 더 낮은 우선순위의 큐로 격하시키는 시기를 결정하는 방법 · 프로세스들이 어느 큐에 들어갈 것인가를 결정하는 방법 · 프로세스가 서비스를 받는 시기를 결정하는 방법 v 다단계 피드백 큐 스케줄러의 정의에 의해 프로세서 스케줄링 알고리즘 중 가장 일반적인  기법이며, 이 정의들은 특정 시스템에 맞게 적용 가능함 v 최상의  스케줄러를  정의하기  위한  요소들의  평가치를  찾기  위한  어떤  방법이  요구된다는  단점을 가지며, 이로 인해 가장 복잡한 알고리즘이라 할 수 있음 ­ 순환할당 알고리즘과의 비교 · 동일한 시간(t=0)에 프로세서 중심의 프로세스 시스템이 3개 있다고 가정 · 프로세서 버스트 길이는 각각 P1(30), P2(20), P3(10) · 시스템은  각각 큐  1(1),  큐  2(2),  큐  3(4)의  규정  시간량을  할당하며,  순환할당  알고리 즘의 규정 시간량은 1임 · 아래 그림은 반환시간 및 대기시간을 계산하기 위한 다단계 피드백 큐의 간트 도표 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 종료 종료 종료 큐1: P P P P P      큐2: P P P    큐3: P P P P P P P P P P P            시간 1  2  3  5  7  9  13 17 21 25 29 32 34 40 44 48 52 53 60 · 순환할당(RR)  및  다단계  피드백  큐(MLex)Q)  스케줄링  알고리즘의  반환시간  및  대기시간 은 아래와 같음 반환시간 RR : P1: 60, P2: 50, P3: 30 평균 : (60+50+30)/3 = 46 2/3 Mex)LQ : P1: 60, P2: 53, P3: 32 평균 : (60+53+32)/3 = 48 1/3 대기시간 RR : P1: 30, P2: 30, P3: 20 평균 : (30+30+20)/3 = 26 2/3  Mex)LQ : P1(53
-23), P2(52
-19), P3(29
-7) 평균 : (30+33+22)/3 = 28 1/3 · 프로세스를 변경하여 앞의 예제와 비교함 · 시스템은 각각 큐 1(2), 큐 2(4)의 규정 시간량을 할당 · 프로세스(P3)는 2단위 프로세서 버스트 실행 후에 1단위 입출력 버스트를 실행 · 입출력 버스트 실행 후 P3은 큐 1로 돌아가 입출력장치에 보류하면서 남은 시간만큼 다 시 수행됨 · 아래 그림은 반환시간 및 대기시간을 계산하기 위한 다단계 피드백 큐의 간트 도표 종료 종료 종료 큐1:  P P P P    P    P    P           큐2: P    P    P    P    P P P P P P P P P P               입출력: P    P    P    P        시간    2  4  6  7  9  10 12 13 15 16 18 22 26 30 34 38 42 46 50 52 60 반환시간 RR : P1: 60, P2: 50, P3: 30 평균 : (60+50+30)/3 = 46 2/3  Mex)LQ : P1: 60, P2: 52, P3: 18 평균 : (60+52+18)/3 = 43 대기시간 RR : P1: 30, P2: 30, P3: 20 평균 : (30+30+20)/3 = 26 2/3  Mex)LQ : P1(52
-22), P2(52
-18), P3(4) 평균 : (30+32+4)/3 = 22 2. HRN(Highest Response
-Rate Next) 스케줄링 ▶ HRN(Highest Response
-Rate Next) 스케줄링 ­ 한슨(Brinch Hansen)이 개발 · 최소  작업 우선(SJex)) 기법의 약점이었던 긴 작업과  짧은  작업  간의 지나친 불평등을 어 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 느 정도 보완한 기법 · 비선점 스케줄링 기법으로 각 작업의 우선순위는 작업이 서비스 받을 시간 뿐만 아니라  서비스를 기다린 시간 등, 두 가지의 함수로 나타냄 · 한 작업이 프로세서를 차지하면 작업이 종료될 때까지 실행됨 · HRN 기법의 가변적 우선순위는 다음 식에 따라 계산됨 대기한 시간 + 서비스를 받을 시간 우선순위 = 서비스를 받을 시간 · HRN 기법의 가변적 우선순위는 다음 식에 따라 계산됨 ­ ‘서비스를  받을  시간’이  분모에  있으므로  ‘서비스를  받을  시간’이  짧은  작업이  우선순 위가 높음 ­ ‘대기한  시간’이  분자에  있으므로  ‘서비스를  받을  시간’이  긴  작업도  ‘대기한  시간’이  큰 경우에 우선순위가 높아짐 · 따라서 시스템의 응답시간은 다음과 같이 나타낼 수 있음 시스템의 응답시간 : 대기한 시간 + 서비스를 받을 시간 ­ [HRN 알고리즘의 작업 정리]표의 작업 5개를 이용한 HRN 스케줄링 HRN 알고리즘의 작업 정리 프로세스 도착시간 실행시간 P 0 3  P P P P P      P 2 6  P 4 4  0 3 9 13 15 20 P 6 5  P 8 2  HRN 스케줄링의 간트 도표 대기시간 : 0+(3
-2)+(9
-4)+(15
-6)+(13­8)/5 = 4 · 순환할당 스케줄링의 간트 도표(규정 시간량=1) P P P P P P P P P P P P P P P P P P                   0 5 10 15 20 순환할당 스케줄링의 간트 도표 대기 시간 : (3
-2)+(17
-5
-2)+(16
-3
-4)+(18
-3
-6)+(14
-1
-8)/5 = 6.8 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 3. 다중 처리기 스케줄링 ▶ 다중 처리기 스케줄링 ­ 강결합 다중처리기 시스템을 중심으로 다중 프로세스의 구조를 살펴봄 ­ 각  프로세서들은  독자적인  큐와  독자적인  알고리즘을  가지므로  프로세서가  다르면  선택의  여지는 상대적으로 제한됨 ­ 작업은 프로세스의 구조에 따라 특정하게 지정, 특정 프로세서의 의해 실행되어야 함 ­ 같은 종류의 프로세서가 한 시스템에 여러 개 있다면 부하 공유가 발생함 ­ 이를 방지하기 위해 각 프로세서에 서로 독립된 큐를 제공 · 프로세서의 할당이 모든 프로세스에 한 번만 이루어지므로 스케줄링 오버헤드가 적음 · 어떤 프로세서는 큐가 비어  아무 일도  하지 않을 수도, 다른 프로세스는 처리할  작업이  준비 큐에 가득 차 매우 바쁠 수 있다는 단점이 있음 ­ 공동의 준비 큐를 통해 모든 작업이 이용 가능한 프로세서 큐로 가도록 스케줄 함 · 프로세스가 메모리에 적재되는 동안 다른 프로세서에서 작업을 실행 가능 ­ 강결합된  공유  메모리  구조에서  모든  프로세서는  모든  프로세스에  대한  문맥  정보를  이용 할 수 있음 · 프로세스의 스케줄링 비용은 프로세스가 스케줄 되는 프로세서에 독립적 ­ 두 가지 스케줄링 방법 사용
① 프로세서 자신이 스스로 스케줄링하는 것 ­ 각 프로세서는 공통의 준비 상태 큐에서 실행시킬 프로세스 하나를 선택  ­ 두 프로세서가 같은 프로세스를 선택하지 않아야 하며, 프로세스가 큐에서 누락되지  않도록 해야 함 ­ 단일  프로세서  스케줄링(우선순위,  순환할당  등)  기법의  활용이  가능하나,  스케줄링 이 복잡하여 오버헤드를 증가시킬 수 있음
② 한 프로세서를 다른 모든 프로세서의 스케줄러로 지정, 주/종(Master/Slave) 구조를 갖 게 함 ­ 비대칭 다중 프로세싱(Asymmetric Multiprocessing). ­ 운영체제의 핵심 커널 기능들은 특정 프로세서에서 수행, 다른 프로세서들은 사용자  프로그램들만 수행함 ­ 주 프로세서는 프로세스들을 스케줄링하여 프로세스를 활성화시킴 ­ 종 프로세스가 입출력 호출  등의 서비스가 필요할  때 주 프로세서에 요청하여 서비 스의 처리가 완료되길 기다림 ­ 단일 프로세서 다중 프로그래밍 기법과 유사하며 자원 충돌 문제를 해결할 수 있음 ­ 주 프로세서의 오류는 시스템 전체를 정지시키며, 주 프로세서의 과중한 오버헤드는  성능의 병목지점이 될 수 있다는 단점이 존재함 4. 스레드 스케줄링 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 스레드 스케줄링 ㆍ 스레드 실행의 개념
- 어플리케이션과 같은 주소 공간에서 동시에 실행하고 협동하는 스레드들로 구현 가능
- 스레드 교환은 프로세스 교환보다 오버헤드가 적어 성능을 향상시킬 수 있음 ㆍ 부하 공유(Load Sharing)
- 프로세서를 특정 프로세스 하나에 할당하지 않고 전역 큐에서 프로세서를 유지
- 쉬고 있는 프로세스는 전역 큐에서 스레드 하나를 선택함
- 단일 프로세서 환경에서 사용한 기법을 그대로 채택한 가장 간단한 다중 프로세서 기법 ⋅ 부하공유의 장점 ­ 부하는 프로세서들에 균등하게 분산되며 실행 대기 중인 작업에는 분산되지 않음 ­ 스레드 제어를 위한  중앙  제어 스케줄러 없이 사용  시, 현재  작업을  진행한  프로세서 에서 다음 작업 선정 ­ 전역(공유) 큐는 선입선처리(ex)Cex)S)나 우선순위 기법을 이용하여 구성 가능 ⋅ 부하공유의 단점 ­ 중앙 큐는 상호  배제 방식으로 접근되는 메모리 영역으로 많은 프로세서가 동시에 작 업을 찾을 시 병목지점이 될 수 있음 ­ 선점된 스레드들은 동일한 프로세서 상에서 실행을 재개하기 어려움 ­ 프로그램의  스레드들 사이에  밀접한  협조가 요구된다면  관련된  프로세스  교환은  성능 을 저하시킬 수 있음 v 현재 다중 프로세서 상에서 가장 일반적으로 사용되고 있음 ㆍ 갱(Gang) 스케줄링
- 관련된 스레드의 집합이 일대일 대응 원칙에 따라 프로세서 집합에서 동시에 실행될 수  있도록 스케줄링하는 기법
- 단일 프로세스에 속한 스레드들이 동시에 스케줄링됨
- 동기화 보류 및 프로세스 문맥교환의 횟수를 최소화하여 성능을 향상시킬 수 있음
- 스케줄링 오버헤드를 감소시킬 수 있음 ㆍ 전용 프로세서 할당
- 스레드들을 실행 전담 프로세서에 할당하여 정의된 스케줄링을 제공
- 각 프로그램을 실행되는 동안 프로그램 내의 스레드 개수와 동일한 수의 프로세스를 할 당받으므로 프로세스가 낭비될 수 있음
- 프로세서의 합리적인 이용의 지원이 필요함 · 활성화된  스레드의  개수를  시스템상의  프로세서와  동일한  개수로  제한하여  효율성을  높임 ㆍ 동적 스케줄링
- 프로세스 내의 스레드 수를 동적으로 변경하여 운영체제가 시스템 이용률을 높일 수 있 도록 부하 조절을 허용한 기법 v 갱 스케줄링과 전용 프로세서 할당은 프로세서 단편화 문제를 회피하기 위한 기법 v 동적 스케줄링 기법이 갱 스케줄링, 전용 프로세서 할당 기법보다 우수하나 오버헤드로  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 인한 성능 감소가 발생할 수 있음 5. 알고리즘 평가 ▶ 알고리즘 선택 기준 ­ 알고리즘 선택 시 사용할 기준의 정의가 모호함으로 인해 선택이 어려움 · 일반적으로 프로세스  이용률,  응답시간, 처리율을  선택  기준으로  이용하나,  이들의  기준 을 정의하는 것이 어려움 · 이용하기 위해선 측정한 내용의 상대적인 중요성을 정의하는 것이 필요함 · 아래의 예가 기준이 되며, 선택 기준이 정의되면 다양한 알고리즘을 평가할 수 있음 ­ 최대 응답시간이 1초라는 제약 조건에서 프로세서 이용률 ­ 평균 반환시간이 전체 실행 시간에 선형적으로 비례하는 처리율 ▶ 분석적(해석적) 평가 ­ 작업 부하(Workload)를  줄이기 위해  알고리즘의 성능을 평가하는 공식, 값을 생성하기 위 한 알고리즘, 시스템 작업 부하를 이용 ­ 결정성 모형화 : 분석적 평가의 한 형태로 이 방식은 사전에 정의된 특정한 작업에 대하여  각 알고리즘의 성능을 평가 · 다섯 개의 모든 프로세스가 시간 0을 기준으로 다음 [프로세스의 버스트 시간]표와 같이  도착했다 가정함 · 프로세스  P ,  P ,  P ,  P 에  대하여  선입  선처리,  최소작업  우선,  순환할당(시간  할당량     =10) 스케줄링에 대하여 평균 대기시간을 조사 프로세스의 버스트 시간 프로세스 버스트 시간 P 10  P 29  P 3  P 7  P 12 

1) 선입 선처리 평가 ­ P 대기시간은 0, P 는 10, P 는 39, P 는 42, P 는 49      ­ 평균 대기시간은 28(=(P +P +P +P +P )/5 =(0+10+39+42+49)/5)      P P P P P      0 10 39 42 49 61 선입 선처리 간트 도표 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
2) 비선점 최소 작업 우선 스케줄링 평가 ­ P 대기시간은 10, P 는 32, P 는 0, P 는 3     ­ 평균 대기시간은 13(=(P +P +P +P +P )/5 = (10+20+0+3+32)/5)      P P P P P      0 3 10 20 32 61 비선점 최소 작업 우선 스케줄링 간트 도표
3) 순환 할당 평가 ­ 프로세스  P 는 10단위 이후에 선점되어 큐의 뒤에 넣음  · P 은  대기시간이  0,  P 는  32(=10+20(=40
-20)+2(=52
-50)),  P 는  20,  P 는  23,      P 는 40  · 평균 대기시간은 23(=(0+32+20+23+40)/5) P P P P P P P P         0 10 20 23 30 40 50 52 61 순환 할당 간트 도표 v 결정성 모형화는 간단하고 신속하며, 알고리즘들을 비교할 수 있도록 정확한 값을 제공 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 메모리 관리(1)

1. 메모리 관리 개념에 대해 알 수 있다.  수업목표  
2. 연속 메모리 할당의 개념과 종류를 알 수 있다. 1. 메모리 관리 9주차     
- 메모리 관리 개념 1교시     
- 메모리 관리 방식 세부내용     
- 프로세스 교체 2. 연속 메모리 할당    
- 단일 사용자 연속 메모리 할당    
- 고정 분할 다중 프로그래밍 1. 메모리 관리 ▶ 메모리 관리 기법 ­ 메인 메모리는 운영체제를 위한 영역과 실행 중인 프로그램을 위한 영역으로 구분 · 메모리 관리 ­ 다중 프로그래밍 시스템에서 운영체제에 의해 동적으로 메모리의 사용자 영역을 여러  프로세스가 상주할 수 있도록 세분화하는 과정

1) 반입 정책 ­ 메인 메모리에 적재할 다음 프로세스의 반입시기를 결정하는 방법 
① 요구 반입 기법 · 운영체제나  시스템  프로그램,  사용자  프로그램  등의  참조요구에  따라  메인  메모리에  적재하는 방법으로 오랫동안 사용됨
② 예상 반입 기법 · 시스템의 요구를 예측하여 메모리에 미리 적재하는 방법으로 최근 사용되기 시작함 · 요구되는  페이지  외의  다른  페이지도  함께  불러들이며,  탐색시간과  회전  지연시간을  갖는 보조기억장치의 특성을 참조한 정책

2) 배치 정책 ­ 디스크에서 반입한 프로세스를 메인 메모리 어느 위치에 저장할 것인가를 결정하는 방법 ­ 최초 적합, 최적 접합, 최악 적합 등
3) 대치 정책 ­ 재배치 기법으로 메인 메모리에 있는 어떤 프로세스를 제거할 것인가를 결정 ▶ 메모리 해석에 대한 두 가지 관점 ­ 물리적 공간과 논리적 공간으로 구분
① 물리적 공간(물리적 주소) · 실제 데이터나 프로그램이 저장되는 공간 · 메모리 칩(Chip) 또는 디스크 공간으로 생성. 사용되는 단위는 바이트(Byte) 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 논리적 주소보다 크거나, 작거나, 같을 수 있음라 다름
② 논리적 공간(논리적 주소) · 프로그래머가 프로그래밍에 사용하는 공간 · 목적코드(Object Code)가  저장된  공간과  프로그램에서 사용하는 자료  구조  등이 해 당됨 · 논리적 메모리 크기는 각 시스템에서 정의한 워드의 길이에 따라 다름 0 P
-시작 A 0 A 0 P
-끝 A P
-시작 B B S B P B
-끝 S C P
-시작 C C P
-끝 C S A 논리적 관점 물리적 관점 (논리적 주소 공간) (물리적 주소 공간) 메모리 해석에 대한 두 가지 관점 ㆍ 메모리 매핑(Memory Mapping)
- 논리적 주소와 물리적 주소의 연결
- 메모리 관리 장치(MMU, Memory Management Unit)인 하드웨어에서 실행
- 메모리 관리 방식에 따라 여러 방식으로 구분됨 · 고정 분할 · 동적 분할(가변 분할) · 페이징(Paging) · 세그먼트(Segment) · 페이지화된 세그먼트 방식 등 주소 변환 메모리 관리 장치  프로세서 메모리 (MMU) 프로그램 하드웨어 (논리 또는 가상 주소) (물리 또는 실제 주소) 변환 기법 고정 분할 동적 분할(가변 분할)  페이징(Paging)  세그먼트(Segmentation)  페이지화된 세그먼트 메모리 관리 장치에 의한 메모리 매핑 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 메모리 관리 방식 ­ 크게 두 가지 방법으로 구분
① 연속 메모리 할당 방식 · 프로그램(프로세스)를 적재하는 과정에서 연속적으로 메모리를 할당
② 분산 메모리 할당 방식 · 프로그램을 페이지나 세그먼트 단위로 나누어 여러 곳에 적재하여 할당 ㆍ 초기 컴퓨터 시스템
- 연속 메모리 할당 방식 사용 · 각 프로그램이 연속된 하나의 블록을 차지하도록 할당 · 직접 배치, 중첩(오버레이), 분할 기법 등이 해당됨
- 고정 분할 기법 · 메모리 영역을  여러  개의  고정된  크기로 분할하여  프로세스에  제공하며,  메모리의  낭 비(내부 단편화)를 유발함
- 동적(가변) 분할 기법 · 각  프로세스의  크기에  따라  메모리를 분할하는  방식으로,  고정 분할 기법의  문제점을  해결하기 위해 제시됨 · 다중 프로그래밍 기법에 적용하며, 분산 메모리 할당 방식이 제시됨
- 분산 메모리 할당 방식 · 사용자의 프로세스가 페이지나 세그먼테이션 등의 단위로 보조기억장치에 적재되어 있 다가 프로세스의 요구에 의해 메인 메모리의 여러 영역에 할당되는 방식 · 현재의 가상 메모리 관리 기법으로 발전됨 ▶ 주소 바인딩(Binding) ­ 논리적 주소를 물리적 주소로 변환하는 과정 · 프로그램에 있어서의 주소를 절대 주소로 바꾸어 메인 메모리의 고정된 부분에 적재하는  것 ­ 방식에 따라 다음과 같이 단계별로 구분
① 컴파일(Compile) · 프로세스가 메모리 내에 적재될 위치를 컴파일 과정에서 알 수 있다면 컴파일러는 물 리적 주소(절대 주소)를 생성할 수 있음 · 절대 재배치 : 메인 메모리의 실제 주소로 변환되는 과정
② 적재시간 · 정적 재배치 ­ 프로세스가  메모리  내의  어디에  적재되어야  할  것인가를  컴파일  과정에서  알려주 지 않으면 컴파일러는 재배치 가능 상대 주소를 생성함 ­ 상대 주소는 프로그램의 시작 주소가 0으로 생성되므로 최종 바인딩은 적재시간까 지 연기됨 ­ 시작 주소가 변하면 사용자 코드는 변화된 값 반영을 위해 재적재함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
③ 수행시간 · 프로세스가  실행되는  도중에  메모리의  한 세그먼트에서  다른  세그먼트로  이동  시 바 인딩은 수행시간까지 연기됨 · 현대의 운영체제는 실행시간에 바인딩이 이루어짐 원시 프로그램 컴파일러 또는 어셈블러 컴파일시간 다른 목적 모듈 목적 모듈 시스템 연결 편집기 라이브러리 적재 모듈 적재시간 동적으로  적재기 적재된 시스템 라이브러리 동적 연결 내장된 2진 코어 이미지 실행시간 사용자 프로그램의 처리 단계 ▶ 동적 적재(Dynamic Loading) ­ 메모리 공간 이용의 효율적 운영을 위해 제안됨 · 모든 루틴은 호출될 때까지 메모리 내에 적재되지 않고 재배치 가능한 형태로 디스크에  저장 · 주 프로그램은 메모리에 적재되어 수행됨 · 주  프로그램(호출  루틴)이  다른  루틴을  호출할  필요가  있을  때,  호출  루틴은  호출될  루 틴이 메모리에 적재되어 있는지 조사 · 적재되어  있지 않다면,  재배치 가능 연결적재기(로더)는 요구된  루틴을 메모리로 적재하 기 위해 호출하면서 프로그램의 주소 테이블을 갱신, 변화를 반영함 ㆍ 장점
- 사용하지 않는 루틴을 적재하지 않음
- 코드 양이 많이 필요한 경우 유용함
- 프로그램  전체  양은  많으나  실제로  사용된  구역은  작으며,  운영체제로부터  특별한  지원 을 필요치 않음(동적 연결적재기는 제공되어야 함) v 이용하기 위해서는 사용자 자신이 프로그램의 설계를 책임져야 함 ▶ 중첩(Overlay) ­ 프로세스의 크기가 실제 메모리 크기로 제한되는 문제점을 해결하기 위해 사용됨 · 운영체제 영역과 메모리 공간의 일부 영역에 프로그램(작업) 실행에 반드시 필요한 명령 어와 데이터를 저장 · 중첩 구동기(오버레이 드라이버) 영역에는 실행기간 동안 필요한 각종 사용자 코드 등을  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 적재하여 필요한 시기에 해당 프로그램을 불러들여 실행 ㆍ 중첩 구조
- 사용자 프로그램을 초기 모듈, 처리 모듈, 출력 모듈로 구별, 초기 모듈에 적재한 후 실 행
- 처리 모듈을 실행한 후 출력 모듈을 실행함 메인 메모리의 이용 가능한  운영체제 영역보다 큰 사용자 프로그램 실행기간 동안  초기 처리  출력  주 기억장치에  모듈 모듈 모듈 적재되어야 할  사용자 코드와  데이터 중첩 영역 중첩 구조 ㆍ 중첩 구조 예
- 1단계(패스 1) 동안 심볼 테이블 작성, 2단계(패스 2)동안 기계어 코드를 생성하는 어셈 블러(Assembler) [요소의 크기] · 패스 1 : 70KB (1KB = 1024 Byte) · 패스 2 : 80KB · 심볼 테이블 : 20KB · 공통 루틴 : 30KB · 오버레이 드라이버 : 10KB
- 수행되는 기능이 다른 패스 1과 패스 2는 동시에 메모리 내에 있을 필요가 없으므로 아 래와 같은 두 개의 중첩을 정의하여 사용 · 중첩 A : 심볼 테이블, 공통 루틴, 패스 1 · 중첩 B : 심볼 테이블, 공통 루틴, 패스 2
- 오버레이 드라이버를 추가하여 중첩 A를 시작, 패스 1이 끝날 때 중첩 B를 메모리로 읽 어 들임
- 중첩 A에 기록한 다음 제어를 패스 2로 옮김 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 2단계 어셈블러를 위한 중첩 심볼 테이블 20KB 공동 루틴 30KB 중첩 A 중첩 B 오버레이 드라이버 10KB 패스 1 패스 2 70KB 80KB 2단계 어셈블러를 위한 중첩 구조
- 중첩은  프로그래머에  의해  파일들을  메모리로  읽어  들이고,  그  메모리로  분기하여  새로 운 읽기 명령을 수행하는 간단한 파일 구조를 사용
- 실행함으로써 운영체제는 평상시보다 더 많은 입출력이 있다는 것만을 인식함
- 중첩은 현재 마이크로 컴퓨터나 실제 메모리 크기가 제한된 하드웨어에서 사용 · 중첩을  이용하려면  프로그래머는  중첩  구조를  적절하게  설계,  프로그래밍해야  하므로  프로그램 구조와 코드, 자료 구조를 완전히 이해해야 함 · 현재 프로그램이 커지는 추세이므로 전체 내용을 충분히 이해하기 어려움 ▶ 프로세스 교체 ­ 다중 프로그래밍 환경에서 프로세스는 사용자 프로그램이 끝날 때까지 메인 메모리에 저장 됨 ­ 순환  할당  알고리즘이나  우선순위에  바탕을  둔  프로세서  알고리즘에서  사용하기  적합하지  않음 ­ 프로세서 할당이  끝나고  수행이 완료된  프로세스는 보조기억장치로 이동, 새롭게  시작되는  프로세스를 불러와야 함 · 프로세스가 수행되기 위해 메모리 내에 위치해야 하므로, 일시적으로 보조기억장치로 이 동 후 다시 메모리에 적재해야 함 ㆍ 프로세스 교체 예
- 순환 할당 프로세서 스케줄링 알고리즘을 가진 다중 프로그래밍 환경
- 프로세서에 할당된  시간이  지나면, 메모리  관리  장치가  방금  끝난  프로세스(P1)를  보조 기억장치로 이동, 다른 프로세스(P2)를 사용가능 공간 안으로 이동시킴 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 운영체제 ❶ 스왑 아웃 프로세스 P1 사용자 영역 프로세스   ❷ 스왑 인 P2 메인 메모리 보조(예비) 기억장치 교체 개념 ㆍ 프로세스 처리 상태
- 교체 실행 스케줄러는 디스크(스왑 준비)에 저장된 작업(프로세스)을 메인 메모리로 이동
- 메인 메모리로 이동한 작업은 준비 큐에서 실행을 대기, 실행 도중 교체 대상이 되면 대 기 상태
- 실행 조건이 만족되면 준비 큐로 이동 또는 디스크로 이동함(스왑 아웃)
- 스왑 대기 상태의 작업은 실행 조건 만족 시 스왑 준비 상태로 변경 교체 실행 스왑 준비 실행 준비 스왑 대기 대기 작업(프로세서)이 작업(프로세서)이 디스크에 메모리에 작업(프로세스)의 스왑 과정 ㆍ 롤인(Roll
-In), 롤 아웃(Roll
-Out)
- 더 높은 우선순위를 가진 프로세스 도착 시 메모리 관리 장치는 우선순위가 높은 프로세 스를 수행하기 위해 낮은 우선순위의 프로세스와 스왑(교체) 가능
- 높은  우선순위의  프로세스가  끝나면,  낮은  우선순위의  프로세스는  다시  스왑되어  계속  수행됨 ㆍ 스왑 과정
- 주소 바인딩 방법에 따라 다름
- 바인딩이 어셈블 시간이나 적재시간에 이루어지면 프로세스는 다른 위치로 이동 불가
- 수행시간에 바인딩이 이루어지면 교체 가능 ㆍ 교체 시간
- 속도가 빠른 보조기억장치가 필요하며, 문맥교환시간이 중요함
- 사용자  프로세스가  100KB이고,  보조기억장치는  초당  1MB의  전송률을  가진  디스크를  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 가정
- 보조기억장치에서 실제 전송은 아래와 같은 시간이 소요됨 100KB/초당 1,000KB = 1/10초 = 100ms(밀리 초)
- 회전 지연 시간을 평균 8ms로 가정했을 때 교체시간은 108ms임
- 스왑  아웃(Swap
-Out)과  스왑  인(Swap
-In)  모두  이루어져야  하므로  총  교체시간은  216ms
- 효과적인 프로세서 사용을 위해 각 프로세스에 대한 수행시간이 교체시간보다 길어야 함 ­ 전체 전송시간은 직접적으로 교환되는 메모리 양에 비례함 · 메인 메모리가 1MB이고 100KB의 상주 운영체제를 가진 컴퓨터가 있다 가정 ­ 사용자 프로세스의 최대 크기는 900KB ­ 대부분 사용자 프로세스는 다수의 프로세스를 가지므로 100KB보다 작음 ­ 프로세스 크기가 900KB이면 교체 시 908ms 소요, 100KB 크기의 프로세스일 경우  9번에 걸쳐 교환되므로 972ms 소요됨 ­ 프로세스 교체 시 교체시간 감소를 위한 방법 필요 · 시스템에 메모리 요청에 대한 정보 변화를 유지 ­ 동적인  메모리  요청을  가진  프로세스는  변화하는  메모리  요구를  운영체제에  제공할  수 있는 시스템 호출(메모리 요청, 메모리 해제)이 필요함 ­ 실제 사용되는 프로세스를 교체하려면 완전히 유휴상태에 있음을 확인해야 함 · 어떤 입출력에 대한 대기(입출력 완료를 기다리는 상태)는 중요함 · 프로세스가 입출력 동작을 위해 기다리면 메모리를 회수하도록 교체 가능 · 입출력 버퍼가 사용자 메모리를 비동기적으로 액세스하면 프로세스 교체 불가 ­ 두 가지 문제의 해결 방법 · 대기입출력을  가진  프로세스는  교체를  수행하지  않고,  입출력  동작이  있는  운영체제의  버퍼 내에서만 교체를 수행해야 함 · 운영체제와 프로세스 메모리  사이의  전송은  프로세스가 교체되어  들어올  때만  이루어져 야 함 v 교체 작업은 초기 시분할 시스템에서 채택되었으며, 현재 페이지 시스템으로 발전함 2. 연속 메모리 할당 ▶ 연속 메모리 할당 개념 ­ 초기 컴퓨터 시스템에 적용한 메모리 관리 기법 · 실행될  모든  프로그램은  필요한  영역만큼  연속적인  메모리  공간을  할당  받아  메모리에  적재 · 한번에  적재  불가능하면  실행이  불가능하므로,  프로그램  수정  및  작은  모듈로  구성해야  함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 단일 사용자 연속 메모리 할당 ­ 메모리 영역을 사용자를 위한 공간과 운영체제 상주를 위한 공간으로 구분 · 운영체제를 메모리의 하위나 상위에 두는 것이 가능함 · 메모리를  운영체제  루틴이  들어  있는  부분(모니터)과  사용자  프로그램이  들어있는  부분 (사용자), 사용되지 않는 부분으로 구분 ([그림]사용자 프로세스의 상위 메모리 적재(a)) · 사용자가 모든 메인 메모리에 대한 제어권을 가짐 ­ 운영체제 파괴를 막기 위해 프로세서 내에 경계 레지스터를 둠 ([그림]사용자 프로세 스의 상위 메모리 적재(b)) ­ 사용자 프로그램이 메모리 주소를 참조할 때마다 경계 레지스터를 검사한 후 실행됨 512KB 512KB 사용자 (사용자 프로세스 적재) 사용되지 않은 공간 사용자 (사용자 프로세스 적재) 경계 레지스터 모니터 모니터 0 0 (a) (b) 사용자 프로세스의 상위 메모리 적재(a)와 메모리 보호(b) ㆍ 문제점
- 사용자 프로그램의 적재 · 컴퓨터 주소 공간이 0000부터 시작하더라도 사용자 프로그램의 처음 주소는 0000번 지가 아니라 기준 레지스터 값 이후가 되므로, 기준 주소가 변하면 다시 적재해야 함 ㆍ 해결 방법
- 사용자  프로그램을 기준으로  상위  주소에  적재하지  않고  기준  레지스터로부터  내려가는  상위 메모리에 적재 · 사용되지 않은  모든  공간이  중간에 있고,  운영체제나  사용자는 필요에  따라  사용되지  않은 공간으로 확장 가능
- 수행할 때까지 주소 바인딩을 연기함 · 동적  적재를  위한,  주소  바인딩을  연기하기  위한  기준  레지스터(재배치  레지스터)가  필요함 · 기준 레지스터에 있는 값은 사용자 프로세스가 메모리로 보내질 때 생성되는 주소값에  더해짐 ex: 기준값이 1400일 경우, 주소 0에 대한 사용자 프로세스는 동적으로 1400으로 재 배치, 주소 346에 대한 접근은 17446으로 재배치됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 기준 레지스터 1400 346 1746 프로세스 메모리 논리적 주소 물리적 주소 메모리 관리 장치 기준 레지스터를 이용한 동적 재배치 v 한 번에 한 프로그램만 사용 가능하며, 메모리의 효율성이 떨어지고 다중 프로그래밍이  불가능함 v 논리적 메모리가 물리적 메모리보다 작을 때만 프로그램을 수행할 수 있음 ㆍ 교체 기법
- 메인 메모리보다 더 큰 프로그램을 실행할 수 있으므로 제한된 메인 메모리를 확장시키 는 방법으로 사용됨
- 단일 사용자 연속 메모리 할당 시스템이 프로세서 중심 작업 일 경우 · 프로세서를 집중적으로 사용 가능 · 입출력 작업이 교대로 발생하는 경우에 프로세서의 유휴 상태가 자주 발생함 프로세서를 집중적으로 사용 프로세서 입출력이 프로세서 입출력이 프로세서 사용 끝나기를  사용 끝나기를  사용 기다림 기다림 단일 사용자의 프로세서 이용도 v 단순하고 사용자 공간이 확대되는 장점을 가짐 
- 운영체제 부분이 작아도 가능 v 자원의  낭비가  심하며, 프로세스  교체 비용이 크고 입출력 때  프로세스가 유휴 상태가  되며, 사용되지 않는 프로그램의 적재 발생
- 프로그램이 차지하고 남은 부분에 대한 활용이 불가능함 ▶ 고정 분할 다중 프로그래밍 ­ Mex)T(Multiprogramming with a ex)ixed number of Tasks) 메모리 할당 방법 · IBM OS/360에서 사용되었으나, 현재는 사용되지 않음 · 고정된 크기의 분할 영역에 프로세스(작업)가 각각 할당됨 · 물리 주소는 분할 기준 레지스터(PBR) 값에 논리 주소를 더하여 생성됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 논리 주소가 분할 영역 크기보다 크면 오류 발생 ­ 분할 영역보다 프로세스의 크기가 대부분 작으므로 내부 단편화가 발생함 각 분할은 하나의 프로세서 포함 0 1 논리 주소 1 1 분할 기준 레지스터  2 0 (PBR) P 분할 0  3 1 PBR 물리 주소 사용 플래그 프로세스가 디스패치 P  분할 1 될 때마다 PBR 적재 내부 단편화 아니요 논리 주소＞분할크기 분할 2 P 예  분할 3 오류 고정 분할 다중 프로그래밍(IBM OS/360) · 분할의 수에 고정 분할 다중 프로그래밍의 성능이 제한 받음 ­ 분할 영역이 비면 프로세스는 프로세스 큐에서 하나를 선택하여 빈 분할에 적재 ­ 프로세스의 작업이 끝나면 그 분할은 다른 프로세스가 이용 가능 ­ 고정 분할 시스템 예 · 프로세스 큐 하나의 크기가 2KB인 Q2, 6KB인 Q6, 12KB인 Q12가 있는 경우 · 작업량이 2KB 미만은 Q2로, 6KB 미만은 Q6, 12KB 미만은 Q12로 보냄 · 큐에 할당하는 과정은 자동적으로 처리되며, 최대 메모리 요구량을 큐에 표시함 · 각 큐는 자신의 기억 영역을 가지므로 큐 사이에 경쟁은 없음 운영체제 (모니터) 2KB 1KB 2KB Q2 2KB 3KB 4KB Q6 6KB 12KB 7KB 11KB 8KB Q12 각 영역에 독립된 큐를 갖는 고정 분할 시스템 · 문제점 ­ 크기에 따라 각 분할 영역을 담당하는 큐가 있어 Q12 큐가 이미 다 차있는 경우, 다 른 큐(Q2, Q6)가 비어있더라도 큐를 이용할 수 없음 ­ 통합 큐 운영 고정 분할 시스템 · 모든 작업을 하나의 통합 큐에 넣고 운영 · 문제점 ­ 작업 스케줄러는 수행할 다른 작업을 선택, 그 크기의 메모리 공간을 이용할 수 있을  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 때까지 대기함 운영체제 (모니터) 2KB 6KB 4KB 1KB 7KB 3KB 2KB 5KB Q 12KB 통합 큐 운영 고정 분할 시스템 · 통합 큐 운영 고정 분할 시스템 예 ­ 2KB, 6KB, 12KB의 분할된 메모리 여역과 선입 선처리 작업 스케줄러, 작업 큐를 가 진다 가정함 ­ 작업이 5KB, 2KB, 3KB, 7KB 순으로 도착했다면,
① 작업 1(5KB)을 6KB 영역에, 작업 2(2KB)를 2KB 영역에 할당
② 작업 1이 끝난 후 작업 3(3KB)이 6KB 영역에 할당됨
③  작업  4(7KB)는  작업  4를  위한  영역(12KB)이  비어  있다  해도  작업  스케줄러가  선입 선처리 기법을 사용하므로, 작업 3이 할당될 때까지 대기해야 함 ▶ 고정 분할 다중 프로그래밍에서의 단편화 ­ 메모리의 단편화(ex)ragmentation)는  메모리 구성과 관계없이 모든 컴퓨터 시스템에서 발생 함 · 고정 분할 다중 프로그래밍에서의 단편화 ­ 사용자  작업의  크기가  지정된  분할에  정확히  맞지  않거나  분할이  너무  작아서  대기  중인 작업 중 하나도 맞는 것이 없는 상태 ­ 분할된 공간은 사용되지 않고 남아 내부 단편화의 원인이 됨 ­ 다수의 영역을 할당한 메모리 영역 · 18,464byte의 사용가능 공간이 있을 때 프로세스가 18,462byte를 요구한다 가정함 · 요구된 블록을 정확히 할당하면 2byte의 사용가능 공간이 남음 · 남은 2byte의 사용가능 공간을 활용하기 위한 처리비용은 사용가능 공간을 활용하는 비 용보다 큼 · 이러한 부분을 내부 단편화라 부르며, 대부분 사용할 수 없는 공간임 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 모니터 작업 7 다음 요청 메모리 크기  공간 크기  18,462바이 18,464바이트 작업 43 다수의 영역을 할당한 메모리 영역 ­ 내부 단편화 · 시스템의  메모리(32KB)가  10KB의 운영체제  1개,  10KB의 사용자 공간 1개, 4KB의 사 용자 공간 3개로 나뉜다고 가정함 · 작업 큐에 7KB, 3KB, 6KB, 6KB를 요구하는 작업이 있다면, ­ 7KB의  작업을  10KB  영역에(3KB  내부  단편화),  3KB  작업을  4KB  영역  중  하나에  할당(1KB 내부 단편화) ­ 이때 6KB의 작업은 할당할 수 없음 · 시스템 메모리 영역을 10KB, 8KB, 4KB로 나누면, ­ 7KB  작업은  8KB  영역에서,  3KB  작업은  4KB  영역에서,  6KB  작업은  10KB  영역에 서 수행되어 모두 6KB의 내부 단편화가 발생함 ­ 할당하는 과정에서 7KB 작업을 10KB 영역에 할당 가능함 P 7KB 운영체제 P 7KB 운영체제   P 3KB P 3KB   P 6KB P 6KB   P 6KB 10KB P 6KB 10KB   작업 큐 3KB 작업 큐 4KB 4KB 내부 단편화 1KB 8KB 4KB 1KB 4KB 4KB 1KB (a) (b) 내부 단편화 ­ 단편화는 작업 스케줄러와 분할의 크기에 의해 좌우됨 · 메모리의 낭비를 가져오므로 어떤 분할에서도 실행 가능한 재배치 가능 프로그램을 만들 어야 함 · 고정 분할은 효율적인 메모리 운영이 가능하나 기억 장소의 낭비가 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 메모리에 상주해야 하는 프로세스들이 있으므로 메모리 보호가 필요함 ­ 고정분할에서의 메모리 보호 · 두 개의 레지스터(기준 레지스터와 한계 레지스터)를 사용하여 분할된 영역 보호 ­ 기준 레지스터 : 가장 작은 합법적인 물리 메모리 주소(300040)를 저장  ­ 한계 레지스터 : 프로그램 영역이 저장되어 있는 범위의 크기(120900)를 저장 0 모니터 256000 작업 1 300040 300040 기준 레지스터 작업 2 420940 120900 작업 3 한계 레지스터 880000 작업 4 1024000 고정분할에서의 메모리 보호 ­ 고정분할에서의 메모리 보호 예 · [그림 기준 레지스터와 한계 레지스터를 이용한 프로세스 보호]에서 작업 2는 가장 작은  물리적 주소의 하한값이 300040이고, 크기가 120900인 프로세스임 ­ 기준 레지스터의 가장 작은 물리적 주소는 300040이며, 한계 레지스터는 논리 주소  120900임 ­ 사용자 주소 범위는 0~120900으로, 논리 주소는 한계 레지스터 주소보다 작아야 함 ­ 프로세스의  상한값은  420940(=기준  레지스터(300040)+한계  레지스터(120900))이  되므로, 사용자 주소 범위는 상한값과 하한값 사이가 됨 ­ 프로세서에 의해 생성된 모든 주소는 레지스터와 함께 검사되므로 다른 사용자의 프로그램 과 데이터를 보호할 수 있음 기준 기준+한계 레지스터 레지스터 주소 예 예 프로세서 메모리 아니오 아니오 트랩 : 주소 지정 오류 기준 레지스터와 한계 레지스터를 이용한 프로세스 보호 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 메모리 관리(2)

1. 연속 메모리 할당 기법들에 대해 알 수 있다. 수업목표  
2. 분산 메모리 할당 기법들에 대해 알 수 있다.
3. 세그먼트 메모리 관리 기법에 대해 알 수 있다. 9주차  1. 연속 메모리 할당 2교시     
- 가변 분할 다중 프로그래밍    
- 외부 단편화 세부내용  2. 분산 메모리 할당    
- 페이징 기법 3. 세그먼트 메모리 관리 기법 1. 연속 메모리 할당 ▶ 가변  분할  다중  프로그래밍(MVT,  Multiprogramming  with  a  Variable  number  of  Tasks) ­ 고정된 경계를 없애고 각 작업이 필요한 만큼만 메모리를 할당 · 각 프로세스(분할 영역)를 나타내기 위해 기준(재배치) 레지스터와 한계 레지스터를 사용 · 한계 레지스터는 프로세스 크기만큼의 영역에 저장 ­ 프로세서에 의해 생성된 논리 주소가 한계 레지스터 값보다 크면 오류 발생 · 가변분할 다중프로그래밍 예 ­ 분할  테이블에  있는  P3의  경우  한계  레지스터(250),  기준  레지스터(5034)와  매핑,  물리 메모리 공간에 저장됨 한계 기준 레지스터 레지스터 프로세스 프로세스(P)의 i 물리주소 공간 프로세스(P )의 i 주소 오류 논리주소 공간 물리 메모리 메모리 관리 장치(MMU) 분할 테이블 프로세스 기준 크기 P  28 1000 P  1028 3000 P  5034 250 가변분할 다중 프로그래밍 ­ 운영체제는 메모리의 사용 내역을 확인할 수 있는 테이블을 유지해야 함 · 256KB의 이용할 수 있는 메모리와 40KB 크기의 운영체제 그리고 작업 큐에 ([그림]메 모리와 작업 큐)와 같이 작업을 가진다 가정함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 0 작업 큐 운영체제 작업 메모리 시간 40KB 1 60KB 10 2 100KB 5 3 30KB 20 216KB 4 70KB 8 5 50KB 15 256KB 메모리와 작업 큐 0 0 0 0 0 운영체제 운영체제 운영체제 운영체제 운영체제 40KB 40KB 40KB 40KB 40KB 작업 5 작업 1 작업 1 작업 1 90KB 100KB 100KB 100KB 100KB 100KB 작업 2 작업 4 작업 1 작업 5 작업 4 작업 4 작업 4 작업 2 종료 할당 종료 할당 170KB 170KB 170KB 200KB 200KB 200KB 200KB 200KB 작업 3 작업 3 작업 3 작업 3 작업 3 230KB 230KB 230KB 230KB 230KB 256KB 256KB 256KB 256KB 256KB (a) (b) (c) (d) (e) 메모리 할당과 스케줄 ­ 운영체제는 메모리의 사용 내역을 확인할 수 있는 테이블을 유지해야 함 · 256KB의 이용할 수 있는 메모리와 40KB 크기의 운영체제 그리고 작업 큐에 ([그림]메 모리와 작업 큐)와 같이 작업을 가진다 가정함 · 작업 1(60KB), 작업 2(100KB), 작업 3(30KB)에 메모리를 할당하여 기억장소 작성([그 림] 메모리 할당과 스케줄 (a)) ­ 5시간  후 작업  2가 종료되면서 사용했던 메모리 할당량을 해제  ([그림] 메모리 할당 과 스케줄 (b)) ­ 작업 4가 스케줄되어 할당됨 ([그림] 메모리 할당과 스케줄 ©)  ­ 작업 1이 10시간 후에 종료되면 메모리가 해제됨 ([그림] 메모리 할당과 스케줄 (d)) ­ 작업 5에 메모리 할당 ([그림] 메모리 할당과 스케줄 (e)) · 가변  분할(동적  메모리  할당)는 요구된 크기 n을  사용가능 공간에 어떻게 할당하느냐의  문제임 예 : 최초 적합(ex)irst
-ex)it), 최상 적합(Best
-ex)it), 최악 적합(Worst
-ex)it) 등 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 메모리 재배치 기법

1) 최초 적합 기법 ­ 프로세스는 사용가능공간 리스트에서 충분히 큰 첫 번째 공백 분할 공간에 할당됨 ­ 검색은  사용가능공간  리스트의  맨  앞에서  시작하거나  이전의  최초  적합  검색이  끝났던  곳에서 시작됨 ­ 검색은 빠르나 공간 활용률이 떨어짐 0 운영체제 시작 주소  길이 1000 16KB 공백 1000 16KB 13KB를 요구  5000 14KB 사용중 8000 5KB 5000 14KB 공백 11000 30KB 사용중 사용가능공간 리스트 8000 5KB 공백 사용중 11000 30KB 공백
2) 최상 적합 기법 ­ 프로세스가 들어갈 수 있는 충분히 큰 사용가능공간 중에서 가장 작은 크기의 사용 공간 에 작업을 할당함 ­ 사용가능공간에 대한 지속적인 정렬과정이 필요하여 비효율적임 · 공간 리스트가 크기 순서로 정렬되어 있지 않을 시 전 리스트를 검색해야 함 ­ 사용가능공간 이용률은 향상되나 할당되는 과정에 많은 시간이 소요됨 ­ 가장 작은 또 다른 사용가능공간 생성 가능 0 운영체제 시작 주소  길이 1000 16KB 공백 13KB를 요구  8000 5KB 사용중 5000 14KB 5000 1000 16KB 14KB 공백 11000 30KB 사용중 사용가능공간 리스트 8000 5KB 공백 (공백 크기 오름차순) 사용중 11000 30KB 공백 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
3) 최악 적합 기법 ­ 작업을 가장 큰 사용가능공간에 할당함 ­ 공간이 크기 순서로 정렬되어 있지 않을 시 전 리스트를 검색해야 함 ­ 최상 적합보다 메모리 활용면에서 더 유용함 0 운영체제 시작 주소  길이 1000 16KB 공백 11000 30KB 13KB를 요구  1000 16KB 사용중 5000 14KB 5000 14KB 공백 8000 5KB 사용중 사용가능공간 리스트 8000 (공백 크기 내림차순) 5KB 공백 사용중 11000 30KB 공백 v 시간과 메모리 이용률 감소 측면에서 최초 적합과 최상 적합이 유용함 v 일반적으로 최초 적합이 최상 적합보다 메모리 할당이 더 빠름 ▶ 가변 분할에서의 메모리 보호 ­ 프로세스 보호를 위해 두 개의 경계 레지스터 사용 · 상한값과 하한값을 갖는 기준 레지스터와 한계 레지스터를 사용 ­ 가장 작은 물리적 주소의 하한값이 100040 이고 크기가 74600인 프로세스인 경우 ­ 상한값은  174640(=100040+74600)이며,  사용자  주소  범위는  하한값과  상한값  사 이임 · 기준 레지스터 및 한계 레지스터는 수행시간에 동적 재배치를 허용함 ­ 기준 레지스터가 가장 작은 물리적 주소로 100040이며, 한계 레지스터가 논리 주소  76400을 포함할 경우 ­ 사용자 주소 범위는 ‘0~76400’임 · 논리 주소는 한계 레지스터보다 작아야 하며 기준 레지스터에 추가하여 동적 재배치됨 ­ ‘100040~174639’범위 내에서 동적으로 재배치되며, 재배치된 주소는 메모리로 전송 됨 · 프로세서 스케줄러가 프로세스 선택 시, 디스패처는 정확한 값을 가진 두 경계 레지스터 를 함께 적재함 ­ 프로세서가 생성한 모든 주소는 레지스터와 함께 검사되므로 다른 사용자의 프로그램 과 데이터 보호 가능 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 기준 기준+한계 레지스터 레지스터 주소 예 예 프로세서 메모리 아니오 아니오 트랩 : 주소 지정 오류 기준 및 한계 레지스터를 이용한 메모리 보호 ▶ 외부 단편화 ­ 가변 분할 알고리즘은 외부 단편화 문제가 발생함 · 프로세스들이  메모리에서  제거되고  새로운  프로세스가  적재될  때  사용가능공간은  작게  나뉘어짐 · 프로세스들이 연속된 메모리를 차지하는 과정에서 공백이 발생, 사용가능공간은 많은 수 의 작은 공간으로 단편화될 수 있음 · 분할은 프로세스가 요구한 크기로 만들어지므로 내부 단편화는 거의 없으나 외부 단편화 는 발생할 수 있음 ­ 외부 단편화 예 0 0 0 0 0 운영체제 운영체제 운영체제 운영체제 운영체제 40KB 40KB 40KB 40KB 40KB 작업 5 작업 1 작업 1 작업 1 90KB 100KB 100KB 100KB 100KB 100KB 작업 2 작업 4 작업 1 작업 5 작업 4 작업 4 작업 4 작업 2 종료 할당 종료 할당 170KB 170KB 170KB 200KB 200KB 200KB 200KB 200KB 작업 3 작업 3 작업 3 작업 3 작업 3 230KB 230KB 230KB 230KB 230KB 256KB 256KB 256KB 256KB 256KB (a) (b) (c) (d) (e) 메모리 할당과 스케줄 · ([그림] 메모리 할당과 스케줄)의 (a)에서 26KB의 외부 단편화 발생 ­ 이 공간은 너무 작아 나머지 프로세스 작업 4와 작업 5를 만족시킬 수 없음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · ([그림] 메모리 할당과 스케줄)의 (c)에서 56KB(=30KB+26KB)의 외부단편화 발생 ­ 이 공간은 두 개의 조각으로 나뉘어져 작업 5의 메모리 요구를 만족시킬 수 없음
1) 통합 ­ 하나의 작업이 끝났을 때 기억 장소가 비어 있는 다른 기억 장소(공백)와 인접되어 있는 지를 점검, 하나의 공백으로 합하는 과정 ­ 통합 과정을 수행하더라도 메모리 전반에 흩어져 있는 비어있는 공간을 모두 사용가능공 간으로 통합하기 어려움 운영체제 운영체제 운영체제 다른 사용자 다른 사용자 다른 사용자 2KB 공백 2KB 공백 7KB 공백 5KB 사용자 A  5KB 공백 사용자 A가 끝나고  운영체제가 인접한 그 기억 장소가 공백을 합하여  다른 사용자 다른 사용자 다른 사용자 공백이 된다. 하나의 더 큰  공백으로 만든다. 메모리 통합
2) 압축(Compaction) ­ 메모리 내용들을 적절히 움직여 모든 사용가능메모리를 하나의 큰 블록으로 만듦 ­ 압축 과정 · ([그림] 메모리 할당과 스케줄 (e))의 메모리 맵  중  10KB,  30KB, 26KB의  사용가능 공간을 66KB의 하나의 공간으로 통합 확장 0 0 운영체제 운영체제 40KB 40KB 작업 5 작업 5 90KB 90KB 10KB 100KB 작업 4 압축 작업 4 160KB 170KB 작업 3 30KB 200KB 190KB 작업 3 230KB 66KB 26KB 256KB 256KB ­ 압축은 항상 가능하지 않음 · ([그림] 압축 과정)에서 작업 3과 작업 4를 이동함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 이동한 작업 프로세스들이 새로운 위치에서  수행되기  위해 모든 내부 주소들이 재배 치되어야 함 · 재배치가 정적이면서 어셈블리나 적재할 때 실행될 경우 불가능함 v 압축은 재배치가 동적인 경우만 가능하며 수행시간에 이루어짐 ­ 주소의 동적 재배치 후 프로세스들이 이동함 · 새로운 기준 주소 반영을 위해 기준 레지스터의 변화가 필요함 ­ 메모리 테이블을 관리하고 유지해야 함 · 과부하를 발생, 작은 단위의 조각이 많을 경우 더 심함 ­ 압축 방법에 따라 비용이 많이 듬 ­ ([그림]  압축  과정의  여러  방법)에서  작업  3과  작업  4를  위해  총  600KB를  이동,  또는  작업 3을 작업 4 밑으로 이동해 200KB를 이동시킬 수 있음 ­ (d)에서  사용 가능한 하나의 큰  메모리  공간이  가운데에  있으며, 큐가 450kB를 요구하 는 한 프로세스만을 가진 경우, 작업 2를 다른 위치로 이동시켜 요구 만족시킴 0 0 0 0 운영체제 운영체제 운영체제 운영체제 300KB 300KB 300KB 300KB 작업 1 작업 1 작업 1 작업 1 500KB 500KB 500KB 500KB 작업 2 작업 2 작업 2 작업 2 600KB 600KB 600KB 600KB 작업 3 400KB 800KB 작업 3 1000KB 작업 4 1000KB 900KB 작업 3 작업 4 1200KB 1200KB 1200KB 300KB 1500KB 1500KB 900KB 900KB 작업 4 작업 4 1900KB 1900KB 200KB 작업 3 2100KB 2100KB 2100KB 2100KB 초기할당 600KB 이동 400KB 이동 200KB 이동 (a) (b) (c) (d) 압축 과정의 여러 방법 ⋅ 장점
- 가변 메모리에서 발생하는 수 많은 작은 공간을 하나의 큰 공백으로 변환, 새로운 작 업에 할당 가능 ⋅ 단점
- 압축할 동안 시스템은 모든 일을 멈추어야 함
- 메모리에 있는 작업들을 이동시켜야  하므로  프로그램  적재 시 제거되는 재배치 관련  정보를 액세스 가능한 형태로 보관해야 함
- 압축 작업이 자주 요구되어 시스템 자원 소모가 큼 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 2. 분산 메모리 할당 ▶ 페이징 기법 ­ 처리할 작업을 동일한 크기의 페이지로 나누어 처리함 · 실제  메모리를  프레임(페이지  프레임)이라  불리는  고정  크기  블록으로  나누고,  각  프로 세스도 페이지라 불리는 동일한 크기의 작고 고정된 크기의 영역으로 분할 · 연속 할당과 분산 메모리 할당 시스템 ­ 연속 메모리  할당  시스템은  메모리  관리  장치(MMU)를  이용,  프로세스의  논리  메모 리를 연속된 물리적 공간(메모리)에 저장 ­ 페이징  시스템은  페이지  4개로  나누어져  물리적  공간(메모리)의  임의의  장소에  각각  저장됨 메모리 관리 장치(MMU) 연속 메모리 한계 기준 할당 시스템 레지스터 레지스터 연속공간 논리 메모리 주소 오류 물리 메모리 (a) 연속 할당 시스템 메모리 관리 장치(MMU) 페이징 분산 적재 논리 메모리 물리 메모리 (b) 분산 메모리 할당 시스템 ­ 논리 메모리는 페이지와 같은 크기의 블록으로 나뉘어 짐  ­ 보조기억장치는 프레임과 같은 크기로 나뉘어 짐 ­ 일정한 크기로 나누면 프로세스의 페이지는 보조기억장치에서 이용 가능한 프레임 안 으로 적재, 효율적으로 동작함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 메모리 시스템에서 작업 수행을 위해 다음이 준비되어야 함 · 프로그램에 소요되는 페이지를 결정하여 페이지 번호를 부여 · 프로그램을 적재하도록 메모리의 빈 프레임을 조사하여 위치 파악 · 프로그램의 페이지를 빈 페이지 프레임에 적재하도록 준비함 ­ 장⋅단점 · 빈 페이지 프레임이 어떤 작업, 즉 프로세스의 어떤 페이지에도 사용될 수 있음 ­ 효율적인 메모리 사용, 페이지 프레임 간 외부 단편화가 발생하지 않음 · 한 작업의 페이지가 메모리의 여러 위치에 분산 적재됨 ­ 페이지들의 위치 정보 등 페이지 관리가 복잡해지므로 운영체제의 부담이 커짐 · 프레임 단위로 할당되므로 내부 단편화는 발생됨 ­ 어떤 프로세스의  메모리  요구가  페이지  범위  내에  맞지  않으면, 할당된  마지막  프레 임은 완전히 가득 차지 않을 수 있음 v 단순한 내부 단편화 현상만 생각하면 크기가 작은 페이지가 바람직함 v 페이지  테이블  유지가  부담이  될  수  있으나,  페이지  크기를  증가시킴으로써  감소시킬  수 있음 ▶ 페이징 시스템 하드웨어 ㆍ 하드웨어 구조
- 논리 페이지의 물리 메모리(페이지)프레임 적재과정을 수행하는 페이지 시스템 하드웨어  구조 메모리 관리 장치(MMU) f 논리 주소 물리 주소 f0000...0000 프로세서 p d f d f1111...1111 p f 페이지 테이블 물리 메모리 페이징 시스템 하드웨어
- 프로세서에 의해 생성되는 논리 주소는 페이지 번호(p)와 변위(d) 두 부분으로 나뉨 · 페이지 번호는 페이지 테이블에 대한 색인(p)으로 사용되어 페이지 테이블의 p위치(항 목)에 저장된 f값을 얻음 · f는 실제 메모리의 페이지 기준 주소로 메인 메모리의 프레임 번호가 됨  · 기준 주소(f)에 페이지 변위(d)가 더해져 실제 메모리 주소(물리 주소)가 결정됨 · 변위는 페이지  시작위치로부터 얼마나 떨어져 있는가를 나타내는 상대 주소로 프레임  내 위치를 표시하며 페이지 프레임 크기보다 작음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 페이지 스케줄링 ­ 프로세스 수행을 위해 준비 큐에 도착했을 때, 프로세스의 크기는 페이지 단위로 표현 ­ 장기 스케줄러는 할당되지 않은 빈 페이지 프레임 리스트를 유지, 이용 가능한 상태로 준비 함 ­ 프로세스가 페이지 n개를 요구할 경우, · 메모리에서 이용할 수 있는 n개의 빈 프레임이 있어야 함 · 프레임 n개를 사용 가능할 경우 장기 스케줄러가 프레임을 프로세스에 할당함 ­ 최초 페이지는 할당된 프레임 중 하나에 적재, 프레임 번호는 페이지 테이블 속에 기록됨 · 다음 페이지는 다른 프레임에 적재되고 프레임 번호는 페이지 테이블에 기록됨 ㆍ 사용가능 프레임 리스트에 있는 프레임에 새로운 작업 할당 과정 사용가능 프레임 리스트 사용가능 프레임 리스트 14 15 13 18 20 페이지 0 13 13 페이지 1 15 페이지 1 14 페이지 2 14 페이지 0 페이지 3 페이지 0 15 15 페이지 1 새로운 프로세스 16 16 페이지 2 페이지 3 17 17 0 14 새로운 프로세스 18 1 13 18 페이지 2 19 2 18 19 3 20 20 20 페이지 3 새로운 프로세스 21 21 페이지 테이블 (a) 사용가능 프레임의 할당 전 (b) 사용가능 프레임의 할당 후 사용가능 프레임의 할당 전과 후 ▶ 페이지 테이블의 구현 ­ 전용 레지스터를 사용하여 구현 · 페이징 주소변환을 매우 효율적으로 하기 위해 초고속 논리회로로 설계됨 · 효율성이 주요 고려 대상임 ­ 메모리의 모든 액세스는 페이징 테이블 정보에 의해 수행됨 · 페이지 테이블 항목이 적을 수록 관리(하드웨어 비용 감소)가 쉬움 ㆍ 페이지 테이블 기준 레지스터(PTBR, Page Table Base Register)
- 기존 컴퓨터는 페이지 테이블이 매우 크므로, 레지스터로 구현이 적합하지 않음
- 페이지  테이블을  메모리에  유지,  페이지  테이블  기준  레지스터가  페이지  테이블을  지시 함
- 하나의 레지스터 값 변화로 페이지 테이블이 변경, 실제적인 문맥교환 시간 감소됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 메모리와 액세스 시간 문제 · 페이지 테이블 항목과 워드를 위한 메모리 액세스가 필요하며, 이로 인해 속도가 느려 짐 · 연관  레지스터  또는  변환  우선참조  버퍼(TLBS,  Translation  Look
-aside  Buffers)를  이용
- 사상 방법에 따른 주소 변환 · 직접 사상(Direct Mapping)에 의한 페이지 주소변환 · 연관 사상(Associative Mapping)에 의한 페이지 주소변환  · 연관/직접 사상을 결합한 페이지 주소변환 ▶ 페이징에 대한 견해 ­ 사용자의 메모리에 대한 관점과 메모리 분리가 중요함 · 메모리의  사용자  관점과  실제  메모리  사이의  차이점은  주소변환  하드웨어에  의해  논리  주소를 실제 주소로 변환 조정됨 ⋅ 장점 ­ 공유 페이지의 이용, 외부 단편화 제거(내부 단편화는 발생함), 메모리 활용을 통한 다중  처리 프로그래밍 실현, 압축 기능 제거 등 ⋅ 단점 ­ 페이징  사상을  위한  하드웨어  준비로  인한  가격  상승과  속도  저하  그리고  내부  단편화  현상 등 3. 세그먼트 메모리 관리 기법 ▶ 세그먼트 메모리 관리 기법 ­ 메모리의 사용자 관점 지원 · 메모리는 크기를 변경 가능한 세그먼트 단위 모음 · 고정 크기를 갖는 페이징과는 다름 · 메모리를  일반적으로  프로그램을  구성하는  서브루틴(Sub
-Routine),  프로시저 (Procedure),  함수(ex)unction)  또는  모듈(Module)  등의  각각  다른  크기를  갖는  세그먼 트로 나눔 · 각 세그먼트는 연관된 기능을 수행하는 하나의 모듈 프로그램 · 각 세그먼트는 연속된 위치에 구성되나, 메모리에서 서로 인접할 필요는 없음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 스택 서브 루틴 심볼 테이블 함수 메인  Sqrt 프로그램 논리 주소 공간 프로그램의 사용자 관점 ▶ 세그먼트 메모리 할당 ­ 논리 구조 공간을 세그먼트의 모임으로 인식 · 세그먼트는  일반적으로  컴파일러(어셈블러)가  자동적으로  입력  프로그램(원시  프로그램) 을 이용하여 작성함 · 하드웨어 보호 등 관리에 필요한 세부 사항은 페이징과 비슷하거나 동일함 · 동적 분할(가변 분할) 기법으로 메모리를 할당 ­ 프로세스에 따라 세그먼트 크기가 다르므로 메모리가 일정한 크기의 페이지 프레임으 로 나누지 않음 메모리 관리 장치(MMU) 페이징 분산 적재 논리 메모리 물리 메모리 페이징과 세그먼트 메모리 할당 비교 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 세그먼트  메모리 관리 메모리 관리 장치(MMU) 각각의 크기에 따른 분산 적재 논리 메모리 물리 메모리 페이징과 세그먼트 메모리 할당 비교 ▶ 단편화 ­ 모든 세그먼트에 대한 적당한 기억 장소를 찾아 할당 · 페이징 시스템의 일정한 크기(페이지)에 비해 세그먼트 기법은 크기가 변함 · 최상 적합 알고리즘이나 최초 적합 알고리즘을 사용하여 해결되는 동적 메모리 할당 방 법 이용 · 외부 단편화 발생 가능 ­ 사용가능메모리의 모든 블록들이 너무 작아 세그먼트를 수용할 수 없는 경우 ­ 단순히 기다리거나 압축하여 더 큰 공간 생성 ­ 동적 재배치 알고리즘이므로 원할 때마다 메모리를 압축 가능 v 외부  단편화  문제는  평균  세그먼트  크기에  의존하므로,  평균  세그먼트  크기가  작으면  외부 단편화 또한 작음 ▶ 페이지화된 세그먼트 메모리 할당 ㆍ 페이징과 세그먼트의 장단점
① 페이징
- 내부 단편화 현상을 가짐
- 메모리를 효율적으로 사용 가능하며, 동일한 크기의 작업을 가지므로 많은 알고리즘  개발 가능
② 세그먼트
- 외부 단편화 현상을 가짐
- 가변적인 데이터 구조와 모듈 처리, 공유와 보호의 지원이 편리함 ㆍ 페이지화된 세그먼트 메모리 할당
- 페이징과 세그먼테이션의 결합된 구조
- 외부 단편화 문제를 제거하면서 할당 과정을 쉽게 해결함
- 멀틱스(Multics) 시스템에서 사용, 인텔 386 계열에서도 사용되고 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 멀틱스 시스템의 세그먼트 논리 주소 · 18bit의 세그먼트 번호와 16bit의 변위로 구성, 변위는 6bit의 페이지 번호와 10bit의  페이지 변위로 구성됨 · 프레임 번호는 페이지 변위와 결합, 메모리 주소를 산출 세그먼트 변위 세그먼트 번호 페이지 번호 페이지 변위 18 6 10
- 각  프로세스는  하나의  세그먼트  테이블을  가지며,  각  세그먼트는  자신의  페이지  테이블 을 가짐
- 특정  프로세스가  실행  중일  때,  하나의  레지스터가  프로세스에  대한  세그먼트  테이블의  시작 주소를 가짐
- 각 세그먼트의 마지막 페이지는 완전히 차지 않으므로 내부 단편화가 발생 가능
- 외부 단편화는 제거되나, 내부 단편화는 계속 발생되며, 테이블 공간에 대한 부담 증가
- 복잡하며 각 사용자의 메모리를 3번 참조함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 전문가 시스템 개발팀 가상 메모리(1)

1. 가상메모리 특징을 이해 할 수 있다. 수업목표  
2. 요구 페이징 기법에 대해 이해 할 수 있다. 1. 가상 메모리 10주차     
- 가상 메모리의 등장 배경 1교시     
- 블록 사상 세부내용  2. 요구 페이징    
- 요구 페이징 기법    
- 페이지 성능    
- 페이지 대치 1. 가상 메모리 ▶ 가상 메모리의 등장 배경 ㆍ 가상 메모리(Virtual Memory)
- 1960년 영국 맨체스터 대학교에서 제작된 아틀라스 컴퓨터 시스템에서 처음 등장
- 메인 메모리보다 용량이 큰 기억 공간에 주소지정이 가능한 메모리 관리 기법
- 메인 메모리에서 사용자와 논리 메모리를 물리적으로 분리, 프로그래머에게 가상에 메모 리를 제공함 ⋅ 메모리 계층 구조 ­ 페이징 시스템으로 가상 메모리 시스템을 구현 ­ 메인 메모리를 보다 효율적으로 사용할 수 있어 더 많은 작업을 메모리에 적재 가능 ­ 사용자(프로그래머)에게  메인  메모리의  제한된  용량  사용과  중첩  사용  문제를  해결해  줌 메인 메모리 가상 메모리 캐시 레지스터 워드 로드/저장  라인 명령에 의한  캐시 실패에 메모리 엄격한 이동 따른 자동 이동 페이지 부재에 따른 자동 이동 ­ 동시에 실행되지 않는 프로그램의 특징을 이용 · 실제로 프로세스를 실행하는 데 꼭 필요한 부분만 메인 메모리에 저장, 나머지는 2차 기 어장치(디스크)에 저장함 · 가상 메모리 공간에 있는 프로세스 항목이 2차 기억장치에 분산 적재된 후 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 0 1 2차 기억장치 2 2 3 4 0 2 6 0 5 5 6 1 논리 주소 공간 3 3 4 메인 메모리 실행 중인 프로세스 항목이 2차 기억장치에서 메인 메모리로 이동 ­ 가상 메모리 관리 기법의 운영 가능한 이유 · 실제적으로 모든 프로그램이 항상 동시에 사용되지 않음 · 아래의 현상을 적절히 활용 ­ 예외적인  오류  조건을  처리하는  오류  코드  루틴의  경우,  자주  필요하지  않으며  발생 하지 않을 수 있음 ­ 행렬(배열), 리스트, 테이블 등의 크기는 실제로 사용된 크기보다 정의된 크기가 항상  클 수 있음 ­ 문서  편집기(Text  Editor)에서  자주  사용되지  않는  메뉴인  복사,  붙이기,  잘라내기,  삽입 등은 실제로 선택한 한 개의 메뉴만 적재, 나머지는 메모리에서 내보내도 됨 ­ 장단점 ⋅ 장점 ­ 프로그래밍 작업이 쉬우며, 공간의 제약이 없으므로 중첩을 작성할 필요가 없음 ­ 공간이 부족해도 부분 적재가 가능하여 많은 작업을 실행할 수 있어 프로세서의 이용 률과 처리율 향상 ⋅ 단점 ­ 메모리와 디스크 공간 사이의 이동량 증가에 따른 교체 공간의 확보  ­ 어느 시기에 어느 페이지를 적재하고 다시 복귀시킬 것인가에 대한 페이징 알고리즘의  결정 ­ 페이지 부재에 대한 처리 방안 요구 ­ 실행 중인 프로세스의 참조 주소와 메인 메모리에서 사용하는 주소가 분리되어야 함 · 사상(Mapping) : 가상 주소를 실제 물리적 주소로 변환하는 과정  ­ 변환 함수로 표시하며 속도가 느리면 시스템 성능이 떨어짐 · 프로그램 주소 공간(가상 주소)을 V, 메인 메모리 공간(실제주소)을 R이라 할 경우 사상 (ex))에 의해 가상 메모리는 아래와 같이 정의됨 ex):V → R‖가상주소(V)와 실제 주소(R)의 분리 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 가상 주소 V가 메인 메모리 R에 적재되어 있는 경우 R = ex)(V) ex) : V → R V 변환함수 R 프로그램 속의 주소 공간 메인 메모리 공간 (가상 주소) (실제 주소) 가상 기억 공간과 실제 주소 공간의 사상 ­ 동적 주소 변환(DAT, Dynamic Address Translation) 기법 · 인위적 연속성 성질을 가지므로 프로세스의 가상 주소 공간에 있는 연속적인 주소를 물 리 주소공간에 연속적으로 저장할 필요 없음 ­ 인위적  연속성  : 가상  주소  공간상의  연속적인  주소가  메인  메모리에서  연속적일  필 요 없음 · 사용자는 프로그램과 데이터의 적재 위치를 고려할 필요 없음   ­ 중첩 관련 작업 수행이 필요 없으며, 하드웨어 구조와 상관없이 알고리즘의 효율성과  프로그램 구조를 고려함 주소 사상 기법 연속적  가상 기억 장소 메인 메모리 가상기억장치 ­ 메인 메모리 공유를 위해 메모리 관리 기법 활용 · 여러  사용자가  메인  메모리  공유를  위해  메인  메모리보다  큰  보조기억장치에  데이터나  프로그램을 저장, 유지할 수 있는 방법 필요 · 2단계 메모리 관리 기법 ­ 단계  1  :  프로세스가  수행되고  참조  데이터를  저장하는  1차  기억  장소인  메인  메모 리 ­ 단계 2 : 제한된 메인 메모리에 들어갈 수 없는 데이터를 저장하는 디스크와 같은 대 용량의 2차 기억 장치 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 2차 기억장치 (예비 기억장치) 디스크 물리적 프로세서 기억장치 기타 유형의 1차 기억장치 보조 저장소 메인 메모리 ▶ 블록 사상 ­ 블록 단위로 처리 · 사상이 Byte, Word 단위로 이루어질 경우 주소 사상 테이블(Address Mapping Table)  유지를 위한 정보량이 커짐 · 사상 정보의 양(테이블)을 줄이기 위해 주소를 블록 단위로 처리  ­ 블록은  가상  메모리의  분할  단위로,  블록의  크기가  일정하면  블록을  페이지라  하며  블록화 방법을 페이징 기법이라 함 ­ 블록의 크기가 다를 경우 세그먼트라 하며 세그먼테이션 기법이라 함 · 가상 메모리와 보조기억장치(디스크)와의 사상 ­ 시스템이 블록의 위치만을 유지하고 추적하므로 효율적인 관리 가능  ­ 블록의 평균 크기가 클수록 주소사상의 정보의 양(테이블 크기)은 적어지나, 내부 단 편화로 인한 2차 기억장치와 메인 메모리 주소사상 시간이 더 요구될 수 있음 블록 0 블록 1 블록 2 주소사상테이블 블록 n 보조기억장치 가상 메모리 물리적 메모리 실제 메모리를 확장한 가상 메모리 ­ 블록 가상 시스템은 2차원적 주소체계를 가짐 블록 번호 변위 b d b : 블록 번호 가상주소 V=(b, d) d : 블록 시작점으로부터의 변위 블록사상 시스템에서의 가상 주소체계 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 프로세스 실행 동안 가상 주소 V=(b, d)로부터 메모리 주소 r로 변환되는 과정 ­ 시스템은 메모리에 각 프로세스의 블록 사상 테이블을 유지함 ­ 시작점 레지스터(Block Table Origin Register)에는 메모리 주소 a가 들어 있음 ­ 블록  사상  테이블의  항목은  블록번호(b)와  프로세스의  블록사상테이블의  기준  주소 (a)를 더하여 메모리의 주소 b’을 얻음 ­ 변위 값을 더하여 실제 메모리 주소는 r= b’ + d로 계산되며, b’는 실제 메모리 주소  a + b의 위치에 있는 블록사상테이블의 셀에 저장됨 블록사상 테이블의 시작 주소 블록 a 사상 테이블의 블록 번호 변위 시작점 b b d 가상 주소 V=(b,d) 레지스터 블록사상테이블 a d a+b b 블록 길이 b’ 메모리 주소 1 b’ R=(b+d) 블록 존재 비트 메모리 주소 논리합(OR)에 의해 이루어질수도 있음 블록 사상을 통한 가상 주소 변환 ▶ 가상 주소와 테이블 항목 ­ 가상 주소는 순서를 가지는 쌍 V=(p, d) 표시, 페이지 번호와 페이지 변위로 구성 · 16bit의 가상 주소가 1KB(=1024byte) 크기의 페이지를 사용할 경우  ­ 가상  주소  1502(0000  0101  1101  1110)의  경우  최하위  bit  10개는  페이지  변위 (0111011110), 최상위 bit 6개(000001)는 페이지 번호(프레임)를 나타냄 · 32bit의 논리 주소와 4KB(=212) 크기의 페이지를 사용할 경우 ­ 페이지  변위는  12bit(4KB=212),  페이지  프레임  번호는  20bit를  사용,  220  (1,048,576)개의 페이지 테이블 항목(프레임)으로 구성됨 ­ 페이지 테이블은 항목 당 4byte(32bit) 크기를 유지함 · 페이지는  블록  단위로 디스크에서  메인  메모리로 옮겨져  메인  메모리의  한  블록(페이지  프레임)에 자리 잡음 · 메인 메모리는 가상 페이지와 같은 크기의 페이지 프레임들로 분할 · 페이지는 사용 가능한 어떤 페이지 프레임에도 들어갈 수 있음 ­ 페이지 테이블 항목 구성 · 제어비트와 프레임 번호로 구성됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 가상주소 V=(p, d) 0 19 20 31 페이지 번호 변위 물리 페이지 테이블 항목(PTE) : 페이지 변위(12비트)+프레임 번호(20비트) 주소 0 1 2 3 4 5 6 7 8 9 11 12 31 P P 프로그래머 프레임 번호 P R/W U/S A D PAT G W C 사용가능 (페이지 기준 주소) T D 비트 페이징 시스템에서의 가상 주소와 페이지 테이블 항목 · 페이지 테이블 항목(PTE, Page Table Entry)의 제어비트  ­ P 플래그 : 참조 페이지의 메인 메모리 저장 여부 ­ R/W 플래그 : 쓰기/읽기 액세스 권한 포함 ­ U/S 플래그 : 사용자/슈퍼사용자에 대한 페이지(페이지 테이블) 액세스 권한 포함 ­ PWT, PCD 플래그 : 하드웨어 캐시에 의한 페이지(페이지 테이블) 처리  ­ A 플래그 : 페이지 프레임에 따른 페이징 단위 주소 적용 ­ D(M) 플래그 : 페이지 수정 여부 ­ PAT 플래그 :페이지 테이블 속성 색인 ­ G 프래그 : 페이지 테이블 항목 적용 ­ 나머지 bit는 시스템 프로그래머 사용 가능 ­ 가상(논리) 주소에서 물리 주소로 변환 과정 · 가상 주소의 페이지 번호(0x2)를 페이지 테이블에서 색인, 프레임 번호 (0x8)을 얻음 ­ 현재 참조하고 있는 페이지가 메인 메모리에 있는 경우 프로세스 수행 불가능 · 프레임 번호(0x8)와 페이지 변위에 접속, 메인 메모리의 주소(물리 주소)를 구함 · 페이지  프레임  번호가  {1,  2,  …  ■}이라  가정하면,  실제  메모리  주소  r(=프레임  번호ⅹ 페이지 크기 + d)로 나타냄 ­ 실제 물리 메모리 주소는 페이지 프레임 번호와 페이지 크기를 곱한 결과 가상 주소 페이지 번호 변위 0 x 2 0 x 14 페이지 테이블 페이지 테이블 0 x 0 x L 기준 레지스터(PTBR) 0 x 1 x L 0 x 2 x L 0 x 8 L : 항목 크기 0 x 8 0 x 14 프레임 번호 변위 페이지마다 한 항목 물리 주소 프로세서마다 한 테이블 페이징 시스템에서의 가상 주소 변환 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 2. 요구 페이징 ▶ 요구 페이징 기법 ­ 스왑 기법을 사용하는 페이징 시스템과 비슷함 · 프로그램을 실행하기 위해 프로그램의 일부만을 메인 메모리에 적재 · 순차적으로 작성되어 있는 프로그램의 일부(모듈)을 처리할 때 다른 부분은 실행되지 않 는다는 사실을 이용함 · 오류 처리 루틴의 실행 과정, 과도한 공간 확보, 모듈의 일부 처리 시 발생   ­ 오류  처리  루틴의  실행  과정  :  일부  오류  발생  시  해당  오류  처리  루틴만이  필요하 고, 나머지 루틴은 디스크에 저장 ­ 과도한 공간 확보 : 배열 선언 · 프로세스는  디스크에  저장되었다가  수행될  때,  직접  적재하지  않고  지연  교환기(Lazy  Swapper)를 사용해 메인 메모리에 적재함 ­ 페이지  요구가  있을  때  요구  페이지를 메모리에  교체,  동시에  모든 페이지를  교체하 지 않음 ­ 사용되지 않는 페이지를 메모리에 읽어 들이는 것을 예방, 교체시간, 기억 공간 감소  및 다중 프로그래밍 정도를 증가시킴 교체되어 나감 0 1 2 3 프로그램 A 4 5 6 7 8 9 10 11 12 13 14 15 프로그램 B 교체되어 들어감 16 17 18 19 20 21 22 23 메인 메모리 보조기억장치 연속된 디스크 공간에 교체시킨 페이지화된 메모리 ▶ 요구 페이징의 기본 개념 ­ 타당
-비타당을 나타내는 bit를 페이지 테이블의 각 항목에 추가함 · 타당/비타당 비트가 추가된 페이지 테이블 ­ 타당 비트(v)로 설정된 경우 해당 페이지가 물리적 메모리에 있음을 의미함 ­ 비타당 비트(i)로 설정된 경우 페이지는 보조기억장치(디스크)에 있음을 의미함 ­ 저장되지 않은 페이지 사용 시 페이지 부재(Page ex)ault) 발생하며, 이때 액세스 방지 를 위해 타당/비타당 비트를 이용하여 처리함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 0 타당
-비타당 비트 1 0 A 프레임 2 3 1 B 0 4 v 4 A B 2 C 1 i 5 3 D 2 6 v 6 C D E 7 4 E 3 i 8 G H 5 ex) 4 i 9 ex) 10 6 G 5 9 v 11 7 H 6 i 12 보조기억장치 7 i 13 논리적 메모리 14 페이지 테이블 15 물리적 메모리 타당/비타당 비트가 추가된 페이지 테이블 ­ 비타당 비트 · 프로그램이 비타당 비트로 표시된 페이지에 액세스 하지 않는 경우 실행에 영향을 주지  않음 · 프로그램이 액세스하는 경우 페이지 부재로 운영체제에 트랩 발생  ­ 무효 주소에 의한 오류 ­ 페이지 부재 · 페이징 시스템의 페이지 부재 ­ 프로세서에 의해 생성되니 가상(논리) 주소 V=(p, d)에서 페이지 번호(p)는 주소번역 (페이지 테이블 레지스터)과정을 통해 페이지 테이블에서 해당 페이지 테이블 항목에  접속 ­ 메모리에 지정된 프레임의 저장 여부 확인 ­ 지정된  프레임  페이지가  저장되어  있지  않는  경우  프레임 번호와  변위  결합,  물리주 소 생성 ­ 페이지 부재로 해당 페이지(프레임)가 디스크에 저장되어 있음을 의미하므로 명령 재 시작 논리 주소 페이지 테이블 항목 물리 주소 프로세서 p d 주소번역 v/i f f d 메모리 예 메모리 페이지 타당 여부  (v/i=1?) v/i = 0 : 페이지가 디스크에 아니요 (f
- 페이지 파일 변위) 페이지 부재로 명령 다시 시작 v/i = 1 : 페이지가 디스크에 페이지 부재 (f
- 프레임 번호) 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 페이지 부재 처리 과정
① 프로세스 제어 블록에 있는 내부 테이블 검사, 프로세스 참조가 메모리 액세스에 타 당한지 부당한지 결정함
② 프로세스  참조가  무효화될 경우 프로세스는  중단  프로세스가 유효한  참조이나  페이 지를 가져오지 않은 경우 페이지를 가져옴
③ 비어있는 프레임 리스트 중 하나를 선택
④ 할당된 프레임에 요구된 페이지를 읽어 들이기 위해 디스크 동작을 스케줄함
⑤ 요구된 페이지가 메모리에 있다는 것을 알리기 위해 페이지 테이블을 수정
⑥ 주요 트랩에 의해 인터럽트된 명령어들을 다시 시작 ❸ 페이지가 예비기억 보조기억장치 장치에 있음 운영체제 ❷ 트랩 ❶ 참조 load M i ❻ 명령어  재시작 페이지 테이블 free frame ❺ 페이지 테이블 ❹ 부재 중인 페이지를 재설정 가져옴 물리적 메모리 ­ 순수 요구 페이징 · 요구가 계속될 때까지 페이지를 메모리에 들여놓지 않는 방법 ­ 메모리에 실행할 프로세스의 페이지가 없어도 프로세스는 수행을 시작할 수 있음 ­ 프로세스는 최소의 명령으로 페이지 부재를 일으킴 ­ 페이지가 메모리로 들어온 후, 프로세스는 수행을 계속하면서 수행에 필요한 모든 페 이지가 메모리에 적재될 때까지 필요할 때마다 페이지 부재를 발생시킴 ­ 수행에 필요한 모든  페이지가 메모리에 적재되면 프로세스는  더 이상 페이지 부재를  발생시키지 않고 수행을 계속함 ­ 장단점 ⋅ 장점 ­ 다중 프로그래밍의 정도를 증가시키고 액세스되지 않은 페이지를 로드 하지 않아 메모 리가 절약됨 ­ 프로그램을 시작할 때 적재(로딩) 지연이 적음 ­ 적은 수의 페이지를 읽으므로 초기 디스크 오버헤드가 적음 ­ 보호  오류를  페이지  오류로  사용  가능하므로  페이징에  필요한  별도의  하드웨어  지원  불필요함 ­ 적재된 페이지들 중 하나가 수정될 때까지 페이지들은 여러 프로그램에 의해 공유되므 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 로 공유 페이지(코드 공유) 기술은 보다 많은 자원 절약 가능 ­ 프로그램을  실행할 충분한  메모리가  없는  시스템에서도  대용량  프로그램을  실행  가능 하며, 프로그래머는 이전 중첩(오버레이) 기법보다 쉽게 구현 가능함 ⋅ 단점 ­ 개별 프로그램들은 페이지에 처음 액세스할 때 약간의 지연이 발생함  ­ 프리  페이징은  마지막으로  수행한  몇  개의  페이지를  미리  불러오는  방법으로  성능을  향상시킴 ­ 낮은  비용,  낮은  성능의  시스템에  실행되는  프로그램은  페이지  대체를  지원하는  메모 리 관리 장치가 없음 ­ 메모리 관리(페이지 교체)가 복잡함 ▶ 페이지 성능 ­ 요구 페이지된 메모리의 유효액세스시간 · 메모리 액세스시간(Ma)은 대부분 10~ 200ns(Nano Second) · 페이지 부재가 발생하지 않는 경우 유효액세스시간은 메모리액세스시간과 동일함 · 페이지 부재 발생 시 보조기억장치에서 관련 페이지를 읽은 후 요구된 단어에 액세스하 여 더 많은 시간이 소요됨 · 페이지 부재의 확률이 p라고 가정함(0 ≤ p ≤ 1) ­ p는 0에 매우 가까운, 약간의 페이지 부재율이 있다고 가정함 유효 액세스 시간 = (1
-p) x Ma + p ⅹ(페이지부재시간) ­ 페이지 부재 시간 계산 · 유효액세스시간 계산을 위해 페이지 부재시간을 계산하여야 함 · 페이지  부재  시에  처리하는  인터럽트  처리시간과  페이지  교체시간,  프로세스  재시작  과 정이 필요함 ­ 인터럽트  처리  및  프로세스  재시작  과정은  수백  개의  명령어로  구성,  짧은  시간(약  1~1000microsecond 범위)에 처리 가능 ­ 페이지  교체시간은  디스크의  헤드  이동에  따른  탐색시간  (5millisecond
-ms)과  지연 시간(3ms), 전송시간(005ms) 등으로 대략 8ms로 예상됨 ­ 소프트웨어와 하드웨어 시간을 포함한 총 페이지부재시간 처리는 약 8ms임 · 평균 페이지부재 처리시간이 8ms이며, 메모리 액세스시간이 200ns일 경우 유효액세스 시간 = (1
-p) x 200 + p x(8 mili sec ond) = (1
-p) x 200 + px 8,000,000 = 200 + p(8,000,000 ­ 200) = 200 + px 7,999,800 ­ 유효액세스 시간 감속 · 유효액세스시간은 페이지 부재율에 비례함 · 1,000개  중  한  개의  액세스에  페이지  부재  발생  시  유효액세스시간은  82(81998ns)  microsecond 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 요구 페이징으로 인해 유효액세스시간은 40배(메모리 액세스시간은 200ns) 감속됨 · 유효액세스시간을 10% 미만으로 감속, 메모리 액세스시간을 220ns보다 적게 유지하기  위한 조건 220 ＞ 200 + 7,999,800 x p 20 ＞ 7,999,800 x p p＜ 0.0000025 (0.0000025      6250) · 페이징으로 인한 감속을 적당한 수준에서 유지하기 위해  399,990(=1/000000250006250)번 중 한 번의 메모리 액세스가 페이지 부재 발생율  보다 더 낮은 비율로 발생해야 함 v 페이지 부재율이 높을 경우 유효액세스시간이 증가하며, 프로세스 수행시간이 늦어짐 v 대부분의 페이지가 처음  참조될 때 부재가 발생하고 이후에는 메모리에 저장되어 있어  페이지 부재율이 발생하지 않을 수 있음 ▶ 페이지 대치 ­ 페이지 대치의 필요성 · 페이지 대치의 필요성 ­ 프로그램  카운터(PC)에  의해  사용자  1의  페이지  M을  적재하면  물리적  메모리에  비 어있는 프레임이 없음을 발견 ­ 사용자 2의 페이지 B는 물리적 메모리에 적재할 수 없음 타당 ­비타당 비튿 0 H 프레임 0 모니터 3 v 1 load M 1 pc 4 v B 2 J 2 D 5 v 3 M i 3 H 사용자 1의 사용자 1의  4 load M M 논리적 메모리 페이지 테이블 5 J 타당 ­비타당 비튿 6 A 보조기억장치 0 A 프레임 7 E 6 v 1 B 물리적 메모리 i 2 D 2 v 3 E 7 v 사용자 2의 사용자 2의 논리적 메모리 페이지 테이블 ­ 페이지 대치 기법 · 페이지 방식을 취하는 가상 메모리에서 페이지 부재 발생 시 메인 메모리에 있으면서 사 용되지 않는 페이지를 없애고 새로운 페이지로 변경 · 아래와 같은 방식으로 액세스 됨
① 비어 있는 프레임이 없다면 현재 사용하지 않는 프레임(희생자)을 찾음 사용하지 않 는 프레임이 있는 경우 발견한 프레임을 비우기 위해 프레임의 내용을 보조기억장치(디 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 스크)에 저장
② 페이지가 메모리에 더 이상 존재하지 않는다는 것을 알려주기 위해 페이지 테이블을  변화(비타당 비트로 전환)시킴으로써 프레임이 비게 됨
③ 원하는 페이지(f)를 디스크로부터 읽어 프레임에 저장
④ 새로운 페이지(f)를 위하여 페이지 테이블을 수정함 타당 ­비타당 비트 ❶ 희생자  프레임 페이지를 내 보냄 ❷ 비타당 변경 f 희생 프레임 0 i ❸ 원하는 f v ❹ 새로운  페이지를 페이지를 위한  읽어 들임 보조기억장치 페이지 테이블  페이지 테이블 재설정 · 프로그램에 의해 빈 프레임은 부재된 페이지 수용을 위해 사용됨 · 페이지 부재 서비스 루틴은 페이지 대치를 포함하도록 수정됨 · 페이지 대치 과정
① 디스크에서 요구한 페이지의 위치 확인
② 빈 프레임을 찾음 ­ 빈 프레임이 발견되면 빈 프레임을 사용 ­ 빈 프레임이 발견되지 않으면 희생 프레임 선정을 위해 페이지 대치 알고리즘 사용 ­ 희생 페이지는 디스크에 기록, 페이지와 프레임 테이블을 수정함
③ 요구된 페이지를 읽어 들이고 페이지와 프레임 테이블을 수정
④ 사용자 프로세스를 시작함 · 페이지 부재로 인한 페이지 대치 과정은 페이지 부재 처리 시간이 증가하는 결과를 가져 와 액세스 시간이 증가하므로 시스템에 부담이 됨 ­ 페이지 두 개가 이동(하나는 나오고 하나는 들어감) ­ 수정된 비트를 활용하여 부담을 감소시킬 수 있음 · 페이지 대치는 요구 페이징의 기본 요소로 논리적 공간과 실제 메모리 공간을 완벽히 분 리해주므로 프로그래머는 실제 메모리에서 매우 큰 가상 메모리(디스크)를 제공할 수 있 음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 가상 메모리(2)

1. 페이지 대치 알고리즘에 대해 알 수 있다. 수업목표  
2. 가상 메모리 중요한 개념을 이해 할 수 있다. 10주차  1. 페이지 대치 알고리즘    
- 선입선출(ex)Iex)O, ex)irst
-In
-ex)irst
-Out) 대치 알고리즘 2교시     
- 최근 최소사용(LRU, Least Recently Used) 알고리 세부내용  2. 프로세스 적재 정책    
- 스레싱    
- 작업설정 모델 1. 페이지 대치 알고리즘 ▶ 페이지 부재와 프레임 개수 ­ 참조 문자열을 이용한 페이지 부재 횟수와 프레임 개수와의 관계 · 참조문자열은 메모리를 참조하는 페이지를 의미함 참조 문자열 : 1, 4, 1, 6, 1, 6, 1, 6, 1, 6, 1 · 프레임 수가 증가하면 페이지 부재수가 감소함 ­ 위의 참조 문자열에 대해 세 개 또는 그 이상의 프레임을 가진 경우, 총 3번의 페이 지 부재 발생 ­ 한  프레임만  이용할  수  있는  경우  각  참조마다  페이지  대치가  필요하며  결과적으로  11번의 부재 발생 · 페이지 부재와 프레임 개수 그래프 ­ 프레임 수가 증가함에 따라 페이지 부재의 수가 최소한도의 수준으로 내려감 페이지 16 부재 횟수 14 12 10 8 6 4 2 0 1 2 3 4 5 6 프레임 수 v 페이지  대치  알고리즘을  확인하기  위해  아래  참조  문자열을  프레임이  3개인  메모리에  사용함 참조 문자열 : 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 ▶ 선입선출(ex)Iex)O, ex)irst
-In
-ex)irst
-Out) 대치 알고리즘 ­ 각 페이지가 메모리 안으로 들어간 시간을 이용 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 가장 오래된 페이지부터 우선 대치시킴 · 페이지 부재 발생  시, 즉 제거해야 할  페이지 선택 후 보조기억장치로 이동 교체시키고  페이지 테이블의 타당/비타당 비트를 변경함 · 새로운 페이지에 대한 페이지 테이블 항목 변경 후 ex)Iex)O 큐의 마지막 위치에 삽입 ❻ ex)Iex)O 큐에 삽입되는 ex)Iex)O 큐 (헤드) 프레임 ❶ 제거 페이지 선택 ❷ 제거 페이지 스왑 아웃 ❸ 제거 페이지에 대한  f i 비트당 항목 변경 희생 프레임 ❹ 제거 페이지 ❺ 새로운 페이지에 대한  g v 스왑 인 항목(타당) 변경 보조기억장치 페이지 테이블 물리 메모리 선입선출(ex)Iex)O) 대치 알고리즘 ­ 선입선출 큐(ex)Iex)O Queue)에 의해 메모리의 모든 페이지가 관리됨 · 큐의 헤드부분에 있는 페이지를 먼저 대치함 · 큐에 있는 페이지가 메모리로 들어갈 때 큐의 끝 페이지가 삽입 · 큐의 크기는 사용 가능한 메모리 프레임의 수에 해당됨 · 선입선출(ex)Iex)O) 대치 알고리즘의 실행 ­ 세 개의 프레임을 사용할 수 있다 가정하고 앞의 참조 문자열을 실행, 페이지 부재는  15번 발생함 참조 문자열 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 7 7 7 2 2 2 4 4 4 0 0 0 7 7 7 0 0 0 3 3 3 2 2 2 1 1 1 0 0 1 1 1 0 0 0 3 3 3 2 2 2 1 v 알고리즘의 이해가 쉽고 프로그램의 작성이 쉬움 ­ 문제점 · 벨레디의 변이(Belady’s Anomaly) 발생 ­ 할당되는 프레임의 수가 증가해도 페이지 부재율이 증가하는 현상 ­ 이로 인해 최적 페이지 대치 알고리즘을 추구하는 경향 발생 · 아래의 참조 문자열을 적용하여 문제점 확인 참조 문자열 : 0, 1, 2, 3, 0, 1, 4, 0, 1, 2, 3, 4 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 모든 페이지 프레임은 초기에 비어 있음 0 1 2 3 0 1 4 0 1 2 3 4 0 1 2 3 0 1 4 4 4 2 3 3 3페이지 0 1 2 3 0 1 1 1 4 2 2 프레임 0 1 2 3 0 0 0 1 4 4 P P P P P P P P P 페이지 부재 표지(9회) 0 1 2 3 0 1 4 0 1 2 3 4 0 1 2 3 3 3 4 0 1 2 3 4 4페이지 0 1 2 2 2 3 4 0 1 2 3 0 1 1 1 2 3 4 0 1 2 프레임 0 0 0 1 2 3 4 0 1 P P P P P P P P P P 페이지 부재 표지(10회) 프레임별 실행결과 16 페이지 14 부재 횟수 12 10 8 6 4 2 0 1 2 3 4 5 6 7 프레임 수 벨레디의 변이 현상 ▶ 최적(Optimal) 페이지 대치 알고리즘 ­ 모든 알고리즘 중 페이지 부재율이 가장 낮음 · ‘앞으로 가장 오랜 기간 동안 사용하지 않을 페이지를 대치하라’는 사상을 표현 · 고정된 프레임 수에 대해 가능한 가장 낮은 페이지 부재율이 보장됨 · 최적 페이지 대치 알고리즘 ­ 앞의 참조 문자열을 적용한 경우, 총 9번의 페이지 부재가 발생함 참조 문자열 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 7 7 7 2 2 2 2 2 7 0 0 0 0 4 0 0 0 1 1 3 3 3 1 1 페이지 프레임 v 현실적인 구현이 어려우며, 비교 연구를 위해 주로 사용됨 ­ 참조 문자열이 언제 사용될 것인가에 대한 정확한 정보를 요구함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 최근 최소사용(LRU, Least Recently Used) 알고리즘 ­ 과거의 데이터를 이용, 미래를 예측하기 위한 통계적 개념 · 메모리의  지역성을 이용한 알고리즘으로  각  페이지에 마지막으로  사용된  시간을  연관시 킴 · 페이지 대치 시, 오랫동안 사용하지 않은 페이지를 선택 ­ 시간적으로 거꾸로 찾는 최적 페이지 대치 알고리즘이라 할 수 있음 · 최근 최소사용(LRU) 알고리즘 ­ 앞의 참조 문자열 적용 시, 12번의 페이지 부재를 일으킴  ­ 처음  5번의  부재  처리  과정은  최적  대치  알고리즘과  같으나,  이후  페이지  4에  대한  참조가 일어날 때 메모리 속 페이지 중 가장 늦게 사용한 페이지 2를 선택하여 대치 함 ­ 만약 페이지 2에 부재 발생 시, {0, 3, 4} 중 가장 늦게 사용한 페이지 3으로 대치함 참조 문자열 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 7 7 7 2 2 4 4 4 0 1 1 1 0 0 0 0 0 0 3 3 3 0 0 1 1 3 3 2 2 2 2 2 7 페이지 프레임 v 알고리즘의 구현을 위해 하드웨어 지원이 필요함 v 프레임(페이지)이 마지막에 사용된 기간을 이용, 정의되는 순서 결정을 위해 계수기 또 는 스택을 사용하는 두 가지 방법으로 구현 가능함
① 계수기를 이용한 순서 결정 방법 ­ 각  페이지  테이블  항목과  사용시간  레지스터를  연관,  프로세서에  논리  클록이나  계수기 를 덧붙여 프레임의 순서 결정 · 페이지에 대한 참조가 있을 때마다 클록은 증가함 ­ 클록 레지스터의 내용은 페이지의 해당 페이지 테이블에 있는 사용시간 레지스터에 복사 되어 각 페이지의 최소 참조에 대한 시간을 가짐 · 가장 작은 시간 값을 가진 페이지는 대치됨 ­ 페이지 탐색과 페이지 테이블의 변화 과정을 유지해야 하는 부담을 고려해야 함
② 스택을 이용한 순서 결정 방법 ­ 순서 결정을 위해 페이지 번호를 스택(Stack)에 넣어 관리 ­ 페이지가 참조될 때마다 페이지 번호를 스택의 꼭대기(Top)에 둠  · 꼭대기에 있는 페이지 번호는 가장 최근 사용한 페이지가 되며, 밑바닥(Bottom)에 있 는 페이지 번호는 가장 늦게 사용한 페이지가 되어 페이지 부재 시 교체됨 ­ 필드 비교, 업데이트, 계수기 등의 처리 과정은 생략되나, 스택의 중간에서 항목을 가져 오므로 이중 링크의 조작이 필요하여 오버헤드를 증가시킬 수 있음 ­ 헤드와 꼬리 포인터를 가진 이중 연결리스트를 사용하여 해결 가능 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 탐색시간을 감소시킬 수 있음 ­ 최근의 페이지를 참조한 스택 · a 이전의 스택 정보는 꼭대기에 가장 최근에 사용한 페이지 2가 있으며, 밑 바닥에는  가장 오래 전에 사용한 페이지 4를 유지하고 있음 · b 이전의 스택에서는 꼭대기에 있는 페이지가 최근 사용한 페이지 7로 교체됨 참조 문자열 4 7 0 7 1 0 1 2 1 2 7 1 2 2 7 a  b 1 2 0 1 7 0 4 4 a 이전의 스택 b 이전의 스택 ▶ 최근 최소사용 근접 알고리즘 ­ 시스템은 하드웨어의 지원 대신 참조 비트(Reference Bit)의 형태로 지원 · 처음  모든  bit는  0으로  초기화한  후  사용자  프로세스가  수행될  때  참조된  각  페이지와  관련된 bit를 1로 변환, 어느 페이지가 사용되었는지 조사하여 확인 가능 · 부분적인 순서 정보를 활용하여 최근 최소사용 알고리즘에 근사하게 대치 가능한 알고리 즘 구현 가능
① 부가된 참조비트 알고리즘 ­ 각 페이지에 8bit(1byte) 정보에 일정한 간격으로 참조 비트를 기록 ­ 8bit Shift Register를 이용하여 순서 정보를 얻음 · 각  페이지에 대한 참조비트(1)를  최상위 bit(8bit  위,  가장  왼쪽)로  삽입  이동하고 나 머지 bit들은 한 비트씩 오른쪽으로 이동시켜 가장 낮은 자리 bit는 제거함 ­ 8bit Shift Register는 최근 8번의 기간 동안 페이지 사용의 기록 정보를 유지함 · Shift Register의 값이 ‘00000000’인 경우 8번의 기간 동안 단 한 번도 사용되지 않 음을 의미함 · ‘11000100(19610)’은 ‘01110111(11910)’보다 최근 사용되었음을 의미함 ­ 부가된 참조비트 예 ­ ‘00001011(11)’이 가장 사용빈도가 낮아 페이지 대치 대상임 페이지 테이블 참조 비트 00110001 11001111 01110010 11111100 가장 낮은 정수로 00001011 페이지 대치 대상 01010011 00011101 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 8bit를  부호  없는  정수로  해석할  경우  가장  낮은  bit를  가진  페이지는  최근  최소사용 (LRU) 페이지(오랫동안 미사용 페이지)이며, 대치 가능함 ­ 참조 비트의 내용이 동일한 경우 발생 가능 · 모든 페이지 프레임이 갖는 참조 비트의 값이 유일하지 않기 때문에 발생함 ­ 작은 정수값을 갖는 프레임이 두 개 이상 있는 경우 희생자 선정 시점에서 문제 발생 · 희생자를 선정하지 않는 경우는 문제 없음 · 가장 작은 정수값을 갖는 프레임 모두를 희생자로 선택하거나 ex)Iex)O의 원칙에 따라 하 나를 희생자로 선택함
② 시계(2차적 기회 대치) 알고리즘 ­ 선입선출(ex)Iex)O) 대치 알고리즘을 기반으로 함 ­ 최근 최소사용(LRU) 알고리즘과 성능은 비슷하나 과부하가 적음 · 각 프레임의 사용여부를 나타내는 참조(사용)비트를 추가 · 페이지가  메모리  내의  프레임에  처음  적재되었을  때  1로  설정한  후,  참조될  때마다  다시 1로 설정 · 프레임들은 원형 버퍼(큐)로 구성되고 각각 관련 포인터를 가짐 · 페이지 교체 시 포인터는 교체된 버퍼 다음 프레임을 가리키도록 설정 ­ 운영체제가 페이지 교체 시기에 참조비트가 0인 프레임을 찾기 위해 원형 버퍼 검색 · 프레임의 참조비트가 ‘1’이면 ‘0’으로 조정하고 현재 시간으로 고침 · 수정한 페이지에 2차적 기회를 주고 다음 검사 시까지 대치시키지 않음 · 모든 사용비트가 1인 경우 각 페이지에 2차적 기회를 주며 포인터는 전체 큐를 한 바 퀴 돌 수도 있음 · 처음 시작한 위치에서 중단하고 그 프레임을 교체대상으로 선택 ­ 모든 bit가 1인 경우 2차적 알고리즘은 선입선출(ex)Iex)O) 대치와 같아짐 · 사용비트가 1인  프레임을 통과하는 과정을 제외하면 선입선출(ex)Iex)O) 대치  알고리즘과  비슷함 · 원형으로 배치된 것처럼 보여 시계 알고리즘이라고 함 페이지 페이지 참조 비트 참조 비트 0 0 0 0 1 수정된 0 다음 1 비트 0 희생자 0 0 1 1 1 1 (a) (b) 시계 페이지 대치 알고리즘 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 페이지 번호 참조 비트 페이지 번호 참조 비트 0 33 1 0 33 1 1 12 1 1 12 1 2 8 0 2 8 0 3 545 1 3 545 1 4 768 1 4 768 0 프레임 5 9 1 5 9 0 포인터 6 11 0 6 420 1 7 233 0 7 233 0 m
-1 66 0 m
-1 66 0 프레임 번호 프레임 번호 페이지 대치 이전의 버퍼와 페이지 대치 이후의 버퍼 상태 ­ 시계 알고리즘에 사용비트 추가 시 더 강력한 대치 알고리즘 작성 가능 · 사용 중인 페이지들은 메인 메모리의 각 프레임과 연관되므로 메인 메모리의 각 프레 임의 상태를 나타내는 수정(타당/비타당 비트)를 이용 · 해당 프레임이 보조기억장치(디스크)에 저장되었는지 확인 가능함  · 페이지를 가져온 후 수정되지 않았으며 최근에 사용되지 않은 페이지를 찾을 수 있으 므로 변경되지 않은 페이지가 우선 교체 대상이 되어 시간을 줄일 수 있음
③ 최소사용 빈도수(Lex)U, Least ex)requently Used) 알고리즘 ­ 각 페이지마다 참조 횟수에  대한 계수기가 있으며,  가장 작은 수를 가진 페이지를 대치 함 · 많이 사용되는 페이지는 큰 참조 횟수 값을 가짐 ­ 어떤 프로세스의 초기 단계에서 한 페이지가 많이 사용되나 그 후로 다시 사용되지 않을  경우 사용하기 어려움 · 큰 계수를 가진 페이지가 더 이상 필요하지 않음에도 메모리 속에 계속 남음 · 계수기를  어떤  일정한  시간  간격으로  하나씩  오른쪽으로  이동,  지수적으로  감소하는  평균 사용수를 형성하여 해결 가능함
④ 최대사용 빈도수(Mex)U, most ex)requently Used) 알고리즘 ­ 가장 작은 계수를  가진 페이지가 방금  들어온 것으로 아직 사용되지  않아, 앞으로 사용 할 확률이 높다고 가정하여 대치 페이지 후보에서 제외시킴 ­ 가장 많이 사용된 페이지(계수가 높은 페이지)를 대치함 v Lex)U,  Mex)U는 구현  시  비용이  많이  들고  최적  페이지  대치에  비해  성능이  떨어져  일반적 으로 사용되지 않음 ㆍ 페이지 버퍼링(Page Buffering)
- ex)Iex)O  같은  성능  저하를 막기  위해  교체  대상으로 선택된  페이지를  즉시 교체하지  않고  잠시 동안 메인 메모리에 유지함
- 포인터 리스트 두 개를 이용, 페이지를 관리하며, 페이지 대치 알고리즘은 ex)Iex)O임 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- VAX 컴퓨터의 VMS, XP, Mach에서 사용된 방식
- 페이지 버퍼링 개념 · 수정 안 된 가용페이지 리스트 : 메모리에 적재된 후에 수정된 적이 없는 프레임 리스 트로 교체 불필요 · 변경 페이지 리스트 : 메모리에 적재된 후 수정된 프레임의 리스트로 디스크에 재저장 해야하므로 디스크 기록을 대기함 제거 추가 사용 변경 페이지 리스트 수정 안 된 가용 페이지 리스트 일괄 기록 = 속도 향상
- 변경되지  않은  페이지  교체  시,  교체된  페이지는  메모리에  남고  페이지  프레임은  가용  페이지 리스트의 끝에 추가됨
- 변경된 페이지 교체 시, 페이지 프레임을 변경 페이지 리스트의 끝에 추가함
- 페이지 교체 시 · 페이지 테이블 내에 있는 항목만 삭제되어 가용 페이지 리스트나 변경 페이지 리스트 에 놓임 · 포인터 리스트의 각 항목은 재배치되는 프레임의 번호 저장 · 가용 페이지 : 항상 사용 가능한 몇 개의 프레임들을 보유, 페이지를 읽어 들일 수 있 는 페이지 프레임의 리스트
- 페이지 읽을 때 · 가용 리스트의 헤드가 가리키는 페이지 프레임(가용 페이지 리스트 상의 첫 페이지)이  사용되고 그 페이지는 없어짐 · 페이지  부재  발생  시  리스트  두  개를  검색,  원하는  페이지가  아직  메모리에  있는  지  검사함 · 메모리에 없으면 가용 페이지 리스트의 첫 번째 프레임에 원하는 페이지 적재
- 프로세스가 페이지를 참조하면 오버헤드 없이 페이지가 해당 프로세스의 작업에 추가 가 능하여 페이지 부재가 해결됨
- 변경 페이지 리스트에 있는 프레임은 일괄 처리되어, 입출력 연산 횟수가 감소하므로 디 스크 액세스 시간을 줄여줌 ▶ 알고리즘의 비교 분석 ㆍ 배르(BAER, 1980년) 발표
- 페이지 대치 알고리즘의 비교 · 분석에 사용한  페이지 크기는 256word이며, 프레임 수를  6,  8,  10, 12, 14개로  변 경시키면서 실행 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 적은 수의 프레임을 사용할 경우 차이가 크게 나타남 1000번의 40 선입 35 선출 참조당  30 시계 페이지 부재수 25 LRU 20 15 OPT 10 5 0 6 8 10 12 14 할당된 프레임 수 2. 프로세스 적재 정책 ▶ 스레싱(Thrashing) ­ 페이지 교환이 계속 일어나는 현상 · 어떤 프로세스가 프로세스 수행에 보내는 시간보다 페이지 교환에 보내는 시간이 더 크 면 ‘스레싱을 하고 있다’고 말함 ㆍ 스레싱 발생 원인
- 운영체제는 항상 프로세서의 효율성(이용률)을 감시하여 운영
- 이용률이  떨어지면  이를  높이기  위해  새로운  프로세스를  도입,  다중  프로그래밍의  정도 를 높임 · 새로운  프로세스가  수행  중인  프로세스의  페이지를  빼앗아서  수행을  시작할  경우  더  많은 페이지 부재 발생 · 프로세서가 요구하는 최소한의 수보다 페이지 프레임 수가 적으면 적을수록 페이지 부 재율이 증가함 · 페이지 부재가  많이  일어날수록  프로세스가 페이징 처리장치를 기다리는 시간이 길어 지므로 프로세스의 효율성은 떨어짐 v 페이지 부재로 프로세서의 이용률  감소 시  스레싱이  발생하여 시스템의 처리율은 낮 아지고  페이지  부재는  늘어나  유효  메모리  액세스  시간이  증가,  페이지  교체시간이  낭비됨 ㆍ 스레싱
- 프로세서의 이용률과 다중 프로그래밍의 정도에 따라 다름 · 다중 프로그래밍의 정도가 높아지면 프로세서의 이용률도 최대값이 될 때까지 증가 · 다중  프로그래밍의  정도가  더욱  커지면  스레싱이  발생,  프로세서의  이용률은  급격히  떨어짐
- 프로세서의 이용률을 높이고 스레싱을 중단하려면 다중 프로그래밍의 정도를 낮춰야 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로세서 이용율 스레싱 다중 프로그래밍 정도 ㆍ 스레싱 예방
- 지역 교환 알고리즘이나 우선순위 교환 알고리즘을 사용하여 제한할 수 있음 · 지역 교환 알고리즘 사용 시 프로세스 하나에 스레싱이 발생하더라도 다른 프로세서에 서 프레임을 가지고 올 수 없어 다른 프로세스는 스레싱 현상에 빠지지 않음 · 여러  프로세스에서 스레싱이 발생할 경우 프로세스들은 대부분의 시간을 페이징 처리 장치를 기다리는 큐에서 보냄 · 스레싱은 발생하지 않으나 유효 액세스시간은 증가함 ▶ 지역성(국부성) ­ 실행 중인 프로세스에 의해 나타나는 특성 · 프로세스들은 실행기간 동안 메모리 내의 정보를 균일하게 액세스하는 것이 아닌 페이지  중 일부를 선호하여 지역적인 부분만을 집중적으로 참조하는 현상 · 프로그램들의 순환(Looping)이나 부  프로그램,  스택, 변수들의 계산과 합계,  배열 순례,  순차적 코드의 실행 등으로 발생 · 프로그래머들이 관련 있는 변수들을 서로 근처에 배치시키기 때문에 발생함 ㆍ 지역성의 종류
① 시간 지역성
- 참조된 기억장소는 가까운 미래에도 계속 참조될 가능성이 높음을 의미함
- 순환구조의 루틴, 부프로그램, 스택, 계산이나 합계의 변수 등
② 공간 지역성
- 프로세스가  어떤  기억장소를  한  번  참조하면,  이후에  참조한  기억장치  근처에  있는  기억장소를 참조할 가능성이 높음을 의미함
- 배열 순례(검색 작업), 순차적 코드의 실행, 근처의 관련 변수 선언 등 ▶ 작업설정 모델(Working Set Model) ­ 프로그램의 수행과정을 지역성 개념으로 설명하기 위해 데닝이 개발 · 프로세스가  많이  참조하는  페이지  집합을  메모리  공간에  계속  상주시켜  빈번한  페이지  대치 현상을 줄이는 방법 · 프로세스의  작업모델  구성을  위해  작업설정의  크기를  알아야  하며,  작업설정의  크기는  작업설정 창을 이용하여 구함 · 최근에 참조된 페이지들을 메인 메모리에 유지시켜 프로세스가 빠르게 실행될 수 있음 · 새로운  프로세스들은  메인  메모리에  그들의  작업설정들이  적재할  수  있는  공간이  있을  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 때만 시작될 수 있음 ­ 프로세스 작업설정 정의 · 창 크기와 작업설정 ­ w가 증가함에 따라 작업설정의 크기가 변함 ­ 창의  크기(설정시간  간격)  w가  커짐에  따라  메인  메모리에  유지하는  작업설정이  커 지나, w가 너무 커지면 메인 메모리의 용량을 초과하므로 작업설정도 증가하지 않음 프로그램 크기 작업설정 크기 창 크기 W ­ 작업설정 크기에 따른 페이지 프레임 수와 페이지 부재율과의 관계 · 작업설정 크기가 너무 작고 페이지 프레임 수가 적으면 페이지 부재율이 높아 프로세스 의 실제 작업 페이지들이 메모리에 있지 않고 스레싱 현상을 일으킬 수 있음 · 작업설정 크기가 너무 크고 페이지 프레임 수가 너무 많으면 프로세스의 실제 작업 페이 지들 뿐만 아니라 다른 페이지까지 메모리를 차지하여 메모리 낭비가 발생하며 다중 프 로그래밍의 정도를 감소시킬 수 있음 작음 크기의 작업 설정 적당한 크기의 작업 설정 페이지 부재비율 큰 크기의 작업 설정 페이지 프레임 수     ▶ 페이지 부재 빈도(Pex)ex), Page ex)ault ex)requency) ­ 스레싱 예방을 위한 직접적인 액세스 방법 · 페이지 환경에서 프로세스의 실행을 측정하는 기준이 됨 · 페이지 부재가 발생할 때 조절하여 작업설정 모델보다 오버헤드가 적음 ­ 작업설정 모델은 페이지가 메모리에 액세스할 때 조절 · 스레싱은 페이지 부재에서 발생하므로 페이지 부재비율 조절이 필요함 ­ 페이지 부재 비율이 높음 = 프로세스가 더 많은 프레임을 필요로 함 ­ 페이지 부재 비율이 낮음 = 프로세스가 너무 많은 프레임을 갖고 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 페이지 부재 빈도 ­ 하나의 프로세스가 갖는 페이지 프레임 수에 따라 페이지 부재 비율이 변화화는 과정 을 보여주는 그래프 페이지 부재 비율 프레임 개수 증가시켜 상한 값 유지 상한값 하한값 프레임 개수 감소시켜 하한 값 유지 프레임 개수 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 입출력 시스템과 디스크 관리(1)

1. 입출력 모듈에 대해 이해하고 커널 입출력 서브 시스템에 대해  정리할 수 있다. 수업목표  
2. 자기 디스크의 물리적 구조와 디스크 액세스 시간에 대해 알  11주차  수 있다. 1. 입출력 시스템 1교시     
- 입출력 모듈    
- 커널 입출력 서브 시스템 세부내용  2. 자기 디스크    
- 자기 디스크의 물리적 구조    
- 디스크 액세스 시간 1. 입출력 시스템 ▶ 입출력 시스템 ­ 컴퓨터 시스템의 입출력 장치와 입출력 모듈을 포함 · 물리적 입출력 장치는 실제 입출력을 수행함 · 입출력  모듈은  내부  저장장치와 물리적 입출력 장치(외부 입출력장치) 사이의 2진  정보 를 전송하기 위한 방법 제공 ­ 입출력장치의 물리적 특성으로부터 프로세서를 독립시켜 제어함 ▶ 입출력 모듈 ­ 프로세서를 대신하여 입출력과 관련된 복잡한 일 수행 · 입출력 채널(I/O Channel) 또는 입출력 프로세서(I/O Processor)라 함 ­ 단순히 프로세서의 입출력과 관련된 일 담당 · 입출력 제어기(I/O controller) 또는 장치 제어기(Device Controller)라 함 · 입출력 모듈을 통해 시스템 버스에 연결됨 ­ 입출력장치에 따라 제어 방법과 운용 방식이 다르므로 입출력 모듈을 통해 연결됨 인터럽트 프로세서 캐시 시스템 버스 ­ 입출력 버스 입출력 입출력 입출력 입출력 메인  제어기 제어기 제어기 제어기 메모리 네트워크 컴퓨터 시스템의 기본 하드웨어 구성과 입출력 모듈 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 프로세스와  입출력장치의  실행속도가  다르므로,  각  입출력장치의  실행속도를  맞추는  과 정이 필요함 ­ 장치들을 동기화시키지 못하면 실행속도가 다르기 때문에 데이터의 손실이 발생될 수  있음 · 정보의 단위와 처리량도 동기화해야 함 ­ 컴퓨터 내부의 정보 단위는 워드(Word)이며, 입출력장치가 다루는 정보의 단위는 문 자(Character) ­ 프로세서보다 입출력장치의 처리속도가 느리므로 시간의 낭비가 발생될 수 있음 · 입출력 모듈의 구성 ­ 제어장치들의 수와 구조에 따라 구성이 다양함 ­ 일반적인 입출력 모듈의 내부 조직 시스템 버스  외부 장치  인터페이스 인터페이스 데이터 레지스터 외부장치 데이터 데이터선 인터페이스 상태신호 상태/제어 레지스터 논리회로 제어신호 주소선 외부장치 데이터 입출력 인터페이스 상태신호 논리회로 제어선 논리회로 제어신호 입출력 모듈의 내부 조직 ­ 입출력 모듈로 들어가거나 나오는 데이터는 일시적으로 데이터 레지스터에 저장됨 ­ 현재의 상태정보가 저장되는 상태 레지스터는 프로세서에서 보내는 제어 정보를 받기  위해 제어 레지스터로 동작함 ­ 제어 레지스터는 프로세서로부터  받은  명령에  따라 자신이 제어하는  각 장치와의 인 터페이스를 위한 입출력 논리회로를 가짐 ­ 신호선(시스템  버스선)을  통해  컴퓨터  내의  다른  부분들과  연결,  모듈  내의  입출력  논리회로는 제어선을 통해 프로세서와 교신(프로세서가 입출력 모듈로 명령을 보내는  데 사용)함 · 입출력 모듈의 기능
① 입출력장치의 제어 ­ 내부  자원들과  데이터 입출력을  비롯한  다양한  동작 조정을  위한  제어와  타이밍  기능 제공 ­ 프로세서가  입출력장치에 명령어를  보내려면  입출력장치의 식별자(Identity)를 주 소로 지정해야 함 ­ 주소 지정 방법은 전용 입출력 주소 방식과 메모리 사상 주소 방식이 있음
② 프로세서와의 통신 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 입출력  모듈은  프로세서로부터  수행해야  할  명령어를  전달받고  관련된  메시지를  인식하기 위한 기능을 제공함 ­ 메시지 인식을 위해  명령 해독, 데이터 교환,  상태 보고, 주소 인식  등의 과정을  거침
③ 데이터 버퍼링 ­ 메인 메모리나 프로세서의 데이터 전송률은 높으나, 입출력장치의 전송률은 낮음 ­ 데이터는  입출력  모듈  내에  일시적으로  저장되었다가  적절한  속도로  주변장치로  내보내야 함 ­ 반대 방향으로 데이터를 보낼 때는 메인 메모리 등이 느린 전송률에 영향을 받지  않도록 데이터를 일시 저장할 수 있는 버퍼를 제공, 데이터를 전송함
④ 오류검출 ­ 기계적 오류와 전송 오류 등이 있으며, 전송 오류 검출을 위해 오류검출 코드(패 리티 비트)를 사용 ㆍ 프로그램 제어 입출력
- 프로세서 내부에 있는 입출력 데이터와 주소 레지스터를 입출력 모듈과 연결한 형태
- 주소 레지스터와 버스 사이에서 데이터를 직접 전송할 수 있는 가장 간단한 형태
- 폴링(Polling)방식(바쁜 대기)라고도 함
- 상대적으로 프로세서보다 느린 입출력장치의 입출력 동작 상태를 확인하기 위해 상태 비 트(Status Bit)를 주기적으로 검사함 됨
- 데이터 전송 시, 폴링 순환 수행 · 프로세서는 주변장치에 전송할 데이터가 있는 경우, 입출력장치가 데이터를 받을 준비 가 되어 있는지 확인하기 위해 포트 상태 레지스터를 확인 · 플래그를 검사하여 입출력장치가 준비되어 있다면 데이터를 전송함 · 준비되어 있지 않다면 루프를 돌아 다시 포트 상태 레지스터를 확인 포트 상태 레지스터 확인 입출력장치 미준비 플래그 조사 입출력장치 준비 데이터 전송 폴링 순환
- 폴링의 횟수는 데이터 전송의 성능에 영향을 끼침 · 폴링이 너무 빈번히 수행되면 프로세서는 입출력 동작의 진행 여부 검사에 많은 시간 을 낭비함 · 폴링 횟수가 너무 작으면 입출력장치는 오랜 시간 동안 쉬게 됨 ㆍ 인터럽트 기반 입출력 : 외부 입력 제어
- 입출력장치가  작업을  완료한  후  작업과  관련된  상태와  결과를  메모리에  저장,  인터럽트 를 발생시켜 프로세서에 알림 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 인터럽트를 받은 프로세서는 입출력 명령어를 전송, 입출력 작업 중에 다른 작업을 시작 할 수 있음
- 프로세서가 입출력장치에  프로세서의 도움이 필요한지  확인하는  절차  대신  직접  입출력 장치가 프로세서에 신호를 주는 방식
- 불규칙적이고 빠른 응답성을 요구하는 경우에 적합함
- 장단점 · 프로세서는 폴링 절차를 생략하여 입출력 연산의 대기시간을 소모할 필요가 없어 효율 성이 증가함 · 현재의 작업 내용을 스택에 저장한다는 오버헤드가 존재 · 모든 데이터가 프로세서의 레지스터에서 전송됨 프로세서 ❶ 입출력 제어기 장치 드라이버  ❷ 입출력 초기화 입출력 초기화  (입출력 시작) (입출력 시작) ❸ 프로세서 실행 중 명령어 수행 후 인터럽트 조사 입력 준비, 출력 완료  ❹ 또는 오류 인터럽트 수신 인터럽트  인터럽트 신호 생성 처리기에게 제어 전환 ❼ ❺ 인터럽트 처리기가  자료처리,  인터럽트로부터 복귀 ❻ 인터럽트된 작업된 처리 및 다시 시작 인터럽트 기반 입출력 사이클 ㆍ DMA(Direct Memory Access) 입출력
- 프로세서의 부담을 줄이기 위해, 메인 메모리를 직접 제어하여 데이터를 전송 · 프로세서는  읽기  및  쓰기  정보를  비롯한  입출력  주소와  메모리  주소  그리고  길이를  DMA 제어기에 전달(입출력 요청) · DMA 제어기는 버스 관리자(Master)로서 직접 작업을 처리 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- DMA 입출력 과정 커멘드 :  읽기/쓰기  버스 관리자, 입출력 주소  버스 사이클 초기화 메모리 주소  바이트 수 DMA 제어기 입출력 요청 프로세서 디스크 드라이버 메모리 디스크에서 메모리로 데이터가 전송되는 과정
- 프로세서에서 입출력장치로 데이터를 블록 단위로 전송 가능 · 제어는 입출력 모듈에서 담당, 전송은 프로그램 제어 입출력이 담당 · 전송이 완료되면 출력 모듈은 프로세서에 인터럽트를 발생하여 종료를 통보, 데이터를  메모리에 보관함 · 프로그램은 메모리의 데이터를 사용
- 고속  디스크의  데이터  전송에  적합한  방식으로,  멀티미디어와  같은  대용량  데이터  전송 에 적합함 ㆍ 입출력 채널
- 모든  입출력  동작이  완료된  시점에서  인터럽트  받는,  프로세서와  메인  메모리를  입출력 장치에 결합하여 프로세서의 명령으로 입출력을 제어하는 장치
- 프로그램
-제어 입출력과 직접 메모리 액세스 방법의 특징 비교  
① 프로그램
-제어 입출력 ­ 프로세서가  계속  제어하므로  입출력장치와  컴퓨터를  연결하는  데  최소한의  하드 웨어만 필요함 ­ 저속 장치들에서 사용됨  
② 직접 메모리 액세스 ­ 매개변수의  초기화를  제외하고  프로세서를  모든  입출력  연산과  분리,  데이터  전 달을 제어하기 위해 외부 제어기가 필요함 ­ 고속의 장치에서 사용
- 입출력 전용 처리기 · 대형 컴퓨터에서 프로세서를 좀 더 효율적으로 이용하기 위해 사용됨 · 다수의 장치를 공유할 수 있음 · 입출력  동작  명령어를  가진  프로세서를  포함하여  다른  프로세서의  도움  없이  입출력  프로그램의 입출력 동작을 지시함 · 지역기억장치(Local Memory)를 가지며 사실상 하나의 컴퓨터라 할 수 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 프로세서의 개입이 최소화된 상태에서 많은 입출력장치를 제어, 입출력 프로세서로 불 림 ▶ 커널 입출력 서브 시스템 ­ 입출력 서비스와 입출력 인터페이스 실행을 위해 인터페이스가 구성 되어야 함 · 커널 입출력 구조 ­ 입출력장치의  모델이나  제조사와  관계없이  공통적인  특징을  가진  입출력장치들을  액 세스하기 위해 필요한 표준 함수들을 정의함 ­ 정의된 함수들은 장치 드라이버에 의해 수행 * 장치 드라이버는 여러 입출력장치의 차이를 간단한 표준 인터페이스로 변환하여 상위 의 커널 입출력 서브 시스템에 제공 커널 커널 입출력 서브시스템 소프트웨어 SCSI 장치 키보드 장치 마우스 장치  제어기 드라이버 드라이버 하드웨어 인터페이스 SCSI 장치 키보드 장치 마우스 장치  제어기 드라이버 드라이버 하드웨어 SCSI 장치 키보드 마우스 · 커널은 입출력과 관련된 서비스를 제공하며, 커널 입출력 서브시스템은 컴퓨터의 효율성  증진을 위해 메모리나 디스크의 기억장소를 이용함 ㆍ 커널 입출력 스케줄링
- 입출력 요구를 스케줄링 함 = 요구들의 실행 순서를 결정
- 응용 프로그램은 입출력을 요청한 순서대로 실행하기 보다 전반적인 시스템 성능을 향상 시키면서 프로세서들의 요구를 공평하게 처리할 수 있도록 순서를 결정함 ㆍ 커널 입출력 버퍼링
- 버퍼링을 통해 송신자와 수신자의 전송 속도 차이 때문에 발생하는 시스템의 데이터 전 송 문제를 해결 가능
- 장치들이 보내는 데이터의 크기가 다르기 때문에 발생하는 메시지 전송 문제를 해결 가 능 · 대부분의 전송  메시지는  작은  네트워크  패킷으로  나누어 전송, 수신측에서  원래의  자 료로 복원하기 위해 패킷들을 버퍼에서 결합
- 버퍼링의 구조 · 입출력장치에서 들어온 데이터를 모뎀을 통해 디스크에 저장(기록)한다고 가정함 (a) : 입출력장치의 모뎀에 버퍼가 없으므로 데이터의 입력 속도에 따라 디스크에 전 달 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr (b) : 시스템 성능 향상을 위해 메모리에 버퍼를 만듦 (c) : 두 개의 버퍼를 사용(이중 버퍼링) (a) 버퍼 기능 없음 디스크 데이터 입력 데이터 이동 입출력장치 (b) 단일 버퍼링 버퍼 디스크 데이터 입력 데이터 이동 입출력장치 (c) 이중 버퍼링 버퍼 버퍼 디스크 교대 데이터 이동 입출력장치 버퍼 데이터 입력 교대 ㆍ 커널 입출력 캐싱
- 명령어와 데이터를 캐시 메모리에 일시적으로 저장, 프로세서와 메모리(디스크)간의 액세 스 속도 차를 프로세서에 가깝게 단축시켜 컴퓨터의 성능을 향상시킴 · 캐시 : 버퍼와 달리 자주 사용될 자료를 미리 복사하여 저장하는 빠른 메모리 영역 * 다른 곳에 저장되어 있는 데이터의 복사본을 저장하는 장소
- 한 메모리 영역이 두 가지 목적을 위해 사용(캐싱, 버퍼링)  · 커널이 데이터 입출력 요구를 받으면, 커널은 먼저 데이터가 캐시에 있는지 조사 · 데이터가 캐시에 있으면 디스크 입출력을 생략, 입출력의 효율성을 높임 · 메모리 내에 버퍼를 사용하여 디스크 입출력 스케줄링을 효율적으로 수행 또는 프로세 스들 간에 공유 해야 하는 파일들을 위한 캐시로 사용 가능 ㆍ 커널 입출력 스풀링
- 여러  응용  프로그램이  동시에  출력  데이터를 프린터로  전송  시  커널(운영체제)은 각  출 력이 다른 프로그램의 출력과 섞이지 않고 프린터로 출력되도록 관리함 · 각 응용 프로그램의 출력은 각각 대응되는 디스크 파일에 저장(스풀)됨
- 스풀링 시스템 · 응용 프로그램이 출력 데이터에 대한 작업을 종료하면 그때까지 모아 놓은 출력 데이 터를  프린터  출력용 준비  큐에  삽입(이동)하여  스풀  파일을  한  번에  하나씩  프린터에  내보냄
- 커널 스레드에 의해 처리됨 ㆍ 오류 처리
- 커널(운영체제)은 입출력장치나 네트워크 전송의 원인으로 발생되는 일시적인 고장을 효 과적으로 극복 가능
- 중요한 구성 요소가 영구적인 고장을 일으키는 경우 문제를 완전히 극복하기 어려움 ㆍ 자료 관리 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 커널은 입출력 구성에 대한 상태 정보를 유지함
- 입출력 서비스를 커널이 아닌 독립 프로그램이 담당할 경우의 장단점 · 오버헤드가 증가함 · 입출력 시스템의 구조와 설계가  간단해지며 운영체제 커널의 크기가 작아지고 유연성 이 좋아짐
- 입출력 서브시스템은 광범위한 서비스를 조정, 다음 사항을 관리함 · 장치의 이름 및 장치에 대한 액세스 제어 관리 · 장치 할당과 입출력 스케줄링 관리 · 버퍼링, 캐싱 및 스풀링 관리 · 장치 상태 모니터링과 오류 처리 및 고장 복구 관리 2. 자기 디스크 ▶ 자기 디스크의 물리적 구조 ­ 원판 모양, 표면에 자기 물질이 입혀져 있으며 이곳에 정보를 기록하여 저장 · 디스크가 사용 중일 때 구동 모터는 빠른 속도로 디스크를 회전시키고 디스크 표면 바로  위에 입출력 헤드가 위치함 ­ 논리적으로 디스크 표면은 트랙으로 나뉘어 짐 ­ 입출력  헤드  아래의  트랙에  정보가  자기적으로  기록되며,  디스크의  한  표면은  수백  개의 트랙으로 구성됨 · 고정 헤드와 자기 디스크 장치 트랙 t 축 암 회전 방향 이동 섹터 s 장치 고정 읽기 쓰기 R/W 실린더 c 헤드 헤드 트랙 1 트랙 2 트랙 3 원판 트랙 4 회전 암 (a) 고정 헤드 디스크 (b) 자기 디스크 (a) 고정 헤드 디스크 : 트랙마다 각각의 헤드가 있음 (b) 자기 디스크(이동 헤드 디스크 방식) : 한 개의 헤드와 헤드를 이동시키는 하드웨 어로 구성 · 높은 성능 요구 시 고속 디스크 또는 램 디스크(Random Access Memory Disk)를 사 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 용하여 종래의 이동 헤드 디스크보다 빠른 액세스와 데이터 전송 가능 · 디스크 표면에 저장 밀도를 높이거나 트랙 수 증가 가능 ­ 디스크의 저장 능력 향상 · 원판 양면에 각각의 디스크 헤드를 설치하여 저장 능력의 향상 가능 · 자기 디스크 장치 ­ 한  개의  회전축에  여러  개의  디스크를  쌓고(Disk  Pack)  한  개의  구동  모터로  회전,  디스크마다 각각의 입출력 헤드로 처리 가능 ­ 디스크는 교체 가능하므로 필요에 따라 다른 디스크를 장치하여 사용 가능 ­ 디스크 시스템은 디스크 드라이버, 프로세서, 디스크 제어기로 구분
① 디스크 드라이버 ­ 구동 모터, 액세스 암 이동장치와 입출력 헤드 부분의 기계적인 부분 담당 ­ 탐색(Seek), 기록, 판독 등의 명령 수행
② 프로세서 ­ 원하는 컴퓨터의 논리적인  상호작용,  즉 원하는 데이터의  위치(디스크  주소)와 버퍼  및 판독/기록 관리 등을 관리함
③ 디스크 제어기 ­ 디스크 드라이버의 인터페이스 역할 담당 ­ 프로세서로부터 명령을 받아 디스크 드라이버를 동작 · 디스크 상의 정보는 드라이버 번호, 표면 번호 및 트랙 번호 등 여러 부분으로 나뉘어지 는 디스크 주소에 의해 참조됨 ­ 정보는 블록 단위로 입출력 됨 · 실린더(Cylinder) ­ 헤드의 움직임 없이 액세스할 수 있는 하나의 드라이버상의 모든 트랙 · 섹터(Sector) ­ 트랙 내의 정보는 블록(Block)을 이루고, 이러한 블록이 하드웨어적으로 고정된 크기 를 가진 경우 ­ 각 섹터는 독립적으로 입출력 될 수 있음 ­ 섹터는 디스크로부터 입출력이 가능한 정보의 가장 작은 단위 트랙 표면 실린더 섹터 번호 섹터와 트랙 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr v 디스크  드라이브의  섹터  크기는  32~4096byte,  트랙당  4~32섹터,  디스크  표면  당  20~1500트랙으로 구성됨 ▶ 디스크 액세스 시간
① 탐색(Seek) ­ 디스크상의 원하는 섹터에 액세스하기 위해 헤드를 해당 트랙 또는 실린더로 이동해 위 치시킴
② 탐색 시간 ­ 탐색에 걸리는 시간 ­ 디스크의 헤드가 움직이는 시간에 좌우되므로 멀리 떨어진 트랙 탐색 시 탐색시간이 길 어짐
③ 회전지연시간 ­ 원하는 섹터가 입출력 헤드 아래로 회전할 때를 기다리는 시간
④ 전송시간 ­ 디스크와 메인 메모리 간의 섹터를 주고받는 데 걸리는 시간 ㆍ 디스크 액세스 시간 회전지연시간 전송 시간 탐색 시간 이동헤드 회전방향 회전지연시간 ㆍ 데이터 액세스 시간
- 고정 헤드 디스크의 데이터 액세스 시간 · 각 트랙에 읽기, 쓰기 헤드를 가지고 있어 탐색시간이 필요 없음 · ‘회전지연시간 + 전송시간’
- 이동 디스크의 데이터 액세스 시간  · ‘탐색지연시간 + 회전지연시간 + 전송시간’
- 데이터 액세스 시간 예 · 다음과 같은 조건에서 전송 크기가 1KB일 때, 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 탐색시간 : 50ms · 디스크 회전지연시간 : 165ms · 전송시간 : 000094ms/byte (1KB 전송시간 : 096256(=000094ⅹ1024)) · 이동 디스크와 고정 헤드의 데이터 액세스 시간 계산 · 이동 디스크의 데이터 액세스 시간 : 50 + 168 + 096256 · 고정 헤드의 데이터 액세스 시간 : 168 + 096256 ㆍ 특정 섹터의 주소
- 메모리와 디스크 사이에 입출력 전송은 하나 또는 여러 개의 섹터 단위로 이루어짐
- 디스크는 섹터들의 3차원 배열로 볼 수 있음 · 특정  섹터의  주소를  만들기  위해 트랙번호(또는 실린더),  표면번호,  섹터번호  등이  필 요함
- 트랙 당 섹터들의 개수를 s로 표시, 실린더당 트랙들의 개수를 t로 표시할 때 · 실린더 번호  i, 표면번호  j, 섹터번호 k인  디스크  주소는  1차원  블록 수 b로  표시 가 능 b = k + s x( j + i x t )
- 트랙 당 섹터들의 개수를 s로 표시, 실린더당 트랙들의 개수를 t로 표시할 때 · 사상(Mapping)에서 블록 b+1을 액세스할 때, b가 실린더의 마지막 블록임 · b+1  블록(실린더)에  대한  탐색이  필요하며,  이  경우  헤드가  단지  한  트랙만  옮기면  됨
- 디스크는 디스크 내에 어떤 파일이 있는지를 표시하는 장치 디렉터리를 가짐 · 장치 디렉터리는 파일 이름으로 목록을 나타냄 · 파일이  디스크의  어디에  있는지  즉,  파일의  길이,  종류,  소유주,  생성된  날짜,  마지막 으로 사용된 시간 그리고 부호 등에 대한 정보를 포함함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 입출력 시스템과 디스크 관리(2)

1. 디스크 스케줄링에 대해 알 수 있다. 11주차  수업목표  
2. RAID 개념을 이해하고, RAID 계층을 특징을 알 수 있다. 2교시  1. 디스크 스케줄링 세부내용  2. RAID 1. 디스크 스케줄링 ▶ 디스크 스케줄링 전략 ­ 입출력장치(디스크 드라이버)는 요청(Request)을 위한 큐를 가짐 · 프로세스는 입출력이 필요할 때마다 운영체제에 시스템 호출을 보냄 · 요청은 다음과 같은 정보를 포함함 ­ 입력 동작인지 출력 동작인지에 대한 정보 ­ 디스크 주소(구동기, 실린더, 표면, 블록) ­ 메모리 주소 ­ 전송할 정보의 총량(바이트 도는 단어의 수) · 디스크 드라이버와 제어기를 사용할 수 있다면 요청을 즉시 처리 가능 · 다른 프로세스가 둘 중 하나라도 사용하고 있다면 요청은 디스크 대기 큐에 저장됨 · 디스크 대기 큐에서 시스템의 스케줄링은 아래의 몇 가지 기준으로 평가할 수 있음 ­ 처리량 단위 : 시간당 처리한 서비스 요청의 수 ­ 탐색시간 : 디스크 헤드(암) 이동시간 ­ 평균반응시간 : 요청 후 서비스될 때까지의 대기시간 ­ 반응(응답)시간 변화 : 반응시간에 대한 예측 정도(적절한 시간 안에 서비스하여 요청 이 무기한 연기되지 않도록 방지함) v 스케줄링 정책은 처리량을 최대화하고 평균반응시간과 탐색시간을 최소화해야 함 v 처리량 및 평균반응시간 최적화로 시스템 성능 향상은 가능하나 개별 요청에 지연 발생  가능 ▶ 선입 선처리 스케줄링(ex)Cex)S, ex)irst
-Come
-ex)irst
-Served) ­ 디스크 스케줄링의 가장 간단한 형태 · 요청이 도착한 순서에 따라 처리 · 프로그램하기 쉽고 어떤 요청도 무기한 연기되는 경우가 없으며 본질적으로 공평성이 유 지됨 · ex)Cex)S 스케줄링 예 ­ 처음 요청이 트랙 98, 마지막은 트랙 67로 되는 선형 요청 디스크 큐 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 큐 : 98, 183, 37, 122, 14, 124, 65, 67 헤드시작위치 : 53 0 14 37 53 65 67 98 122 124 183 199 · 문제점 ­ 디스크 요청이 흩어져 있는  경우  실행시간  오버헤드는 적으나 탐색시간이 오래 걸려  처리량이 감소함 ▶ 최소 탐색시간 우선 스케줄링(SSTex), Shortest Seek Time ex)irst) ­ 최소 위치결정 시간 우선(SPTex), Shortest Positioning Time ex)irst) 알고리즘이라고도 함 · 디스크 요청을 처리하기 위해서 헤드가 먼 곳까지 이동하기 전에 현재 헤드 위치에 가까 운 모든 요구를 먼저 처리하는 방법 · 최소탐색 우선 알고리즘 예 큐 : 98, 183, 37, 122, 14, 124, 65, 67 헤드시작위치 : 53 0 14 37 53 6567 98 122124 183 199 · 디스크 처리시간을 실질적으로 줄일 수 있으나, 디스크 요구의 기아상태 발생 가능 ­ [그림 최소탐색 우선 알고리즘 예]에서 트랙 14와 186에 대한 요청이 있는 경우 → 트랙  186을  기다리게  하고  트랙  14를  처리할  경우,  트랙  14를  처리하는  동안  가까운 곳에서 다른 요청이 계속 발생할 수 있음 → 이론적으로 트랙 186을 무한히 기다리도록 하는 연속적인 요청이 있을 가능성이  있음 v 배치  처리  시스템의  경우  반응시간의 변화가  커도  미치는  영향이  작아  SSTex)의  적용이  가능하나,  대화식  처리  시스템의  경우  SSTex)의  불확실한  예측  가능시간  때문에  적용하 기 부적당함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 스캔 (SCAN) 스케줄링 ­ 요청 큐의 동적 특성 반영 · 입출력 헤드가 디스크의 한 끝에서 다른 끝으로 이동 · 한쪽 끝에 도달했을 때는 역방향으로 이동하면서 요청한 트랙을 처리 ­ 헤드는 디스크의 한 끝과 다른 끝 사이를 계속해서 왕복함 ­ 새로운 디스크 요청이 헤드의 바로 앞 요청의 큐에 도착하면 즉시 처리되나, 헤드 뒤 에 있는 경우 헤드가 디스크의 끝까지 이동하고 돌아올 때까지 기다려야 함 · 엘리베이터와 동작이 유사하여 엘리베이터 알고리즘이라 부르며, 눈 치우기와 비슷함 ­ 각  트랙에  대한  요청이  균등하다고  가정하면,  눈이  쌓이는  현상과  비슷하게  헤드가  한쪽 끝에 이르러 방향을 바꾸어야 할 시점에서 요청 밀도가 높은 쪽은 최초의 시작  부분이며, 나중에 처리된 헤드 바로 뒷부분은 비교적 밀도가 낮음 ­ 밀도가 높은 쪽의 요청은 오랜 시간 기다리게 됨 · 스캔 알고리즘 예 ­ 현재 헤드의 위치와 이동방향 파악 필요 큐 : 98, 183, 37, 122, 14, 124, 65, 67 헤드시작위치 : 53 0 14 37 53 6567 98 122124 183 199 ▶ 순환 스캔 스케줄링(C
-SCAN, Circular SCAN scheduling) ­ 스캔 알고리즘을 변형, 대기시간을 균등하게 · 스캔  스케줄링처럼  헤드는  한쪽  방향으로  이동하면서  요청을  처리하지만,  한쪽  끝에  다 다르면 반대 방향으로 헤드가 이동하지 않고 다시 처음부터 요청을 처리 · 처음과 마지막 트랙을 서로 인접시킨 것과 같은 원형처럼 디스크를 처리, 처리량을 향상 · 바깥 트랙과 안쪽 트랙에 대한 차별이 없어 반응시간의 변화를 줄임 · 동일한 실린더(트랙)에 대한 요청이 연속적으로 발생되면 처리가 무기한 연기될 수 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 큐 : 98, 183, 37, 122, 14, 124, 65, 67 헤드시작위치 : 53 0 14 37 53 6567 98 122124 183 199 순환 스캔 알고리즘 ▶ 룩(Look) 스캐줄링 ­ 스캔 또는 순환 스캔 방법은 원리와 달리 구현됨 · 헤드는 요청에 따라 각 방향으로 이동, 현재 방향에 더 이상의 요청이 없을 때 이동 방 향을 바꿈 · 스캔과 순환 스캔의 이런 형태를 룩(Look), 또는 순환 룩(C
-Look)라 부름 ­ Look : 진행 방향으로 움직이기 전에 먼저 요청이 있는지 검사함을 의미함 큐 : 98, 183, 37, 122, 14, 124, 65, 67 헤드시작위치 : 53 0 14 37 53 6567 98 122124 183 199 순환 락 알고리즘 ▶ 회전 최적화 ­ 디스크  스케줄링  알고리즘은  대기시간과  총  처리시간을  줄이기  위해  디스크  헤드  이동을  최소화하는데 목적을 가짐 · 초기 시스템과 달리 현재의 디스크 시스템은 탐색시간과 평균 지연시간이 비슷하여 회전  최적화로도 성능 개선이 가능함 · 일괄처리  프로세스들은  데이터의  트랙  전체를  액세스하므로  회전  최적화의  효과를  얻지  못함 · 대화식 프로세스 같은 디스크의 실린더에 분산된 소량의 데이터만 요구하는 요청이 많을  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 경우, 회전 최적화로 성능 개선 가능함
① 최소 지연시간 우선 스케줄링(SLex)T, Shortest
-Latency
-Time
-ex)irst) ­ 모든 요청 중 회전 지연시간이 가장 짧은 요청을 먼저 처리 ­ 디스크 헤드가 특정 실린더에 도달했을 때 해당 실린더의 트랙들에 대한 요청이 대기하 고 있다면, 헤드는 더 이상 움직이지 않고 도착 순서와 관계없이 모든 요청을 우선 처리 함 1 디스크 헤드 2 3 회전 방향 ­ 트랙을 일정한 수의 블록으로 나눈 섹터를 토대로 요청들을 섹터 위치에 따라 큐에 넣고  가장 가까운 섹터에 대한 요청을 먼저 처리 · 디스크 액세스 요청(디스크의 주소)은 트랙과 섹터로 구성됨 · 고정 헤드에서는 탐색을 하지 않으므로 탐색시간이 없음 · 회전지연시간만이 지연시간이 되므로 드럼과 같이 고정헤드를 사용하는 경우 효과적임 ­ 섹터 큐잉(Sector Queueing) 알고리즘이라 표현 ­ 고정헤드 디스크의 다음 섹터를 위한 경로 선택 시, 섹터 지원 시간의 간격은 트랙이 전 환하는데 걸리는 시간 · 최대 가동률은 ‘액세스된 사용자 블록 수/통과된 디스크 블록 수’임 ­ 고정헤드 디스크를 위한 큐 최적화 · 8개로 구성된 섹터 큐에 요청이 12개 있다 가정함 큐 트랙1 스케줄링 트랙2 Q1 T4 S8 S7 Q2 T1 T2 Q3 S6 S1 Q4 T5 T1 T4 T3 S5 Q5 T5 S2 Q6 T5 T4 S3 S4 Q7 T2 T3 Q8 섹터 큐 다음 요청 S6
-T4 ­ 섹터 큐잉(Sector Queueing) · 고정헤드장치에서도 사용되나 특별한 트랙마다 실린더 내에  처리 요청이 하나 이상일  때는 이동헤드 장치에서도 쓸 수 있음 · 헤드가 특정한 실린더에 도착하면 헤드를 더 이상 움직이지 않고 실린더에 대한 모든  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 요청을 처리함 · 같은 실린더 내에서 다중 요청의 정렬에 사용 가능 · 운영체제가  하나  이상의  요청  중에서  헤드  밑에  위치한  첫  요청을  선택해야만  효과  있음
② 최소 위치결정시간 우선 스케줄링(SPTex), Shortest
-Positioning
-Time
-ex)irst) ­ 가장 짧은 위치결정시간, 즉 탐색시간과 회전지연시간의 합이 가장 짧은 요청을 다음 서 비스 대상으로 선택 ­ 최소  탐색시간 우선(SSTex))과  같이  처리량이  많고  평균  반응시간은  짧으나,  가장  안쪽과  바깥쪽 실린더에 대한 요청이 무기한 연기될 가능성이 있음 ­ SPTex) 알고리즘 예 · 서로 인접한 곳에 위치해 있는 동일한 크기의 데이터 레코드 A와 B에 대한 요청을 가 정함 B 디스크 암(헤드) A ㆍ 에션바흐 기법(Eschenbach Scheme)
- 탐색시간과 회전지연시간을 최적화하기 위한 기법
- 헤드는 순환스캔(C
-SCAN) 스케줄링과 같이 진행하나 요청과 관계없이 트랙 한 바퀴 회 전할 동안 요청을 처리하도록 요청을 재배열함
- 1회전 동안 섹터 내의 많은 레코드들이 처리되어 회전지연시간을 줄임
- 회전은  한  방향으로  진행되므로  두  개의  요청이  실린더의  같은  섹터에  있으면  한  개의  요청만 처리되어 순환스캔(C
-SCAN) 스케줄링보다 성능 감소 ▶ 디스크 스케줄링 알고리즘의 선택 ­ 성능은 요청의 형태와 요청의 수에 좌우됨 · 큐가 하나 정도밖에 요청하지 않는다면 모든 스케줄링 알고리즘의 효과가 거의 같음 ­ 이 경우 선입 선처리 스케줄링이 적당함 · 디스크 서비스의 요청은 파일 할당 방법에 많은 영향을 받음 ­ 연속적으로 할당된 파일을 읽는 프로그램은 디스크 상의 인접된 범위 내에서 많은 요 청이 발생, 헤드의 이동을 제한함 ­ 링크 파일이나  색인  파일의  경우,  블록들이  디스크에  흩어져 헤드의  이동  거리는  길 지만 디스크 상용 효율은 높음 · 디렉터리 위치에 따라 이동거리가 달라짐 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 모든  파일은  개방(Open)되어야  사용  가능하며,  파일  개방을  위해  디렉터리  구조를  조사해야 하므로 디렉터리가 자주 호출됨 ­ 디렉터리를 디스크의 양 끝에 두는 것보다 중간 부분에 두는 것이 디스크 헤드 이동 을 줄일 수 있음 · 디스크는 시스템의 성능과 신뢰성 측면에서 병목현상의 주요 원인이 됨 ­ 컴퓨터 장치 중 가장 속도가 느림 ­ 전반적인 시스템의 성능은 아직 디스크의 속도와 신뢰성에 좌우됨 2. RAID ▶ RAID(Redundant Array of Inexpensive 또는 Independent) 개념 ­ 운영체제로 여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술 · 다수의 장치로 컴퓨터 성능 향상을 위한 연구 결과 · 디스크 장치를 독립적이며 병렬적으로 작동시키는 디스크 배열 개발 · 초기의 RAID ­ 프로세서와  디스크의  속도  차이를  극복하기  위해,  여러  대의  디스크장치를  이용하여  다수의 드라이브에 있는 데이터를 동시에 액세스할 수 있도록 데이터를 분산 저장 · 데이터의 중복에 대한 필요성을 효과적으로 해결하는데 도움을 줌 ▶ RAID 계층 ㆍ RAID 기법
- 여러 개의 하드 디스크를 하나의 논리적 가상 디스크로 구성, 대용량 저장장치로 사용할  수 있는 기법
- 데이터를  여러  개의  하드  디스크에  분할,  저장하여  전송속도를  향상시키고  시스템  가동  중 생길 수 있는 디스크의 오류를 시스템 정지 없이 교체 가능한 것이 특징임
- 총 6계층으로 분류되며, 서로 다른 용도로 사용됨 · 초기 제안자들이 6개로 구분했던 각 계층은 다양화됨 · 구성과 기능면에서 다르게 변했으므로 사용자의 목적에 맞는 계층 구성이 필요함 v 초기 6계층 외 여러 방식이 개발되었으나 RAID 0, RAID 1, RAID 0+1, RAID 5를 제 외한 나머지 방식들은 거의 사용되지 않음 ㆍ RAID 0
- 일련의 데이터를 하나의 논리적 디스크 배열에 일정한 크기로 나누어 분산 저장하는 기 법
- 데이터를 사용 가능한 디스크에 나누어 저장 · 사용자와 시스템 데이터는 하나의 논리 디스크상에 저장되어 있는 것으로 인식 · 디스크는  스트립(Strip)으로  나누어  연속적인  배열  첨자(구성요소)와  대응되도록  순환  할당됨 * Strip : 이정한 크기의 섹터 또는 물리적 블록 단위 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 스트라이프(Stripe)  :  하나의  스트립들과  각  배열의  구성요소가  대응하는  논리적으로  연 속적인 스트립들의 집합 · ■
-디스크 배열에서 첫 번째  n개의 논리 스트립들은 디스크 n개의 각각 첫 번째 스트 립으로 저장 · 두 번째 n개의 스트립들은 각 디스크의 두 번째 스트립들로 분산 저장됨  · 동일한 하드 디스크 여러 대를 병렬 방식으로 구성, 입출력 시간을 감소시킬 수 있음
- 하드 디스크 4개로 구성된 RAID 0계층 RAID 0 A B C D E ex) G H I J K L M N O etc... RAID 0(스트라이핑)
- RAID 0 계층은 스트라이프를 가지고 있으나 데이터를 중복해서 기록하지 않아 장애 발 생에 대비한 여분의 저장 공간을 가지고 있지 않음 · 어느 한 드라이브에서 장애 발생 시 데이터는 손실됨 · 안정성을 추구하는 RAID 시스템에 부합되지 않는다 할 수 있음
- 데이터를 입출력 할 때, RAID 컨트롤러에서 여러 개의 하드 디스크로 나눠 쓰고 읽음 · 중요하지 않은 데이터에 대한 빠른 데이터 입출력 성능이 요구되는 동영상 편집 등에  적합하지 않음 ㆍ RAID 1(미러링)
- 데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크가 동일한 데이터를 가지는 미러  디스크(Mirror Disk)를 가짐
- 각 논리적 스트립은 두 개의 별도 디스크에 대응되므로 미러링(Mirroring)이라고 함
- 중복 저장된 데이터를 가진 적어도 두 개의 드라이브로 구성 RAID 1 A A E E I I M M B B ex) ex) J J N N C C G G K K O O D D H H L L P P 미러링 미러링 미러링 미러링 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 읽기 요구 · 요구 데이터를 가지고 있는 두 개의 디스크 중 어떤 디스크에서도 서비스 받을 수 있 어 성능이 향상됨 · 데이터를 분할 저장하지 낳아 두 스트립이 갱신되어야 함
- 쓰기 요구 · 단일 디스크 드라이브의 경우와 동일하며, 병렬적으로 갱신됨
- 드라이브에  장애  발생  또는  데이터  손상  발생  시,  즉시  두  번째  디스크를  통해  액세스  가능 · 전체 용량의 절반이 여분의 데이터 기록을 위해 사용되어 지원하는 논리적 디스크 공 간의 두 배가 필요하므로 비용이 증가함
- 성능 · 읽기 요구가 많은 경우 높은 입출력 달성(RAID 0 보다 2배 증가) · 쓰기 요구가 많은 경우 RAID 0의 성능과 비슷함 · 시스템 드라이브 등의 중요 파일에 적합 ㆍ RAID 2(허밍코드를 통한 중복)
- RAID 2와 RAID 3은 병렬 액세스 기법 사용   · 모든 멤버 디스크는 모든 입출력 요구에 참여
- 디스크들  간에  데이터  스트라이핑을  사용하며,  오류  검출  능력이  없는  드라이브를  위해  허밍(Hamming) 코드 기법을 사용함 · 몇몇  디스크들은  오류  감지  및  수정을  위해  사용되는  오류정정코드(ECC,  Error  Correcting Code) 정보가 저장되어 있음 · 허밍  오류  정정코드는  패리티  비트를 사용, 디스크로부터  전송된  데이터에  오류가  있 는지 확인 및 오류 정정
- 오류정정코드는 각 데이터 디스크의 대응되는 비트들을 계산
- 우측의 ESS 디스크에 저장된 허밍코드를 이용, 오류 검출 및 정정 RAID 2 A0 A1 A2 A3 ECC/Ax ECC/Ay ECC/Az B0 B1 B2 B3 ECC/Bx ECC/By ECC/Bz C0 C1 C2 C3 ECC/Cx ECC/Cy ECC/Cz D0 D1 D2 D3 ECC/Dx ECC/Dy ECC/Dz A0 to A3 = Word A; ECC/Ax to Az Word A ECC; B0 to B3 = Word B; ECC/Bx to Bz Word B ECC;  C0 to C3 = Word A; ECC/Cx to Cz Word C ECC; D0 to D3 = Word D; ECC/Dx to Dz Word D ECC;
- 실시간 오류 수정이 가능함   · 현재의 SCSI 드라이브들이 자체 오류 검출 능력을 가지므로 별로 쓰이지 않음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 디스크 오류 발생이 많은 경우 효과적 · 디스크의 신뢰성이 높으면 낭비가 크므로 구현 자체가 제외된 경우가 많음 v 빠른 기록 속도와 함께 장애 복구 능력이 요구되는 경우에 사용됨 v 드라이브 두 대만으로 구성할 수 있어 작은 시스템에 적합함 ㆍ RAID 3(비트 인터리브된 패리티)
- 데이터 분산 저장을 위해 스트라이프 사용
- 오류 검출과 수정을 위해 별도의 드라이브 한 개를 패리티 드라이브로 사용함 · 내장된 오류 정정코드 정보는 오류를 감지하는 데 사용하며, 데이터 복구는 다른 드라 이브에 기록된 XOR을 계산하여 수행
- 각각의 데이터 디스크에 데이터를 비트 단위로 스트라이핑하여 기록 · 디스크에 입출력 할 데이터의 크기가 K바이트일 경우, N개의 디스크에 나누어져(K/N)  분산 저장되고 N+1 디스크에는 패리티 비트가 저장됨 · 바이트 단위의 분산 저장을 경제적으로 수행하기 위해 하드웨어적인 지원이 필요함 RAID 3 스트립 스트립 0 스트립 1 스트립 2 스트립 3 패리티 생성 0, 1, 2, 3 패리티 A0 A1 A2 A3 A 패리티  B0 B1 B2 B3 B 패리티 C0 C1 C2 C3 C 패리티 D0 D1 D2 D3 D 패리티
- 데이터는 스트립들로 나누어지므로 높은 데이터 전송률을 제공 · 병렬적 데이터 전송 가능
- 입출력 작업이 모든 드라이브에서 이루어지므로 파일서버(ex)ile Server) 등의 입출력이 빈 번한 곳에서의 사용이 부적합함 · 입출력 요청을 한 번에 한 요청만 실행됨 v 단일 사용자 시스템과 다량의 데이터 전송이 요구되는 CAD나 이미지 작업에 적합 ㆍ RAID 4(블록 인터리브된 패리티)
- 패리티  드라이브를  사용(RAID  3과  유사함),  각  드라이브에  데이터를  블록  단위로  분산  저장
- 데이터 분산 저장을 위해 스트라이핑을 사용
- 독립된 액세스 기법을 사용하여 디스크의 각 멤버는 독립적으로 동작, 각각 분리된 입출 력 요구들을 병렬로 처리 가능 · 많은 입출력 요청이 필요한 업무에 적합 · 높은 데이터 전송률을 필요로 하는 업무에 성능이 떨어짐
- 크기가 작은 입출력 요청 시 쓰기 성능이 저하됨 · 쓰기  요청  시  사용자  데이터와  함께  패리티  정보를  갱신,  추가시간이  소요(입출력의  병목 현상)됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 데이터 읽기 요청은 RAID 0과 비슷한 성능을 보임
- 여러  드라이브  중  한  대의  드라이브만이  여분의  패리티  정보를  기록하는데  사용되므로  용량당 비용은 높지 않음 · 저렴한 가격으로 장애복구 능력이 요구되거나 빠른 판독 속도 필요 시 사용됨 RAID 4 블록 블록 0 블록 1 블록 2 블록 3 패리티 생성 0, 1, 2, 3 패리티 A0 A1 A2 A3 A 패리티  B0 B1 B2 B3 B 패리티 C0 C1 C2 C3 C 패리티 D0 D1 D2 D3 D 패리티 ㆍ RAID 5(블록 인터리브된 분산 패리티 블록)
- RAID 4와 유사하나, 별도의 패리티 드라이브 대신에 모든 드라이브에 패리티 정보를 나 누어 저장 · 패리티를 담당하는 디스크의 병목현상을 일으키지 않음
- 다중 프로세스 시스템에서와 같이 작고 잦은 데이터 기록이 있는 경우 빠름
- 읽기 요청의 경우 각 드라이브에서 패리티 정보를 건너뛰어야 하므로 RAID 4보다 느림
- 최소한 3대, 일반적으로는 5대 이상의 드라이브가 필요 · 데이터는 각 데이터 영역에 블록 단위로 스트라이핑하여 저장
- 병렬 입출력이 가능하므로 기록과 읽기가 동시에 가능 · 데이터  입출력  성능이  빠르면서도  안전성  또한  높아  파일  서버  등  입출력이  빈번한  업무에 적합
- 현재 가장 널리 사용되는 RAID 방식 RAID 5 A 블록 B 블록 C 블록 D 블록 E 블록 A0 B0 C0 D0 0 패리티 A1 B1 C1 1 패리티 E1 패리티 생성 A2 B2 2 패리티 D2 E2 A3 3 패리티 C3 D3 E3 4 패리티 B4 C4 D4 E4 ㆍ RAID Level 0+1
- 스트라이핑 방식과 미러링 방식을 혼합한 형태로 각각의 장점을 살린 시스템
- 미러링은 반드시 똑같은 수의 디스크를 필요로 하므로, 디스크 두 개를 사용하여 스트라 이핑하려면 최소 네 대의 디스크가 필요함
- 쓰기 속도는 디스크 두 개로 스트라이핑 할 때와 같으며 디스크 네 개에 나눠서 읽어오 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 기 때문에 읽기 속도가 빠름
- 미러링으로 같은 디스크 복사본을 가지고 있어 디스크 오류 발생 시 복구가 가능함
- 디스크가 다수 필요하므로 안전성과 빠른 속도가 모두 필요한 중대형 서버에 많이 사용 함 RAID 0+1 A C A C B D B D 스트라이핑 스트라이핑 E G E G ex) H ex) H 미러링 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 파일 관리(1)

1. 파일 시스템의 개요를 알 수 있다. 12주차  수업목표  
2. 파일 개념에 대해 정리할 수 있다. 1교시  1. 파일시스템 세부내용  2. 파일 1. 파일시스템 ▶ 파일 시스템 개요
1) 파일 시스템의 개념 ­ 파일  자원을  관리하고  파일의  생성,  삭제  등  파일  액세스  및  제어에  대한  책임을  갖는  소프트웨어 ­ 파일의 저장 위치, 저장 방법, 저장 공간 활용, 파일 사용 할당, 파일 접근 횟수 등과 관 련된 복잡한 작업 수행 · 작업  수행을  위해  각  파일에  대한  정보를  수록한  디렉터리를  사용하여  해당  파일을  관리 ­ 디스크 저장소를 관리하는 것과 관련이 많음 · 메인 메모리 및 다른 매체에 저장된 파일 데이터 액세스 포함 ­ 사용자가 파일을 생성, 수정, 삭제할 수 있도록 지원 ­ 파일이 각 응용 프로그램에 적합한 구조로 구성할 수 있도록 지원함 ­ 파일 읽기, 쓰기, 실행 등이 다양하게 액세스되도록 제어된 방식 제공 ­ 설계를 위해 사용자 수, 사용자당 평균 파일 수와 크기 등 사용자들에 관한 지식 필요 ­ 해당 시스템에서 실행할 응용 프로그램의 특성을 이해, 적합한 파일 구성과 디렉터리 구 조를 결정
2) 파일 시스템의 기능 ­ 일반적으로 파일 시스템이 담당하는 기능
① 파일 관리 · 파일  저장,  참조,  제거  및  보호  기능을  제공하며  적절한  제어방식을  통해  다른  사 람의 파일을 공유, 다른 사람의 작업을 활용할 수 있게 함
② 보조 메모리 관리 · 2차 저장장치에 파일을 저장할 공간을 할당  
③ 파일 무결성 보장 · 파일에 저장된 정보가 손상되지 않도록 보장, 파일이 정의한 정보만 저장함
④ 파일 액세스 방법 · 저장된 데이터에 판독, 기록, 실행 등 여러 종류의 액세스 제어 방법 제공  
⑤ 파일 백업과 복구 · 사고로  정보를  손실하거나  고의로  손상시키는  일을  방지하기  위한  데이터  사본(중 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 복)을 생성하는 백업 및 손상된 데이터를 복구할 수 있는 복구 기능을 제공해야 함 v 사용하기 편리한 인터페이스 제공이 가장 중요한 요소임 ­ 사용자(어플리케이션)는  파일의  생성과  삭제,  파일에  대한  연산  수행을  위해  파일  시스 템과 상호 작용 ­ 모든 파일의 위치와 파일의 속성을 기술하는 디렉터리 사용 · 허가된 사용자만 특정 파일을 액세스할 수 있도록 사용자 액세스 제어 ­ 기본 연산(생성, 기록, 판독, 삭제 등)들은 레코드 수준에서 수행 · 파일은 레코드로 구성되는 여러 형태의 구조(순차, 인덱스 등)를 가짐 · 파일 구조에 타당한 액세스 방법을 사용하며 특정한 파일 조장 명령으로 실행 ­ 파일의 레코드들은 출력을 위해 블록화되어야 하며 입력 후에 블록이 해제 되어야 함 · 파일의 블록 입출력  지원을  위해  파일의  디스크의  미사용  블록에  할당하고  회수하는  등의 빈(가용) 공간 관리와 각각의 블록 입출력에 대한 요구들의 스케줄링이 필요함 v 디스크 스케줄링과 더불어 파일 할당은 성능의 최적화와 관계 있음 액세스 제어 액세스 방법 버퍼링(블로킹) 파일 할당 빈 공간 관리 파일 구조 레코드 블록 캐시 사용자 디렉터리 관리 파일 조작 제어기 캐시 디스크 스케줄링 논리적 관점 파일 관리 요소

3) 파일 시스템 구조  ­ 파일의 정의, 속성, 디렉토리 구조, 파일에 허용되는 연산 등을 표현하는 논리적 파일과  실제 디스크에 논리 파일 시스템을 사상(Mapping)하는 것으로 구분 ­ 계층적 파일 시스템 · 여러 계층(수준)으로 이루어져 있으며 각 계층은 낮은 계층의 서비스를 사용 어플리케이션 디렉터리 정보 논리 파일 시스템 보호 및 보안 파일 ↔ 블록  파일·구성 모듈 가용공간 관리 드라이버 호출 기본 파일 시스템 GET 블록 123 장치 드라이버  입터럽트 처리기  입출력 제어 입력 : GET 블록 123  출력 : 저급 명령어 장치 드라이버 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
① 장치 드라이버 · 주변장치,  장치  제어기나  채널들과  직접적으로  통신하며  장치에  대한  입출력  연산 의 시작과 입출력 요구의 완료 등 입출력을 수행
② 입출력 제어 · 장치  드라이버  루틴과  인터럽트  처리기로  이루어지며  명령어를  해석,  메모리와  디 스크 시스템 간의 정보 전송을 담당
③ 기본 파일 시스템 · 물리적 입출력 수준으로 컴퓨터 시스템의 외부 환경과의 주요한 인터페이스 · 물리적  블록을 읽거나 쓰기  위해 적절한 장치 드라이버를 호출(명령)하는 계층, 디 스크에서 블록을 배치하는 것과 관계됨 · 각 디스크 블록은 숫자로 표시된 디스크 주소에 의해 식별됨
④ 파일⋅구성 모듈 · 특정 파일의 논리 블록과 물리 블록에 대한 정보뿐 아니라 파일의 할당 및 파일의  유형 정보를 이용, 파일에 대한 논리 블록 주소를 물리 블록 주소로 변환, 기본 파 일 시스템에서 이동할 수 있도록 함 · 디스크의 빈(가용) 공간을 파악
⑤ 논리 파일 시스템 · 사용자들이  파일  이름과  디렉터리  등의  정보를  이용하여  레코드를  처리(액세스)한  후 하위 층에 넘겨줌 · 보호에 관한 일도 수행함 · 논리적 입출력은 레코드 입출력 기능을 제공, 파일들에 관한 기초 데이터를 유지함 ㆍ 블록
- 파일은 디스크의 하나 이상의 블록에 저장, 블록은 메모리와 디스크 간의 전송 단위임
- 디스크에 하나 이상의 섹터들로 구성, 블록 할당 방법은 운영체제에 따라 다름
- 운영체제는  파일에  속하는  정보를  블록에  유지하며  0에서  시작하는  연속  정수를  통해  일부 최대수에 이르는 논리 블록 번호를 사용
- 논리 블록 번호는 물리적 디스크 주소(트랙, 실린더, 표면, 섹터)로 변환됨   · 변환은 장치 드라이버가 수행하며 디스크 제어기에 낮은 수준의 하드웨어 명령어로 전 달됨
- 논리적 파일의 물리적 장치로의 사상   · 가상 블록 번호(VBN, Virtual Block Number), 즉 논리적 파일을 파일 시스템에 의해  논리 블록 번호(LBN, Logical Block Number), 즉 물리적 파일로 사상하는 과정 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr VBN LBN 블록 4 블록 24 0 jki def pqr 1 def 운영체제 블록 33 블록 120 2 ghi mno abc 3 abc 블록 558 블록 26433 4 mno jki ghi 5 pqr 558 물리적 파일 논리적 파일 파일 주소 (디스크 파일) ㆍ 메타 데이터(Mata data)
- 저장장치의 가용 블록 위치나 파일이 마지막으로 수정된 시간 등 여러 데이터를 포함한  데이터
- 파일 시스템에 대한 크기, 가용 공간, 루트 데이터 위치, 가용 리스트 등의 정보와 파일 에 대한 소유자, 크기, 블록 위치, 액세스 시간 등의 정보를 가짐
- 사용자가 직접 수정할 수 없으므로 파일 시스템의 무결성을 유지함 ㆍ 마운팅(Mount)
- 시스템에서 새로운 파일 시스템을 사용하기 위해, 파일 시스템이 미리 제공된 파일 시스 템의 디렉터리에 설치되는 절차 · 운영체제는 여러 파일 시스템을 마운트 할 수 있는 기능을 제공
- 여러 파일 시스템을 단일 파일 시스템에서 식별할 수 있는 파일 집합으로 결합 · 운영체제에  마운트하려는  파일  시스템의  저장  위치(장치의  이름)와  새로운  파일  시스 템의 설치(올려 놓을) 지점, 즉 마운트 포인트를 제공함으로써 이루어짐
- 마운트 테이블을 사용, 마운트된 디렉터리들을 관리함 · 마운트 테이블은 마운트 지점 경로명과 마운트된 각 파일 시스템을 저장하고 있는 장 치에 관한 정보를 포함함
- mount 명령을 이용, 새로운 파일 시스템(/dev/sda6)을 초기 파일 시스템의 /mnt/로 액 세스 할 수 있도록 마운트하는 과정 · 초기  파일  시스템의  디렉토리  이름  앞에  /mnt를  삽입한  경로명(mnt/dir1  또는  mnt/dir2)을 사용 · 신규 파일 시스템(/dev/sda6)에 액세스 할 수 있음 · 파일  시스템이  마운트되어  있으면,  사용자는  해당  파일  시스템이  다시  언마운트 (unmount)될  때까지  마운트  지점에  있든  디렉토리(cdrom  등)의  내용을  사용할  수  없음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 초기 파일 시스템 / /bin /boot /etc /dev /home /lib /mnt 신규 파일 시스템 /lost+found /cdrom /dir1 /lost+found /rsimms /fioppy /dir2 /grub /dev/sda5 /hgfs /lost+found /dev/sda1 /hgfs /dev/sda6 마운팅 전 파일 시스템 2. 파일 ▶ 파일 개념 ­ 서로 관계 있는 정보의 집합체 또는 레코드들의 집합체 · 작성자에  의해  정의된  많은  종류의  서로  다른  형태의  정보,  즉 원시 프로그램, 목적 프 로그램, 숫자, 데이터, 텍스트, 도형 이미지, 소리 등이 기록 · 사용 목적에 따라 특별한 구조를 지님

1) 파일 구성 ­ 파일 내용은 운영체제에 의해서 물리적 장치에 저장 ­ 사용자의  관점에서  파일은  논리적으로는  저장되는  기본  단위로서  프로그램과  데이터를  가질 수 있음 ­ 논리적 파일을 실제 저장장치로 매핑시키는 작업은 운영체제가 담당함 종업원 =1  레코드 이름 급여 근무부서 JOEDOE 0567128 OPERATIONS 문자 필드 물리적 장치 파일 구성 요소 ­ 파일 구성 요소는 다음과 같음 
① 항목(필드) · 바이트의 모임으로 데이터 파일을 구성하는 기본적인 구성요소로 의미 있는 데이터 의 가장 작은 단위 · 필드 길이는 미리 정해지는 것이 보통이나 때로는 고정 길이 또는 가변 길이를 가 짐 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 고정길이 필드는 포함할 문자나 바이트의 수가 미리 결정된 필드 · 가변길이 필드는 입력하는 데이터의 크기에 맞도록 최대 한계의 길이까지 확장
② 레코드 · 파일을  구성하는  요소는  레코드이며,  레코드를  구성하는  요소는  필드이며,  하나의  파일에 여러 개의 레코드가 들어 있음 · 고정된 길이 또는 가변 길이로 구성, 필요에 따라서 파일을 구성하는 레코드 몇 개 가 모여 하나의 블록을 형성하기도 함 · 고정길이 레코드는 직접 액세스하기 쉬워 가장 일반적인 형태이나 레코드의 크기가  너무 작은 경우 남은 문자열들은 잘리고, 너무 크면 저장 공간이 낭비됨 · 가변길이 레코드는 고정길이의 단점을 해결하나, 레코드의 정확한 위치를 파악하기  어려워 직접 액세스하기 힘들고, 대부분 순차처리에 적합함 서브항목 1 서브항목 2 서브항목 3 항목 1 항목 2 항목 3 항목 N 레코드 레코드 1 레코드 2 레코드 3 레코드 N 블록 블록 1 블록 2 블록 3 블록 N 파일 필드, 레코드, 블록 및 파일의 관계

2) 파일 이름 명명 ­ 심볼릭 이름을 사용하여 파일을 참조(조회)할 수 있어야 하며 유일한 이름이어야 함 · 사용자에 의해 아스키 문자로 작성되며 운영체제마다 길이가 다름 ­ 파일은 루트 디렉터리로부터 각 트리 구조에 도달하는 경로를 따라 위치 ­ 특정 파일을 위한 경로명은 디렉터리 이름과 파일의 이름으로 구성 ­ 디렉터리 계층 구조 · / : 경로명에서 이름을 구분하기 위한 기호 김정수 루트이름 프로젝트 교육과정 제안서 bin etc 수학과 usr dev 556 570 656 교직원 교수 졸업생 프로그램 Donald 박성식 김정수 a1 a2 a3 a4 a5 a6 프로젝트 교육과정 제안서 p3.h p3.c p3 556 570 656 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
3) 파일 속성 ­ 시스템이 파일을 관리하는 데 필요한 정보로, 속성을 포함하는 파일 제어 블록은 디스크 (2차 저장소)에 저장 ­ 파일을 열 때 파일의 연산의 효율성을  높이기 위해, 즉 탐색시간을 단축하기 위해 열린  파일 정보(테이블)를 메인 메모리에 유지함 ­ 속성은  파일  시스템의  구현에  다라  다르나,  일반적으로  디렉터리와  파일  헤더의  데이터  구조로 구성됨 디렉터리 파일 인덱스 파일 헤더 파일  이름 데이터 또는 파일 인덱스 속성 인덱스 블록 주소 파일 인덱스 파일 헤더 파일  데이터 또는 파일 속성 인덱스 블록 주소 디렉터리와 파일헤더 ­ 다음과 같은 속성(파일 관련 정보를 기술하는 항목)들을 제공함  · 파일 이름 : 사용자들이 이해할 수 있는 형태로 붙여짐 · 파일 타입 : 다양한 파일 형식을 지원하는 시스템의 경우 필요함 · 저장 위치 : 파일이 저장된 장치와 그 장치 위치에 대한 포인터 · 파일 크기 : 파일의 현재 크기와 경우에 따라 최대 허용 가능한 크기도 포함 · 액세스 제어 데이터 : 파일 읽기, 쓰기, 실행 등 권한(액세스) 제어에 관한 정보 · 소유자 : 파일 최초 생성자 · 레코드 크기 : 고정된 크기 또는 최대 크기 등 레코드 종류에 따라 다름 · 시간, 날짜, 사용자 식별 정보 : 생성시간, 수정변경시간, 최근 사용된 시간들을 유지,  이들 정보는 파일의 보호, 보안 및 사용자 감시를 위해 사용 ­ 디렉터리에는 파일 이름에 의한 파일 인덱스 사상과 여러 개의 파일이 존재함 · 모든 파일 속성을 유지하는 ex)AT와 같은 작은 규모의 파일 시스템이 존재함 ­ 각 파일에 존재하는 파일 헤더는 파일 속성과 내용을 저장함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 계층 구조의 디렉터리와 파일 헤더
4) 파일 유형 ­ 파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있음 ­ 각각의 파일은 그 파일을 다루는 프로그램에 의해 인식 가능한 내부 구조를 일정한 형태 로 가짐 ­ 운영체제는  그  시스템이  지언  가능한  파일  구조를  정의,  그러한  구조를  가지는  파일을  다룰 수 있는 특별한 연산 기능을 제공함 ­ 파일 이름의 한 부분으로 파일 유형을 나타냄 · 파일 이름을 마침표로 구분, 이름과 확장자의 두 부분으로 구성 파일 형태 일반적 확장자 기능 실행 기능 exe, com, bin 등 이진 수행 기능 프로그램 소스코드 c, p, pas, f77, asm, a 다양한 언어로 된 소스 코드 배치 bat, sh 명령어 해석기에 대한 명령 문서 txt, doc 텍스트 데이터, 서류 워드 프로세서 wod, hwp, doc, 기타 다양한 워드 프로세서 형식 라이브러리 lib, a, DLL 프로그래머들을 위한 라이브러리 루틴 관련된 파일들을 하나로 묶어서 보관하는  백업 보관 arc, zip, tar 것으로 저장을 위해 압축도 가능
5) 파일 구조 ­ 파일을  구성하는  레코드들이  보조기억장치에  배치되는  방식으로,  자주  사용되는  방식은  아래와 같음
① 순차 파일 · 레코드는 고정된 크기로 같은 수의 필드로 구성, 물리적 순서에 따라 저장됨 · 순차 파일 구조는 테이프장치뿐만 아니라 디스크에 쉽게 저장되는 유일한 구조 · 파일의  순차적 탐색으로 레코드에  대한  액세스가  지연될  수  있으며  레코드 추가가  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 어려움 · 순차  파일을  연결  리스트로  구성,  레코드  추가를  포인터  조작으로  해결  가능하나  부가적인 오버헤드 발생 데이터 1 데이터 2 데이터 3 데이터 4 데이터 n
② 인덱스 파일 · 순차 파일의 단점 극복을 위해 인덱스 순차 파일을 구성, 단일(키) 필드를 기반으로  순차적으로 구성 · 순차  파일의  특성을  유지하므로  키  필드  외에  다른  속성으로  검색이  필요한  경우  적합하지 않음 · 유연성을 제공하기 위한 파일 구조로 순차성과 단일 키의 개념을 없애고 레코드 자 신의 인덱스를 통해 참조하는 방법 · 레코드는  각  레코드의  키에  따라  논리적  순서대로  배열,  시스템은  일부  주요  레코 드의 실제 주소가 저장된 인덱스(Index)를 관리함 완전 완전  부분  인덱스 인덱스 인덱스 주파일(가변 길이 레코드) · 인덱스 유형은 완전 인덱스와 부분 인덱스가 존재함 · 완전  인덱스  :  파일에  있는  레코드들을  위해  하나의  항목을  포함,  순차  파일로  구 성 · 부분 인덱스 : 찾고자 하는 필드가 포함된 레코드를 위한 항목을 가리킴 · 가변  길이  레코드에서  어떤  레코드는  필드를  포함하지  않으므로  새로운  레코드가  파일에 추가되면 모든 인덱스 파일을 갱신해야 함
③ 직접 파일(해시 파일) · 파일  내의 레코드들은  일정한  순서를  유지할  필요  없으며,  레코드  중  특정  항목을  키로 하여 기억 가능한 주소 계산, 이 주소에 레코드를 기억시킴 · 키 값이 순차적으로 되어있는 경우보다 그렇지 않은 경우가 많아, 별도의 주소계산  루틴을 만들고 이 루틴을 통해서 주소를 생성하는 방법을 사용 · 레코드의  키를  입력하면  해싱  함수(Hashing  ex)unction)에  의해  주소가  계산,  물리 적인 기억장치의 기억 장소에 대응됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 0 키 주소 1 해싱함수 101 102 103 104 105 106 107 ■
-2 ■
-1
④ 분할된 파일(Partitioned ex)ile) · 여러 개의 순차 서브파일(Subfile)로 구성된 파일 · 파일을  구성하는  각각의  순차  서브파일을  멤버라  하며,  각  멤버의  시작  주소는  파 일의 디렉터리에 저장 · 프로그램 라이브러리(Program Library)나 매크로 라이브러리(Macro  Library)를 저 장할 때 사용

6) 파일에 대한 연산 ­ 파일은 저장할 수 있는 어떤 정보를 표현하는 논리적인 요소로 추상적인 데이터 형태 ­ 나중에 사용하기 위한 정보를 저장하는 수단 ­ 연산 과정
① 파일 생성 · 파일 생성을 위해 2단계가 필요함 ­ 파일을 위해 파일 시스템에 있는 공간을 발견해야 함 ­ 새로 생성한 파일에 대한 항목을 디렉터리에 만들어 파일의 이름과 파일 시스템  내의 위치를 기록
② 파일 기록 · 파일명과 파일에 기록할 정보를 표시하는 시스템 호출을 수행 · 파일명이 주어지면 시스템은 파일의 위치를 알기 위해 디렉터리를 탐색 · 디렉터리 항목에는 파일의 현재 블록에 대한 포인터를 기록, 이 포인터를 사용하여  다음 블록의 주소를 계산하고 정보를 기록할 수 있음 · 기록 포인터(Write Pointer)는 갱신됨
③ 파일 판독 · 파일은  판독되거나  기록되므로  두  개의  포인터(판독  포인터,  기록  포인터)를  가질  수 있음 · 대부분의 시스템은 하나의 현재 파일 포인터를 가짐 · 판독과 기록 동작은 포인터를 사용, 디렉터리 항목 내의 공간을 절약하고 시스템의  복잡성을 감소시킴
④ 파일 재설정(=파일 탐색) · 현재의 파일 포인터를 조정 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 포인터 값만 바꾸는 것이므로 실제적인 입출력을 할 필요 없음 · 디렉터리가 탐색되면 현재 파일 위치는 파일의 첫 부분으로 재설정(Reposition)됨
⑤ 파일 삭제 · 파일을 삭제하기 위해 지명된 파일을 디렉터리에서 찾음 · 관련  디렉터리  항목  발견  시,  해당  파일의  모든  공간을  해제시키고  디렉터리  항목 을 무효화시킴 · 해당 파일 공간은 다른 파일이 재사용 가능
⑥ 파일 크기 조절 · 파일의 크기를 변경하는 작업 v 이 외, 파일 편집, 내용 수정, 복사 작업 가능 v 파일은 이름이 부여된 객체이므로 현존하는 파일에 다시 이름 부여 가능하며, 목적코드  형태의 파일은 실행 가능함 ▶ 액세스 방법 ­ 파일은 정보를 저장, 저장된 정보는 액세스되어 컴퓨터 메모리에 저장됨 ­ 액세스 : 컴퓨터 메모리에 저장된 데이터를 찾아서 가져오는 과정

1) 순차 액세스 ­ 파일에 있는 정보는 레코드 단위의 순서로 처리되는 것이 일반적임 ­ 파일에서 대부분의 동작은 읽기와 쓰기 · 읽기 동작은 파일의 다음 부분을 읽은 후 자동적으로 파일 포인터를 증가시킴 · 기록은 파일의 끝에 추가, 기록된 내용의 끝으로 포인터는 이동 ­ 파일은 시작 위치로 재설정 될 수 있고, 어떤 시스템에서 프로그램은 정수 n개의 레코드 를 앞뒤로 건너뛸 수 있음 현재 위치 시작 끝 되감기 판독 또는 기록 순차 액세스 방법
2) 직접 액세스 ­ 어떠한 블록도 직접 읽거나 쓸 수 있으며, 읽기나 기록은 순서가 없음 · 대규모의 직접 액세스 가능 ­ 직접 액세스 파일은 어떠한 블록도 직접 읽거나 쓸 수 있으며, 읽기나 기록의 순서에 제 약이 없음 · 대규모의 정보를 직접 액세스하는 데 유용하며, 대규모 데이터베이스가 이에 해당함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 어떤 과제에 대한 질의(Query)가 들어오면 어떤 블록이 그 해답을 가지고 있는지 계 산하고 원하는 정보 제공을 위해 직접 정보를 읽어 들임 ㆍ 인덱스 순차 액세스 방법
- 직접  액세스  방법을  기반으로  인덱스를  구성,  탐색하고  포인터를  사용해서  파일을  액세 스
- 큰 파일도 적은 입출력으로 탐색 가능하며, 인덱스는 1차, 2차 인덱스 파일을 구성하여  처리 가능
- IBM의 ISAM(Indexed Sequential Access Methods) 파일 구조 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 파일 관리(2)

1. 디렉터리 시스템을 이해하고 설명할 수 있다. 수업목표   12주차 
2. 디스크 할당 방법들을 알 수 있다. 1. 디렉터리 시스템 2교시  2. 디스크 할당 방법 세부내용     
- 연결 할당    
- 인덱스 할당 1. 디렉터리 시스템 ▶ 디렉터리 시스템 ­ 기호 테이블(Symbol Table)로 구성되며 두 개의 분리된 디렉터리 구조
① 장치 디렉터리 ­ 각 실제 장치에 저장되어 있으며 장치에 있는 파일의 물리적 속성 등을 나타냄
② 파일 디렉터리 ­ 모든 파일의 논리적 구성으로 이름, 파일  유형, 소유하고 있는 사용자,  계정  정보, 보호  액세스 코드 등 기술 ㆍ 디렉터리 개요
- 장치 디렉터리는 단일 사용자 시스템에서는 충분하나, 저장 공간의 양과 사용자 수가 증 가하면 사용자들은 모든 파일에 대한 구성과 추적이 어려워 짐
- 이를 해결하기 위해 다른 디렉터리 구조를 추가, 파일 시스템에 있는 파일들을 구성
- 디렉터리 · 파일  시스템에서  다른  파일들의  이름과  위치  정보를  담고  있는  파일,  사용자  데이터  저장 안 함 · 장치의 범위를 확장할 수 있으며, 다른 디스크 장치 포함 가능 · 디렉터리 내의 정보 중 일부는 사용자 또는 애플리케이션이 이용 가능하나, 대부분 시 스템 루틴에 의해 사용자에게 간접적으로 제공됨
- 디렉터리 내 각 파일의 정보는 운영체제마다 다르나, 대체로 아래의 내용이 포함됨 · 파일명 : 기호로 된  각 파일의 이름은 사람이 읽을  수 있어야 하며,  특정  디렉터리에 서는 유일한 이름이어야 함 · 파일 형태 : 다른 유형들을 제공하는 시스템들을 위해 필요함 · 위치 : 파일이 존재하는 장치와 위치에 대한 포인터(경로명) · 크기 : 바이트, 워드, 혹은 블록들로 나타내며 파일의 현재 상태 크기와 최대 허용 가 능한 크기를 포함 · 현재 위치 : 파일에서 현재의 판독이나 기록이 행해지는 위치의 포인터 · 사용 수 : 현재 개방된 파일을 사용하는 프레임 수 · 시간,  날짜,  처리  식별 :  생성  시간,  수정 시간, 마지막  액세스  시간  등을 위해  유지,  보호와 사용 감시를 위해 이용됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 서브 파일 디렉터리 디렉터리 디스크 장치 컴퓨터     디렉터리와 파일    ▶ 디렉터리 구현 ­ 디렉터리 공간 할당 및 관리 방법은 파일 시스템의 효율성과 신뢰성에 영향을 미침 ­ 대부분의 디렉터리는 파일명, 파일 인덱스의 내용(리스트)을 포함하는 파일 ­ 리스트 디렉터리 구현 방법은 아래와 같이 구분 ㆍ 선형 리스트
- 디렉터리에 파일 이름, 포인터들의 선형적 리스트를 구성, 파일의 생성 및 삭제 실행
- 파일을 찾기 위해 선형 탐색 때문에 오버헤드 증가로 시스템 성능이 저하됨 ㆍ 해시 테이블(Hash Table)
- 파일의 이름을 제시하면 해시로부터 값(포인터)을 얻어서 리스트를 직접 액세스 함
- 디렉터리 탐색 시간을 줄이고 성능을 개선시켜 자주 이용됨
- 둘 이상의 파일명이 같은 위치를 지정하는 경우 충돌이 발생할 수 있으나 보완으로 삽입 과 삭제가 쉽게 수행됨
- 해시 테이블이 고정된 크기를 가지며, 해시 테이블 크기에 따라 해시 기능도 제한 받음
- 체인 오버플로우 해시 테이블을 사용하여 충돌 해결 가능 · 각 해시 항목은 하나의 값이 아니라 연결 리스트가 되고, 새로운 항목을 연결 리스트 에 추가, 충돌을 해결함 ▶ 디렉터리 연산 ­ 디렉터리에 대해 실행되는 연산은 다음과 같음
① 탐색 ­ 파일들이 기호로 된 이름(Symbolic Name)을 가지며, 이 이름들은 파일 상호 간의 연관 성을 나타내므로 특정 파일을 찾기 위해 디렉터리를  탐색함
② 파일의 생성 ­ 새로운 파일들을 생성하여 디렉터리에 추가
③ 파일의 삭제 ­ 필요하지 않은 파일들을 디렉터리에서 지움 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
④ 파일의 열람 ­ 디렉터리의 내용이 되는 파일들을 보여주고 각 파일에 대한 디렉터리 항목값을 보여줌
⑤ 파일의 재 명명  ­ 파일의 이름 변경
⑥ 파일 시스템의 순회 ­ 파일 시스템의 여러 디렉터리를 순회해 다니며 파일들을 볼 수 있게 해줌
⑦ 예비(Backup) ­ 신뢰성을 위해 일정한 시간마다 파일 시스템의 내용과 구조를 자기 테이프에 복사 ­ 백업한 디스크 공간은 다른 목적으로 전용이 가능 ▶ 디렉터리 구조
① 1단계(Single Level) 디렉터리 ­ 가장 간단한 디렉터리 구조로 모든 파일이 같은 디렉터리에 있어 유지와 이해가 쉬움 ­ 파일  수가  증가하거나  다수의  사용자가  있을  때  모든  파일이  같은  디렉터리  내에  있어  모두가 고유한 이름을 가져야 함 · 파일명은 보통 내용과 관련된 이름을 가지나 시스템이 정하는 길이의 제한을 받음 · 파일  수가  많을  때는  고유한  이름으로  새  파일을  생성해야  하므로  모든  파일명을  기 억해야 함 파일명 파일형태  기억장소 디렉터리 ex) ex) ex) 파일   ex)   ex) ■
② 2단계 디렉터리 ­ 사용자 간 파일명 혼란 예방을 위해 각 사용자에게 다른 디렉터리를 만들어 사용하도록  함 · 모든 파일들은 물리적으로 같은 장치에 있게 되므로 대형 시스템에서는 사용자 디렉터 리가 물리적이기 보다는 논리적 구성을 가짐 ­ 각  사용자는  자신의  사용자 파일 디렉터리(Uex)D,  User  ex)ile  Directory)를 갖고,  각  Uex)D 는 유사한 구조(선형, 이진 혹은 해시)를 가지면서 오직 한 사용자의 파일만을 나타냄 ­ 파일 이름 충돌 문제의 해결과 다른 사용자가 액세스 할 수 없다는 장점을 가짐 ­ 두 사용자가 한 파일을 공유해서 사용해야 하는 경우 문제 발생 · 서로가 자신의 Uex)D 액세스를 허용하지 않으면 공유가 불가능 함 · 액세스를 허용하려 해도 다른 사용자 디렉터리 밑에 이는 파일의 이름도 알아야 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 2단계 디렉터리 구조 · 한 사용자의 업무를 시작하거나 새로 등록(로그인)할 때, 각 사용자의 이름 또는 계정  번호 인덱스와 사용자 디렉터리에 대한 각 항목 포인터가 있는 마스터 파일 디렉터리 (Mex)D, Master file Directory)를 먼저 탐색함 마스터 파일 사용자 1 사용자 2 사용자 3 사용자 4 디렉터리 사용자 파일 cat bo a test a date a test x date a 디렉터리 파일 v 사용자들이 완전히 독립적일 때는 장점이나 서로 협력 또는 공유가 필요한 경우 단점이  됨 ­ 경로명 · 루트는  마스터  파일  디렉터리이고,  그  아래  사용자  파일  디렉터리이며,  그  아래  파일 이 있음 · 파일은 트리의 잎(Leaf) · 사용자  이름과  파일명  명시는  루트(마스터  파일)  디렉터리로부터  잎(특정파일)까지의  경로를 정의한다고 하며, 경로명이라 함 · 시스템 내의 모든 파일은 유일한 경로명을 가지며, 원하는 파일의 경로명을 알아야 해 당 파일을 지정 가능 · 모든 시스템은 파일을 지명하기 위한 각각의 문법(Syntax)를 가짐 ­ MS
-DOS 시스템은 파티션을 글자 뒤에 콜론(:)을 붙여 나타냄 ­ VMS는  logincom  파일은  u:[sstjdeck]logincom;1으로  u는  파티션의  이름,  sst는  디렉터리의 이름, jdeck는 서브 디렉터리 이름, 맨 뒤의 1은 버전을 나타냄 ­ 탐색 경로(Search Path) · 자동적으로 특수한 시스템 디렉터리를 탐색하는 순서 · 경로는 수시로 변경 가능 ㆍ 트리 구조 디렉터리
- 2단계 디렉터리는 높이가 2인 트리 구조임
- 디렉터리 구조를 확장하는 일반적인 방법
- 사용자들이 자신의 서브 디렉터리(Sub Directory)를 생성, 그곳에 자신의 파일을 구성함
- 트리는 하나의 루트 디렉터리를 가지며, 시스템 내의 모든 파일은 유일한 경로명을 가짐 · 디렉터리는  파일들이나  서브  디렉터리를  가지며,  모든  디렉터리들은  내부적으로  똑같 은 형식을 가짐 · 각 항목 속 한 비트를 지정, 파일(0), 서브 디렉터리(1)로 항목 구분
- 디렉터리 생성 및 삭제를 위해 특별한 시스템 호출을 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 파일의 참조가 일어나면 현재 디렉터리를 검색 · 현재 디렉터리에 없는 파일 사용 시 경로명을 주거나 시스템 호출로 현재 디렉터리를  변경
- 사용자 작업 시작 또는 사용자가 등록할 때 운영체제는 사용자에 대한 항목 검색 · 사용자에 대한 첫 번째 디렉터리 포인터(또는 이름)는 계정 파일에 들어 있으며, 사용 자의 지역 변수가 지정, 사용자의 현재 디렉터리를 명시함
- 경로명은 절대(완전) 경로명과 상대 경로명이 있음
① 절대 경로명 : 루트에서부터 지정된 파일까지 모든 경로가 지정되어 있음
② 상대 경로명 : 현재 디렉터리의 위치를 기준으로 목적하는 파일까지의 경로를 지정
- 디렉터리 삭제 방법 · 디렉터리가 비어 있다면 항목은 간단히 삭제 됨 · 비어있지 않는 경우 삭제되지 않으므로 먼저 그 디렉터리의 모든 파일을 삭제해야 함 · 삭제  요청  시  그  디렉터리에  있는  모든  파일과  서브  디렉터리의  모든  파일이  제거된 다는 가정 하에, 삭제가 이루어 지는 경우 · 두 방법 모두 구현이 쉽고 선택은 필요에 따라 이루어짐 루트 디렉터리 spell bin programs root stat mail dist find count hex reorder p e mail prog copy prt exp reorder list find hex count list obj spell all last first 트리 구조에서의 디렉터리     ▶ 연속 할당 ­ 파일들을 디스크의 연속적인 주소들의 집합에 할당 · 순서에 의해 블록 b 다음에 블록 b+1을 액세스 하는 데 헤드의 이동이 필요하지 않음 · 한 실린더의 마지막 섹터에서 다음 실린더의 첫 번째 섹터로 오직 1트랩만 헤드가 이동 · 연속적으로 할당된 파일들에 액세스하기 위해 필요한 디스크 탐색 횟수를 최소화함 · 한 파일의 연속 할당은 주소와 첫 번째 블록의 개수에 의해 정의됨 ­ 파일이 n개의 블록 길이를 갖고 b의 위치에서 시작할 때, 이 파일은 블록 b와 b+1,  b+2, … , b+n
-1개의 블록들을 차지함 ­ 각 파일의 항목은 시작 블록의 번지와 이 파일을 위해 할당된 영역의 길이를 표시 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 디렉터리(파일 할당 테이블) 파일명 시작블록 길이 count 0 2 tr 14 3 mail 19 6 list 28 4 f 6 2 디스크 공간의 연속 할당 · 연속적으로 할당된 파일에 액세스하는 것은 매우 쉬우므로 임의(직접) 액세스가 가능 · 순차적 액세스의 경우 파일 시스템은 마지막으로 참조된 블록의 디스크 주소를 기억, 필 요할 때 다음 블록을 읽음 ­ 블록 b에서 시작되는 파일의 i번째 블록에 직접 액세스하기 위해 b+i 블록에 액세스 함 · 순차적 액세스, 직접 액세스 모두 연속 할당 기법 지원 · 새로운 파일을 위해 연속적인 빈 공간을 찾는 것이 중요함  ­ 새로  생성되는  파일이  n의  길이를  가진  블록일  경우,  빈  공간  리스트에서  n개  크기 의 비어있는 연속적인 블록을 찾아야 함 ­ 연속 할당의 문제점 · 빈 공간 리스트로부터 크기 n의 요구사항을 만족시키는 방법 ­ 사용 가능한 빈 영역 선택을 위해 ‘최초 적합’, ‘최상 적합’ 그리고 ‘최악 적합’기법 사 용 · 외부 단편화 발생 ­ 파일들이 할당되고 삭제되면서 디스크 공간들은 조그만 조각들로 나뉘어짐 ­ 전체 디스크  공간이  요구량을 만족시킬  때도,  연속된  공간이 아닐  경우  외부  단편화  발생 ­ 디스크 전체 크기와 평균 파일 크기에 따라 다르게 나타남 ­ 해결  방법  :  재포장  루틴(Routine)  수행,  플로피  디스크를  완전히  비워  연속  사용가 능 공간 생성 * 재포장 루틴 : 사용자가 전체 파일 시스템을 다른 플로피 디스크나 테이프에 복사 · 파일 공간 크기 결정 ­ 파일을 위해 얼마나 많은 공간이 필요한지 결정 ­ 생성자는 파일 복사 등의 과정을 통해 생성할 파일의 크기를 확인 ­ 출력되는 파일의 크기를 평가하는 것은 어려우며, 이를 해결하는 방법은 다음과 같음 * 사용자 프로그램이 오류 메시지를 출력하고 종료되면 사용자가 더 많은 공간을 할당,  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 프로그램을 다시 수행시키는 방법 ­ 비용이  더 들 수 있으므로 사용자는 일반적으로 필요한  공간의  양을 크게  추정하 고, 이로 인해 공간이 낭비됨 * 아주 큰 공간을 찾아서 파일의 항목들을 새로운 공간에 복사, 이전 공간을 해제시킴 ­ 시간의 제약을 받음 2. 디스크 할당 방법 ▶ 연결 할당 ­ 각 파일은 디스크 블록들의 리스트에 연결됨 · 디스크 블록들은 디스크 내의 어느 곳에 흩어져 있어도 상관 없음 · 디렉터리는 파일의 첫 번째와 마지막 블록들의 포인터를 가지고 있음 블록 포인터 블록 포인터 · 디스크 공간의 연결 할당 ­ 다섯 개의 블록으로 구성된 파일이 블록 9에서 시작하여 블록  16으로 연결, 블록  1 로, 블록 10으로, 마지막 블록 25로 연결되어 있다 가정함 ­ 각 블록은 다음 블록의 포인터를 가지고 있으며, 사용자는 이 포인터를 사용할 수 없 음 ­ 섹터가 512 워드로 구성되어 있을 때, 디스크 주소는 두 개의 워드를 필요로 함 ­ 사용자는 510 워드의 블록 사용 가능 디렉터리(파일 할당 테이블) 파일명 시작블록 길이 jeep 9 25 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 파일 생성 및 읽기
- 장치 디렉터리 내에 새로운 항목들 생성
- 파일의 첫 번째 디스크 블록의  포인트를 가지며 nil(리스트의 마지막 포인터 값)로 초기 화되면 빈 파일임을 나타냄
- 파일을 읽기 위해 블록에서 블록까지의 포인터를 따라가며 각 블록을 읽음
- 외부 단편화가 없음 · 모든 블록들이 함께 연결, 빈 공간  리스트의 각  사용가능 블록들은 요구 사항에 만족 함 ㆍ 문제점
- 순차 액세스 파일에 적합 · 디스크 공간의 압축과정은 없으나 순차적 액세스 파일에만 효과적으로 사용 가능 · 파일의 i번째 블록을 찾기 위해 파일의 처음부터 시작, i번째 블록을 얻기 위해 포인터 들을 따라감 · 직접 액세스 기능을 지원할 수 없음
- 포인터들을 위한 공간이 필요 · 포인터가  512워드의  블록  중  2워드를  필요로  한다면,  디스크의  039%가  데이터(정 보)가 아닌 포인터로 사용되므로 각 파일들은 약간씩 많은 공간을 필요로 함
- 신뢰성 · 각 파일들이 포인터들로 연결되므로 포인터를 잃어버리거나 파괴되면 안됨
- 탐색시간 증가 · 파일들이 디스크 블록 위치로 흩어져 파일에 대한 탐색시간 증가 ㆍ 해결 방법
- 이중 연결리스트를 사용하거나 각 블록 내의 관련된 블록과 파일명들을 저장 · 각 파일들에 대한 더 많은 부담을 요구함
- 파일 할당 테이블(ex)AT) 사용 · 각  디스크  블록  내에  한  개의  항목을  가지고  있고,  블록  번호에  의해  참조되며  연결  리스트로 많이 사용됨 · 디렉터리는 파일의  첫 번째 블록 번호를 포함, 그 블록 번호에 의해 인덱스된 테이블  번호는 파일 내의 다음 블록의 블록 번호를 가짐 · 테이블 항목 내에서 특별히 끝(EOex), End of ex)ile) 값을 가지고 있는 마지막 블록까지  계속되며, 사용되지 않는 블록들은 제로 테이블 값으로 표시됨 · 단순하며, 디스크 공간 할당에 있어 효율적임 · MS
-DOS, OS/2 운영체제에 사용됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 디렉토리 항목 0 test 217 파일명 시작 블록 217 618 339 End
-Of
-ex)ile 618 339 디스크 블록 번호
-1 ex)AT ▶ 인덱스 할당 ­ 모든 포인터들을 하나의 장소, 즉 인덱스 블록으로 관리, 직접 액세스 지원 · 각 파일들은 디스크 블록(섹터) 주소의 배열인 자신의 인덱스 블록을 가짐 ­ 인덱스 블록의 i번째 항목은 파일의 i번째 블록으로 연결됨 ­ 디렉터리는 각 항목의 인덱스 블록의 주소(포인터)를 가짐 ­ i번째 블록을 읽기 위해 i번째 인덱스 블록 항목을 블록 진입 내에 있는 포인터를 사 용해 찾고 원하는 블록을 읽음 인덱스 블록 파일 블록 1 1 2 2 3 3 4 4 5 5 인덱스 테이블 · 파일이 생성될 때 인덱스 블록 내 모든 포인터들은 nil값으로 설정  ­ i번째 블록이 쓰여지면 그  블록은 빈 공간  리스트로부터 제거,  그 주소가 i번째 인덱 스 블록 항목 내에 쓰여짐 · 외부 단편화와 상관없이 직접 주소를 제공하나 공간의 낭비가 심함 ­ 포인터의 부담이 연결 할당의 포인터 부담보다 큼 · 전체의 인덱스 블록이 할당해야 하며 한 개 혹은 두 개의 포인터가 nil이 아니어야 함 · 각 파일들은 하나의 인덱스  블록들을 가져야 하며,  블록의 크기는 가능한 작은 것이 좋 음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 디스크 공간의 인덱스 할당 디렉터리(파일 할당 테이블) 파일명 인덱스블록 jeep 19 ▶ 성능 ­ 저장의 효율성은 할당 방법과 액세스에 필요한 시간에 따라 다름 ㆍ 연결 할당
- 메모리 내 다음 블록의 주소를 보관할 수 있으며, 그것을 읽을 수 있음
- 순차 액세스는 용이하나 직접 액세스의 경우 i번째 블록을 읽기 위해 i번 만큼 디스크를  읽어야 함 ㆍ 연속 할당
- 파일의 직접 액세스를 지원하며, 연결 할당을 이용한 순차적 액세스 지원
- 작은 파일들에 효율적이며 평균 성능도 좋음 ㆍ 인덱스 할당
- 인덱스 블록이 메모리 내에 있다면 직접 액세스 가능
- 인덱스 할당의 성능은 인덱스 구조 및 파일의 크기와 원하는 블록의 위치에 따라 좌우됨 · 메모리 내에 인덱스블록을 보관하기 위해 많은 양의 메모리가 필요함 · 메모리 공간을 사용할 수 없는 경우 인덱스 블록을 읽은 후 원하는 데이터 블록을 읽 음 · 두 번째 수준의 인덱스인 경우 두 번의 인덱스 블록을 읽어야 함
- 작은  파일들의  경우  연속  할당을  사용,  파일이  커지면  자동  인덱스  할당으로  변환하는  방법도 사용됨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 분산 및 병렬 처리 시스템(1)

1. 네트워크 컴퓨터의 구성에 대해 살펴보고, 분산 시스템의 개념  13주차  수업목표   및 투명성에 대해 알 수 있다. 1교시 
2. 네트워크 운영체제의 개념과 주요기능에 대해 알 수 있다. 1. 네트워크 및 분산 시스템 세부내용  2. 네트워크 운영체제 1. 네트워크 및 분산 시스템 ▶ 네트워크 컴퓨터 구성 ㆍ 네트워크 개념
- 몇 개의 독립적인 시스템이 적절한 영역 내에서 빠른 속도의 통신 채널을 통해 상호 직 접 통신할 수 있도록 지원해 주는 데이터 통신 체계
- 1960년대, 사이트 간의 효율적인 통신을 제공하려는 학교 연구 프로젝트로 탄생
- 광범위한 사용자 모임 간에 하드웨어나 소프트웨어를 편리하고 경제적으로 공유할 수 있 도록 지원
- 1968년 ARPANET ­ 최초로 개발되어 작동된 네트워크
- 원거리의 여러 하드웨어나 소프트웨어 계산 자원에 액세스 할 수 있는 능력을 사용자에 게 제공
- 네트워킹 속도와 신뢰성이 개선되며 전 세계 컴퓨터들은 더 많이 연결됨
- 최근 여러 개의 물리적 프로세서들 사이에 연산을 분산시키려는 경향이 나타남 ㆍ 강결합(Tightly Coupled) 시스템
- 프로세서들이 메모리와 클록(Clock)을 공유, 통신은 공유된 메모리를 통해 일어남 · 여러  개의  프로세서가  하나의  메모리를  공유하는  다중  프로세서(Multi
-processor)  시 스템 구조  · 프로세서 간 통신은 공유 메모리를 통해 이루어짐 · 공유 메모리를 차지하려는 프로세서 간의 경쟁 최소화가 주요 고려 대상임
- 결합교환(Combining Switch)으로 프로세서 간 경쟁 해결 · 하나의 공유 메모리를 차지하려는 여러 개의 프로세서 중 오직 하나의 프로세서만 액 세스 허용 프로세서 메모리 프로세서 입출력장치 입출력장치 강결합 시스템 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 약결합(Loosely Coupled) 시스템 ­ 두 개 이상의 독립된 컴퓨터 시스템이 통신선을 통해 연결됨 · 각  시스템은  자신의  운영체제와  메모리,  프로세서,  입출력장치를  가지고  독립적으로  운 영, 필요할 때 통신함 · 분산(Distributed) 처리 시스템으로 알려짐 ­ 통신선을 통해 서로 다른 시스템의 파일을 참조 가능 ­ 각 시스템의 부하를 조절하기 위해 부하가 적은 프로세스에 작업 전송 ­ 시스템에  장애  발생  시  다른  프로세서는  독립적으로  작업  수행이  가능하여  치명적인  시스 템 장애는 발생하지 않음 ­ 분산 시스템과 단일 시스템과의 차이점은 프로세스간 통신임 ­ 단일 시스템에서의 프로세서들은 공유 메모리로의 입출력을 통해 서로 통신 가능 ­ 원격 프로시저 ­ 공유 메모리가 없는 분산 시스템에서 클라이언트 프로세스와 서버 프로세스 간의 요청/응답  형태로 이루어지는 프로세스 간 통신을 기반으로 구현된 기법 메모리 메모리 통신선 프로세서 프로세서 입출력장치 입출력장치 약결합 시스템 ▶ 원격 프로시저 호출(RPC, Remote Procedure Call) ­ 브리웰(Birrell)과 넬슨(Nelson)에 의해 제안됨 ­ 컴퓨터에서  실행되는  프로세스가  다른  컴퓨터에서  실행되는  프로세스의  프로시저(혹은  함 수)를 호출할 수 있게 함 ­ 클라이언트/서버 모델을 전제로 함 · 클라이언트와 서버 사이에 프로시저를 호출하는 프로그램을 허용, 지역 프로시저 호출과  같은 메커니즘을 통해 지역적으로 분산되어 있는 원격의 프로시저를 호출함 · 클라이언트에 있는 프로세스가 서버에 있는 프로시저를 호출, 클라이언트에 있는 프로세 스는 중단되고 서버에 있는 호출된 프로시저가 실행됨 · 함수의 반환 값은 네트워크를 통해 클라이언트로 전송 · 호출  프로그램과  피호출  프로그램이  데이터를  공유,  호출자와  피호출자  사이의  정보는  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 매개변수로 전달 ­ 원격지  컴퓨터의  프로그램  호출  시  원격지에  클라이언트가  필요로  하는  데이터가  존재할  때 사용됨 결과 기다림 클라이언트 원격 프로시저 호출 호출로부터 돌아옴 요청 응답 서버 지역 프로시저 호출과 시간 결과 반환 클라이언트와 서버 간 RPC 원리 ㆍ 스터브(Stub)
- 전송 데이터를 준비하고 수신 데이터를 변환해 올바른 해석을 할 수 있도록 지원하여 처 리 결과를 교환하는 모듈
- 클라이언트 스터브와 서버 스터브가 있음
- 데이터 전송을 위해 다양한 형태의 데이터를 서로 변환하는 기능 수행 ㆍ 원격 프로시저 호출 동작 과정
- 클라이언트가 원격 프로시저 호출 시 원격 프로시저 호출의 동작 과정은 아래 그림과 같 음 클라이언트 서버 매개변수 결과 매개변수 결과 클라이언트 스터브 서버 스터브 요청 응답 요청 응답 RPC 메커니즘 RPC 메커니즘 네트워크 원격 프로시저 호출의 동작 과정
① 클라이언트는 원격 프로시저 호출을 위해 클라이언트 스터브 호출 ⇒ 클라이언트  스터브는  클라이언트  자신의  주소공간에  있으며,  원격  프로시저  호 출을 위한 매개변수들이 전달됨
② 클라이언트 스터브는 호출 매개변수들을 요청 메시지로 변환(표준 포맷으로) 복사함
③  서버에  요청  메시지를  전송하기  위해  원격  프로시저  메커니즘을  이용,  네트워크를  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 통해 요청 메시지를 서버 스터브에 전달함
④ 메시지를 수신한 서버 스터브는 요청 메시지를 프로시저의 매개변수들로 변환, 해당  프로시저를 호출함
⑤ 해당 프로시저의 실행이 끝나면 프로시저의 결과를 서버 스터브로 전송
⑥ 서버 스터브는 전달받은 결과를 필요한 정보들과 함께 응답 메시지로 변환, 원격 프 로시저 호출 메커니즘에 전달함
⑦ 네트워크를  통해  전달된  결과  메시지는 다시  클라이언트  스터브에 전달되어  결과값 으로 변환됨
⑧ 요청한 클라이언트에 결과값 전달
- 원격  프로시저  호출은  상호  운용성을  증진시키나,  통신의  신뢰성과  보안,  전역  변수의  미지원 등의 문제를 가짐 ▶ 분산 시스템 ㆍ 분산 시스템의 개념
- 경제적 요인으로 값이 저렴한 여러 컴퓨터를 한 운영체제가 제어할 수 있도록 구현함으 로써 강력한 시스템을 구성함
- 네트워크로 연결된 여러 대의  컴퓨터(노드)에 하나의 프로그램이 분산, 실행되면서 하나 의 프로그램처럼 움직임 · 공유 메모리와 공유 클록을 갖고 있지 않은 프로세서들의 집합  · 각각의 프로세서들은 자신들의 메모리와 통신 회선을 이용하여 서로 정보 교환을 수행 함 · 여러 사용자가 자원을 공유, 대규모 작업을 지원하여 다양한 사용자에게 서비스함 · 각  프로세서들은  초소형  프로세서들로부터  워크  스테이션,  소형  컴퓨터,  대형  컴퓨터  등 다양함
- 분리된 상태에서 컴퓨터 통신 네트워크를 통해 약결합(Loosely Coupled)을 이루는 정보  시스템 · 단일 시스템에 비해 처리능력과 저장용량이 높고 신뢰성이 향상됨 · 네트워크와 관련된 통신 지연과 시스템 고장에 대한 처리 등 구현과 관리가 복잡하고  어려움 노드 B 노드 A 기계적 제한 사용자 노드 C 노드 D 소프트웨어 컴포넌트 통신 분산 시스템 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 분산 시스템의 개발 동기
- 분산 시스템 내의 프로세서들은 크기와 기능이 서로 다름 · 마이크로 프로세서, 워크스테이션,  미니  컴퓨터,  범용  컴퓨터  등에  포함된  프로세서들 은 경우에 따라 사이트(Site), 노드(Node), 컴퓨터 등과 같은 이름으로 표현 · 시스템의 물리적인 분산을 강조하기 위해 사이트(장소)라는 용어를 주로 사용함
① 자원 공유
- 서로 다른 기능을 가진 많은 수의 사이트가 서로 연결되어 있다면 한 사이트에 있는  사용자는 다른 사이트의 이용 가능한 자원을 사용할 수 있음
- 분산체제의 자원 공유 방식 · 원거리에 있는 고속의 배열 조작 · 다른 연산을 위한 특수 목적의 하드웨어 사용 · 원거리 사이트 파일의 공유 · 분산 데이터베이스 내에서의 정보처리 · 원거리 사이트의 파일 프린팅에 대한 기능 제공
② 연산 속도 향상
- 어떤  특정한  연산이  동시  수행  가능한  다수의  부분연산으로  분할  가능할  경우  동시  수행을 위해 여러 사이트에 연산을 분산시킬 수 있음
- 부하 분담(Load Sharing) · 특정 사이트가 과부화된 경우 이 중의 일부를  부하가  적게 걸린 사이트로  이동시 킬 수 있음
③ 신뢰성
- 한  사이트가  고장  나도  나머지  사이트들은  계속  작동해  동작의  신뢰성을  보장할  수  있음 · 분산  시스템  내에  같은  종류의  하드웨어와 데이터가  여러  개 존재할 경우, 한  사 이트가  고장  나도  같은  기능을  가진  다른  사이트가  기능을  대신함.  한  사이트의  고장은  시스템에  의해  반드시  감지되어야  하며,  그  고장을  회복하기  위한  작업이  필요 · 시스템은 고장에서 회복될 때까지 그 사이트의 서비스를 사용할 수 없음 · 고장난 사이트의 기능을 다른 사이트가 대행한다면 기능이 올바르게 이동되었는지  확인이 필요함 · 고장난  사이트가 회복 또는  수리된  경우 시스템 내에  다시 포함시키는 기법이 필 요함
④ 통신
- 다수의 사이트가 통신 네트워크를 통해 서로 연결되었을 경우 다른 사이트에 있는 사 용자들이 정보를 서로 교환할 수 있음
- 지역적으로 멀리 떨어져 있어도 임의의 작업이 가능함
- 자원을 이용할 수 있으므로 효율적인 시스템 관리가 가능함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ㆍ 분산 시스템의 투명성
- 분산 처리 시스템의 기본적인 목표
① 투명성
- 상호 연결된 컴퓨터들을 사용자가 하나의 컴퓨터 시스템으로  인식할  수 있도록 시스 템의 사용자에게 분산 양상을 감추어, 사용자는 프로세스 사이의 통신 과정과 사용자  요청을  처리하는  프로세스,  자원의  물리적  위치를  몰라도  자원에  액세스할  수  있는  현상
- 사용자 관점에서는 서로 다른 컴퓨터가 통신에 의해 연결된 상태가 아닌 하나의 가상 적인 프로세서만을 인식함
② 접근 투명성
- 서로 다른 컴퓨터 구조와 프로그램 언어들 사이의 상호 교류가 가능하도록 함
- 프로세스는 지역과 전역에서 같은 형식으로 액세스 가능
- 시스템 전체에 걸쳐 다른 데이터 포맷으로 저장된 데이터에 액세스가 가능함
③ 위치 투명성
- 분산  시스템에  있는  자원  위치와  각  컴포넌트가  상호작용하는  위치를  액세스하려는  사용자에게 감춤
- 분산 파일 시스템은 지역 파일에 액세스하듯 원격 파일에 액세스하여 어떤 서버가 해 당 파일을 보유하고 있는지 알 수 없음
④ 고장 투명성
- 시스템 구성요소(컴포넌트)와 통신상의 오류에 의한 시스템 수행 장애를 방지
- 여러 자원이나  컴퓨터  오류  발생 시,  시스템의  사용자는  성능의 저하 정도만을  느낄  수 있음
- 오류를 시스템에서 제거하고  재사용할  수 있도록 회복시켜주며  복제  혹은 복구를 통 해 구현함
- 복구된 자원 중 하나만 남고 모두 고장 날 경우에도 분산 시스템은 기능을 계속함
⑤ 중복 투명성
- 시스템에 자원의 사본이 여러 개 있다는 사실을 감춤
- 복제된 자원 그룹에 대한 모든 액세스가 자원이 하나만 있는 것처럼 보이게 하여 신 뢰성과 유용성을 증대시킴
⑥ 이동 투명성
- 자원을  어떤  컴퓨터에서  다른  컴퓨터로  이동하여도  그것을  의식하지  않고  사용자가  그 자원을 사용
⑦ 영속 투명성
- 자원이 저장된 위치(메모리나 디스크)에 관한 정보를 감춤
⑧ 자원 투명성
- 구성요소에  대한  자원의  배당과  해제에  관한  정보를  감추고, 자원의  공유를  위해  제 공됨
⑨ 트랜잭션 투명성 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 공유 공간에서 동작하는 트랜잭션 연산에 대한 조정과 자원 집합 사이의 결합을 숨김
- 데이터 무결성과 일관성을 확보함
⑩ 재배치 투명성
- 한 객체의 재배치를 이와 통신하는 다른 객체에 감춤
⑪ 규모 투명성
- 구성요소를 추가하거나 제거하는 등의 규모가 바뀌어도 사용자가 의식하지 않음 v 투명성에 대한 실현은 복잡하고 비용이 높음
- 각 응용 시스템이 필요로 하는 투명성의 종류가 다르며, 응용에 따라 선택적으로 제 공할 수 있어야 함 2. 네트워크 운영체제 ▶ 네트워크 운영체제(NOS, Network Operating System) ­ 통신을 제어, 분산된 자원 공유하며 독립된 시스템들이 서로 연결하기 위해 개발됨 · 클라이언트(Client)  컴퓨터의  요청을  받아  서버(Server)에  저장된  대용량의  파일이나  서 버에 연결된 공유 자원을 클라이언트 컴퓨터에 제공하기 위해 설계됨 · 컴퓨터 네트워크로 연결된 환경에서 서버와 클라이언트 간의 원활한 통신을 보장하기 위 해 자원공유 서비스 및 각 클라이언트의 관리 기능 제공 · 주로 자원공유 기능 서비스를 제공하는 서버의 분산 애플리케이션 ­ 자원 공유(프린트 서비스, 주변장치 공유) ­ 파일 전송 ­ 액세스 권한(원격 처리, 사용자 관리) ­ 데이터 보호(보안 인증, 권한 부여) ­ 관리 제어(전자우편, 네트워크 관리) 등 노드 A 노드 B 노드 C 분산 애플리케이션 네트워크 운영체제 네트워크 운영체제 네트워크 운영체제 서비스 서비스 서비스 커널 커널 커널 네트워크 네트워크 운영체제의 일반적인 구조 ­ 각 컴퓨터(노드)는 도립된 운영체제(커널)로 자원 공유를 실현 · 사용자가 다른 컴퓨터와 쉽게 통신할 수 있는 기능을 제공 ­ 여러 대로 구성된 LAN(Local Area Network, 근거리 통신망) 전체의 자원을 관리 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 클라이언트들이 서버와 상호 작용할 수 있도록 도와줌 · 제한된 자원 공유를 제공, 지역적으로 분산되어 있는 이 기종 컴퓨터 시스템들을 연결함 ­ 사용자는 네트워크를 통해 서버의 자원을 사용자 시스템의 자원처럼 사용할 수 있음 ­ 최근의  네트워크  운영체제들은  디렉터리  서비스를  지원,  자원의  위치에  대한  투명성 을 제공함 · 네트워크 사용은 각 노드에서 실행되는 사용자 프로그램에 의해 제어됨 ­ 컴퓨터  운영체제가  서비스를  요구하면  네트워크  운영체제는  요구를  받아들이고  수행 함 ­ 메모리 관리, 프로세서 관리, 장치 및 파일 관리 등에 대한 전역 제어를 수행하지 않 고, 네트워크에 있는 서버를 사용하도록 지원 ­ 자율적인 컴퓨터들이  편리하고  효율적인  방법으로 서로를 이용할  수  있도록  돕는 분 산 시스템 소프트웨어의 집합 파일 서버 공유 파일 시스템 클라이언트  클라이언트  1 2 디스크에 저장 요청 응답 네트워크 네트워크 운영체제의 클라이언트/서버 ㆍ 네트워크 운영체제의 주요 기능
① 자원 공유
- 네트워크에 연결된 서버와 클라이언트 간에 하드디스크나 프린터 등의 자원을 공유할  수 있어야 함
② 액세스 권한
- 사용자는 원격 사이트의 자원을 사용할 수 있도록 액세스 할 수 있어야 함
- 자격 있는 사용자만 특정자원을 사용하도록 제한할 수 있음
- 호스트 컴퓨터에 대한 하드웨어 사항을 몰라도 되지만 원격  시스템의 명령을 알아야  함
③ 파일 전송
- 한 컴퓨터에서 다른 컴퓨터로 데이터 전송이 이루어져야 함
④ 데이터 보호
- 서버에 접근하는 클라이언트  사용자가  서버의  사용 권한을 인증하기  위해 사용자 별  적합한 권한을 설정, 데이터를 관리하고 보호
⑤ 관리 제어
- 네트워크를  이용하는  각  클라이언트들의  이용정보  및  네트워크  상에서  발생  가능한  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 여러 문제를 해결하고 조절하는 관리 기능 제공 v 운영체제의  기능은 기종의 차이가 심하고 지역적으로 널리 분산된 대규모 네트워크 시 스템에서 유용함 ㆍ 네트워크 운영체제의 운용 방식
- 자원 운영방식에 따라 Peer
-to
-Peer 모델과 클라이언트/서버(Client/Server)모델로 분류
- 네트워크  상의 각  노드는 자율성을 보장하고 서로 연결할  필요가 있을 때 적합하나, 자 원의 공유와 투명성에 있어 문제를 가짐 파일 서버 클라이언트 클라이언트 자원은 ­ Peer
-to
-Peer  자원은 클라이언트/서버 네트워크에서 네트워크에서 균일하게 공유함 파일 서버에 의해 재어됨 운용 형태별 자원 관리
① Peer
-to
-Peer 방식
- 동등하게 작동하는 LAN에 연결된 각각의 컴퓨터가 클라이언트 혹은 서버로서 상황에  따라 동작
- 소형  사무실  도는  가정의  PC도  클라이언트/서버이며,  네트워킹은  별도의  장비  없이  개별 사용자들이 서로의 파일을 액세스하고  전자메일을 보낼 수 있음
- 파일 서버 도는 중앙 집중식 관리 자원이 없음
- 모든 컴퓨터가 동일한 액세스 권한과 네트워크에 있는 사용 가능한 자원에 대한 동일 한 권한을 가짐
- Peer
-to
-Peer 방식의 장단점 · 장점
- 적은 초기 비용 ­ 클라이언트 및 서버의 기능을 한 PC에서 구현
- 자원 ­ 자원의 활용 극대화와 자원을 각각 균일하게 공유 · 단점
- 분산 ­  파일  및  어플리케이션에  대한  중앙  저장소가 없이 분산되어  관리가  어 려움
- 보안 ­ 서버와 클라이언트에 대한 보안을 제공하지 못함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 클라이언트/서버 클라이언트/서버 공유 네트워크 프린터 클라이언트/서버 지역 프린터 클라이언트/서버 동시 운용 컴퓨터
② 클라이언트/서버 방식
- 네트워크와는  독립적이며  네트워크에  접속하지  않은  PC의  시스템은  자신의  환경에  맞게 변경 관리할 수 있음
- 네트워크에 연결된 컴퓨터가 각각 자신의 역할을 수행 
- 클라이언트/서버 모델이 워크스테이션 모델인 경우 클라이언트들은 동시에 한 사용자 에 의해 사용될 수 있음
- 클라이언트/서버 시스템은 중앙에서 관리하는 형태로, 응용 프로그램에 전용 파일 서 버를 허용 · 파일 서버는 보안과 자원에 대한 액세스를 제공하는 시스템의 핵심임
- 개별 워크스테이션(클라이언트)은 파일 서버에 있는 사용 가능 자원을 액세스함 디렉토리 서버 프린터 서버 파일 서버 디스크배열 프린터 서버와 파일 서버와  파일 서버와  클라이언트 클라이언트 클라이언트/서버 구조
- 클라이언트/서버 방식의 장단점 · 장점
- 중앙 집중식 ­ 자원 및 데이터 보안이 서버를 통해 제어
- 유연성 ­ 새로운 기술을 시스템에 쉽게 통합
- 접근성 ­ 서버를 여러 플랫폼 또는 원격으로 액세스  학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 단점
- 비용 ­ 전용 서버에 초기 투자가 필요
- 소프트웨어 ­ 네트워크 운영체제 소프트웨어 필요
- 의존성 ­ 서버가 다운된다면 작업은 네트워크를 통해 중지됨
- 유지 관리 ­  대형  네트워크 작업을  효율적으로 동작시킬  수  있는  관리자  필요 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 분산 및 병렬 처리 시스템(2)

1. 분산 운영체제에 대해 알 수 있다. 13주차  수업목표  
2. 미들웨어의 구조와 역할에 대해 정리할 수 있다.
3. 다중 처리 시스템의 개념과 목적에 대해 알 수 있다. 2교시 
1. 분산 운영체제 세부내용 
2. 미들웨어
3. 다중 처리 운영체제 1. 분산 운영체제 ▶ 분산 운영체제(DOS, Distributed Operating System) ­ 네트워크  운영체제의  지역적인  자원  관리와  지역  제어의  제한을  벗어나  시스템  자원의  전 역 제어 및 관리의 필요성에 의해 발전 ­ 네트워크가  공유하는  공동  운영체제로  사용자에게  시스템이  제공하는  여러  자원들에  액세 스가 가능한 참조 투명성을 제공 ­ 분산된 컴퓨터 간의 자원을 쉽게 공유하고 액세스할 수 있음 ­ 통신  구조에  의존하며  한  사이트에서  다른  사이트로의  데이터와  프로세스  이동은  분산  운 영체제의 제어 아래 이루어 짐 사이트 A 사이트 C 서버 네트워크 자원 통신 클라이언트 사이트 B 분산 시스템 ▶ 클라이언트/서버 컴퓨팅 ­ 중형컴퓨터를 중심으로 한 다운사이징(Downsizing) 환경 ­ 네트워크를 통한 자원의 공유, 정보의 교환은 각기 다른 역할을 하는 컴퓨터에 의해 수행됨 · 클라이언트  컴퓨터들은  단일  사용자를  위한  PC나  워크스테이션에서  사용하기에  편리한  윈도우와 마우스가 포함된 그래픽 인터페이스를 사용자에게 제공함 · 서버는  데이터베이스  서버로서  클라이언트들이  동일한  데이터베이스에  액세스하여  데이 터를 공유할 수 있도록 데이터베이스를 관리할 수 있게 함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 분산 컴퓨팅으로 사용자, 어플리케이션, 자원들이 네트워크(단일 LAN이나 WAN)의 인터넷 을 통해 서로 연결됨 ㆍ 클라이언트/서버 시스템 구성요소
- 클라이언트, 서버, 통신 네트워크(인터넷, LAN) 등 클라이언트 워크스테이션 클라이언트 클라이언트 인터넷/LAN 클라이언트 클라이언트 클라이언트 서버 클라이언트/서버 구성요소 ㆍ 클라이언트/서버 시스템의 정의
- 서비스를  요청하는 클라이언트와  이에  대응하여 서비스를 제공하는  서버가  원격  접속을  통해 하나의 응용 프로그램을 논리적으로 분리된 여러 부분으로 분산시키는 것
- 서버에  있는  하나의  어플리케이션을  독립된  역할을  담당하는  다수의  작업으로  분할,  클 라이언트들의 서비스 요청을 처리함 사용자 클라이언트 서버 클라이언트에게  클라이언트 요청 서버와 연결 클라이언트  서버  사용자 애플리케이션 애플리케이션 클라이언트는 서버응답 보냄 사용자에게 응답 표시 클라이언트/서버 컴퓨팅
- 클라이언트에는  데이터를  표현하는  처리  모듈을,  서버에는  데이터  관리와  저장을  위한  모듈을 두어 각 작업을 효율적으로 처리할 수 있는 컴퓨터에 할당하는 모델 · 클라이언트는  기본적으로  1대  이상의  서버가  제공하는  서비스를  사용하는  소비자에  속함 · 하드웨어적으로 기능과 역할이 분리되지 않음
- 사용자 자신의 시스템에서 사용자에게 사용하기 편리한 인터페이스와 어플리케이션을 제 공함 · 데이터베이스나  네트워크  관리 유틸리티  기능들은  중앙 집중화되어  있어 복잡한 컴퓨 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 터 기반 시설들을 유지해야 하는 부담을 덜어줌
- 데이터와 정보에 액세스하기 위해 필요한 컴퓨터와 인터페이스의 유형 선택 가능
- 네트워크 관리 및 보안은 정보 시스템의 구성과 운영에서 높은 우선 순위를 가짐
- 네트워크상에서  여러 다른 지역에  걸쳐  분산되어  있는  프로그램들을 연결시켜주는  수단  제공 · 클라이언트의 대표적인 예는 “웹 브라우저”
- 웹 사이트의 웹 서버(IIS, Apache)가 서버 역할을 하고 사용자가 쓰는 웹 브라우저 가 클라이언트 역할을 수행함
- 최근  네트워크 어플리케이션들의  기능이 고도화되어  두 가지 역할 동시에  수행 가 능 ㆍ 클라이언트/서버 시스템의 구현
- 두 개의 컴퓨터 프로그램 사이에 이루어지는 역할 관계 · 클라이언트 ­ 다른 프로그램에서 서비스를 요청하는 프로그램 · 서버 ­ 그 요청에 응답을 해주는 프로그램
- 클라이언트/서버  환경  구축의  핵심  요소는  사용자와 시스템의  전체적인  원활한 상호 작 용 · 클라이언트 컴퓨터에서 사용자 인터페이스의 설계는 매우 중요함 · 사용하기 쉬우면서도 친밀한 인터페이스 제공 · 강력하고 유연한 그래픽 사용자 인터페이스(GUI)가 제공되어야 함
- 일반적인 2계층의 클라이언트/서버 구조 · 클라이언트와 서버가 물리적으로 서로 독립된 시스템에 존재하는 형태로 구성
- 클라이언트와 서버의 플랫폼과 운영체제는 서로 다를 수 있음 · 클라이언트와  서버를  상호  연동할  수  있게  하는  통신  소프트웨어(동일한  프로토콜을  공유)와 분산 어플리케이션들을 위한 기반을 제공
- 공유 자원 및 작업을 클라이언트와 서버 간에 분할 가능
- 대부분의 어플리케이션 프로그램이 클라이언트에 설치됨 · 클라이언트는 프리젠테이션 서비스 모듈을 통해 사용자에게 친밀한 인터페이스를 제공 함 프리젠테이션 서비스 애플리케이션 로직 애플리케이션 로직 (클라이언트 부분) (서버 부분) 통신 소프트웨어 통신 소프트웨어 클라이언트 서버 운영체제 운영체제 하드웨어 플랫폼 하드웨어 플랫폼 일반적인 클라이언트/서버 구조 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
- 팻(ex)at) 클라이언트 · 가장 일반적인 클라이언트/서버 형태 · 서버는 최적으로 수행될 수 있는 데이터 확인 루틴과 데이터베이스와 관련된 로직 기 능을 가짐 · 실질적으로  모든  어플리케이션을  처리할  수  있도록  어플리케이션  처리  모듈을  포함,  프리젠테이션 로직이 클라이언트에 위치한 클라이언트 기반 처리 방식
- SQL(Structured Query Language)문을 작성, 원격지의 컴퓨터에 위치한 데이터베 이스 서버에 전달
- 서버는  데이터베이스에  대한  Read/Write만을  처리하여  결과를  다시  클라이언트에  보내는 데이터 전송 형태의 원격 데이터베이스 액세스 모델
- 씬(Thin) 클라이언트 · 서버에는 어플리케이션 처리 모듈에 해당하는 저장 프로시저(Stored Procedure)와 데 이터베이스가 위치 · 클라이언트에는  프리젠테이션  로직만  위치하고,  단순히  서버의  프로시저  호출  기능을  통해 사용자의 요구를 처리함 · 클라이언트는 사용자 인터페이스만을 담당하는 형태의 메시지 전달 기능만 수행함
- 팻 클라이언트와 씬 클라이언트 데이터베이스 서버 데이터베이스 어플리케이션 처리 모듈(저장 프로시져) 질의 삽입 결과 반환 프로시져 실행 네트워크 결과 반환 어플리케이션 클라이언트 처리 모듈 프리젠테이션 로직 프리젠테이션 로직 (a) 팻 클라이언트 (b) 씬 클라이언트
- 2계층 모델의 문제점 · 클라이언트/서버  간의  네트워크  통신량의  증가로  시스템  성능  저하와  네트워크  병목  현상 발생
- 파일  서버가  사용될  때,  파일  입출력은  네트워크에서  발생되는  지연  때문에  지역  파일 참조에 비해 성능 저하 발생
- 파일 캐시를 사용하여 원격 서버의 접근 횟수 감소가 가능하나 캐시의 일관성 문제  해결이 필요함 · 어플리케이션의  논리적  구조와 물리적 구조가 완전히 분리되지 않아 업무  프로세스나  업무환경 변경 시 많은 부분의 소프트웨어의 수정이 필요함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 확장성의 한계
- 대부분의  어플리케이션이  특정  데이터베이스에  종속되어  데이터나  어플리케이션이  증가될 경우 통합하기 어렵고 유연성이 떨어짐 · 개발된 어플리케이션의 이식성의 한계
- 한 서버에서 다른 서버로 프로그램 기능의 일부를 이동하는 것이 어려움 ㆍ 3계층의 클라이언트/서버 구조
- 2계층 구조의 문제점을 해결하기 위해 데이터베이스가 위치한 서버 부분과 사용자가 주 로 사용하는 클라이언트의 완전 분리
- 어플리케이션  로직을  모듈화하여  중간  계층을  별도로  두어,  유연하고  확장  가능한  시스 템
- 네트워크와 운영체제의 불일치를 극복하기 위한 계층으로 미들웨어를 포함, 분산 클라이 언트/서버 컴퓨팅 실현
- 어플리케이션 서버에 “미들웨어”라는 중재 소프트웨어를 적용 · 클라이언트 수의 증가에 따른 성능저하 문제 해결 · 데이터베이스의 위치와 상관없이 확장 가능
- 부하분산(Load Balancing) 가능 · 여러 클라이언트와 서버 사이에서 인터페이스를 처리함
- 어플리케이션 로직을 분산시키기 위해 어플리케이션 로직을 모듈화하여 중간 계층에 둠 · 이질적인 대규모 분산 환경에서 일관성있는 액세스가 이루어짐 · 작업  수행을  위한 대부분의  어플리케이션 로직은  중간계층 서버가  유지하여 클라이언 트와 서버의 기능 분산으로 어느 한쪽이 비대해지는 현상 방지 요청 질의 삽입 결과 클라이언트 어플리케이션과 데이터베이스 미들웨어 서버
- 3계층 모델의 장점 · 클라이언트의 작업처리 부담이 덜어지고 어플리케이션 서버가 작업처리를 맡음
- 중간계층은 서로 다른 많은 기능을 실행할 수 있어 시스템 성능과 융통성 향상 · 어플리케이션 서버에 작업 로직을 배치, 개발자들이 프로그래밍 언어와 관계없이 개발  가능하며, 어플리케이션 로직을 모듈화하여 유지 관리가 쉬움 · 데이터베이서 서버는 데이터 작업만 수행해 데이터베이스 서버의 처리 용량 증가로 확 장성 향상 2. 미들웨어 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 미들웨어(Middleware) ㆍ 미들웨어의 정의
- 네트워크를 통하여 클라이언트/서버 사이에서 교량적인 역할을 하고, 사용자들에게 다양 한 데이터 자원을 지원하는 소프트웨어 서비스 · 서로 다른 시스템(네트워크, 데이터베이스, 운영체제)에 대하여 상호 운영을 위해 호환 성을 제공함 · 분산 컴퓨팅 환경에서 사용자의 컴퓨터와 네트워크에서 실행되는 어플리케이션들 간에  자유롭게 데이터를 이동, 응용 애플리케이션 개발을 지원하는 소프트웨어 · 3계층 클라이언트/서버 시스템 구축의 필수적인 기술
- 기본 목표 · 클라이언트에 있는 애플리케이션이나 사용자가 서버의 종류에  관계없이 각  서버에 있 는 다양한 서비스를 이용할 수 있는 시스템 구축 클라이언트 데이터베이스 서버 데이터베이스 미들웨어 미들웨어 네트워크 네트워크 프로토콜 프로토콜 클라이언트/서버의 미들웨어 컴포넌트 ㆍ 미들웨어의 구조와 역할
- 운영체제와 애플리케이션 사이에 존재 · 분산 컴퓨팅을 구현할 수 있도록 애플리케이션의 구성 요소를 서로 결합 · 클라이언트와 서버를 연결하는 수단을 제공하는 소프트웨어
- 다른 데이터베이스 엔진과 클라이언트를 연결 · 특정  데이터베이스에 액세스하기  위해 작성된 프로그램이  다른 데이터 베이스에도 액 세스할 수 있는 기능을 가짐 · 데이터베이스와  웹  서버를  연결,  데이터베이스로부터  데이터를  검색하거나  사용자의  요청 내용에 따라 페이지를 동적으로 나타낼 수 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 노드 A 노드 B 노드 C 분산 애플리케이션 미들웨어 서비스 네트워크 운영체제 네트워크 운영체제 네트워크 운영체제 서비스 서비스 서비스 커널 커널 커널 네트워크 미들웨어에 의한 분산 시스템의 일반적 구조
- 운영체제와 애플리케이션 사이에 위치하는 모든 소프트웨어 · 데이터베이스  관리  시스템(DBMS,  Database  Management  System),  소프트웨어  개 발 지원을 위한 그래픽 사용자 인터페이스(GUI, Graphic user Interface), 각종 통신  소프트웨어 등을 모두 포함
- 애플리케이션  서비스에  대한  액세스  그리고  다른  시스템과의  애플리케이션을  지원하는  기능으로 구성됨
- 미들웨어 컴포넌트의 구성 · 개발 도구와 실행 환경, 관리 도구로 구성 · 실행 환경은 각각 통신 서비스, 코어 서비스, 애플리케이션 서비스로 나뉘어짐
- 미들웨어 컴포넌트의 구성 미들웨어 컴포넌트 실행환경 애플리케이션 서비스 (트랜잭션, 이메일, DB 액세스) 개발 도구 코어 서비스 관리 도구 (이름 관리, 보안 등) 통신 서비스 API (제어, 프로토콜 서비스) 3. 다중 처리 운영체제 ▶ 다중 처리 시스템(Multi
-Processing System) ­ 병렬 시스템이라 불림 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 다수의 프로세서를 이용한 동시 수행 과정을 통해 시스템의 성능을 향상시키는 방식 · 각각의 프로세서는 자체 계산 능력과 공유 기억 장소를 통하여 주변장치를 공동으로 이 용 · 프로세스가 두 개 이상 존재하는 시스템 ­ 소프트웨어적 관점의 다중 프로그래밍과 달리 하드웨어적 관점임 ▶ 다중 처리 시스템의 목적
① 신뢰성, 가용성, 컴퓨터 능력의 증가 ­ 시스템의 한 프로세서가 고장 나도 다른 프로세서들은 계속 작동하므로 신뢰성이 증대됨 ­ 계산 능력은 감소되나 전체적으로는 계속 작동함 ­ 여러 프로세스의 처리 능력을 결합, 컴퓨터 능력의 증대 가능
② 막대한 비용 없이 단일 프로세서 컴퓨터 시스템의 계산 능력 증대 ­ 하드웨어  비용이  싸짐에  따라  여러  개의  마이크로프로세서를  연결,  다중  프로세스를  만 드는 것이 보편화 됨 ­ 저렴한 비용으로 대형 컴퓨터에 근접하는 능력을 얻음
③ 융통성 제공 ­ 시스템을 모듈식으로 설계함으로써 프로세서를 추가, 전체 시스템 능력 확장 ▶ 다중 처리 시스템의 하드웨어 구조 ­ 다중 처리 시스템 설계 시 고려 사항 · 여러 개의 프로세서들과 입출력 프로세서들을 메모리에 연결시키는 방법 ­ 다중 처리 시스템은 거의 비슷한 능력을 갖는 두 개 이상의 프로세서를 포함함 ­ 모든 프로세서는 같은 메모리를 공동으로 사용 ­ 모든 프로세서는 입출력 채널들과 제어장치 및 그 외의 장치들을 공동으로 사용함 ­ 전체 시스템은 하나의 운영체제에 의해 운영되며 이  운영체제는 프로세스와  각 작업 의 상호작용을 여러 단계에서 도와줌 · 프로그램, 데이터 집합, 데이터 단위들의 단계에서 상호 작용을 도움 P P P P CPU P P 공유 메모리 P P P P P P 공유 메모리 모델 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 다중 처리 시스템의 장점 ­ 한 프로세서가 고장난 경우 나머지 프로세서들은 계속 가동할 수 있음 · 고장  난  프로세서는  다른  프로세서들에  자신이  수행하던  프로세서들을  떠맡도록  알려야  하며 정상  가동 중인 프로세서들은 고장 난 프로세서를  알아낼 수  있어야  함 · 고장이  발생한  경우  시스템  전체  능력이  떨어지므로  운영체제는  자원할당  기법을  조정, 시스템이 너무 과중한 부담을 받지 않도록 조치함 ▶ 다중 처리 시스템 운영체제 ­ 하나의  처리기만  갖는  시스템  운영체제와  다중  처리  시스템  운영체제의  주요  차이점은  다 중 처리기를 토대로 한 운영체제의 구성과 구조임 ­ 단일 프로세서 시스템보다 복잡하며, 기본적인 운영체제 구성 방법은 다음과 같음 ㆍ 주/종(Master/Slave) 운영체제
- 구현하기가 가장 쉬운 구조로, 현존하는 다중 프로그래밍 시스템을 수정하여 구현 가능 · 하드웨어를 최적으로 사용하지 못함
- 하나의 프로세서가 ‘주(M)’로 지정, 운영체제를 실행하고 나머지 프로세스들은 사용자 수 준의 프로그램을 실행할 수 있는 ‘종(S)’로 지정됨 · 주(M) 프로세서는 범용 프로세서로서 연산뿐만 아니라 입출력도 담당함 · 종(S) 프로세서는 연산만을 담당 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 시스템 보호와 보안

1. 보안의 범위와 위협에 대해 알 수 있다. 14주차  수업목표  
2. 보호의 개요와 영역에 대해 정리할 수 있다. 
3. 암호를 정리할 수 있다. 1교시 
1. 시스템 보안 세부내용 
2. 보호
3. 보안 기법 1. 시스템 보안 ▶ 시스템 보안의 범위 ㆍ 보안 범위
- 시스템뿐만  아니라  시스템이  작동하는  외부  환경과  더불어  내부  조직의  구성원  액세스  제한도 포함
① 기술적 보안
- 불법 공격을 막기 위한 각종 하드웨어 및 소프트웨어 조치와 정보(데이터) 보호를 위 한 액세스 제어에 사용되는 기술, 정책, 절차를 포함 · 대상 : 서버, 네트워크, 데이터베이스(DB), 어플리케이션, PC 등 · 네트워크에 대한 액세스 제어, 암호화, 정보유출방지 · 시스템(서버,  DB,  어플리케이션)에  대한  사용자  인증,  암호화,  액세스  제어,  침입  차단/탐지
② 물리적 보안
- 시설에 대해 허가하지 않은 접근(사용)을 차단, 모니터링하기 위한 활동 · 물리적 시설에 대한 출입 제어 · 기술적 제어 : 스마트 카드, 감사 추적, 접근 이력 관리, 침입 탐지 관리 등
③ 관리적 보안
- 조직  내부의  정보보호  체계를  정립하고  절차,  감시  조직,  사고  대책  등  절차적  보안 을 뜻함 ㆍ 보안 요구 사항
① 비밀성(기밀성)
- 컴퓨터 시스템 내의  정보는  오직  인가받은  사용자만이 액세스할 수  있도록  보장되어 야 함
- 비인가된 개인 또는 개체에 정보가 전송되거나 보관 중인 메시지에 대한 불법적인 출 력, 복사 금지
- 정보가 인가받지 않은 사용자나 프로세스들에 누설되거나 공개되지 않는 특성
② 무결성
- 컴퓨터 시스템의 정보는 오직 인가받은 사용자만이 수정할 수 있도록 보장됨
- 정보가 의도적 또는 비의도적으로 변조, 파괴되지 않는 특성 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
③ 가용성
- 컴퓨터  시스템의  정보는  오직 인가받은  사용자만이 이용할  수  있고,  언제나  사용  가 능하도록 보장됨
④ 인증
- 실제로 등록된 사람(사물)인지를 판단하는 과정
- 컴퓨터와  최초  연결이  이루어질  때  필요하며,  네트워크에서  인증은  대부분  로그온  시, 암호(비밀번호 또는 비밀키)를 통해 이루어 짐
- 사용자는 처음 자신의 암호를 등록하고, 이후 로그인 시 등록한 암호를 사용함 ▶ 보안 위협의 형태 ­ 정보를 제공하는 관점에서 다음과 같이 구분함 ㆍ 중단(흐름 차단)
- 시스템 가용성에 대한 공격으로 시스템의 일부를 파괴 또는 사용할 수 없게 하거나 이용 할 수 없도록 만드는 공격
- 하드웨어 파괴(디스크 파괴), 통신 회선의 절단, 파일 관리 시스템의 무력화 등 ㆍ 도청(가로채기)
- 권한이 없는 사용자가 컴퓨터 자원을 액세스하는 경우로 정보의 불법적인 획득 또는 복 사 등으로 비밀성에 관한 공격
- 권한이 없는 사용자는 프로그램이나 다른 컴퓨터도 동일하게 적용됨 ㆍ 변조(수정)
- 권한이 없는 사용자가 자원에 접근할 뿐만 아니라 내용을 변경하는 경우로 무결성에 대 한 공격
- 파일의 내용 수정, 프로그램 변경, 전송 중인 메시지 변경 등 ㆍ 위조(조작)
- 권한이 없는 사용자가 정보의 전부 또는 일부분을 교체, 제거 및 데이터 블록 순서를 바 꿔 시스템에 위조 객체를 삽입하는 공격
- 정보를 가로채어 변조하여 원래 목적지로 전송하는 것으로 무결성 또는 인증에 대한 공 격
- 허위 메시지 삽입, 파일에 레코드 추가 등 ㆍ 사칭(가장)
- 비인가된  사용자가 인가된 사용자로  가장해  시스템에 부당하게 액세스하는  행위로  인증 에 대한 공격
- 통신회선, 즉 네트워크에서 수동적인 공격과 능동적인 공격으로 구분함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 정보 발생지 정보 목적지 (a) 정상적인 흐름 (b) 중단(흐름 차단) 공격자 (c) 도청(가로채기) (d) 변조(수정) (e) 위조(조작) (f) 사칭(가장) 보안 위협의 예 ▶ 소프트웨어 위협 ­ 악성 프로그램에 의해 발생하는 위협 ­ 호스트 프로그램이 필요한 경우와 독립적으로 시스템에 위협을 주는 프로그램으로 구분 ­ 최근 컴퓨터 통신망에 구축되는 가상 공간인 사이버 공간, 즉 컴퓨터 통신망을 이용한 사이 버 테러(Cyber Terror)도 발생됨 ㆍ 사이버 테러
- 정부  기관이나  민간  기관의  정보  시스템에  침입,  중대한  장애를  발생시키거나  파괴하는  등의 범죄 행위 종류 ㆍ 트로이 목마(Trojan Horse) 프로그램
- 유용한  프로그램  또는  명령  프로시저로  호출되었을  때,  해로운  기능을  수행하는  은폐된  코드를 포함하는 프로그램 · 예) 게임 프로그램 등에 위장해 있다가 게임 실행 시 하드 디스크의 데이터를 파괴함 ㆍ 트랩도어(Trap Door)
- 서비스  기술자나 유지보수 프로그래머들의 액세스 편의를 위해 시스템  설계자가  만들어  놓은  통로로  사용자가  정상적인  보안  예방조치를  통과하지  않고  바로  시스템에  들어갈  수 있도록 만들어진 비상명령 ▶ 컴퓨터 바이러스(Computer Virus) ­ 자기 자신을 스스로 복제할 수 이는 기능을 가진 실행 가능한 명령어들의 집합 ­ 컴퓨터의 프로그램이나 중앙처리장치(CPU)의 서비스 영역에 자신 또는 자신의 변형을 복재 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 해 시스템에 영향을 미침 ▶ 웜(Worm) ­ 컴퓨터 시스템에 해를 끼칠 수 있는 장소에 위치하는 바이러스 또는 복제 코드의 일종 · 컴퓨터는 정상적으로 작동하면서 프로그램 자체의 전염성을 과시하기 위한 바이러스 2. 보호 ▶ 보호의 개요 ­ 운영체제 내의 프로세스의 활동은 다른 프로세스들의 활동으로부터 보호되어야 함 · 파일의  액세스에  대한  지정,  메모리의  주소  지정으로  그  자신의  공간  내에서만  실행할  수 있도록 보호해야 함 · 파일, 메모리 세그먼트, 프로세서 등 모든 자원들이 운영체제로부터 적절한 권한을 받은  프로세스에 의해서만 동작하도록 보장해야 함 ㆍ 보호의 개념
- 컴퓨터 시스템에 의해 정의된 자원에 대해 프로그램, 프로세스 또는 사용자의 액세스 제 어를 의미함
- 불법적인  액세스를  제한하는  방법으로  식별  및  인증  절차를  거친  사용자만이  시스템을  액세스할 수 있도록 해야 함 식별 및 인증 액세스 제어 자료 ▶ 보호의 영역 ­ 객체는 보안 운영체제가 보호하고자 하는 대상으로 하드웨어 객체와 소프트웨어 객체로 구 분 · 컴퓨터 시스템은 객체를 사용하려는 주체(사용자, 프로세스, 자원), 즉 객체들의 집합 ­ 하드웨어 객체 : 프로세서, 프린터, 카드판독기, 테이프 드라이버 등 ­ 소프트웨어 객체 : 파일, 프로그램, 세마포어 등 · 프로세스는  액세스  권한을  부여  받은  자원들에만  액세스할  수  있으며,  작업을  완수하기  위해 필요한 자원만을 액세스할 수 있음 ­ 잘못된 프로세스가 일으킬 수 있는 피해를 줄임 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ­ 한 프로세스는 하나의 보호 영역 내에서 동작하도록 프로세스가 액세스할 수 있는 자 원을 제한함 ▶ 사용자 액세스 제어 ­ 식별과 인증은 각 시스템 자원을 보호하기 위한 1차적인 보호 계층임 · 서버나 공유 시스템에서 사용자 액세스를 제어하기 위한 일차적인 기법은 시스템 로그인  과정임 ­ 시스템의 사용자는 시스템 사용을 위해 식별과 인증 과정을 통해 로그인한 후 시스템  사용을 시작함 ­ 시스템  사용을  위한  로그인  과정은  사용자  식별자(ID)와  암호를  알면  로그인이  허용 됨 · 사용자 액세스 제어 ­ 시스템이  사용자의  식별자(ID)와  암호를  요청한  후  시스템에  저장된  식별자  ‘sun’과  암호 ‘alis
-00’을 비교한  후 일치되면  시스템의  액세스를  승낙, 아니면  거절하는  과정 을 나타냄 ­ 식별자나 암호가 노출되면 시스템이 쉽게 노출되어 신뢰성이 떨어지므로 식별자와 암 호의 관리가 매우 중요하며, 식별자와 암호가 저장된 파일은 침투당하기 쉬워 암호화  기법을 이용해 보호함 (ID, 암호) 로그인 요청 (sun, alis
-00) 사용자 ID 암호 sun alis
-00 암호 = N alis
-00 거절 Y 사용자 승낙 ▶ 데이터 액세스 제어 ㆍ 액세스 행렬(Access Matrix)
- 파일이나 데이터베이스 관리 시스템의 액세스 제어 보호 · 모델 행 ­ 영역, 즉 주체(사용자)를 나타냄 · 열 ­ 객체를 나타냄 · 행렬에서 각 항은 액세스 권한의 집합으로 구성
① 액세스 행렬 구성
- 객체의 액세스 행렬 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr · 네  개의  주체(사용자)와  다섯  개의  객체,  즉  세  개의  파일(ex)1,  ex)2,  ex)3)과  프로그 램, 프린터가 있다 가정하고, 표와 같은 액세스 권한을 부여함 · 간단하지만  파일과  사용자의  수가  증가함에  따라  행렬이  커지며  대부분의  항목이  공백이므로 저장 공간이 낭비됨      객체 ex) ex) ex) 프로그램 프린터    주체 A 판독 판독 B 실행 인쇄 C 판독 실행 D 판독, 기록 판독, 기록
② 전역 테이블(Global Table)
- 액세스 행렬의 가장 단순한 구현으로, 세 개의 순서쌍 ＜사용자(영역), 객체, 권한(액 세스 형태)>들의 집합으로 구성됨
- 표[전역테이블 ] 앞의 표[객체액세스 행렬]의 객체의 액세스 행렬에 대한 전역 테이블 사용자(D)  객체 권한(액세스 형태 i A ex) 판독  A ex) 판독  B 프로그램 실행 B 프린터 인쇄 C ex) 판독  C ex) 실행  D ex) 판독, 기록  D ex) 판독, 기록 
- 테이블은  보통  매우  크기  대문에  메인  메모리에  보관할  수  없어  추가적인  입출력이  필요함
- 가상 메모리  기법을  테이블  관리에  이용할  수  있으나,  어떠한  객체와 영역이  분류되 어 있는 점을 이용하기 어려움 · 특정한  객체가 누구에게나 읽혀질 수  있으려면  모든 영역 내에  각각 별개의 항목 을 가져야 함
③ 액세스 제어 목록(Access Control List)
- 액세스 행렬에 있어 각 열은 하나의 객체에 대한 액세스 제어 목록으로 구현할 수 있 으며, 공백 항목도 없앨 수 있음
- 각 객체에 대한 목록은 <사용자, 권한>의 순서쌍으로 구성되며, 그 객체에 대한 액세 스 권한을 갖는 모든 사용자 영역을 정의함
- 액세스 목록은 사용자의 요구와 일치하며 사용자가 객체를 만들 때  객체에  액세스할  수 있는 영역과 허용되는 오퍼레이션을 지정할 수 있음
- 그림 [액세스 제어 목록] 표[객체의 액세스 행렬] 객체의 액세스 행렬에 대한 액세스  제어 목록 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 사용자(프로세스) A B C D 사용자 공간 ex) A: 판독, D: 판독, 기록  액세스 제어 목록  ex) C: 판독  ex) A: 판독, C: 실행, D: 판독, 기록 커널 공간  프로그램 B: 실행  프린터 B: 인쇄 3. 보안 기법 ▶ 암호(Password) ­ 안전한 보호 방법이 없을 때 컴퓨터 시스템 내 객체 보호를 위해 이용 · 자원의 이용에 대한 요구가 있을 때마다 암호를 요청, 암호가 정당하면 액세스 허용 · 암호화(Encryption) ­ 신뢰할 수 없는 링크를 통해 전송되는 정보를 보호하는 방법으로, 가장 널리 사용됨 · 암호의 기능 ­ 비밀성 : 통신망을 통한 정보의 전송이나 시스템에 저장되어 있을 때 정보의 노출 방 지 ­ 인증 : 액세스하려는 사용자의 확인 및 시스템 액세스 권한이 있는지를 보증 ­ 무결성 검사 : 메시지나 파일이 변조나 수정되지 않았음을 보장 ­ 전자 서명 : 메시지나 파일이 인증 및  무결성 검사 기능에 의해 신원 확인과 정보가  보호 상태에서 생성되고 전송되었음을 보장 · 암호의 문제 ­ 암호의 비밀 유지가 어려움 ­ 추측이나 우연한 노출로 인해 알려질 수 있음 · 암호화 수행 방법은 전통적인 암호화 기법의 대칭키 알고리즘과 비대칭키의 공개키 알고 리즘으로 구분됨
① 대칭형 암호화 기법 ­ 가장 널리 알려진 방법으로 단일키 암호화 알고리즘 ­ 암호 및 복호(해독) 알고리즘과 두 알고리즘에 사용할 비밀키 하나를 이용 ­ 비밀키(개인키)를 사용해 데이터를 암호화함 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 평문(Planintext) 평문 암호 장치 복호 장치 암호 알고리즘 복호 알고리즘 송신자 수신자 단일키 암호화 알고리즘 ­ 데이터 암호화 표준(DES, Date Encryption Standard) 기법 · IBM이 개발, 1977년 NIST(National Institute of Standards and Technology)가 표 준 암호화 기법으로 채택 · 대칭형 암호화 기법 중 가장 널리 사용됨 ­ 키 분배 시 문제 발생 · 데이터 전송 전 비밀키는 송신자와 수신자에게 안전하게 전달되어야 함 · 통신망 환경에서 효율적인 수행이 어려움 · 문제를 해결하기 위해 비대칭형 공개키 암호화 기법 사용
② 공개키 암호화 기법 ­ 1976년 디피(Diffie)와 헬먼(Hellman)에 의해 처음 발표 ­ 각 사용자는 공개키와 개인(비밀)키를 모두 가짐 · 공개키 : 다른 사용자에게 공개하는 키로 암호화 시 사용 · 개인키 : 소유자만이 가지고 있으며 데이터 복호화 시 사용됨 ­ 공개키 암호화 · 송신자가 수신자에게 보낼 메시지를 수신자의 공개키로 암호화해 전송 · 수신자는 자신의 개인키로 암호화된 메시지를 복호화함 · 데이터 전송 중에는 누구도 메시지를 해독해서 읽을 수 없으며, 키 분배에 대한 안전 을 유지할 수 있음 수신자의 공개키 복호화 알고리즘 평문 입력 평문 출력 암호문 전송 암호화  수신자의 개인키 알고리즘 송신자 수신자 ­ RSA 암호화 알고리즘 · 1977년 MIT의 리베스트(Ron Rivest), 샤미르(Adi Shamir), 아델만(Len Adleman)에  의해 제안 · 코드화하기 간단하나, 암호문 해독이 매우 어려움 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 네트워크 보안 ㆍ 방화벽(ex)irewall)
- 다른 네트워크의 사용자들로부터 네트워크 자원들을 보호하는 프로그램
- 침입 차단 시스템이라고도 함 ㆍ 침입탐지 시스템(IDS, Intrusion Detection System)
- 적극적인 방어 기법으로, 침입 사실을 빠르게 검출, 침입자를 봉쇄하여 시스템의 손실과  데이터의 훼손을 최소화함
- 정보 시스템의 비밀성, 무결성, 가용성을 침해하는 모든 행위를 탐지 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 유닉스 운영체제

1. 유닉스의 개요와 프로세스 관리에 대해 알 수 있다. 수업목표  
2. 프로그래머 인터페이스 및 파일 시스템에 대해 정리할 수  14주차  있다. 2교시 
1. 유닉스의 개요
2. 프로세스 관리 세부내용 
3. 프로그래머 인터페이스
4. 파일 시스템 1. 유닉스의 개요 ­ 유닉스의 설계 및 구현 향상을 위해 다양한 운영체제의 특징을 채택함 · TENEX 운영체제 ­ 많은 수의 터미널 행 편집 기능 · 새로운 사용자 인터페이스 · 새로운 문서 편집기 · PASCAL과 LISP를 위한 컴파일러 · 새로운 시스템 프로그램들이 버클리에서 구현됨 ­ PC와 메인 프레임뿐만 아니라 많은 컴퓨터 판매사들의 호스트에 사용됨 · IBM의 AIX, 선마이크로시스템의 Solaris 등 ­ 유닉스와 비슷한 운영체제들 개발됨 · DEC ­ VAX를 위해 Ultrix라 불리는 유닉스 시스템 개발 · 마이크로소프트 ­ Intel 8088을 위해 유닉스를 개발하여 Xenix라 부름 · 개발된 시스템들은 대부분 System III, Version 7, 42 BSD, System V등에 기초하고 있 음 ▶ 유닉스의 설계 원리 ­ 시분할 시스템과 다수의 프로세스들을 지원하도록 설계됨 · 하나의 프로세스는 새로운 프로세스들을 쉽게 만들 수 있음 · 소형 컴퓨터에 대한 운영체제의 좋은 예로, 설계자들인 프로그래머들의 편리성에 기초함 ­ 운영체제의 크기가 작고 이해하기 쉬움 ­ 단기적인 설계 목표 · 소프트웨어 개발을 지원해주는 운영체제 개발 · 운영체제 알고리즘을 가능한 단순하게 구성 ­ 특징
① 프로그래머들을 위한 대화형 설계 · 프로그램 개발을 위한 기능에 높은 우선순위를 부여함
② 표준 사용자 인터페이스 · 간단하고, 다른 인터페이스로 대체 가능 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr
③ 파일 시스템 · 사용자가 자신의 부디렉터리를 만드는 것을 허용하는 다단계 트리
④ 장치의존성 등 여러 특성을 가능한 하나의 커널에 포함시킴 · 디스크 파일들과 입출력장치들을 가능한 동일하게 취급하기 위함 · 프로그래머가 코드를 작성하는데 필요한 유틸리티들을 운영체제에 포함 · 각 유틸리티는 한 가지 기능을 수행하면서 완벽하게 실행될 수 있도록 단순하게 설 계됨
⑤ 소규모 모듈로 구성 · 유틸리티들이 서로 결합되어 사용할 수 있도록 설계됨 · 프로그래머가 특정 작업의 수행에 필요한 적절한 유틸리티 선택 가능 · 단순하고 간결한 구조로 표현되어 쉽게 숙달 가능
⑥ 장기적인 설계 목표로 “이식성의 용이함”을 가짐 · 운영체제에서 개발한 운용소프트웨어들이 기계에 쉽게 이식될 수 있도록 하는 것 · 변환비용을 감소시키고 하드웨어 변경 시 응용 패키지들의 수정이 필요 없음
⑦ C언어 채택 · 어셈블리보다 유연한 C언어를 사용하여 유닉스를 하나의 하드웨어 시스템에서 다른  시스템으로 옮기는 문제를 단순화시킴
⑧ 개방성 · 모든  유닉스소스들을 누구나  사용할  수  있도록  온라인화하여  개발자들이  기본  시스 템 개발에 사용 · 새로운 가능성과 구현 사항을 만들고, 부족한 사항 및 곤란한 문제점들의 발견을 용 이하게 만듦 · 오늘날 유닉스의 다양화 현상을 촉진시킴 ▶ 유닉스의 구조 ­ 3가지 수준 “사용자, 커널, 하드웨어”로 이루어 짐 · 커널은 파일 및 입출력을 담당하는 파일 서브시스템과 프로세스를 제어하는 프로세서 제 어 서브시스템의 두 요소로 구성됨 · 시스템 커널의 블록도 ­ 커널 내의 일부 모듈은 다른 모듈의 내부연산과 상호작용함 ­ 실제와는 차이가 있으나 논리적 관점을 효과적으로 보여줌 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 사용자 프로그램 라이브러리 사용자 수준 커널 수준 시스템 호출 인터페이스 파일 서브 시스템 실행을 위해 프로세스  프로세스 간 통신  버퍼 캐시 메모리로  제어  스케줄러 파일 적재 서브시스템 메모리 관리 문자 블록 장치 드라이브 하드웨어 제어 하드웨어 수준 하드웨어         ▶ 유닉스의 사용자 인터페이스 ㆍ 셸(Shell)
- 프로그램은 명령어 해석기에 의해 수행되며, 명령어 해석기는 사용자 프로세스로 운영체 제의 커널을 둘러싸고 있음 · 셸은 그 기능 때문에 명령어 해석기로 알려져 있음
- 셸 자체가 프로그래밍 언어임 · 단순히 상호작용하는 명령어 해석기이면서, 유닉스 프로그램들의 조정 및 협동을 위한  기능 수행
- 명령의 수행은 fork 시스템 호출과 목적 파일의 execve에 의해 수행됨  · 명령에 대한 수행이 끝날 때까지 자신의 실행을 중단하고 대기함
- 자주 사용되는 프로그램 · 편집기(vi), 파이프라인, 필터, 스크립트 파일 등
- 최근 유닉스에는 많은 메뉴 방식과 아이콘 인터페이스가 추가됨 vi cat ksh who 디바이스 인터페이스 sh sort 하드웨어 awk csh 파일 시스템 멀티태스킹 커널 ls 셸 cc 유틸리티 유닉스 구조 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 2. 프로세스 관리 ▶ 프로세스 ­ 실행 중인 프로그램으로, 정수로 된 프로세스 식별자(ID)를 이용해 구분 · 자신의 스택과 데이터를 읽거나 쓸 수 있음 ­ 다른 프로세스의 스택과 데이터는 읽거나 쓸 수 없음 · 프로세스 간 통신은 시스템 호출에 의해 이루어 짐 ­ 프로세스 0을 제외한 모든 프로세스는 fork 시스템 호출에 의해 생성됨 · 커널은 각 프로세스의 유일한 프로세스 식별자로 구분 ­ 프로세스 0(스와퍼) : 시스템이 부팅할 때 생성, 프로세스 1(Init)을 생성함 ­ 프로세스 1 : 모든 프로세스의 조상(Ancestor) * 사용자가 로그인 했을 때, 사용자에게 사용자 프로세스를 생성해 줌 ­ 세 가지 종류의 프로세스 존재
① 사용자 프로세스 ­ 단말기의 사용자와 관련된 프로세스
② 커널 프로세스 ­ 커널모드에서 실행되며 프로세스 0이 해당됨 ­ 커널 프로세스를 변경하려면 커널을 재컴파일해야 함
③ 데몬 프로세스 ­ 다른 사용자와 전혀 관련이 없지만 전역함수와 같이 네트워크 제어, 관리 등 시스템 을 지원하는 프로세스 ­ 유닉스는 사용자 프로세스 환경에서 실행 · 사용자모드와 커널 모드가 필요함 · 시스템 프로세스와 사용자 프로세스를 사용
① 시스템 프로세스  ­ 커널모드에서 실행 ­ 프로세서  할당,  프로세스  스케줄링,  메모리  할당과  프로세스  교환  등  시스템  관리  작업을 수행하는 운영체제 코드를 실행 ­ 커널은 작업 수행을 위해 프로세스 테이블을 유지함
② 사용자 프로세스 ­ 사용자모드에서 동작 ­ 사용자 프로그램이나 유틸리티를 수행함 ­ 인터럽트 등이 발생되며 시스템 호출을 통해 커널모드로 들어감 ­ 상태 전이도에 따른 전형적인 프로세스 · 유닉스는  프로세스가 사용자모드  또는  커널모드에서  실행되는지를 나타내기 위해 두 개 의 실행상태를 보여줌 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr fork
⑧
⑦ 선점 메모리 생성 메모리 부족 사용자로 복귀 충분 (교체 시스템 해당)
①
③ 교체 나감
⑤ 선점됨 사용자  메모리에서 실행 준비 (중단) 실행 복귀 실행 준비 교체 들어옴 되어 교체 시스템 호출,
② 프로세스를 커널  인터럽트 재스케줄 실행 인터럽트, 깨움 깨움 exit 수면 인터럽트 복귀
④
⑥
⑨ 메모리에서 수면상태로 좀비 수면 교체 나감 교체 프로세스 상태 전이도 ▶ CPU 스케줄링 ­ 유닉스 스케줄러는 다단계 피드백을 갖는 순환할당 스케줄러에 속함 · 시분할 시스템에서 커널은 각 프로세스에 시간 할당량이라는 시간 동안 프로세서를 할당 ­ 시간 할당량 초과 시 그 프로세스를 중단, 다른 프로세스를 스케줄함 ­ 프로세스들은 프로세서 위주의 작업들을 위한 순환할당 알고리즘과 같은 우선순위 알 고리즘에 의해 CPU 시간의 일부를 할당 받음 · 커널이 CPU 시간 할당량을 프로세서에 할당 ­ 프로세스가 시간 할당량을 초과하면 중단시킨 후 여러 우선순위를 갖는 큐 중 우선순 위가 가장 높은 하나를 선택 · 프로세스의 우선순위는 사용자 우선순위와 커널 우선순위의 두 종류로 구분 높은 우선순위
-4 디스크 입출력 대기
-3 디스크 버퍼 대기 커널모드에서
-2 단말기 입력 대기 프로세스 대기
-1 단말기 출력 대기 0 자식 종료 대기 0 사용자 우선순위 0 1 사용자 우선순위 1 2 사용자 우선순위 2 사용자모드에서 3 사용자 우선순위 3 프로세스 대기 낮은 우선순위 우선순위 수준 3 프로세스 큐 우선순위를 갖는 다단계 큐 구조 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 3. 프로그래머 인터페이스 ▶ 파일 조작 ­ 커널 측면에서의 파일은 어떠한 구조도 가지고 있지 않음 · 파일은 트리 구조의 디렉터리에서 생성 · 디렉터리들은 다른 파일들을 어떻게 찾아야 하는지에 대한 정보를 가진 하나의 파일 · 파일에  대한  경로명(Path  Name)은  디렉터리  구조에서  파일에  도달할  수  있는  경로를  명시한 텍스트 문자열임 ex: /usr/local/font ­ 유닉스의 경로명은 절대 경로명과 상대 경로명으로 구분
① 절대 경로명 ­ 파일 시스템의 루트에서부터 시작되고, 이름의 시작 부분이 ‘/’임
② 상대 경로명 ­ 현재 디렉터리에서 시작 · local/font는  현재  디렉터리  내에  있는  local이라는  디렉터리에서  font라는  이름 의 파일 또는 디렉터리를 가리킴 ­ 디렉터리에서 “”이라는 파일명은 디렉터리 자신에 대한 하드 링크임 · 하드웨어 장치는 파일 시스템 내에서 이름을 가짐 · 특수 파일들은 장치 인터페이스로서 커널에 인식되나 다른 파일처럼 시스템 호출에 의해  또는 사용자에 의해서 액세스할 수 있음 · /dev : /dev/console, /dev/1p0, /dev/mt0 등과 같은 특수 장치 파일들을 가짐 · /bin : 유닉스 시스템 프로그램들에 꼭 필요한 2진 파일들을 가짐 · /usr/bin : 문장 형식기(Text ex)ormatters) 등과 같은 응용 시스템들을 가짐 · /lib, /usr/lib, /usr/local/lib 등에는 C, Pascal, ex)ORTRAN 등의 서브루틴 라이브러리 파 일들을 보관 · /home : 사용자 파일들을 각 사용자 디렉터리에 저장 · /etc : 시스템에서 많이 사용하는 관리 파일들 존재 ­ 기본적인 파일 조작에 대한 시스템 호출 · creat : 주어진 경로명에 따른 파일(빈파일)을 생성 또는 파일 제거 · open : 존재하는 파일을 개방(경로명과 읽기, 쓰기, 읽고 쓰기 등과 같은 모드 유지) · close : 파일을 닫음 · trunc : 파일의 길이를 0으로 감소시킴 · read/write : 입출력 수행, 즉 파일로부터 정보를 추출(read)하며 버퍼로부터 자료를 외 부파일로 복사(write)함 · unlink : 링크 제거 4. 파일 시스템 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr ▶ 블록과 단편화 ­ 대부분의 파일 시스템을 실제로 저장하는 데이터 블록을 구성하고 있음 · 디스크 섹터는 속도 면에서 크기가 큰 블록으로 구성하는 게 유리함 · 크기가 작은 파일도 저장되므로 큰 블록은 과도한 내부단편화를 발생시킬 수 있음 ­ 유닉스  시스템  43  BSD에서는  내부  단편화를  줄이기  위해  크기가  다른  두  종류의  블록을  사용함 ㆍ 디스크 블록의 할당
- 한 프로세스가 파일에 데이터  저장 시,  커널은 직접 데이터  블록과 간접 데이터  블록을  위해 파일 시스템에 디스크 블록을 할당해야 함
- 유틸리티 프로그램 mkfs(make file system)   · 파일 시스템의 데이터 블록을 연결 목록으로 고성 · 목록의  각  링크는  자유  디스크  블록  번호의  배열을  포함하고  있는  디스크  블록으로  구성 · 배열의 한 항목은 연결 목록의 다음 블록의 번호를 가리킴 ㆍ 디스크 블록 영역
- 파일에 있는 데이터 블록 개수는 시스템의 고정 블록의 크기에 따라 다름 · 유닉스 시스템 V 버전은 블록의 크기가 1KB이고, 각 블록은 256개의 블록 주소를 갖 고 있음
- 유닉스  파일  관리  시스템에서  디스크는 512,  1024,  2048byte 등의 크기를 갖는 블록 들로 구성되며 다음과 같이 네 개의 영역으로 나뉨 부트블록 수퍼블록 i
-노드 데이터 블록 파일 시스템 배치
① 부트 블록(Boot Block)
- 파일 시스템에 유닉스 커널을 적재시키기 위한 프로그램이 포함된 영역
② 슈퍼 블록(Super Block)
- 파일 시스템마다 있으며, 파일 시스템의 크기 등 전체 파일 시스템에 관한 정보를  가지고 있음
- 자유 블록(ex)ree Block)의 한 블록당 한 개의 비트들이 나열된 비트맵으로 구성
- 비트 1은 그 블록이 사용되지 않고 있음을 나타내고, 0은 사용되고 있음을 나타냄
③ i
-노드 목록(영역)
- 디스크에 정적 형태로 유지되며 커널에 의해 메인 메모리로 적재됨
- 특정 파일에 관한 대부분의 정보를 가지고 있는 레코드(인덱스 노드) 필드 바이트 크기설명 모드 2 파일 형태, 보호 비트 N링크 2 i
-노드에 대한 디렉터리 엔트리 수 사용자 식별자 2 파일의 개별 소유자 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다. 운영체제 www.smart.ac.kr 그룹 식별자 2 파일의 그룹 소유자 크기 4 파일의 크기(바이트 수) 주소 39 주소 정보(직접(10), 간접 블록(3)) 생성자 1 생성번호 액세스 시간 4 파일에 마지막으로 액세스한 시간 수정 시간 4 파일을 마지막으로 수정한 시간 변경 시간 4 i
-노드를 수정한 마지막 시간 i
-노드 구조
④ 데이터 블록
- 파일 저장을 위한 자유 블록을 포함하며 자유 블록을 연결 리스트로 유지
- 실제 데이터가 파일의 형태로 저장되어 있음 학습자님의 학습 편의 향상을 위하여 제공되는 이 자료에 대한 저작권은 숭실원격평생교육원에 있습니다. 해당 자료의 재편집 및 무단 복제가 이루어질 경우 법적 책임이 발생할 수 있습니다.
