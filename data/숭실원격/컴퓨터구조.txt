1  컴퓨터 구성

1. 컴퓨터 내부의 구성 요소를 이해하고 설명할 수 있다. 1주차  수업목표  
2. 컴퓨터의 발전 과정을 세대별로 살펴보고 이를 통해 세대별 1교시  컴퓨터를 설명할 수 있다.
1. 컴퓨터 구성 요소 세부내용 
2. 컴퓨터 발전과정 1. 컴퓨터 구성 요소 ▶ 컴퓨터 구성의 분류
1) 하드웨어(Hardware)와 소프트웨어(Software)로 구분 ­ 하드웨어 : 컴퓨터의 기계적인 장치를 의미(변경 x) ­ 소프트웨어 : 하드웨어의 동작을 제어하고 지시하는 모든 종류의 프로그램을 의미(변경 o) 중앙처리장치 연산장치, 제어장치 하드웨어 기억장치 주기억장치, 보조기억장치 입출력장치 입력장치, 출력장치 컴퓨터 시스템 소프트웨어 소프트웨어 응용 소프트웨어 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 하드웨어 v 컴퓨터 하드웨어(computer hardware, H/W, 순화용어 : 굳은모)는 중앙 처리 장치, 모니 터, 자판, 컴퓨터 기억 장치, 그래픽 카드, 사운드 카드, 메인보드와 같은 컴퓨터의 물리적 부품을 의미 ⋅ 하드웨어가 구현하는 기능 : 입력, 연산, 제어, 기억, 출력이를 위해 컴퓨터는 여러 가 지 부품들로 구성 ⋅ 하드웨어와 반대가 되는 용어는 소프트웨어 ⋅ 소프트웨어는 특정 작업을 수행하기 위해 하드웨어에 의해 저장되고 실행되는 명령어를 의미 ▶ 중앙처리장치 ㆍ 중앙처리장치란? ­ 컴퓨터의 두뇌에 해당하는 장치(제어, 연산, 레지스터) ­ 컴퓨터 시스템 전체를 제어하는 장치로서 입력장치에서 데이터를 입력 받아 처리한 후 출 력장치와 기억장치로 데이터를 보냄   ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ㆍ 산술·논리 연산장치(ALU, Arithmetic Logic Unit) ­ CPU의 핵심 요소로써 산술 연산(Arithmetic Operation)과 논리 연산(Logic Operation)을 수행하는 장치 ⋅ 산술 연산 : 주로 덧셈, 뺄셈, 곱셈, 나눗셈 등의 사칙연산을 수행 ⋅ 논리 연산 : 참과 거짓을 판결하는 연산으로 대표적으로 AND, OR, NOT, X
-OR등의 연산을 수행 ㆍ 제어장치(Control Device) ­ CPU 내부에서 일어나는 모든 작업을 통제하고 관리 ⋅ 적절한 순서로 명령어를 인출하고 그 명령어를 해석한 결과에 따라 컴퓨터 시스템의 필요한 부분으로 제어신호를 전달함(가장 중요) ▶ 기억장치 ㆍ 기억장치 ­ 기억장치는 내부 기억장치와 외부 기억장치로 나눔(경제) ⋅ 내부 기억장치 : CPU 내의 레지스터와 캐시기억장치, 주기억장치 ⋅ 외부 기억장치 : 보조기억장치(하드 디스크, 플로피 디스크, CD
-ROM, DVD) Low High 속도 용량 가격 High Low ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 중앙처리장치 ㆍ 주기억장치(Main Memory) ­ 컴퓨터 시스템에서 수행되고 있는 프로그램과 수행에 필요한 데이터를 기억하고 있는 장 치(명령어와 데이터) ⋅ CPU에 접근 속도가 빠르며 많은 양의 데이터를 기억할 수 있음(DRAM) ⋅ RAM(Random Access Memory)이 사용하고 있음 <CPU> <RAM> ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미  3   ㆍ 보조기억장치(Secondary Memory) ­ 외부 기억장치라고도 하며 반영구적으로 데이터를 저장하고 보존할 수 있음 ⋅ 보조기억장치에 저장된 데이터는 중앙처리장치와 직접 정보를 교환할 수 없기 때문에 주기억장치로 옮겨진 후 처리됨 ⋅ 주기억장치에 비해 가격은 저렴하고 저장 용량 또한 크지만 속도가 느리다는 단점이 있음 <자기 테이프, 자기 디스크, 자기 드럼, 플로피 디스크, 하드 디스크, CD
-ROM, DVD, 플래시 메모리, 광 디스크 등(SSD)> ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 입력장치 ㆍ 입력장치 ­ 컴퓨터에서 처리할 데이터와 정보를 외부에서 입력해주는 역할을 수행 ­ 처리하고자 하는 데이터를 제어장치의 명령에 따라 입력매체에서 읽어서 기억장치로 보냄 (인터럽트) ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 출력장치 ㆍ 출력장치 ­ 컴퓨터 내부에서 처리된 결과를 사용자가 보거나 들을 수 있도록 출력매체를 이용해서 내보냄 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 소프트웨어 v 소프트웨어는 컴퓨터 프로그램과 그와 관련된 문서들을 총칭하는 용어(소프트웨어 → 프로 그램 → 명령어 → mirco
-op) ­ 정보들이 이동하는 방향과 정보처리의 종류를 지정하고 이러한 동작이 일어나는 시간을 지 정하는 명령어의 집합 ­ 시스템 소프트웨어와 응용 소프트웨어로 분류(하드웨어)  4   ­ 하드웨어가 발달하여 가격이 저렴해지고 교체가 잦아짐에 따라 소프트웨어의 중요성은 더 욱 높아지고 있음 ⋅ 소프트웨어로 향상되는 생산성, 바뀐 하드웨어에 적용할 수 있는 소프트웨어의 호환성, 유지보수를 하는 것이 효율적인지 등의 요구 조건 중요(소프트웨어 공학) v 컴퓨터 소프트웨어(computer software, 혹은 간단히 소프트웨어, 문화어 : 쏘프트웨어, 순화 용어 : 무른모)는 저장장치에 저장된 특정한 목적의 하나 또는 다수의 컴퓨터 프로그 램을 뜻함 ­ 프로그램 소프트웨어는 컴퓨터 하드웨어에 직접 명령어를 주거나 다른 소프트웨어에 입력 을 제공함으로써, 그것이 수행하도록 구현된 기능을 수행함 v “소프트웨어”라는 용어는 1957년에 존 터키(John W. Tukey)가 처음 사용했으며, 일상적 으로 이 용어는 응용 소프트웨어의 의미로 자주 쓰임 컴퓨터 과학과 컴퓨터 공학에서 "컴퓨터 소프트웨어"는 컴퓨터 시스템, 프로그램, 데이터 에 의해 처리된 모든 정보를 말함 ⋅ 컴퓨터 소프트웨어는 컴퓨터 하드웨어의 반대 의미 ⋅ 컴퓨터 하드웨어는 소프트웨어가 실행되고 저장되는 물리적 장치(물리 구조) ▶ 소프트웨어의 분류 ㆍ 시스템 소프트웨어(System Software) ­ 여러 컴퓨터 시스템에서 공통적으로 필요한 프로그램으로, 사용자가 컴퓨터를 좀 더 효 율적으로 사용하기 위해 만듦 ­ 컴퓨터 시스템을 제어하고 운영하는 프로그램 ­ 운영체제 프로그램(DOS, UNIX, Windows9x, Window 2000, Windows XP, Window

7), 컴파일러(C •ex)ORTRAN 컴파일러 등), 입출력 제어 프로그램 등이 있음 (하드웨어와 밀접한 연관) ㆍ 응용 소프트웨어(Application Software) ­ 시스템 소프트웨어를 기반으로 특정한 응용 분야에서 특수 목적을 위해 사용할 수 있는 프로그램 ­ 사무 자동화 프로그램, 공학용 계산 프로그램, 인터넷 웹 브라우저, 그래픽 프로그램 등 이 이에 속함 2. 컴퓨터 발전과정 ▶ 컴퓨터의 발전
1) 수동식 계산기 : 수판 ­ 기원전 3000~2500년 경 중국에서 개발, 1980년대까지 사용(주판)
2) 기계식 계산기 ­ 파스칼라인 ­ 가감승제 계산기 ­ 차분기관과 분석기관 ­ 천공카드 도표 작성기(배비지 분석 엔지 ­ 컴퓨터 외형)  5   <파스칼라인> ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미
3) 전기기계식 계산기(최초) ­ MARK1 : 종이 테이프에 천공된 프로그램 명령어들에 의하여 작동 제어되도록 설계됨
4) 전자식 계산기(최초) ­ 아타나소프
-베리 컴퓨터(ABC computer) ­ 순차적 방식과 2진 법체계를 사용하는 진공관방식 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 전자식 디지털 컴퓨터 ㆍ ENIAC ­ 최초의 전자식 디지털 컴퓨터(1946)(vs. ABC) ⋅ 전자적인 가산기를 연산용 기억장치로 사용 ⋅ 컴퓨터 내부의 회로 소자로 진공관을 사용(만개 이상) ⋅ 프로그램을 작성하려면 컴퓨터 각 부분을 전선으로 연결해야 하고, 프로그램의 수행 을 위해서는 6,000여 개의 스위치를 조절해야 함 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ㆍ 내장 프로그램 방식 컴퓨터 ­ 1945년 폰 노이만(Von Neumann)이 제안 ­ 컴퓨터에 기억장치를 설치하고, 프로그램과 데이터를 함께 기억장치에 저장했다가, 프로 그램에 포함된 명령에 따라 자동으로 작업을 처리하는 방식(컴퓨터 내부 동작 원리) ­ 오늘날 컴퓨터의 기본 사상 ­ EDVAC(Electronic Discrete Variables Automatic Computer) : 1952년 미국에서 최 초로 개발된 프로그램 내장 방식의 컴퓨터 ­ 프로그램 내장식 컴퓨터(stored
-program computer) 또는 프로그램 내장식 전산기는 전자식 기억 장치에 프로그램 명령어를 저장하는 전산기(다중 프로그래밍) ­ 축적 프로그램용 컴퓨터, 내장 프로그램 컴퓨터라고도 부르며, 이를 이용한 방식을 프로 그램 내장 방식이라고 함  6   ⋅ 폰 노이만 구조
- 폰 노이만 구조는 프로그램 데이터와 명령어 데이터를 같은 메모리에 저장하는 프 로그램 내장컴퓨터
- 하버드 아키텍처는 프로그램과 데이터를 저장하기 위한 별도의 기억 장치들을 지 니고 있음 ⋅ 아타나소프
-베리 컴퓨터와 같은 수많은 초기 컴퓨터들은 다시 프로그래밍을 할 수 있 는 기능이 없었다. 이들은 사용자가 짜넣을 수 없는 하나의 프로그램을 실행하였다. 이들이 프로그램 명령어가 아닌 까닭에 프로그램 내장 방식은 필요하지 않았다. 프로 그래밍을 할 수 있는 다른 컴퓨터들은 이들의 프로그램을 필요할 때마다 천공 테이 프에 저장하였다 ­ 맨체스터 대학교의 SSEM : 세계 최초의 프로그램 내장식 컴퓨터 ­ 맨체스터 마크 1 : 또 다른 초기 프로그램 내장식 컴퓨터 ㆍ UNIVAC I(Universal Automatic Computer) ­ 이전의 특수 목적용이 아닌 최초의 순수 데이터 처리용이며 상업용 컴퓨터 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ㆍ IBM 701 ­ 1952년에 CRT(cathode
-ray
-tube)를 주기억장치로 하고, 보조기억장치로서 자기 드럼과 자기 테이프를 채택 ⋅ 본격적인 상업용 컴퓨터 시대를 열었음 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 컴퓨터의 세대별 발전 세대별 사용 전자 소자 사용 언어 특징 및 응용 분야 대표 기종 회로 : 진공관 기계어
- 수명이 짧음 ENIAC 기억 : 자기코어 어셈블리어
- 부피가 크고 전력 EDVAC 자기 드럼 소모 많음 UNIVAC 1세대 수은 지연회로
- 냉각장치 필요 (1946~1956)
- 하드웨어에 중점
- 과학 계산, 통계, 집계 2세대 회로 : 트랜지스터 ex)ORTRAN
- 일괄 처리 IBM 1101  7   기억 : 자기코어 COBOL
- 컴파일러 사용 NCR 304 자기 드럼 ALGOL
- 입출력 채널 대두 Honeywell 800 (1957~1964) 자기 테이프
- 생산 관리, 원가 관 리 회로 : 집적회로 PASCAL
- 다중 처리 UNIVAC 9000 기억 : IC 기억장치 LISP
- 예측, 의사결정 PDP
-11 3세대 자성망막 구조화된 언어
- 운영체제 개발 CRAY
-1 (1965~1979) 자기 디스크 CYBER
-205 자기 테이프 회로 : 고밀도 집적회로 ADA
- 네트워크 관리 CRAY 초고밀도 집적회로 문제중심 언어
- 데이터베이스 관리 XMP 4세대 기억 : LSI
- 지식정보 처리 IBM 308 (1980~현재) VLSI
- 인공지능 자기 디스크
- 로봇 자기 테이프
- 인간 지능화 시대
- 사고하는 감각을 지닌 컴퓨터 사용 소자 중심으로 분
- 처리 속도의 류하는 세대가 아니라 5세대 초고속화(4세대의 얼마나 인간다운 컴퓨터 (미래) 약 10
-100배 가 될 것인가로 세대를 속도) 구별
- 바이오칩이나 광소 자를 이용한 칩의 실현 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 진공관

1) 진공관(眞空管, 영어: vacuum tube) ­ 전자공학에서 진공관은 일반적으로 진공의 공간에서 전자의 운동을 조종함으로써 신호를 증폭하거나 변경하는 데 사용하는 장치 ­ 진공관이라는 이름 말고도 전자관(Electronic tube), 열전자관(Thermionic valve), 라디오 밸브(Radio valve)로 부르기도 함 ⋅ 한 때 대부분의 전자 장치에 사용되었으나 현재는 대부분의 전자 장치에서 더 작고 더 값싼 트랜지스터 또는 반도체, 집적회로 등으로 대체되었으며, 진공관은 높은 주파의 큰 전력을 사용하는 전자 장치에만 쓰이고 있음 ⋅ 최근에는 그 이용이 점점 줄어들고 있는 추세(면밀히 말하자면 컴퓨터의 플로피 디스크 격임) ▶ 트랜지스터
1) 트랜지스터(영어: transistor)  8   ­ 트랜지스터는 게르마늄, 규소 따위의 반도체를 이용하여 전자 신호 및 전력을 증폭하거나 스위칭하는 데 사용되는 반도체소자 ⋅ 현대 전자 기기를 구성하는 굉장히 흔한 기본 부품 중 하나 ⋅ 1947년 미국 물리학자 존 바딘, 월터 브래튼, 윌리엄 쇼클리에 의해 트랜지스터가 개 발된 후 전자공학의 대변혁을 일으켰으며, 트랜지스터의 출현으로 인해 더 작고 값싼 라디오, 계산기 컴퓨터 등이 개발되었음 ⋅ 아날로그, 디지털 회로에서 트랜지스터는 증폭기, 스위치, 논리회로, RAM 등을 구성하 는 데 이용됨 ▶ 직접 회로
1) 집적 회로(集積回路, 영어: Integrated Circuit) ­ 집적 회로는 모놀리식 집적회로, 칩, 마이크로칩, IC는 반도체에 만든 전자회로의 집합 ⋅ 여러 독립된 요소를 집적해서 하나의 칩으로 만든 것 ⋅ 각각의 트랜지스터 칩을 이용해서 회로로 만들 때 보다 훨씬 작게 만들 수 있음 ⋅ 손톱수준의 크기에 수십억 개의 트랜지스터나 다른 전자부품이 들어갈 수 있을 정도로 조밀하게 만들 수 있음 ⋅ 반도체 소자가 진공관처럼 증폭기 및 스위치 역할을 할 수 있다는 것이 밝혀 지고, 반 도체 제작 기술이 발달하면서, 집적회로를 만들 수 있게 되었음 ⋅ 이산회로와 비교한 집적회로의 장점 : 비용과 성능 ⇨ 한 번에 하나의 트랜지스터를 조립하는 방식과는 달리 사진석판술을 이용하여 모든 부품을 한꺼번에 찍어내기 때문에 비용이 낮아짐  9   컴퓨터의 분류 및 표현
1. 컴퓨터의 다양한 분류 방법에 대해 살펴보고 이를 통해 컴퓨터 1주차  수업목표   분류 방법을 설명할 수 있다. 2교시 
2. 컴퓨터 내의 정보의 표현을 이해하고 설명할 수 있다.
1. 컴퓨터의 분류 세부내용 
2. 정보의 표현 1. 컴퓨터 분류 ▶ 사용 목적에 따른 분류
1) 전용 컴퓨터(Special Purpose Computer) ­ 특정한 목적 위해 설계된 컴퓨터(한가지 목적) ⋅ 군사용이나 공장의 공정 제어용 등 한정된 목적으로 사용
2) 범용 컴퓨터(General Purpose Computer) ­ 여러 분야의 다양한 일을 처리할 수 있도록 설계 제작된 컴퓨터(다양한 목적) ⋅ 다양한 응용 소프트웨어가 여러 분야의 다양한 일 처리를 가능하게 함 ▶ 사용 데이터에 따른 분류
1) 디지털 컴퓨터 ⋅ 모든 정보를 2진수의 데이터로 부호화하여 사용 ⋅ 대부분의 컴퓨터가 디지털 컴퓨터, 아날로그 컴퓨터보다 정밀도가 높은 편(양자 컴퓨터)
2) 아날로그 컴퓨터 ­ 아날로그 신호를 데이터로 이용하는 컴퓨터 ⋅ 신속한 입력과 즉각적인 반응을 얻을 수 있어 제어용 목적에 적합
3) 하이브리드 컴퓨터 ­ 아날로그와 디지털의 장점을 취하여 제작한 것으로 어떤 종류의 데이터도 처리할 수 있는 컴퓨터 ▶ 처리 능력에 따른 분류 v 중앙처리장치와 기억장치의 규모에 따른 분류
1) 마이크로 컴퓨터(Microcomputer) ­ PC를 의미하며 가정용이나 작은 사업의 용도로 사용되는 소형의 컴퓨터
2) 중형 컴퓨터(Minicomputer) ­ 대용량의 주기억장치와 보조기억장치 그리고 빠른 주변장치들을 가지고 있어 수십 명 또는 수백 명이 쓰기에 적합한 컴퓨터(현재 : 손 안의 작은 컴퓨터) ⋅ 중소기업, 학교, 연구소들에서 주로 사용
3) 대형 컴퓨터(Mainframe Computer) ­ 대용량의 저장장치를 보유하여 다중 입출력 채널을 이용한 고속의 입출력 처리 능력을 보  10   유한 컴퓨터 ⋅ 공공 단체, 대기업, 은행, 병원, 대학 등으로 단말기를 연결시켜 온라인 업무나 분산 처 리 업무에 이용 ⋅ 대규모 데이터 베이스 저장 및 관리 용으로 사용
4) 수퍼 컴퓨터(Super Computer) ­ 복잡한 계산을 초고속으로 처리하는 초대형 컴퓨터로 가장 빠르고 비싼 컴퓨터(6월, 11월 → 성능 top 500) ⋅ 원자력 개발, 항공우주, 기상 예측 등의 분야에서 사용 ▶ 구조에 따른 분류
1) 파이프라인 슈퍼 컴퓨터(Pipeline Supercomputer) ­ 하나의 CPU 내에 다수의 연산장치를 포함하고 있는 컴퓨터 ­ 각 연산장치는 파이프 라이닝 구조를 이용하여 고속 벡터 계산이 가능(파이프라인 → 병렬 수행)
2) 대규모 병렬 컴퓨터(Massively Parallel Computer) ­ 하나의 시스템 내에 상호 연결된 수백 혹은 수천 개 이상의 프로세스들을 포함 ­ 프로세서들이 하나의 큰 작업을 나누어서 병렬로 처리하는 구조 2. 정보의 표현  ▶ 컴퓨터에서 정보의 표현 v 컴퓨터에서는 데이터 1비트를 기본으로 0, 1 두 개의 숫자를 표시하는 2진법을 사용 ㆍ 비트(Bit) ­ 2진수에서 데이터를 표현하는 단위(4비트 → 니블) ­ 2진수의 조합은 만큼의 조합을 가질 수 있고, n은 비트의 수 ㆍ 바이트(byte) ­ 정보처리를 위해 사용되는 비트의 집합, 8bit를 1byte로 규정 ㆍ 워드(word) ­ 컴퓨터가 한 번에 처리할 수 있는 데이터의 양(32bit vs. 64bit) ­ 컴퓨터 종류에 따라 2바이트, 4바이트, n바이트 등으로 구성, 일반적으로 32비트(4바이 트)가 가장 많이 쓰이고 있음
1) 비트당 사용 가능한 2진수의 조합 :  비트 수 사용 가능한 2진수 조합 비트 수 사용 가능한 2진수 조합 1 2 5 32 2 4 6 64 3 8 7 128 4 16 8 256  11  
2) 디지털 정보의 표현 단위(비트)(더 많은 단위 → 위키) 이름 약어 크기 이름 약어 크기 Kilo K =1,024 Giga G =1,073,741,824 Mega M =1,048,576 Tera T =1,099,511,627,776 ▶ 수의 진법
1) 10진법(Decimal Notation) ­ 인간이 사용하는 수의 체계로 0, 1, 2, 3, 4, 5, 6, 7, 8, 9의 열 가지의 기호를 이용하여 수를 표현(사람이 사용) ­ 각 자리에서 9 다음에 자리 올림이 발생. 이때 자리 올림으로 생성된 각 자리의 단위는 10 의 지수 승()이 됨 * 10진수의 표시 :  = 5× + 2× + 8× 
2) 2진법(Binary notation) ­ 컴퓨터에서 사용하는 수 체계로 0과 1만을 가지고 수를 표현(컴퓨터가 사용) ­ 각 자리에서 1 다음에 자리 올림이 발생. 이때 자리올림으로 생성되는 각 자리의 단위는 2 의 지수 승()이 됨 ­ 다른 진법과 구별을 하기 위해서 첨자로 2를 표시 * 2진수 101은  로 표현  2의 지수 승 분해 :  = 1× + 1× + 0× + 1×  ㆍ 10진수와 2진수의 비교 10진수 2진수 10진수 2진수 0 0000 5 0101 1 0001 6 0110 2 0010 7 0111 3 0011 8 1000 4 0100 9 1001
3) 8진법(Octal notation) ­ 숫자들이 0, 1, 2, 3, 4, 5, 6, 7 등 8가지의 문자를 이용하여 구성(사람이 컴퓨터에서 사 용) ­ 각 자리에서 7 다음에 자리 올림이 발생. 이때 자리올림으로 생성되는 각 자리의 단위는 8 의 지수 승()이 됨 ­ 8진수의 표현은 8의 아래 첨자를 이용해서 표현 * 8진수 표현의 예 :   8의 지수 승 분해 :  = 2× + 7×   12   ㆍ 10진수, 2진수, 8진수와의 관계 10진수 2진수(2진화 8진수) 8진수 10진수 2진수(2진화 8진수) 8진수 0 000 0 8 001 000 10 1 001 1 9 001 001 11 2 010 2 10 001 010 12 3 011 3 11 001 011 13 4 100 4 12 011 100 14 5 101 5 13 001 101 15 6 110 6 14 001 110 16 7 111 7 15 001 111 17
4) 16진법(Hexadecimal Notation) ­ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9와 A, B, C, D, E, ex) 기호를 사용 ­ 10진법의 10~15까지의 수가 16진법에서는 A, B, C, D, E, ex)로 표현(사람이 컴퓨터에서 사용) ­ 각 자리에서 15 다음에 자리 올림이 발생. 이때 자리올림으로 생성되는 각 자리의 단위는 16의 지수 승()이 됨 ­ 16진수의 표현은 16의 아래 첨자를 이용해서 표현 * 16진수 표현의 예 : ex)ex)  16의 지수 승 분해 : ex)ex) = 1× + 2× + ex)× + ex)×        0 0 1 2 ex) ex) ㆍ 2진수, 10진수, 16진수와의 관계 10진수 2진수(2진화 16진수) 16진수 10진수 2진수(2진화 16진수) 16진수 0 0000 0 10 1010 A 1 0001 1 11 1011 B 2 0010 2 12 1100 C 3 0011 3 13 1101 D 4 0100 4 14 1110 E 5 0101 5 15 1111 ex) 6 0110 6 20 0001 0100 14 7 0111 7 50 0011 0010 32 8 1000 8 248 1111 1000 ex)8 9 1001 9 ▶ 진법 변환
1) 10진법과 2진법 간의 변환 * 각 진법에서 진수를 진법의 지수 승으로 표현하게 되면 M×BE  13   ㆍ 가수(significant) M ­ 10진법에서는 0~9까지의 값, 2진법에서는 0과 1의 값 ­ 8진법에서는 0~7까지의 값, 6진법에서는 0~ex)까지의 값 ㆍ 기수(base) B ­ 10진법에서는 10이 되며, 2진법에서는 2가 됨. 또한 8진법에서는 8이고 16진법에서는 16이 됨 ㆍ 지수(exponent) E ­ 정수의 값 ㆍ 2진법에서 10진법으로 변환 ­ 이진수를 2의 지수 승으로 분해하고 그 합을 구하면 10진수가 얻어짐(원리 동일 : N진 법 → 10진법) ⋅ 예)   ××××××× ××××    ㆍ 10진법에서 2진법으로 변환 ­ 이진  +  + ··· + 로 표현되는 수 체계가  +  + ··· +  + 로 표현되는 수 체계로 변환 ⋅ 예) (원리 동일 : 10진법 → N진법)  ××××  A ×mA ×m···A ×A × m m   ×××××× ××××× 결과적으로 화살표 방향으로 읽으면 2진수  을 구할 수 있음  ⇨     ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미  14  
2) 10진법과 8진법 간의 변환 ㆍ 8진법에서 10진법으로 변환 ­  ××××    ㆍ 10진법에서 8진법으로 변환 ­  ×××  A ×mA ×m···A ×A × m m   ­  ×××    ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미
3) 10진법과 16진법 간의 변환 ㆍ 16진법에서 10진법으로 변환 ­ E ××××    ㆍ 10진법에서 16진법으로 변환 ­  ××××  ×××× E  ­  ×××  ×××× E  ×B×E× BE  ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미
4) 2진법과 8진법 간의 변환 ㆍ 2진법에서 8진법으로 변환 :   ­ 1단계 : 3비트씩 그룹화      ­ 2단계 : 각 3비트씩 10진수로 변환     ㆍ 8진법에서 2진법으로 변환 :   ­ 1단계 : 각 자리별로 2진수로 변환        ­ 2단계 : 3비트씩 구분된 2진수를 하나의 비트열로 만듦         15  
5) 2진법과 16진법 간의 변환 ㆍ 2진법에서 16진법으로 변환 :   ­ 1단계 : 4비트씩 그룹화      ­ 2단계 : 4비트 단위로 10진수로 변환           ­ 3단계 : 중간 단계의 10진수를 각각 16진수로 변경        ex)     ㆍ 16진법에서 2진법으로 변환 : CD  ­ 1단계 : 각 자리별로 10진수로 변환 CD       ­ 2단계 : 변환된10진수를 각 자리별로 2진수로 변환           ­ 3단계 : 변환된 2진수를 16비트의 비트열로 만듦 CD   
6) 8진법과 16진법 간의 변환 ㆍ 8진법에서 16진법으로 변환 :   ­ 1단계 : 8진수의 각 자리별로 3비트의 2진수로 변환        ­ 2단계 : 변환된 2진수를 4비트 단위로 재분할하고 10진수로 변환              ­ 3단계 : 중간 단계의 10진수를 16진수로 변경       A D     ㆍ 16진법에서 8진법으로 변환 : B  ­ 1단계 : 각 자리별로 10진수로 변환 B      ­ 2단계 : 변환된 10진수를 각 자리별로 4비트의 2진수로 변환         ­ 3단계 : 변환된 2진수를 3비트씩 재분할하고 8진수로 변환             16   보수의 개념
1. 컴퓨터 내에서 보수를 사용하는 이유를 이해하고 설명할 수 있다. 1주차  수업목표  
2. 컴퓨터 내에서 뺄셈 연산을 보수로 하는 방법에 대해서 3교시  이해하고 설명할 수 있다.
1. 보수의 정의 세부내용 
2. 뺄셈 연산 1. 보수의 정의 ▶ 수의 분류 v 컴퓨터에서 보수는 음수를 표현하는 데 사용
1) 수(數)의 분류 양수(자연수) 1, 2, 3, … 정수 0(zero) 음수
-1,
-2,
-3, … 유리수 실수 정수가   a 아닌 분수와 소수      … 무리수 유리수 복소수 a + bi    허수 b ▶ 보수의 정의

1) 어원적 의미 ­ 상호 보완하는 수로, 임의의 수를 보완해주는 다른 임의의 수(덧셈으로 뺄셈을 수행 ­ 비용 절감, 호환성)
2) r진법에서 정의되는 보수(complementary number) ­ 두 종류로 정의 ­ (r
-1)의 보수, 진보수라고 하는 r의 보수로 정의 ⋅ 예) 10진수에서는 9의 보수와 10의 보수가 존재 2진수에서는 1의 보수와 2의 보수가 존재 ㆍ r진법에서 (r
-1)의 보수 ­ A라는 수에 B라는 수를 더한 결과값의 각 자리가 (r
-1)이 될 때, B를 A에 대한 (r
-1)의 보수라고 정의 ⋅ 예) 10진수  에 대한 9의 보수를 B라고 하면   17   237 + B = 999 → 237 + B = (1000
-1) → B = (1000
-1)
-237 = 762 ㆍ r진법에서 r의 보수 ­ A라는 수에 B라는 수를 더해서 각 자리마다 자리올림이 발생하고 해당 자리는 0이 될 때, B를 A에 대한 r의 보수라고 정의 ⋅ 예) 10진수  에 대한 10의 보수를 B라고 하면  237 + B = 1000 → B = 1000
-237 = 763 v 반대로 세어 가는 수. 밑수 n의 보수란, 주어진 수치의 각 자리의 값을 ■
-1에서 뺄셈하고 그 결과의 최하위 자리에 1을 더하여 구하는 수치 ⋅ 10진수의 100까지의 수로 생각하면 25라는 수치는 1의 쪽에서 세어 가면 25번째의 수이지만, 반대로 100에서 세면 75번째의 수가 됨 ⋅ 계산하여 구하면 25의 각 자리의 수치를 ■
-1(＝99)에서 뺄셈하면 74가 되어 최하값의 자리에 1을 더하면 75가 됨(100에서 뺄셈) ⋅ 컴퓨터로 뺄셈을 할 경우, 실제로는 보수를 사용한 덧셈(보수 덧셈)을 하고 있음(비용 절감, 호환성) ▶ r진수에서 (r
-1)의 보수 ㆍ r진수에서 (r
-1)의 보수 ­ r진법에서 임의의 정수 (N)r이 자릿수가 n개로 구성될 때, (r
-1)의 보수 정의를 수식으로 표현하면 다음과 같음 * rnN ⋅ 10진수에서 9의 보수
- 9의 보수는 각 자리의 숫자를 각각의 9에서 뺀 것과 같음 ⋅ 예)  에 대한 9의 보수를 구하여라.  rnN  ⋅ 2진수에서 1의 보수
- 2진수에 대한 1의 보수는 각 자리의 숫자를 각각의 1에서 뺀 것과 같음 ⋅ 예)  에 대한 1의 보수를 구하여라.  rnN  ▶ r진수에서 r의 보수 ㆍ r진수에서 r의 보수 ­ r진법에서 임의의 정수 (N)r이 자릿수가 n개로 구성될 때, r의 보수 정의 * rnN (N=0일 경우 0으로 정의) ­ r의 보수는 다음의 관계에 의해서 (r
-1)보수로부터 쉽게 얻어짐 * rnNrnN (r의 보수는 (r
-1)의 보수에 1을 더하면 됨)  18   ⋅ 예)  에 대한 2의 보수를 구하여라.  2진수에 대한 1의 보수 : 111111 ­ 101100 = 010011 2진수에 대한 2의 보수 : 010011 + 1 = 010100 ▶ 1의 보수 v 1의 보수란 어떤 수를 커다란 2의 제곱수
-1에서 빼서 얻은 이진수. 또는 비트를 반전시켜 얻을 수 있음 ­ 1의 보수는 대부분의 산술연산에서 원래 숫자의 음수처럼 취급됨 ⋅ 주어진 이진수와 자리수가 같고 모든 자리가 1인 수에서 주어진 수를 빼서 얻은 수가 1의 보수임 ⋅ 혹은 주어진 이진수의 모든 자리의 숫자를 반전(0을 1로, 1을 0으로)시키면 1의 보수 를 얻을 수 있음 ▶ 2의 보수 v 2의 보수(
-
-補數, 영어: two's complement)란 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수 ­ 2의 보수는 대부분의 산술연산에서 원래 숫자의 음수처럼 취급됨(1의 보수 +

1) ⋅ 주어진 이진수보다 한 자리 높고 가장 높은 자리가 1이며 나머지가 0인 수에서 주어진 수를 빼서 얻은 수가 2의 보수임 ⋅ 혹은 주어진 이진수의 모든 자리의 숫자를 반전(0을 1로, 1을 0으로)시킨 뒤 여기에 1 을 더하면 2의 보수를 얻을 수 있음 ▶ 9의 보수 ­ 10진법에 있어서 감기수 보수(10 ­
1) ­ 10진 기수법에 있어서 감기수의 보수 ­ 숫자의 합이 10의 제곱수
- 1이 되게 하는 수 ­ 각 자릿수별 9와의 차이로 얻는 수 ­ 수의 각자리 숫자를 9에서 빼서 얻어진 보수 ­ 주어진 수치의 각 자리의 값을 9에서 감산하여 구하는 수치 ▶ 10의 보수 ­ 10진법에 있어서 기수 보수(10) ­ 10진 기수법에 있어서 기수의 보수 ­ 숫자의 합이 10의 제곱수가 되게 하는 수 ­ 각 자릿수별 9와의 차이에 최소 유효 숫자에 1을 더하여 얻는 수 ­ 주어진 수치의 각 자리의 값을 9에서 감산하고 그 결과의 최하위의 자리에 1을 가산하여 구하는 수치 ­ 수의 각자리 숫자를 9에서 빼고 그 결과의 수의 최하위에 1을 더하여 필요한 자리올림을  19   행하여 얻어진 보수 2. 뺄셈 연산 ▶ 부호가 없는 10진수의 뺄셈 연산에서 보수의 활용 ­ 컴퓨터에서 뺄셈 연산은 보수를 이용하는 것이 효율적 ­ 부호를 표시하지 않는 10진수에서 보수를 이용한 뺄셈 연산임(비용 절감, 호환성) ⋅ 예) 8 ­ 6 = 2 8은 빼어지는 수로 피감수라하며, 6은 빼는 수로 감수라고 함 감수를 10의 보수로 표현하게 된다면 뺄셈연산은 덧셈 연산으로 대체할 수 있음(8 + 4 =

12) ­ 컴퓨터에서 뺄셈 연산은 보수를 이용하는 것이 효율적 ­ 부호를 표시하지 않는 10진수에서 보수를 이용한 뺄셈 연산임 ⋅ 6일 때 9의 보수 : (10
-

1) ­ 6 = 3 ⋅ 6일 때 10의 보수 : 3 +1 = 4 구해진 10의 보수를 피감수 8과 덧셈을 수행하면 "8 + 4 = 12” 10의 자리는 버리고 1의 자리만 취하면 원하는 값 2를 얻을 수 있음 ▶ 부호가 없는 10진수에서 보수를 이용한 뺄셈 연산 ⋅ 예) 2
- 4 = 2(?) 감수가 피감수보다 큰 값이므로 결과는 음의 값 부호를 표현할 수 없는 10진수이므로 결과 2는 음의 값으로 간주 감수 7의 9의 보수를 구하고 그 결과로부터 10의 보수를 구하면, 4일 때, 9의 보수 : (10
-

1) ­ 4 = 5, 4일 때, 10의 보수 : 5 +1 = 6 구해진 10의 보수를 피감수와 덧셈을 수행 : 2 + 6 = 8 얻어진 연산 결과의 10의 보수(음수이므로)8의 9의 보수 : (10
-

1) ­ 8 = 1, 8의 10의 보수 : 1 +1 = 2 얻어진 10의 보수 2는 실제적으로는 음수
-2라는 것을 고려하여야 함 ▶ 부호가 없는 2진수에서 보수를 이용한 뺄셈 연산 ⋅ 예1) 보수를 이용한 2진수 뺄셈 결과가 최상위 자리에서 자리 올림이 발생하는 경우 1011
- 0100 = 0111 (피감수가 더 크다) 감수 0100의 1의 보수를 구하고 그 결과에 0001을 더해서 2의 보수를 구하면 * 0100의 1의 보수 : (10000
- 00001) ­ 0100 = 1111 ­ 0100 = 1011 * 0100의 2의 보수 : 011 + 0001 = 1100 구해진 2의 보수를 피감수하고 덧셈하면 1011 + 1100 = 10111 자리올림으로 발생한 최상위 자리의 값을 버리고 나머지 값들을 취하면 원래의 뺄셈의 결과와 동일한 0111을 얻음  20   ⋅ 예2) 보수를 이용한 2진수 뺄셈의 결과가 최상위 자리에서 자리올림이 발생하지 않는 경우 0111
- 1010 = 1100(?) (피감수가 더 작다) 0111보다 1010이 더 큰 수이므로 연산의 결과 값 1100은 맞지 않음 2의 보수를 구하면 * 1010의 1의 보수 : (10000
- 00001) ­ 1010 = 1111 ­ 1010 = 0101 * 1010의 2의 보수 : 0101 + 0001 = 0110 구해진 2의 보수를 피감수하고 덧셈하면 : 0111 + 0110 = 1101 얻어진 결과 1101의 2의 보수를 구하면(음수이므로) * 1101의 1의 보수 : (10000
- 00001) ­ 1101 = 1111 ­ 1101 = 0010 * 1101의 2의 보수 : 0010 + 0001 = 0011 연산 결과는 음의 값이나 부호가 없는 2진수이므로 (
-)0011의 의미를 갖음 10진수와 비교하면 :  ⇔    ▶ 부호가 없는 2진수 뺄셈 연산 ­ 2진수의 1의 보수는 각 자리마다 0→1 또는 1→0으로의 비트 반전으로 얻음 ㆍ 2진수의 뺄셈 연산 과정 ­ 감수의 비트 반전을 통한 1의 보수를 구한다. ­ 1의 보수에 1을 더해서 2의 보수를 구한다. ­ 피감수와 2의 보수를 더한다. ­ 최상위 자리에서 자리올림이 발생하면 새로 생긴 최상위 자리를 버리고 나머지 자리의 값을 취한다. ­ 최상위 자리에서 자리올림이 발생하지 않으면 덧셈 결과의 2의 보수를 구한다. 그리고 음수의 값으로 간주한다. ­ 2진법의 뺄셈과정에서 보수를 사용하면 덧셈 연산만으로 뺄셈 연산을 수행할 수 있음(비용 절감, 호환성) ▶ 부호가 없는 정수 ⋅ 예) 2진수로 1001이라는 데이터가 있으면, 이것은 무엇을 나타낼까요? 2진수로 그대로 읽으면 10진수 9를 나타냄 이처럼 부호가 없는 정수는 2진수 데이터를 그대로 2진수로 읽으면 됨 제한된 비트에서 부호가 없는 정수가 표현 가능한 수의 한계를 알아봅시다. 8비트에서 최소 숫자는 00000000이고, 최대 숫자는 11111111 즉, 10진수로 0 ~ 255가 됨 정리해서, 2진수 N자리수로 ‘부호가 없는 정수’를 표현하면 표현 범위는 0 ~ 2^N ­ 1 그러면 32비트에서 표현 범위는 0 ~ 2^32 ­ 1, 즉 0 ~ 4294967295의 숫자를 표 현할 수 있음  21   ▶ 부호가 있는 정수 ⋅ 부호가 없는 정수를 사용하면 0이하의 음수는 표현하지 못함 ⋅ 그래서 부호에 대한 정보를 표현할 방법을 만들게 됨 ㆍ 부호가 있는 정수의 표현 방법 ­ sign magnitude, 1’s complement, 2’s complement ­ 이 세가지 표현 방법은 최상위 비트에 부호가 있는지 없는지를 표시 ­ 부호가 있다는 것은
-40처럼 ­부호가 있다는 것을 의미 ­ 따라서, 부호비트(최상위 비트)가 1이면 부호가 있다. 즉 음수를 나타냄 ­ 부호비트가 0이면 부하가 없음. 즉, 양수를 나타냄 ▶ Sign magnitude ㆍ Sign magnitude 방식 ­ 최상위 비트를 부호(sign)으로 취급 ­ 최상위를 제외한 나머지는 수의 절대값(magnitude)를 나타냄 ⋅ 예) sign magnitude 방식으로
-7을 나타내 봅시다. 10진수 7은 8자리 2진수로 00000111 최상위 비트가 부호를 나타내고
-7은 마이너스 부호가 있으므로, 부호 비트를 1로 켜줌 그러면, 10000111으로 ­7이 표현됨 표현 범위를 알아보면, 8자리에서 최댓값은 01111111, 최솟값은 11111111이 됨. 이것은 10진수로, 최대값 127 최소값 ­127 정리하면 범위는,
-(2^(N
-1) ­

1) ~ (2^(N
-1) ­

1) N 자리 sign magnitude는, N
-1 자리수만큼 수의 크기를 표현할 수 있음(최대값과 최 소값을 더하면?) ­ 장점 ⋅ 사람이 보기 편함 ⋅
-4가 마이너스와 4로 이루어지듯, 우리가 사용하는 숫자 표기와 비슷하다는 것 ­ 단점 ⋅ 복잡한 점이 있음 ⋅ 계산을 할 때 부호에 대한 처리를 고려해야 하므로 복잡함 ⋅ 결과적으로 뺄셈 회로가 따로 있어야 하는 것이 비용과 효율의 문제를 발생시킴(호 환성) ⋅ 예) 11 + (
-4)를 하기 위해, sign magnitude를 사용하여 표기해보면 00001011 + 10000100 이 수를 그냥 2진법 더하듯이 더하면, 10001111이 되어
-15로 오답이 나옴  22   ▶ 1’s complement ㆍ 1’s complement 방식 ­ 음수를 비트로 표기하기 위해서, 양수에 1’s complement 즉, 1에 대한 보수 연산을 하 여 표현하는 방식 ­ 양수의 모든 비트를 반전하는 것(최대값과 최소값을 더하면?) ⋅ 예) 10진수 5는 4자리 2진수로0101. 그러면 ­5는 1010 비트의 한계에 따라 표현할 수 있는 수의 범위는 다음과 같음 8비트 표현에서 최댓값은 01111111. 최상위 비트는 부호의 의미도 있기에 0이 되어 야 하기 때문(127) 최솟값은 10000000. 이것은 최대값에 마이너스를 붙인 값으로 8비트에서 이것이 최 소값임을 알 수 있음(
-127) N비트에서의 표현범위 : (2^(N
-1) ­

1) ~ (
-2^(N
-1) ­

1) ­ 장점 ⋅ 덧셈 뺄셈을 덧셈 회로 하나만으로 계산할 수 있음(호환) ­ 단점 ⋅ 양수와 음수를 더할 때, 비트 범위를 넘은 자리 올림을 결과값에 더해주어야 함(불 편함) ⋅ 0이 2개(수의 표현 범위가 줄어듦) ▶ 2’s complement ㆍ 2’s complement 방식 ­ 음수를 비트로 표현할 때, 양수에 2’s complement를 비트 연산하여 표현하는 방식 ­ 2에 대한 보수 계산이므로, 각 자리의 숫자를 1로부터 빼고 난 후, 최하위에 1을 더하 면 됨 ⋅ 이진수 0101에 2에 대한 보수 계산을 하면 1111 ­ 0101 + 1 = 1011 ⋅ 십진수 5를 2’s complement로 표현한 이진 데이터는 1011 ⋅ 비트 한계에 따른 표현 가능한 수의 범위를 살펴보면, ⋅ 8비트에서 최댓값은 01111111 (127) ⋅ 최솟값은 10000000 (
-128) ⋅ N비트에서 표현 범위는
-2^N ~ (2^(N
-1) ­

1) (최대 + 최소?) ­ 장점 ⋅ 1’s complement에서 1을 더해서 보정해주어야 하는 문제가 없음(편리함) ⋅ 0이 한 개(수의 표현 범위가 늘어남) ­ 단점 ⋅ 데이터를 보고 어떤 값을 나타내는지 알아내기 위해, 마이너스 부호를 한 최상위 비 트와 나머지를 더하는 작업이 필요함(역변환을 수행해야 함) ⋅ 즉, 비교적 한눈에 알아보기 어려움(단점이라기 보다 불편)  23   데이터의 2진수 표현
1. 데이터의 2진수 표현 중 정수 표현 방법에 대해 이해하고 설명할 수 있다. 2주차  수업목표  
2. 데이터의 2진수 표현 중 소수 표현 방법에 대해 이해하고 1교시  설명할 수 있다.
1. 정수의 표현 세부내용 
2. 소수의 표현 1. 정수의 표현 ▶ 정수의 표현 ­ 일반적인 디지털 장치에서는 2진수로 양의 정수, 음의 정수, 소수를 표현 ­ 2진수는 0, 1, 부호 및 소수점의 기호를 이용하여 수를 표현 ­ 부호가 있고 소수점을 포함하는 동일 값의 10진수와 2진수를 나타낸 예 ⇨     ⋅ 2진법으로 부호를 갖는 정수와 소수를 표현하려면 추가적으로 부호와 소수점의 기호를 사용하여야 하므로 단순한 진법 변환으로 해결되지 않음 ㆍ 10진수를 2진법으로 변환 시 ­ 자연수 또는 양수의 10진수를 2진법으로 변환하면 부호가 없는 2진법으로 표현 ­ 10진수를 2진수의 기수 2로 연속해서 나누고 이때 얻어지는 나머지가 2진수의 가수가 되어 2진수로 표현(원리 : 나눈다, 나머지) ⋅ 10진수  을 부호 없는 2진수로 표현하는 과정 :      ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 자연수의 10진수들을 부호가 없는 2진수로 표현하면 다음과 같음 ⋅ 예)                      24   ▶ 부호가 존재하는 2진 정수의 표현 ­ 디지털 장치에서는 부호를 구분할 수 있는 (+)와 (
-)같은 별도의 기호는 존재하지 않고 최 상위 비트 자리를 부호 비트로 할당하고 0이면 양수, 1이면 음수 ㆍ 나머지 비트들은 적절한 형태로 크기 값을 표현 ­ 부호화
-크기 표현(signed
-magnitude representation) ­ 1의 보수 표현(1's complement representation) ­ 2의 보수 표현(2's complement representation) ▶ 부호화 
- 크기 표현 ­ n비트로 구성된 2진수에서, 최상위 비트는 부호 비트(signed bit)이고 나머지 ■
-1개의 비 트들은 수의 절대 크기(magnitude)를 나타냄 ⋅                     ­ 부호화
- 크기 방법으로 표현된 2진수 a a a a 를 10진수로 변환하는 방법 n n···   ⋅ 부호 비트를 통해서 부호를 결정, 크기 비트는 일반적인 10진수 변환 방법과 동일 Aana ×na ×n a ×a × n n ···     ×××××××    ­ 가장 간단한 개념으로 부호를 표현하지만, 덧셈과 뺄셈 연산을 수행하기 위해서는 부호 비 트와 크기 부분을 별도로 처리하여야 함 ­ 0(zero)의 표현이 두 개 존재하므로 표현할 수 있는 수의 범위가 줄어듦 ⋅           ▶ 보수를 이용한 부호를 갖는 2진수의 표현 ㆍ 1의 보수(1's complement) 표현 ­ 모든 비트를 반전(0 → 1, 1 →

0) ㆍ 2의 보수(2's complement) 표현 ­ 모든 비트들을 반전하고, 결과값에 1을 더함 ­ 보수를 이용한 2진수의 부호 변경 ⋅              (1의 보수)    (1의 보수)        (2의 보수)    (2의 보수)     ­ 보수를 이용하면 부호 비트가 자연스럽게 변경되고 그 크기도 적절한 형태로 변경 ­ 2의 보수는 0에 대한 표현이 하나만 있으며, 산술 연산이 용이 ­ 2의 보수는 가장 효율적이기 때문에 컴퓨터를 비롯한 디지털 장치에 부호를 갖는 2진수를 표현하는데 사용  25   ▶ 10진수의 2의 보수로 표현된 2진수 변환 과정
1) 10진수  를 2의 보수로 표현된 2진수를 변환하는 과정  ⋅ 1단계 ­ 10진수를 부호가 없는 2진수로 변환     ⋅ 2단계 ­ 부호 비트를 삽입(비트 수가 안 주어짐)     ⋅ 3단계 ­ 1의 보수를 구함  ⟹    ⋅ 4단계 ­ 2의 보수를 구함  ⟹    ⋅ 5단계 ­ 다음 결과를 얻을 수 있음  ⟹    ▶ 2의 보수로 표현된 2진수를 10진수로 변환
1) 2의 보수로 표현된 2진수를 10진수로 변환 ­ 2의 보수로 표현된 양의 정수(최상위 비트 : a =
0)는 부호 비트를 제외한 크기의 비트 n 들은 실제의 크기를 나타냄 ­ 부호 없는 2진수를 10진수로 변환하는 방법과 동일 ⋅ Aa ×na ×n a ×a × n n ···  
2) 2의 보수로 표현된 음의 정수(최상위 비트 : a =
1) n ­ 부호 비트의 해당하는 최상위 비트의 자릿수를 2의 승수로 표현하고 (
-)를 붙여서 음수가 되도록 함 ­ 나머지 비트는 양의 정수와 동일 ­ Ana ×na ×n···a ×a × n n   ⋅ 예)  ××××   ­ 2진수 음의 정수를 보수를 이용하여 양의 정수로 만들고 이것을 10진수로 변환. 그리고 최 종 단계에서 (
-) 부호를 붙이는 방식 ⋅ 예) 1단계 : 2의 보수를 이용하여 음수를 양수로 변환 (10101110 → 01010010) 2단계 :  ×××    ▶ 2진수의 표현 범위

1) 2의 보수를 사용한 3비트 이진수 표현의 예    26                 ­ 표현할 수 있는 수의 범위는
-4 ~ 3이 되며, 이것은  ~ 로 표현됨(최소와 최대를 더하면?) ­ n비트 데이터의 경우로 일반화 해서 수의 범위를 나타내면 다음과 같음 ⇨ n≤ N ≤ n ▶ 부호가 있는 8비트 이진수의 표현 ㆍ 부호화 ­ 크기 표현 ­  ~  ㆍ 1의 보수 ­  ~  ㆍ 2의 보수 ­  ~  10진수 부호화 ­ 크기 표현 1의 보수 2의 보수 127 01111111 01111111 01111111 126 01111110 01111110 01111110 : : : : : : : : 1 00000001 00000001 00000001 +0 00000000 00000000 00000000
-0 10000000 11111111 X
-1 10000001 11111110 11111111 ▶ 비트 확장(Bit Extension) v 부호가 존재하는 데이터의 비트 수를 늘리는 연산을 비트 확장이라고 함

1) 부호화 ­ 크기 표현의 비트 확장 ­ 부호 비트를 확장되는 최상위 자리로 이동시키고, 나머지 새로 확장되는 크기 비트들은 0 으로 채움 ⋅   (8비트)   →   (16비트)   ⋅   (8비트)    27   →   (16비트)  
2) 2의 보수로 표현된 2진수의 비트 확장 ­ 확장되는 상위 비트들을 부호 비트와 동일한 값으로 채우며, 이것을 부호 비트 확장 (sign
-bit extension)이라 함 ⋅   (8비트)   →   (16비트)   ⋅   (8비트)   →   (16비트)   ­ 16비트로 부호 확장된 양의 정수에 대한 2의 보수를 구하여 부호를 변경(부호 확장된 음의 정수와 일치) ⋅ 0000000000010101 ⟹ 1111111111101010 ⟹ 1111111111101011 ⋅ 구해진 2의 보수는 음의 정수와 동일하므로 부호 비트 확장의 방법이 정당함을 보여줌 2. 소수의 표현 ▶ 소수(Decimal ex)raction)의 표현

1) 정수와 소수를 포함한 10진수   
2) 10의 지수 승 형태로 표시 ×××××× ­ 정수 부분의 가수는 기수 10으로 연속으로 나눗셈을 수행해 얻은 나머지로 구할 수 있음 ­ 소수 부분은 지수가 음의 정수이므로 가수는 나눗셈의 반대인 곱셈을 연속적으로 수행하는 것. 그리고 정수 부분으로 발생하는 자리올림수가 가수가 됨 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 소수를 포함하는 10진수의 2진수 표현 ­ 2진수로 변환하기 위해서는 2의 지수 승으로 표현해야 함 ⋅   ×××××× A ×m···A ×A ×A ×A ×···A ×m m     m ­ 정수 부분은 2로 연속적인 나눗셈을 소수 부분은 2로 연속적인 곱셈을 수행함(10진수와 동일) ⋅ 1단계 : 정수 부분과 소수 부분을 분리함  28   ⋅ 2단계 : 정수 부분의 10진수를 2진수로 변환     ⋅ 3단계 : 소수 부분의 10진수를 2진수로 변환     ⋅ 4단계 : 얻어진 정수와 소수의 2진수를 합함         ­ 정수 부분은 2로 연속적인 나눗셈을 소수 부분은 2로 연속적인 곱셈을 수행함 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 소수를 포함하고 있는 이진수의 십진수로 변환 ­ 정수 부분은 기존의 방법과 같이 2의 지수 승을 이용하여 분해함. 소수점 이하는 2의 (
-)지 수 승을 사용함 ⋅ Aa ×a × a ×na ×n n n ···   ­ 소수를 포함하는 이진수  를 십진수로 변환  ⋅   ×××××××   ▶ 부동소수점(ex)loating
-point)의 표현

1) 고정소수점(fixed
-point) 표현 ­ 소수가 고정된 소수점을 통해서 구분하여 표현된 방식 :   ­ 표현 범위의 한계가 있어 아주 큰 값과 매우 작은 값을 표현하는 것이 불가능함

2) 부동소수점(floating
-point) 표현 ­ 지수를 사용 소수점의 위치를 이동하여 수의 표현 범위를 확대함 :  × ×   ­ 부동소수점 수(ex)loating
-point Number)을 표현하는 일반적인 형식 : ±M×B±E  29   ­ 여기서, ±는 부호로서 + 혹은 ­을 나타내며, M은 가수(significand), B는 기수(base), E는 지수(exponent)를 나타냄

3) 2진 부동소수점 수(binary floating
-point number) ­ 가수 M은 0과 1로 구성이 되는 2진수 이며, 기수 B는 2가 됨(지수는

3) : × ▶ 2진 부동소수점 수의 표현 ㆍ 단일
- 정밀도(single
-precision) 부동소수점 수 ­ 32비트로 표현 ㆍ 복수
- 정밀도(double
-precision) 부동소수점 수 ­ 64비트로 표현(현재 : 128비트)

1) 단일 ­ 정밀도 부동소수점 수 형식 ­ 32비트가 세 개의 필드로 구성됨 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 부호 필드(S 필드)는 1비트로 0이면 양수이고 1이면 음수 ­ 지수 필드는 지수 값을 저장하는 곳 ­ 8비트이므로 256개를 표현할 수 있음 ­ 가수 필드는 23비트이므로 8388608개를 표현할 수 있으므로, 고정 소수점 수와 비교 해서 표현할 수 있는 수의 범위가 훨씬 넓음 ㆍ 각 필드의 비트 할당 문제는 표현하는 수의 범위와 정밀도를 결정 ­ 지수(E) 필드의 비트 수가 늘어나면, 표현 가능한 수의 범위가 확장됨 ­ 가수(M) 필드의 비트 수가 늘어나면, 이진수로 표현할 수 있는 수가 많아져서 정밀도가 증가하게 됨. 따라서 적절한 비트 할당이 필요함 ▶ 정규화된 표현(Normalized Representation)
1) 정규화된 표현(Normalized Representation) ­ 부동소수점의 수는 지수의 값에 따라 표현이 여러 가지 존재함 ⋅ ××× ­ 정규화된 표현은 부동소수점 수에 대한 표현을 통일하기 위한 방법임(표현 범위 확장) ⋅ ±bbb b×E ··· 위의 예에서 정규화된 표현은 ×이 됨
2) 단일 정밀도 부동소수점의 수에서 정규화된 표현 ⋅ 예) ×을 필드 별로 비트로 표현할 때 ⋅ 부호(S) 비트 = 0 / 지수(E) = 00000101 ⋅ 가수(M) = 1001 0000 0000 0000 0000 000  30   부호(S)필드 지수(E)필드 가수(M)필드 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 바이어스된 지수 값 ­ 정규화된 표현에서 소수점 우측의 첫 번째 비트는 항상 1로 생략 가능 ⋅ 가수 필드 23비트를 이용하여 생략된 소수점 아래 첫 번째 1을 포함하여 24자리의 수 까지 표현 가능하게 되어 1비트를 더 표현할 수 있음 ­ 지수의 바이어스된 수(biased number)로 표현 ⋅ 지수 필드의 지수는 양의 값 뿐만 아니라 음의 값을 가지므로 부호에 대한 표현을 가 능하게 함 ⋅ 음수의 표현 뿐만 아니라 0에 대한 표현에서 모든 비트가 0이 됨 ­ 바이어스된 값은 원래의 지수 비트 값에서 바이어스 값을 더해서 얻음 ⋅ 지수 값이 4이면 이를 8비트의 이진수로 표현하면 00000100이 되며, 이것을 128로 바이어스된 값을 구하기 위해서는 128의 이진수값 10000000을 더해 줌 ⋅ 지수 값 :     ⋅ 128로 바이어스 된 지수 값(나중에 다시 —128) : 00000100 + 10000000 = 10000100 ▶ 지수 비트 패턴과 128로 바이어스된 지수 값 지수 비트 패턴 절대값 128로 바이어스된 지수 값 11111111 255 +127 11111110 254 +126 : : : 10000100 132 +4 10000011 131 +3 10000010 130 +2 10000001 129 +1 10000000 128 0 01111111 127
-1 01111110 126
-2 : : : 00000001 1
-127 00000000 0
-128 ▶ 바이어스 값을 이용한 부동소수점 수

1) 바이어스 값이 128일 때,  에 대한 부동소수점 수의 표현    ×   ㆍ 이것을 필드 별로 비트열로 나타내면 ­ 부호(S) 비트 = 1 (
-) ­ 지수(E) = 00000100 + 10000000 = 10000100 (바이어스 128을 더한다) ­ 가수(M) = 10110100000000000000000 (소수점 우측의 첫 번째 1은 제외)  31   부호(S)필드 지수(E)필드 가수(M)필드 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 부동소수점 수의 표현 범위

1) 부동소수점 수의 표현 범위 ­ 정규화된 표현과 바이어스된 지수를 이용한 부동소수점 수의 표현 ⋅ 32비트 부동소수점 수의 표현 범위 × ~ × 사이의 양수들(0.1~0.1…)
-× ~
-× 사이의 음수들 음수 언더플로우 양수 언더플로우 음수 양수 오버플로우 표현가능 범위 표현가능 범위 오버플로우 × × 0 × × ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 아주 작은 수와 그리고 아주 큰 수는 표현이 불가능함. 그래서 제외되는 범위는 다음과 같 음(over and under) ⋅ ×보다 작은 음수 → 음수 오버플로우(negative overflow) ⋅ ×보다 큰 음수 → 음수 언더플로우(negative underflow) ⋅ ×보다 작은 양수 → 양수 언더플로우(positive underflow) ⋅ ×보다 큰 양수 → 양수 오버플로우(positive overflow) ▶ IEEE 754 표준

1) 국제 표준 : ±bbbb···bbb×±E ­ 단일­정밀도 형식 : 지수 : 8비트 바이어스 = 127 가수 : 23비트 표현 영역 :  ~  ­ 복수­정밀도 형식 : 지수 : 11비트 바이어스 = 1023  32   가수 : 52비트 표현 영역 :  ~  ㆍ 10진수
- 의 IEEE 754 표현  ­ × ㆍ 표준형을 단일 ­ 정밀도 형식으로 표시 ­ 바이어스 값이 127이고 정수 값인 소수점 좌측의 1은 제외 ⋅ 부호(S) = 1(
-) ⋅ 지수(E) = 00000011 + 01111111 = 10000010 → 바이어스 127을 더함 ⋅ 가수(M) = 10110100000000000000000 → 소수점 좌측의 1은 제외 부호(S)필드 지수(E)필드 가수(M)필드 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  33   2진수의 연산

1. 2진수의 연산 중 산술 연산 방법에 대해 이해하고 설명할 수 있다. 2주차  수업목표  
2. 2진수의 연산 중 논리 연산 방법에 대해 이해하고 설명할 수 2교시  있다.
1. 산술 연산 세부내용 
2. 논리 연산 1. 산술 연산 ▶ 진수의 산술 연산 v 덧셈, 뺄셈, 곱셈, 나눗셈 등의 산술 연산과 참, 거짓을 판별하는 논리 연산이 있음 ­ 부호를 갖는 2진 정수의 산술 연산은 2의 보수를 활용하여 수행되며, 부동소수점의 수에 대한 산술 연산은 지수 부분과 가수 부분을 분리해서 독립적으로 수행됨
1) 정수의 산술 연산 ­ 부호 변경(2의 보수) : A = A'+ 1 (A': 1의 보수) ­ 덧 셈 : C = A + B ­ 뺄 셈 : C = A ­ B ­ 곱 셈 : C = A × B ­ 나눗셈 : C = A / B ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 부호 변경 ­ 2의 보수를 사용 ­ 음의 정수를 2진수로 표현할 때 사용 ▶ 2진 정수의 덧셈 연산
1) 오버플로우가 발생하지 않는 덧셈 연산 ㆍ 양수와 양수의 덧셈 ­ 최상위 비트에서 자리 올림이 발생하지 않아 계산의 결과에서 오류가 발생하지 않고 정 확한 답을 출력함 ⋅       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 최상위 비트에서 자리 올림이 발생하지 않은 음수와 양수의 덧셈 ­ 최상위 비트에서 자리 올림수가 발생하지 않음. 따라서 부호 비트가 변경되는 등의 잘못 된 계산이 발생하지 않아서 정확한 값을 얻을 수 있음 ⋅       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  34   ㆍ 최상위 비트에서 자리 올림이 발생하는 음수와 양수의 덧셈 ­ 덧셈 결과로 발생하는 최상위 비트에서 자리 올림 수는 버림. 하지만 연산에는 오류가 없이 올바른 답을 얻을 수 있음 ⋅       버림 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 음수와 음수의 덧셈 ­ 음수와 음수의 덧셈은 필연적으로 최상위 비트에서 자리 올림이 발생하고 자리 올림 수 는 버림을 통해서 버려지나, 그 결과는 정확한 값임 ⋅       버림 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 오버플로우가 발생하는 덧셈 연산 ­ 덧셈 결과가 표현할 수 있는 범위를 초과하여 결과값이 틀리게 되는 상태를 덧셈의 오버플 로우 상태라고 함 ㆍ 양수와 양수의 덧셈 ­ 덧셈의 결과는 자리 올림으로 인해서 부호 비트가 변경되고 잘못된 결과가 발생함(최상 위 xor 그 다음 캐리) ⋅       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 음수와 음수의 덧셈 ­ 자리 올림이 발생하고 부호 비트는 변경됨(xor) ⋅       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 2진 정수의 뺄셈 연산 ­ 2의 보수를 사용하여 결과적으로 덧셈을 수행함 ­ A
- (+B) = A + (
-B), A
- (
-B) = A + (+B) ⋅ 빼지는 수 A를 피감수(minuend)라 하며, 빼는 수 B를 감수라 함  35  

1) 오버플로우가 발생하지 않는 뺄셈 연산 ­ 연산 결과가 디지털 장치에서 표현할 수 있는 범위 안에 존재하여 연산의 결과는 정확함
2) 최상위 비트에서 자리 올림수가 발생하지 않는 뺄셈 ­ 10진수에서는 감수를 음수화하고 그 다음 뺄셈을 덧셈으로 고치고 계산을 한다. ⋅           → 0010 + 1011 = 1101
3) 최상위 비트에서 자리 올림수가 발생하는 뺄셈 ­ 최상위 비트에서 자리 올림 발생하는 뺄셈 ⋅           → 0101 + 1110 = 0011 버림 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 부호 비트의 변경은 없으나 자림 올림이 발생하였음. 자리 올림 수는 버려지게 되고 나머지 를 취하면 올바른 값을 얻을 수 있음 ­ 뺄셈 결과가 그 범위를 초과하여 틀리게 되는 상태를 뺄셈 오버플로우라고 함
4) 최상위 비트에서 자리 올림이 발생하지 않는 경우 ­ 부호 비트가 변경이 발생하지만 자리 올림이 발생하지 않은 경우가 있음(최상위 xor 그 다 음 캐리) ⋅           → 오버플로우 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 부호 변경은 오버플로우가 발생한 것으로 답은 정확하지 않음
5) 최상위 비트에서 자리 올림이 발생하는 경우 ­ 부호 비트가 변경되고 또한 최상위 비트에서 자리 올림이 발생한 경우가 있음(xor) ⋅           → 오버플로우 버림 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 얻어진 결과에서 버림의 과정을 거쳤지만 그래도 뺄셈의 오버플로우가 발생한 경우로 계산 결과는 잘못된 것임  36   ▶ 2진 정수의 곱셈 연산 v A × B = C 곱하는 수(B)를 승수라고 하며, 곱하여 지는 수(A)를 피승수라고 함
1) 부호가 없는 2진수의 곱셈 ­ 승수의 각 숫자에 대하여 부분 합을 계산, 승수의 한 비트가 0이면 부분 합도 0이 되나, 1 이면 부분 합은 피승수와 동일하게 됨 ­ 최종 결과값은 부분 합을 한 자릿수씩 왼쪽으로 이동하고, 더하여 구함 ㆍ 피승수 1101과 승수 1011과의 곱셈 과정 피승수(13) 승수(11) 부분합 곱의 결과(143) ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 4비트의 두 수가 서로 곱셈을 수행하면, 2배인 8비트의 길이의 결과를 출력 ­ 일반화하면, 두 N비트 2진 정수를 곱한 결과값의 길이는 2N 비트가 됨
2) 2의 보수에 의해서 부호를 갖는 2진수의 곱셈 ­ 음수를 양수로 변환하고 부호가 없는 곱셈을 수행하고, 만약 승수와 피승수의 부호가 서로 다르다면 결과 값에 2의 보수를 취하여 부호를 변경함 ⋅ 0010 × 1001 ­ 부호가 있는 2진수의 곱셈을 수행하기 위해서 음수 1001의 2의 보수를 구함 ⋅ 1001 → 0111 ­ 부호 없는 2진수의 곱셈을 수행함 피승수(2) 승수(7) 곱의 결과(14) ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 피승수와 승수의 부호가 서로 다르므로 얻어진 결과를 다시 2의 보수화를 통해서 부호를 변경함 ­ 결과적으로  를 얻게 됨 : 00001110 → 11110010  ▶ 2진 정수의 나눗셈 연산 v D ÷ V = Q … R 나누어지는 수 D를 피제수(dividend)라고 하며, 나누는 수 V를 제수(divisor)라고 함. 나 눗셈의 결과로 몫(quotient) Q와, 나머지 수(remainder) R을 얻음  37  
1) 부호 없는 2진 정수의 나눗셈 ­ 10진수의 나눗셈과 동일 몫 제수 피제수 10010011 ÷ 1011를 부분 나머지 계산하는 과정 부분 나머지 나머지 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 2의 보수를 사용하여 부호가 표현된 2진 정수의 나눗셈 연산 ­ 2의 보수를 통해서 모두 양수로 고친 다음 부호 없는 2진수의 나눗셈 수행 ­ 제수와 피제수의 부호가 다른 경우에는 몫의 부호를 변경 ⋅ 예) 0111 ÷ 1101 ­ 1101은 음수이므로 2의 보수화를 통해서 양수를 구함 ­ 부호가 없는 2진수의 나눗셈을 수행 몫(2) 제수(3) 피제수(7) 나머지(1) ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 제수와 피제수가 동일하지 않으므로 얻어진 몫을 2의 보수로 표현 ⋅ 0010 → 1110 ­ 따라서 몫은  가 얻어짐  ▶ 부동소수점 수의 산술 연산 ­ 부동소수점 수의 산술은 가수와 지수의 연산을 분리해서 수행
1) 부동소수점 수의 덧셈과 뺄셈 ­ 지수들이 동일한 값을 같도록 일치, 가수의 소수점이 좌우로 이동함 ­ 다음으로 가수들 간의 덧셈과 혹은 뺄셈을 수행 ­ 2진수의 경우, 마지막으로 결과를 정규화함 ㆍ 10진수의 부동소수점의 수의 덧셈과 뺄셈 ­ A×B× ⋅ 덧셈 연산 : AB×× ×× × ⋅ 뺄셈 연산 : AB×× ×× ×  38   ㆍ 2진수의 부동소수점 수의 덧셈과 뺄셈 지수 조정 정규화 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 부동소수점 수의 곱셈 ­ 가수끼리는 곱셈 연산을 수행하고 지수끼리는 덧셈을 수행
1) 10진수의 부동소수점 수의 곱셈 ­ A×B× ⋅ 곱셈 연산 : A×B××××× ×
2) 2진수 부동소수점 수의 곱셈 과정 ­ 가수들을 곱하는 것과 지수들을 더하는 과정은 동일하며, 결과값을 정규화하는 것이 추가됨 ⋅ ××× ­ 가수 곱하기 : 1011 × 1001 = 01100011 ­ 지수 더하기 : 3 + 5 = 8 ­ 정규화 : × × ▶ 부동소수점 수의 나눗셈 ­ 가수부분은 나눗셈 연산을 수행하고, 지수부분은 뺄셈 연산의 수행
1) 10진수의 부동소수점 수의 나눗셈 ⋅ 나눗셈 연산 : A÷B×÷× ÷× ×
2) 2진수 부동소수점 수의 나눗셈 ­ 첫 번째로 가수들을 나누고, 피제수의 지수에서 제수의 지수를 뺀 후, 마지막으로 결과값을 정규화하는 과정을 추가 함 ⋅ ×÷× ­ 가수 나누기 : 1100 ÷ 1100 = 1 ­ 지수 뺄셈 : 5
- 3 = 2 ­ 정규화 : × ▶ 부동소수점 수의 연산 과정에서 발생 가능한 문제 ­ 부동소수점의 수의 표현 범위에서 오버플로우와 언더플로우가 발생하는 영역이 존재, 연산 의 결과가 이런 영역에 포함되면 오류가 발생함

1) 지수 오버플로우(exponent overflow) ­ 양의 지수값이 최대 지수값을 초과하여 발생하는 오류 ­ 수가 너무 커서 표현될 수 없음을 의미하는 것으로 +∞ 또는
-∞로 나타냄

2) 지수 언더플로우(exponent underflow)  39   ­ 음의 지수값이 최대 지수값을 초과하는 경우 ­ 수가 너무 작아서 표현될 수 없음을 의미하므로 0으로 표시
3) 가수 언더플로우(mantissa underflow) ­ 가수의 소수점 위치 조정 과정에서 비트들이 가수의 우측 편으로 넘치는 경우로서 반올림 (rounding)을 사용해서 문제를 해결함
4) 가수 오버플로우(mantissa overflow) ­ 같은 부호를 가진 두 가수들을 덧셈하였을 때 올림수가 발생하는 경우로 재조정 (realignment) 과정을 통하여 정규화하여서 해결함 2. 논리 연산 ▶ 2진수의 논리 연산 v 논리 연산은 주어진 명제에 대하여 참(true)과 거짓(false)를 결정하는 연산임 ⋅ 컴퓨터와 같은 디지털 장치에서는 많은 산술 연산뿐만 아니라 다양한 논리 연산을 지원 하고 있음
1) 기본적인 논리 연산 ㆍ AND 연산 ­ 2진수의 모든 입력이 모두 1일 때, 1을 출력하고 나머지의 경우에는 0을 출력 ㆍ OR 연산 ­ 2진수의 입력 중 하나만 1이면, 1을 출력하고, 모든 입력이 0일 때는 0을 출력 ㆍ Exclusive
-OR(XOR) 연산 ­ 2진수의 입력이 모두 동일할 경우에는 0이고, 나머지의 경우에는 1이 됨(입력 중의 1의 개수가 홀수개) ㆍ NOT 연산 ­ 입력에 반대를 출력하는 연산 ▶ 기본적인 논리 연산의 진리표 입력 X 입력 Y X AND Y X OR Y X XOR Y NOT X NOT Y 0 0 0 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 1 0 1 1 1 1 1 0 0 0 ▶ 컴퓨터 응용 논리 연산

1) 선택적
-세트(Selective
-set) 연산 ­ 2진수의 특정 비트를 선택하여서 1로 세트시키는 연산 ­ 데이터 A가 1001 0010일 때, 하위 4비트 모두를 1로 세트하려고 하며, 데이터 B를 0000 1111로 하고 A와 OR 연산을 수행하면 원하는 결과를 얻을 수 있음  40   연산 전 선택적
-세트(OR) 연산 연산 후 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

2) 선택적
-보수(Selective
-complement) 연산 ­ 2진수의 특정 비트를 1의 보수로 변경 시키는 연산. 즉, 지정된 비트가 반전됨 ­ 데이터 A의 특정 비트들을 1의 보수로 나타내기 위해서, 원하는 특정 비트 위치가 1로 세 트 된 데이터 B와 XOR 연산을 수행(중요, 자주 사용됨) ­ 데이터 A의 하위 4비트를 비트 반전 시키기 위해, 데이터 B를 0000 1111로 하고 데이터 A와 XOR 연산을 수행 연산 전 선택적
-보수(XOR) 연산 연산 후 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

3) 마스크(Mask) 연산 ­ 원하는 비트들을 선택적으로 clear(0)하는데 사용하는 연산 ­ 데이터 A의 특정 비트들을 0으로 바꾸기 위해, 원하는 특정 비트 위치가 0로 세트 된 데 이터 B와 AND 연산을 수행 ­ 데이터 A의 상위 4비트를 0으로 clear하기 위해서, 데이터 B를 0000 1111로 하고 A 레 지스터와 AND 연산을 수행 연산 전 마스크(AND) 연산 연산 후 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
4) 삽입(Insert) 연산 ­ 2진 데이터 내의 특정 위치에 새로운 비트 값들을 삽입하는 연산 ­ 마스크 연산과 선택적 세트 연산을 순차적으로 수행함으로써 완성 ­ 삽입할 비트 위치들에 마스크 연산(AND), 새로이 삽입할 비트들과 OR 연산을 수행 ­ 데이터 A = 1011 1010의 하위 4비트에 1100을 삽입하는 경우 마스크(AND)연산 마스크 결과 삽입(OR) 연산 최종 삽입 결과 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
5) 비교(compare) 연산 ­ 두 데이터를 비교하는 연산으로 exclusive
-OR 연산에 의해서 구현(중요, 자주 사용됨) ­ 데이터 A와 B의 내용을 비교 후 만약 대응되는 비트들의 값이 같으면, 데이터 A의 해당  41   비트를 0으로 세트 함. 서로 다르면, 데이터 A의 해당 비트를 1로 세트 함 ­ A =1110 0001과 B=0101 1001과를 비교 연산 전 비교(XOR) 연산 연산 후 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 연산의 결과는 두 데이터가 같으면 0을 출력하고 다르면 1을 출력

6) 순환 이동(Circular Shift) ­ 최상위 혹은 최하위에 있는 비트가 반대편 끝에 있는 비트 위치로 이동해서 비트가 회전 ­ 순환 좌측
-이동(circular shift
-left) : 최상위 비트인 D4가 최하위 비트 위치인 D1으로 이 동 ­ 순환 우측
-이동(circular shift
-right) : 최하위 비트인 D1이 최상위 비트 위치인 D4로 이동 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

7) 산술적 이동(arithmetic shift) ­ 이동 과정에서 부호 비트는 유지하고, 수의 크기를 나타내는 비트들만 이동 ㆍ 산술적 좌측
-이동 ­ D (불변), D ← D , D ← D , D ← 0       ㆍ 산술적 우측
-이동 ­ D (불변), D → D , D → D , D → D        ㆍ 산술적 이동 예 ­ A = 1 0 1 0 1 1 1 0 : 초기 상태 1 1 0 1 1 1 0 0 : A의 산술적 좌측
-시프트 결과 1 1 0 1 0 1 1 1 : A의 산술적 우측
-시프트 결과  42   문자 데이터의 표현

1. 표준 코드를 이용한 문자 데이터의 표현 방법에 대해 이해하고 설명할 수 있다. 2주차  수업목표  
2. 유니 코드를 이용한 문자 데이터의 표현 방법에 대해 이해하고 3교시  설명할 수 있다.
1. 표준 코드 세부내용 
2. 유니 코드 1. 표준 코드 ▶ BCD(Binary Coded Decimal) 코드 v 영숫자 코드(Alphanumeric Code) : 컴퓨터에 사용되는 영문자와 숫자, 특수문자의 데이 터를 0과 1의 조합으로 구성된 코드로 표현한 것(컴퓨터, 약속) ⋅ 이진화 십진 코드라고도 부르며, 기본적으로 6비트의 길이를 갖는 코드이지만 좀 더 효 율적으로 사용하기 위해서 존(zone)비트와 숫자(digit)비트로 분리하고 이를 조합해서 코드를 생성(존 비트가 없으면 규칙성이 없음)
1) 6비트의 표준 BCD 코드의 구성 ­ 가장 왼쪽의 최상위 비트는 패리티(parity) 비트, 그래서 실질적으로 64가지의 문자, 숫 자, 특수문자의 정보를 표현할 수 있음(단일 전송 가능) 패리티 비트 존 비트 숫자 비트 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 존 비트는 숫자를 2진 부호로 밀도 높게 표현할 때 사용되는 숫자 4비트 외의 비트임(존 비트로 구분) 그래서 6개의 비트가 각 문자를 나타내는데, 왼쪽의 두 비트의 존 비트는 알 파벳이나 특수 문자를 나타내기 위해 숫자 비트와 연관해서 사용할 수 있음
2) 존 비트에 따른 표준 BCD 코드 분류(존 비트로 구분) 패리티 비트 존 비트 숫자 비트 6 5 4 3 2 1 0 1 1 영문자 A~I (0001~1001) 1 0 영문자 J~R (0001~1001) 하위 비트에 0 1 영문자 S~Z (0010~1001) 따라 달라짐 0 0 숫자 0~9 (0001~1010) 혼용 특수 문자 및 기타 문자  43  
3) 표준 BCD 코드의 표(P ZZ8421, 홀수 패리티 비트) 문자 P ZZ8421 문자 P ZZ8421 문자 P ZZ8421 A 0 110001 J 1 100001 S 1 010010 B 0 110010 K 1 100010 T 0 010011 C 1 110011 L 0 100011 U 1 010100 D 0 110100 M 1 100100 V 0 010101 E 1 110101 N 0 100101 W 0 010110 ex) 1 110110 O 0 100110 X 1 010111 G 0 110111 P 1 100111 Y 1 011000 H 0 111000 Q 1 101000 Z 0 011001 I 1 111001 R 0 101001 문자 P ZZ8421 문자 P ZZ8421 1 0 000001 = 0 001011 2 0 000010
> 1 001100 3 1 000011 + 0 010000 4 0 000100 , 1 011011 5 1 000101 ) 0 011100 6 1 000110 % 1 011101 7 0 000111 ? 0 011111 8 0 001000
- 1 100001 9 1 001001 @ 1 111010 0 1 001010 $ 1 111111 ▶ ASCII 코드 v 미국 국립 표준 연구소(ANSI)가 제정한 정보 교환용 미국 표준 코드(American Standard Code for Information Interchange) ­ 코드의 길이는 7비트와 패리티 비트가 추가된 두 종류의 8비트 코드가 있으며, 128(=

27)가지의 정보를 표현 할 수 있음(단일 전송) ⋅ ASCII 코드는 128개의 가능한 문자 조합을 제공하는 7비트(bit) 부호로, 처음 32개 의 부호는 인쇄와 전송 제어용으로 사용(유니코드와 호환 혹은 변환) ⋅ 보통 기억장치는 8비트(1바이트, 256조합)를 기본으로 구성, ASCII 코드는 단지 7비 트의 128개의 문자만 사용하기 때문에 나머지 하나의 비트를 추가하여 패리티 비트 로 사용하거나 특정 문자를 표현하는데 사용 ⋅ 이렇게 하나의 비트가 추가되어 8비트의 코드로 특정 문자까지도 표현할 수 있도록 만든 것을 확장 ASCII 코드라고 함(단일 전송 불가)
1) ASCII코드의 구성 패리티 비트 존 비트 숫자 비트 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  44  
2) 존 비트에 따른 ASCII코드의 분류(존 비트로 구분) 패리티 비트 존 비트 숫자 비트 7 6 5 4 3 2 1 0 1 0 0 영문자 A~O (0001~1111) 하위 비트에 1 0 1 영문자 P~Z (0000~1010) 따라 달라짐 0 1 1 숫자 0~9 (0000~1001)
3) 표준 ASCII 코드표(7비트, 규칙성 ­ 0, A, P, a, p) 0 1 2 3 4 5 6 7 8 9 A B C D E ex) 0 NUL SOH STX ETX EOT ENQ ACK BEL BS TAB Lex) VT ex)ex) CR SO SI 1 DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM SUB ESC ex)S GS RS US 2 ! “ # $ % & ‘ ( ) * + ,
- . / 3 0 1 2 3 4 5 6 7 8 9 : ; =
> ? 4 @ A B C D E ex) G H I J K L M N O 5 P Q R S T U V W X Y Z [ \ ] ^ _ 6 ` a b c d e f g h i j k l m ■ o 7 p q r s t u v w x y z { | } ~

4) 확장 ASCII 코드표(8비트, 규칙성, 특정 문자) 0 1 2 3 4 5 6 7 8 9 A B C D E ex) 8 Ç ü é â ä à å ç ê ë > ï î ì Ä Å 9 É æ Æ Ô Ö Ò û ù ÿ ö Ü ¢ £ ¥ Pt ƒ A á í ó ú ñ Ñ a o ¿ 「 」 ½ ¼ ¡ « » B ┃ ┤ ╡ ╢ ╖ ╕ ╣ ║ ╗ ╝ ╜ ╡ ┐ C └ ┴ ┬ ├ ─ ┼ ╞ ╟ ╚ ╔ ╩ ╦ ╠ ═ ╬ ╧ D ┸ ┯ ┰ └ ╘ ╒ ╓ ╫ ╪ ┘ ┌ ▊ ▅ ▍ ▊ E α β π Σ σ μ τ ф Θ Ω δ ∞ φ ε ∩ ex) ≡ ± ≥ ≤ 〔 〕 ÷ ≈ ∘ ⦁ · ⁿ ² ▪ ▶ EBCDIC 코드 v 확장 이진화 십진법 교환 부호(EBCDIC, Extended Binary Coded Decimal Interchange Code)는 IBM 메인프레임용 운영 체제인 z/OS, OS/390, VM 운영 체제, VSE 운영 체제 와 IBM의 중급 컴퓨터 운영 체제인 OS/400과 i5/OS 등에서 사용되는 8비트 문자 인코 딩(코드 페이지)임(중대형 컴퓨터) ­ 또한 후지쯔
-지멘스의 BS2000/OSD나 휴렛 패커드의 MPE/iX, 유니시스의 MCP 등 IBM 외 플랫폼에서도 사용 ­ EBCDIC은 천공 카드에서 사용하던 코드와 1950년대 후반에서 1960년대 초에 나온 대 부분의 IBM 컴퓨터 주변 기기에서 사용됐던 6비트 이진화 십진법 부호(BCD)에서 유래 (6비트에서 8비트로) ­ EBCDIC('엡시딕'으로 읽는다)은 IBM에서 1963년과 1964년에 걸쳐 고안되었고 IBM System/360 계열의 메인프레임 컴퓨터와 함께 소개되었음(중대형) ­ 별도로 개발된 7비트 인코딩 방식인 ASCII와 달리 8비트 문자열 인코딩임(8비트) ­ 천공 카드 상의 두 "존(zone)"과 "숫자"를 6비트에 인코딩하는 효율적인 방법으로 고안  45   된 기존 IBM 이진화 십진법 인코딩(BCD)을 확장하기 위해 만들어짐 ­ IBM은 ASCII 표준화 위원회의 주요 지지자였지만 ASCII 주변장치(일례로 카드 천공기) 를 System/360 출시에 맞춰 내어 놓을 수 없었음(따로 개발) ­ IBM은 이 때문에 당시 EBCDIC을 사용할 수 밖에 없었음. System/360은 큰 성공을 거 뒀고 자연히 EBCDIC도 널리 사용되었음(따로 개발 안함) ­ IBM z시리즈나 i시리즈에 사용된 리눅스 외에 모든 IBM 메인프레임 주변장치와 운영 체제는 고유 인코딩으로 EBCDIC를 사용(중대형 컴퓨터) ­ 하지만 소프트웨어 수준에서는 다른 인코딩 간 변환이 가능 ­ 많은 하드웨어 주변장치 역시 인코딩 간 변환을 지원하며, IBM z시리즈 같은 최신 메인 프레임은 하드웨어 수준에서 서로 다른 문자 집합 간 변환을 빠르게 하기 위한 프로세서 명령어를 포함하고 있음(ASCII와 EBCDIC 간 변환) ­ EBCDIC은 ISO
-8859 계열이나 유니코드 같은 ASCII 기반 코드 페이지에 비해 최근 기 술적인 관점에서는 장점이 없음, 각 부호는 기술적으로 기발하게 설계된 부분도 있음 ­ 일례로 ASCII와 EBCDIC은 특정 1비트만 보면 대문자인지 소문자인지 구분할 수 있게 되어 있으나, 알파벳이 연속적이지 않는 등 EBCDIC은 ASCII에 비해 사용하기 어려운 측면도 있음(연속성 ­ 규칙성) ­ 단일 바이트 확장 ASCII 코드 페이지들처럼 대부분의 EBCDIC 코드 페이지를 사용할 때 하나의 데이터베이스나 텍스트 파일 내에서 최대 언어 2개까지만(즉, 영어와 또 다른 한 언어) 사용할 수 있었음(언어 제한
- 유니코드) ­ 제대로 된 다중 언어 문장을 지원하려면 훨씬 더 많은 문자들을 지원하는 시스템이 필요 (유니코드) ­ 이를 위해서는 일반적으로 어떤 형태든 유니코드가 지원되어야 함 ­ 유니코드 컨소시엄에서는 UTex)
-EBCDIC이라는 EBCDIC 유니코드 변환 형식(Unicode Transformation ex)ormat)을 제안했으나 원래 일반적인 시스템 간 정보 교환을 위해 사 용할 목적으로 설계되지 않았고, EBCDIC을 사용하는 시스템 상에서도 사용된 바가 없음 (사용 안 함) ­ IBM 메인프레임은 UTex)
-16은 지원하나 UTex)
-EBCDIC은 지원하지 않음(UTex)
- 유니코드 문자 인코딩 방식 종류) ­ 아랍어를 위한 EBCDIC 버전들은 유니코드와 같은 최근 인코딩처럼 논리 순서대로 오른 쪽에서 왼쪽으로 인코딩하는 대신, 통상 화면에 보이는 순서, 즉, 더 오래된 메인프레임 이나 라인 프린터처럼 왼쪽에서 오른쪽으로 인코딩함(인코딩 순서가 다름) ­ 다음의 표는 EBCDIC의 코드 페이지 변형 중 하나인 CCSID 500을 기본으로 한 것으로 기 본 영어 EBCDIC 문자만 표시(라틴어) ­ 00
-3ex)와 ex)ex)는 제어 문자이고, 40은 공백, 41은 단어 잘림 방지 공백("RSP" : "Required Space" 즉, "필요한 공백"), E1은 수치 간 공백("NSP" : "Numeric Space" 즉, "숫자 공백 "), CA는 소프트 하이픈(줄 바꿈 시 한 단어 중간에서 하이픈을 넣고 줄 바꿈이 가능한 위 치 표시)을 나타냄(제어 많음) ­ 각 문자는 동등한 유니코드 코드를 표기. 모든 EBCDIC 코드 페이지에 포함되는 알파벳, 숫  46   자, 구두점, 제어 문자는 볼드체로 표시 ­ 할당되지 않은 코드들은 보통 다양한 EBCDIC 코드 페이지 변형들에서 국제 혹은 지역 특 화된 문자에 할당됨(통일?) ▶ EBCDIC 코드 – 앞부분

1) EBCDIC 코드 ­ 앞부분
① (제어 문자, 할당 없음)
-0
-1
-2
-3
-4
-5
-6
-7 NUL SOH STX ETX SEL HT RNL DEL 0
- 0000 0001 0002 0003 0009 007ex) 0 1 2 3 4 5 6 7 DLE DC1 DC2 DC3 RES ENP NL BS POC 1
- 0010 0011 0012 0013 0085 0008 16 17 18 19 20 21 22 23 DS SOS ex)S WUS BYP INP Lex) ETB ESC 2
- 000A 0017 001B 32 33 34 35 36 37 38 39 SYN IR PP TRN NBS EOT 3
- 0016 0004 48 49 50 51 52 53 54 55 ※ https://ko.wikipedia.org/wiki/확장_이진화_십진법_교환_부호

2) EBCDIC 코드 ­ 앞부분
② (제어 문자, 할당 없음)
-8
-9
-A
-B
-C
-D
-E
-ex) GE SPS RPT VT ex)ex) CR SO SI 0
- 000B 000C 000D 000E 000ex) 8 9 10 11 12 13 14 15 CAN EM UBS CU1 Iex)S IGS IRS IUS ITB 1
- 0018 0019 001C 001D 001E 001ex) 24 25 26 27 28 29 30 31 SA Sex)E SM SW CSP Mex)A ENQ ACK BEL 2
- 0005 0006 0007 40 41 42 43 44 45 46 47 SBS IT Rex)ex) CU3 DC4 NAK SUB 3
- 0014 0015 001A 56 57 58 59 60 61 62 63 ※ https://ko.wikipedia.org/wiki/확장_이진화_십진법_교환_부호  47   ▶ EBCDIC 코드 
- 뒷부분

1) EBCDIC 코드 ­ 뒷부분
① (알파벳, 숫자, 할당 없음)
-0
-1
-2
-3
-4
-5
-6
-7 ^ B
- 005E 176 177 178 179 180 181 182 183 { A B C D E ex) G C
- 007B 0041 0042 0043 0044 0045 0046 0047 192 193 194 195 196 197 198 199 } J K L M N O P D
- 007D 004A 004B 004C 004D 004E 004ex) 0050 208 209 210 211 212 213 214 215 ＼ NSP S T U V W X E
- 005C 2007 0053 0054 0055 0056 0057 0058 224 225 226 227 228 229 230 231 0 1 2 3 4 5 6 7 ex)
- 0030 0031 0032 0033 0034 0035 0036 0037 240 241 242 243 244 245 246 247 ※ https://ko.wikipedia.org/wiki/확장_이진화_십진법_교환_부호

2) EBCDIC 코드 ­ 뒷부분
② (알파벳, 숫자, 할당 없음)
-8
-9
-A
-B
-C
-D
-E
-ex) [ ] B
- 005B 005D 184 185 186 187 188 189 190 191 H I SHY C
- 0048 0049 00AD 200 201 202 203 204 205 206 207 Q R D
- 0051 0052 216 217 218 219 220 221 222 223 Y Z E
- 0059 005A 232 233 234 235 236 237 238 239 8 9 EO ex)
- 0038 0039 248 249 250 251 252 253 254 255 ※ https://ko.wikipedia.org/wiki/확장_이진화_십진법_교환_부호 2. 유니 코드 ▶ 한글 완성형 v 한글 완성형 : 한글 2,350자, 특수 문자 130자, 숫자 20자, 한글 낱자 40자, 기본 한자 4,888자, 외국 문자 및 특수 문자 830자의 모양을 미리 만들어 놓고 표현하는 코드이며,  48   모든 글자가 이미 정해져 있으므로 글자체의 모양을 좋게 할 수 있는 장점(사용) ⋅ 현재 KS X 1001과 EUC
-KR로 표준화되어 사용되고 있는 문자 집합 및 인코딩임(한국 산업 규격) KS C 5601:1987에서 처음 도입되었는데, 공식적인 제정 이유는 ISO/IEC 2022와의 호환성이 제시되고 있으나, 그 배경에는 한글 문자 집합 및 인코딩 표준화 과정에서 이미 사용되고 있던 조합형 인코딩들을 수용할 경우, 그 인코딩을 사용하는 업체와 사용하지 않는 업체 사이의 형평성이 문제가 되어 새로 만들었다는 견해도 존재 함 ⋅ ISO/IEC 2022와의 호환성 때문에 94×94 문자 집합을 선택했으며, 결과적으로 2350 자만의 한글을 완성된 형태로 지원하게 되어서 많은 논란을 낳았음(선택되지 못한 문자 들) 11172자의 한글 중 2350자만을 나타내었으므로 ＂똠,홥,뜽＂ 등의 글자를 쓸 수 없음(컴퓨터 표현 못함) ⋅ 예) 10110000 10100001 → ‘가’ ▶ 한글 조합형 v 한글 조합형 : 현대 한글 음절 11,172개 모두를 표현할 수 있는 방식. 초성, 중성, 종성 을 각각 별도로 처리하여 모든 글자를 조합해서 만들 수 있다는 장점을 가지고 있는 코드 ­ 2바이트 조합형 : 최상위 비트를 사용할 수 있는 환경에서 2바이트로 한글을 표현하기 위해 사용하는 방법이며, 그냥 조합형이라고 하면 이 종류의 인코딩을 나타내는 경우가 많음. 이 방법에서는 2바이트(16비트)를 최상위 1비트, 초성 5비트, 중성 5비트, 종성 5비트로 다음과 같이 나누고, ASCII와 겹치지 않도록 한글은 최상위 비트를 설정하여 표현(최상위 비트로 구분함) ⋅ 이 방법은 3바이트 조합형과 같은 원리를 사용하면서 결과물이 더 짧기 때문에, 7비 트 환경을 제외하고 널리 사용되었으며, 미완성 한글을 2바이트로 표현할 수 있다는 장점도 있음(완성형은 안됨) 그러나 둘째 바이트의 최상위 비트가 0일 수도 있기 때 문에 문자열 검색 등에서 문제가 생길 수 있음(ASCII) ⋅ 예) ‘구’ → ‘ㄱ’ (초성/00010) + ‘ㅜ’ (중성/10100) ▶ 유니 코드 v 유니 코드(Unicode) : 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있 도록 설계된 산업 표준이며, 유니코드 협회(Unicode Consortium)가 제정(언어를 통일하 는 효과) ­ 이 표준에는 ISO 10646 문자 집합, 문자 인코딩, 문자 정보 데이터베이스, 문자들을 다 루기 위한 알고리즘 등을 포함하고 있음(코드 변환) ­ 유니코드의 목적은 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체하려는 것(기존 코딩의 단점) ­ 기존의 인코딩들은 그 규모나 범위 면에서 한정되어 있고, 다국어 환경에서는 서로 호환 되지 않는 문제점이 있었음 ­ 유니코드가 다양한 문자 집합들을 통합하는 데 성공하면서 유니코드는 컴퓨터 소프트웨  49   어의 국제화와 지역화에 널리 사용되게 되었으며, 비교적 최근의 기술인 XML, 자바, 그 리고 최신 운영 체제 등에서도 지원(파이썬) ­ 유니코드에서 한국어 발음을 나타날 때는 예일 로마자 표기법의 변형인 ISO/TR 11941 을 사용하고 있음 ▶ 유니 코드의 기원 ­ 유니코드의 기원은 1987년으로 거슬러 올라가며, 이 때 제록스의 조 베커와 애플의 리 콜 린스, 마크 데이비스가 통일된 문자 집합을 만드는 것을 탐구하기 시작 ­ 1988년 조 베커는 유니코드라는 이름의 국제/다언어 문자 인코딩 시스템 (international/multilingual text character encoding system, tentatively called Unicode)를 위한 초안을 출판 ▶ 유니 코드 – 초기 버전 유니코드 버전 대응하는 글자들 문자 ISO/IEC 버전 날짜 책 집합 10646 전체 주요 추가 사항 수 버전 가타카나, 구르무키 문자, 구자라트 문자, 그리스 문자, 데바나가리, 라오 문자, 라틴 ISBN 문자, 말라얄람 문자, 벵골 문자, 1991년 0
-201
-56 아랍 문자, 아르메니아 문자, 1.0.0 24 7,161 10월 788
-1 오리야 문자, 조지아 문자, (Vol.1) 주음부호, 칸나다 문자, 키릴 문자, 타밀 문자, 타이 문자, 텔루구 문자, 티베트 문자, 한글, 히라가나, 히브리 문자 ISBN 1992년 0
-201
-60 20,902자의 한중일 통합 한자가 1.0.1 25 28,359 6월 845
-6 지정됨 (Vol.2) ISO/IEC 기존 2,350자의 한글에 1993년 1.1 10646
-1: 24 34,233 4,306자가 더 추가됨 6월 1993 티베트 문자 삭제 ※ https://ko.wikipedia.org/wiki/유니코드  50   ▶ 유니 코드 – 중간 버전 유니코드 버전 대응하는 글자들 문자 ISO/IEC 버전 날짜 책 집합 10646 전체 주요 추가 사항 수 버전 ISO/IEC 10646:20 ISBN 03과 개정 발리 문자, 쐐기 문자, 응코 2006년 5.0 0
-321
-48 1, 2, 64 99,089 문자, 파스파 문자, 페니키아 7월18일 091
-0 그리고 문자 개정 3의 문자 4개 카리 문자, 참 문자, 카야흐 리 ISO/IEC 문자, 렙차 문자, 리키아 문자, 10646:20 리디아 문자, 올치키 문자, 레장 2008년 100,71 5.1 03과 개정 75 문자, 사우라슈트라 문자, 순다 4월4일 3 1, 2, 3, 문자, 바이 문자, 파이스토스 4 원반의 기호, 마작 타일과 도미노 타일 추가, 대문자 ß 추가 ISO/IEC 10646:20 문자 15종류 추가, 4149자의 2009년 107,36 5.2 03과 개정 90 한중일 통합 한자(CJK
-C), 옛 10월1일 1 1, 2, 3, 한글 확장 자모 추가 4, 5, 6 문자 3종류 추가, 플레잉카드 ISO/IEC 기호, 교통 및 지도 기호, 연금술 2010년 10646:20 109,49 6.0 93 기호, 이모티콘과 에모지. 10월11일 10과 인도 4 222자의 한중일 통합 한자 루피 기호 (CJK
-D) 추가 ※ https://ko.wikipedia.org/wiki/유니코드  51   ▶ 유니 코드 – 현재 버전 유니코드 버전 대응하는 글자들 문자 ISO/IEC 버전 날짜 책 집합 10646 전체 주요 추가 사항 수 버전 ISO/IEC 10646:2014와 개정 1, 2, 문자 6종류와 5771 한중일 통합 2015년 120,73 8.0 조지아 라리 기호, 129 한자(CJK
-E), 체로키 소문자, 6월17일 7 한중일 통합 한자 피부색 조정자 5자 9자와 에모지 41자 ISO/IEC 10646:2014와 개정 1, 2, 2016년 아들람, 네와 128,23 서하 문자 등 6종의 문자와 9.0 135 6월21일 문자, 일본 7 에모지 72자 텔레비전 심벌, 74자의 에모지와 심벌 ISO/IEC 10646:2016과 2017년 개정 1, 2, 변체 136,75 소욤보문자 등 4종의 문자와 10.0 139 6월20일 가나, 한중일 통합 5 한중일 통합 한자(CJK
-ex)) 한자 21자와 에모지 56자 ISO/IEC 10646:2017과 개정 1, 2, 2018년 137,43 드고라 문자 등 8종의 문자와 11.0 드고라 문자 등 146 6월6일 9 에모지 145자 8종, 한중일 통합 한자 5자와 에모지 145자 ※ https://ko.wikipedia.org/wiki/유니코드  52   디지털 논리

1. 디지털 논리의 기초인 논리 게이트와 부울 대수에 대해 이해하고 설명할 수 있다. 3주차  수업목표  
2. 논리 게이트를 이용한 플립플롭에 대해 이해하고 설명할 수 1교시  있다.
1. 논리 게이트 세부내용 
2. 부울 대수
3. 플립플롭 1. 논리 게이트  ▶ 논리 게이트 v 전자공학에서 논리 회로(영어: logic gate)는 불 대수를 물리적 장치에 구현한 것으로, 하 나 이상의 논리적 입력값에 대해 논리 연산을 수행하여 하나의 논리적 출력값을 얻는 전 자회로를 말함 ⋅ AND, OR, NOT의 기본 불 대수를 수행하며, 이 기본 불 대수들의 결합으로 복합적인 논리 기능을 수행함 ⋅ 문맥에 따라서 이상적인 논리 회로라는 말을, 인스턴스에 대해서 상승 시간이 없고 무 제한의 팬아웃이라고 해석하거나 비이상적 물리장치라고 해석하기도 함(안정적 출력) ▶ AND 게이트 ­ ‘0’과 ‘1’ 만 사용하는 이진 정보는 게이트(gate)라고 하는 논리회로에서 처리 ⋅ 논리곱 연산을 수행하는 논리소자 ⋅ 모든 입력이 1인 경우에만 1을 출력(입력의 개수 ■) ⋅ 나머지의 경우에는 0을 출력 ⋅ 논리식 표현 : ⦁ ㆍ 기호 / 진리표(True Map)  입력(A) 입력(B) 출력(X)  0 0 0  0 1 0 1 0 0 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ OR 게이트와 NOT 게이트
1) OR 게이트 ­ 논리합 연산 수행, 다수의 입력 중 최소한 하나 이상의 입력이 1일 경우 1을 출력함(입력 의 개수 ■)  53   ⋅ 논리식 표현 :  ㆍ 기호 / 진리표(True Map)  입력(A) 입력(B) 출력(X)   0 0 0 0 1 1  1 0 1   1 1 1  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) NOT 게이트 ­ 한 개의 입력과 한 개의 출력을 갖는 게이트로 논리 부정을 나타내며, 입력 값에 대하여 출력 값이 반대가 되도록 함  ⋅ 논리식 표현 : ′ ㆍ 기호 / 진리표(True Map) 입력(A) 출력(X)   0 1 1 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ XOR 게이트와 NAND 게이트
1) XOR 게이트(Exclusive OR, 배타적 OR) ­ 여러 개의 입력 중에서 1의 개수가 홀수로 입력되면 1을 출력(보수, 비교) ­ 입력이 2개인 경우에 두 입력 중 하나만 1로 입력되면 1을 출력하고, 둘 모두가 1이거나 0이면 0을 출력(입력 ■)   ⋅ 논리식 표현 : ⦁⦁⊕ ㆍ 기호 / 진리표(True Map)  입력(A) 입력(B) 출력(X)   0 0 0 0 1 1 1 0 1 1 1 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) NAND 게이트 ­ AND 게이트와 NOT 게이트가 결합하여 AND 게이트의 출력과 반대로 출력(universal gate) ­ 모든 입력이 1인 경우에만 출력이 0이며, 나머지의 경우는 1을 출력  ⋅ 논리식 표현 : ⦁  54   ㆍ 기호 / 진리표(True Map)  입력(A) 입력(B) 출력(X)  0 0 1  0 1 1 1 0 1 1 1 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ NOR 게이트와 XNOR 게이트
1) NOR 게이트 ­ 논리합 연산을 수행하는 OR 게이트의 출력에 NOT 게이트를 연결한 개념(universal gate) ­ OR 게이트 출력에 반대로 출력, 다수의 입력 중 최소한 하나 이상의 입력이 1을 갖는 경 우 출력은 0이 됨  ⋅ 논리식 표현 :  ㆍ 기호 / 진리표(True Map) 입력(A) 입력(B) 출력(X)   0 0 1  0 1 0 1 0 0 1 1 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) XNOR 게이트 ­ Exclusive NOR 또는 배타적 NOR ­ XOR 게이트와 NOT 게이트의 결합 형태로 XOR 게이트와 반대의 값을 출력    ⋅ 논리식 표현 : ⦁⦁⊕ ㆍ 기호 / 진리표(True Map) 입력(A) 입력(B) 출력(X)   0 0 1  0 1 0 1 0 0 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 범용 논리 게이트 ­ NAND 게이트와 NOR 게이트는 디지털 시스템에서 사용되는 모든 논리 게이트를 구성하 며, 유니버셜 게이트(Universal Gate) 또는 범용 게이트라고 함  55  
1) AND 게이트의 구성 : ((AB)’(AB)’)’ = AB + AB = AB       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) OR 게이트의 구성       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
3) NOT 게이트의 구성       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 2. 부울 대수  ▶ 부울(또는 불) 대수 ­ 불 대수의 개념은 1847년에 조지 불이 논리학을 형식화하기 위하여 도입 ­ 이후 불은 1854년의 저서에서 이 개념을 추가로 설명 ­ 불은 논리곱(AND)과 배타적 논리합(XOR)을 기초적 연산으로 삼았는데, 이는 오늘날에 불 대수를 가환환(곱셈이 교환 법칙을 만족시키는 환, 환이란 덧셈과 곱셈이 정의된 대수 구조 의 하나)의 일종으로 여김 ­ 이후 윌리엄 스탠리 제번스(영어 : William Stanley Jevons, 1835~1882) · 찰스 샌더스 퍼스(1839~1914) · 에른스트 슈뢰더(독일어 : Ernst Schröder, 1841~1902) 등이 불의 논리 대수의 연구를 계속하였음 ­ 제번스는 1864년의 저서에서 불이 사용한 배타적 논리합 대신 (배타적이지 않은) 논리합 (OR)을 최초로 사용 ▶ 부울 대수의 기본 법칙  ­ 논리 회로 설계 시, 부울 대수를 이용하면 논리 회로를 정확하고 간결하게 표현할 수 있음 (비용 절감) ­ 부울 대수는 변수들의 진리표 관계를 대수식으로 표현하기에 용이하며 동일한 성능을 갖는 더 간단한 회로를 만들 때 사용
1) 교환 법칙(Commutative Law) ­ 입력들의 순서가 변경되더라도 논리 연산의 결과는 동일하게 출력 ⋅ A · B = B · A, A + B = B + A
2) 결합 법칙(Associative Law)  56   ­ 세 입력이 동일한 논리 연산을 수행할 때, 입력의 순서가 바뀌어 연산이 수행되어도 결과는 동일 ⋅ A · (B · C) = (A · B) · C, (A + B) + C = A + (B + C)
3) 분배 법칙(Distributive Law) ­ 세 입력 A, B, C가 있을 때, 두 입력 B, C를 OR 연산을 수행하고 그 결과를 나머지 입력 A와 AND 연산을 수행하는 논리 연산은 B와 C를 A와 AND 연산하고 그 결과들이 다시 OR 연산을 수행하는 것과 결과가 동일 ⋅ A · (B + C) = A · B + A · C, A + B · C = (A + B) · (A + C)
4) 다중 부정 ­ 논리 부정이 여러 번 수행되는 것이 다중 부정임  ⋅  ▶ 드모르강(De Morgan)의 법칙  ­ 여러 논리 변수의 논리합 전체를 부정(NOR)하면 그것은 원래의 논리 변수를 각각 부정한 것을 논리곱 한 것과 같음 ­ 여러 논리 변수의 논리곱 전체를 부정(NAND)하면 그것은 원래의 논리 변수를 각각 부정한 것을 논리합 한 것과 같음    ⋅ ⦁    ⋅ ⦁
1) 드모르강의 정리의 일반화 ­ n개의 입력 X를 갖는 드모르강의 일반식임    ⋅   ⦁⦁⦁ ⦁⦁⦁           ⋅ ⦁⦁⦁ ⦁⦁⦁       ▶ 부울 대수의 기본 정리
① 
② 
③ ⦁
④ ⦁
⑤ 
⑥   
⑦ ⦁
⑧ ⦁ 
⑨   
⑩ 
⑪   
⑫ ⦁ ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 부울 대수의 표준형 

1) 최소항(minterm) ­ 변수들이 AND로 결합된 것 ­ 변수의 값이 참(TRUE)인 ‘1’ 인 경우는 정상 형태인 A, B, C의 형태를 사용하고 변수  값이 거짓(ex)ALSE)인 ‘0’ 인 경우는 보수 형태인 의 형태를 사용 ­ 표준 곱의 항이라고 함  57  
2) 최대항(maxterm) ­ 변수들이 OR로 연결된 것(최소항과 보수 관계)    ­ 변수의 값이 참(TRUE)인 ‘1’ 인 경우는 보수 형태인 의 형태를 사용하고 변수 값이 거짓(ex)ALSE)인 ‘0’ 인 경우는 정상 형태인 A, B, C의 형태를 사용 ­ 표준 합의 항이라고 함 ­ 표준 곱의 항과 표준 합의 항에서 표준의 의미는 부울 대수가 모든 변수(ABC)를 포함하고 있다는 것을 뜻함 ⋅ 표준 곱의 항         ⦁⦁ ⦁⦁ ⦁⦁ ⦁⦁     ⦁⦁⦁⦁⦁⦁⦁⦁ ⋅ 표준 합의 항               ▶ 곱의 합(SOP, Sum Of Product) 표현  ­ 1 단계는 곱의 항(AND 항)으로 구성 ­ 2 단계는 합의 항(OR 항)으로 만들어진 논리식으로 구성하며, 최소항의 합이라고도 함 ⋅ 예) 변수가 3개인 진리표 : 임의의 출력 X와 최소항 그리고 기호 m A B C X 최소항 표현 기호 0 0 0 1  ⦁ ⦁    0 0 1 1  ⦁ ⦁   0 1 0 0  ⦁⦁    0 1 1 0  ⦁⦁   1 0 0 0 ⦁ ⦁    1 0 1 1 ⦁ ⦁   1 1 0 0 ⦁⦁    1 1 1 1 ⦁⦁   ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 논리식의 표현에서 출력 X가 1이 되는 논리식들의 합이 일반 논리식임       ⋅ ⦁⦁⦁⦁⦁⦁⦁⦁            ▶ 합의 곱(POS, Product Of Sum) 표현  ­ 1 단계는 합의 항(OR 항)으로 구성(곱의 합과 보수 관계) ­ 2 단계는 곱의 항(AND 항)으로 만들어진 논리식으로 최대항으로 구성되며, 최대항의 곱이 라고도 함  58   ⋅ 예) 3변수 진리표 : 임의의 출력 X와 최대항 그리고 별도의 기호 M을 표시 A B C X 최대항 표현 기호 0 0 0 1    0 0 1 1     0 1 0 0     0 1 1 0      1 0 0 0     1 0 1 1      1 1 0 0        1 1 1 1       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 합의 곱 표현에서는 곱의 합과 반대로 출력이 0이 되는 최대항을 가지고 일반 논리식으로 표현함       ⋅ ⦁⦁⦁ ⦁⦁⦁        3. 플립플롭  ▶ 플립플롭과 래치
1) 플립플롭 ­ 1비트의 정보를 기억할 수 있는 회로로 컴퓨터의 캐시 메모리, 레지스터를 구성하는 기본 회로(gate, latch, flip
-flop) ­ 전원이 있을 때만 기억이 유지되며 전원이 차단되면 정보는 사라지는 휘발성 기억소자

2) 래치(Latch) ­ 수동적 또는 전자적 조작으로 상태를 바꾸지 않는 한 그 상태를 유지해 주는 장치 또는 회 로를 말함(상태 유지) ­ 주어진 상태를 보관 유지할 수 있도록 NAND 게이트 또는 NOR 게이트를 이용하여 회로를 구성 ­ 논리 회로로 구성되었기 때문에 논리 회로에 준하는 빠른 동작 속도를 얻을 수 있고 플립 플롭으로 활용 v 플립플롭 또는 래치(영어: flip
-flop 또는 latch)는 전자공학에서 1 비트의 정보를 보관, 유 지할 수 있는 회로이며 순차 회로의 기본요소 ⋅ 조합논리회로에 비해 플립플롭은 이전 상태를 계속 유지하여 저장(순차논리회로
-기억소 자) ⋅ 디지털 공학에서 입력을 출력에 반영하는 시점을 클럭 신호의 순간 엣지에서 반영하는 플립플롭과, 입력에 따라 항상 반영되는 래치로 구분(rising, falling) ⋅ 필요한 플립플롭의 클럭 신호는 수정 발진기 등을 이용하여 생성하며, 복잡한 회로는 많은 플립플롭이 같은 클럭 신호를 사용하므로 전용의 클럭 배선이 필요한 경우도 있음  59   (버스
-제어선) ⋅ 래치는 입력되는 순간 바로 반영하기 때문에 플립플롭처럼 엣지의 시점을 결정하는 논 리 회로가 없어도 되므로 래치의 논리 회로가 간단함(latch+clock) ­ 디지털 시스템 설계에서의 회로를 구성할 때, 조합 논리와 결합하여 순차 회로의 기능을 구 현하는 중요한 요소 ­ 마이크로프로세서(CPU)와 같은 디지털 로직을 사용하는 많은 전자회로에 사용 ­ 시계의 카운터회로나 기타 복잡한 디지털 회로에는 필수적 요소(과거 출력 기억) ­ 순차 회로는 단순하게 조합 논리 기능을 실현하는 회로가 아니고, 지연된 하나의 출력을 피 드백하여 입력에 넣으므로써 정보를 보관, 유지하는데 사용하는 특징(기억) ­ 조합 회로에서 일반적으로 출력의 반대 논리인 음의 성질로 여겨지는 출력 신호의 지연을 피드백, 루프의 입력 신호에 사용하도록 구성하는 것이 흥미로움(피드백) ▶ NOR 게이트를 이용한 R
-S 래치 ­ 두 개의 NOR 게이트를 이용하여 R
-S 래치를 구성 ­ 두 입력으로 R(reset)과 S(set) 단자가 존재 ⋅ R 입력이 존재하는 NOR의 출력으로 Q가 있고, S입력이 존재하는 NOR 게이트의 출력  으로 가 존재  ⋅ Q와 는 NOT 관계 또는 1의 보수 관계임(피드백) R(reset)    S(set) ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

1) NOR 게이트를 이용한 래치 회로의 진리표  ­ 출력 Q 와 는 항상 보수의 상태가 되어야 하지만, S=1, R=1인 경우는 모두 0을 출력되 어 위배됨. 이를 불능이라고 함(보수 관계가 깨짐) <NOR 게이트를 이용한 R
-S 래치의 진리표> S R Q   0 0 불변 불변 0 1 0 1 1 0 1 0 1 1 불능 불능 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ NAND 게이트를 이용한 R
-S 래치 ­ 기본적인 동작은 NOR 게이트를 이용한 S
-R 래치와 동일   ⋅ NOR 게이트를 이용한 것과의 차이는 와 의 입력이 와̅의 형태로 인가 됨(NOR 와 보수)  60          ※ https://en.wikipedia.org/wiki/ex)lip
-flop_(electronics) ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

1) NAND 게이트를 이용한 래치 회로의 진리표     Q   0 0 불능 불능 0 1 1 0 1 0 0 1 1 1 불변 불변 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ R
-S 플립플롭 ­ 래치에 입력 게이트를 추가하여 플립플롭이 클럭 펄스가 발생하는 동안에만 동작하도록 만 든 논리회로 ­ 입력을 위한 두 개의 AND 게이트와 NOR 게이트를 사용한 R
-S 래치로 구성

1) R
-S 플립플롭의 회로도와 논리 기호     (클록 펄스)    (a) 회로도 (b) 논리기호 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

2) R
-S 플립플롭의 진리표와 상태도 클록 펄스 R S Q(t+1) 1 0 0 Q 1 0 1 1 1 1 0 0 1 1 1 불능 10 00 00   01 10 01 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  61   ▶ D 플립플롭 ­ 입력 단자 R과 S에 동시에 1이 입력되는 것을 회로적으로 차단(R
-S 단점 보완) ­ 입력신호 D가 클럭 펄스에 의해서 변화 없이 그대로 출력에 전달되는 특성을 가지고 있어, 데이터(Data)를 전달하는 것과 지연(Delay)을 의미하는 D 플립플롭이라 함

1) D 플립플롭의 회로도와 논리 기호     (클록 펄스)   (a) 회로도 (b) 논리기호 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) D 플립플롭의 진리표와 상태도 클록 펄스 D Q(t+1) 1 0 0 1 1 1 1 0  1 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ J
-K 플립플롭 ­ R
-S 플립플롭에서 S=1, R=1인 경우 불능 상태가 되는 것을 해결한 논리회로(R
-S 단점 보 완) ­ J는 S(set)에, K는 R(reset)에 대응하는 입력으로 J와 K의 입력이 동시에 1이 입력되면 플 립플롭의 출력은 이전 출력의 보수 상태로 변화하게 됨(피드백)

1) J
-K 플립플롭의 회로도와 논리 기호     (클록 펄스)    (a) 회로도 (b) 논리기호 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  62  

2) J
-K 플립플롭의 진리표와 상태도 클록 펄스 J K Q(t+1) 1 0 0 Q 1 0 1 0 1 1 0 1 1 1 1   10 11 00 00   01 10 01 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 11 ▶ T 플립플롭 ­ J
-K 플립플롭의 J와 K입력을 묶어서 하나의 입력신호 T로 동작시키는 플립플롭임(J
-K 단순 화) ­ 입력이 0이 되면 이전 상태(Q)의 값이 그대로 출력되고, 입력이 1이 되면 이전 상태(Q)의 보수 값이 출력되게 되는 플립플롭임

1) T 플립플롭의 회로도와 논리 기호     (클록 펄스)   (a) 회로도 (b) 논리기호 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) T 플립플롭의 진리표와 회로도 클록 펄스 T Q(t+1) 1 0 Q 1 1   1 0  0 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  63   조합 논리 회로
1. 조합 논리 회로와 순차 논리 회로의 개념을 학습하고 이를 설명할 수 있다. 3주차  수업목표  
2. 조합 논리 회로의 다양한 예들을 학습하고 이를 설명할 수 2교시  있다.
1. 조합과 순차의 개념 세부내용 
2. 조합 회로의 예 1. 조합과 순차의 개념  ▶ 조합 논리회로(combinational logic circuit) ­ 출력 신호가 입력 신호에 의해서만 결정 ­ 기본적인 논리 회로인 논리곱(AND), 논리합(OR), 논리부정(NOT) 등의 기본적인 논리 소자 의 조합으로 만들어지고 플립플롭과 같은 기억 소자는 포함하지 않음 ㆍ n개의 입력을 받아 m개의 출력을 내는 조합 논리 회로의 블록도 ­ 입력신호가 n개이므로 개의 입력신호 조합을 만들어 낼 수 있음 개 개 입력신호 출력신호 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 조합 논리 회로의 종류 ­ 가산기(Adder), 비교기(Comparator), 디코더(Decoder)와 인코더(Encoder), 멀티플렉서 (Multiplexer), 디멀티플렉서(Demultiplexer), 코드 변환기(Code converter) 등이 있음
1) 조합 논리 회로란? v 디지털 회로 이론에서 조합 논리(combinational logic)는 현재 입력에 따라 출력이 항상 똑같이 결정되는 논리 회로를 말함 ⋅ 현재 입력 뿐만 아니라 이전 입력의 영향 또한 함께 받는 순차 논리와는 구별됨 ⋅ 현재 입력만으로 출력이 결정되기 때문에 조합 논리에는 기억 장치가 쓰이지 않음 ⋅ 조합 논리는 컴퓨터 회로에서 쓰일 때 불 대수로 입력 신호나 저장된 데이터를 받게 됨 ⋅ 실제 컴퓨터 회로에서는 일반적으로 조합 논리와 순차 논리가 함께 쓰임 ⋅ 예를 들어 산술 논리 연산 장치(ALU)의 경우 수학적인 계산은 조합 논리로 구성하고 처리 순서를 조절하는 데는 순차 논리를 쓰는 식 ▶ 순차 논리회로(sequential logic circuit) ­ 출력 신호는 입력 신호뿐만 아니라 이전 상태의 논리값에 의해 결정 ­ 조합 논리 회로와 기억 소자로 구성되며, 기억 소자가 궤환을 형성  64   ⇨ 기억 소자는 2진 정보를 저장할 수 있는 장치로 플립플롭을 사용 ㆍ 순차 논리 회로의 블록도 출력 입력 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 동기(Synchronous)식 순차 논리회로 ­ 클록 펄스가 들어오는 시점에서 상태가 변화하는 회로 ㆍ 비동기(Asynchronous)식 순차 논리회로 ­ 클록 펄스에 영향을 받지 않고 현재 입력되는 입력 값이 변화하는 순서에 따라 동작하는 논리회로(클록
-처음)

1) 순차 논리 회로란? v 디지털 회로 이론에서 순차 논리(Sequential logic)는 출력이 입력에 의해서만 결정되지 않고 기존에 들어왔던 입력들의 영향 또한 받는 논리 회로를 말함 ⋅ 조합 논리와 순차 논리의 가장 큰 차이점은 조합 논리는 현재 입력만을 통해 출력을 결정하지만 순차 논리는 그렇지 않다는 점 ⋅ 따라서 순차 논리는 몇몇 종류의 컴퓨터 메모리나 기억 요소, 유한 상태 기계 등을 만 드는 데 사용 ㆍ 순차 논리 회로를 이용해서 만들 수 있는 유한 상태 기계의 예 ­ 무어 기계 : 출력이 내부 상태에 종속적임(내부 상태는 오직 시간 모서리에만 변환되며, 출력도 마찬가지임)(clock edge) ­ 밀리 기계 : 출력이 내부 상태에만 종속적인 것이 아니라 입력 또한 들어옴 2. 조합 회로의 예  ▶ 가산기(Adder) v 가산기(加算器, adder)란 덧셈 연산을 수행하는 논리 회로이며 디지털 회로, 조합 회로의 하나임 ⋅ 가산기는 산술 논리 장치뿐만 아니라 주소값, 테이블 색인 등을 더하는 프로세서의 한 부분으로 사용되고 있음 ⋅ 이진화 십진법, 3 초과 부호화 같은 여러가지 수학적 연산을 수행하는 가산기를 구성할 수 있지만, 대부분의 가산기는 2진수의 합을 계산함 ⋅ 2의 보수나 1의 보수를 이용하여 음수를 표현하는 경우, 가산기를 가감산기로 사용(덧 셈을 이용하여 뺄셈을 수행) ⋅ 다른 숫자의 부호 표현의 경우 더 복잡한 가산기를 필요로 함 ⋅ 전자계산기가 발명된 당시에는 진공관에 의해서 구성되었고 현재는 집적 회로로 설계되 어서 다양한 기능을 가지는 것(진공관, 트랜지스터, 집적 회로)  65   ⋅ 입력 신호 전압의 덧셈을 출력하는 디지털 회로를 가산 회로라고도 부름 ­ 두 개 이상의 입력을 이용하여 이들의 합을 출력하는 조합 논리회로 ­ 반가산기, 전가산기, 병렬 가산기(가감산)가 있음
1) 반가산기(Half Adder) ­ 1비트씩을 사용하는 두 개의 입력과 두 개의 출력으로 합(sum)과 자리 올림(carry)이 사용 됨 ㆍ 반가산기의 계산 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 반가산기의 진리표 A B 올림수(C) 합(S) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 반가산기의 논리 회로와 논리 기호         ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 전가산기(ex)ull Adder) ­ 두 입력, 2진수 A와 B 그리고 하위비트에서 발생한 자리 올림수를 포함하여 2진수 3개를 덧셈 연산하는 조합 논리회로 ㆍ 전가산기의 8종류 계산 하위 비트 올림수 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  66   ㆍ 전가산기의 진리표 A B  올림수(C) 합(S)  0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 전가산기의 논리 회로와 논리 기호             ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
3) 병렬 가산기 ­ 전가산기를 병렬로 연결하면 여러 비트로 구성된 2진수의 덧셈 연산을 수행할 수 있음 (XOR, 감산) ­ 4개의 전가산기를 병렬로 연결해서 4비트의 2진수 덧셈을 수행하는 병렬 가산기임 ⋅ 와 의 덧셈을 수행하는 것으로 최하위 비트의 덧셈 결과          에서 발생한 자리 올림수는 이 됨  ⋅ 그 다음 비트의 덧셈에서 발생하는 자리 올림수는 이며, 상위비트에서의 자리 올림수  는 와 가 존재                   0                 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 감산기(Subtractor) ­ 두 개 이상의 입력에서 하나 입력으로부터 나머지 입력들을 뺄셈해서 그 차를 출력하는 조 합 논리회로 ­ 가산기를 응용한 것으로 가산기에서의 합(sum)은 감산기에서 차(difference)가 되며, 가산 기에서는 올림수(carry)가 발생했지만 감산기에서는 빌림수(borrow)가 발생  67  
1) 반감산기(Half Subtractor) ­ 1비트 길이를 갖는 두 개의 입력과 1비트 길이를 갖는 두 개의 출력으로 차(D)와 빌림수 (Br)가 존재 ­ 두 입력 간의 뺄셈으로 얻은 결과가 출력에서 차가 되고, 이 차가 음의 값을 갖는 경우 출 력에서 빌림수가 활성화 ­ 두 개의 입력 변수 A와 B에서 4가지의 뺄셈 계산이 가능 ㆍ 반감산기의 계산 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 반감산기의 진리표 A B 빌림수(Br) 차(D) 0 0 0 0 0 1 1 1 1 0 0 1 1 1 0 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 반감산기의 회로도와 논리 기호         ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 전감산기(ex)ull Subtractor) ­ 반감산기가 단지 두 입력 간의 차이를 구하는 논리회로라면, 전감산기는 추가적으로 아랫자 리(하위 비트)에서 요구하는 빌림수에 의한 뺄셈까지도 수행 ㆍ 전감산기에서 수행되는 8가지의 뺄셈 계산 하위 비트 빌림수 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  68   ㆍ 전감산기의 진리표 A B  Br D  0 0 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 1 0 1 0 0 0 1 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 전감산기의 회로도와 논리 기호 반감산기1 반감산기2             ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
3) 병렬 가감산기 ­ 디지털 장치에서는 별도로 감산기를 사용하지 않고, 가산기에 게이트를 추가해 부호 선택 신호로 뺄셈 연산을 수행 ⋅ 4비트의 병렬 가산기 입력 B에 XOR 게이트를 추가 ⋅ XOR 게이트에 입력되는 부호 선택 신호의 값이 0이면 덧셈 연산을 수행 ⋅ XOR 게이트에 입력되는 부호 선택 신호의 값이 1이면 뺄셈 연산을 수행(비트 반전, 보수)                                      ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 비교기(Comparator) ­ 두 2진수의 크기를 비교하는 회로 ⋅ 비교를 통해서 생성되는 결과는 A < B, A
> B, A = B, A ≠ B 의 4가지가 존재  69  

1) 1비트 비교기 ㆍ 1비트 비교기의 진리표 A B  ≠ > <     0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 1 1 0 1 1 1 0 0 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 1비트 비교기의 논리회로     ≠  >  <  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 2비트 비교기의 진리표    ≠ > <         00 1 0 0 0 01 0 1 0 1 00 10 0 1 0 1 11 0 1 0 1 00 0 1 1 0 01 1 0 0 0 01 10 0 1 0 1 11 0 1 0 1 00 0 1 1 0 01 0 1 1 0 10 10 1 0 0 0 11 0 1 0 1 00 0 1 1 0 01 0 1 1 0 11 10 0 1 1 0 11 1 0 0 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  70  
3) 2비트 비교기의 논리회로         < > ≠  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 인코더와 디코더 ㆍ 인코딩(encoding) ­ 정보의 형태나 형식을 표준화, 보안, 처리속도 향상, 저장공간 절약 등의 목적으로 다른 형태나 형식으로 변환하는 방식으로, 부호화라고도 함 ­ 인코더는 변환 장치임 ㆍ 디코딩(decoding) ­ 인코딩된 정보를 인코딩되기 전으로 되돌리는 처리 방식을 말함 ­ 복호기 또는 디코더는 복호화를 수행하는 장치나 회로
1) 디코더와 인코더의 관계도                                 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 인코더(Encoder) v 인코더(Encoder) : 외부에서 들어오는 임의의 신호를 부호화된 신호로 변환하여 컴퓨터 내부로 들여보내는 조합 논리회로 ⋅ 개의 입력 신호로부터 n개의 출력 신호를 만듦 ⋅ 오직 한 비트만이 1, 나머지 개의 비트는 0이 되는 입력 신호가 생성 ⋅ 활성화된 값 1이 몇 번째 위치의 비트인가를 파악해서 2진 정보로 출력 ⋅ 8ⅹ3 인코더는 8비트의 입력 D 중에서 활성화된 값 1의 위치에 따라서 3비트의 출력 B를 얻는 장치  71  
1) 8ⅹ3 인코더의 진리표                       0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
2) 8ⅹ3 인코더의 논리회로                       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 디코더(Decoder) v 디코더(Decoder) : n비트의 이진 코드를 최대 가지의 정보로 바꿔주는 조합 논리회로 ⋅ 디코더는 다수의 입력신호로서 1개의 출력 신호를 얻는 회로 ⋅ 디코더는 인코더 동작과 반대로 동작하는 회로임 ⋅ 3ⅹ8 디코더는 3비트의 입력 C, B, A와 8비트의 출력 Y로 이루어지며, 3개의 입력들 의 조합으로 8종류의 출력 중 하나의 출력이 선택됨
1) 3ⅹ8 디코더의 진리표                    0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  72  
2) 3ⅹ8 디코더의 논리회로                    ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 멀티플렉서와 디멀티플렉서 v 멀티플렉서(multiplexer or mux) : 여러 아날로그 또는 디지털 입력 신호 중 하나를 선택 하여 선택된 입력을 하나의 라인에 전달하는 장치 ⋅ 전자 멀티플렉서는 여러 신호가 이를테면 입력 신호 당 하나의 장치를 보유하지 않고 아날로그
-디지털 변환회로(A/D 변환기)나 하나의 통신선 등 하나의 장치나 자원을 공 유할 수 있게 만들어줌 v 디멀티플렉서(demultiplexer or demux) : 하나의 입력 신호를 받아서 수많은 데이터 출 력선 중 하나를 선택하는 장치를 말하며 단일 입력으로 연결됨 ⋅ 수신을 받는 쪽에서는 멀티플렉서라는 용어를 보완 관계인 디멀티플렉서와 번갈아가며 사용되기도 함 ㆍ 멀티플렉서(Multiplexer) ­ 여러 개의 입력 중 하나의 입력만을 출력에 전달해주는 조합 논리 회로 ­ 선택 신호에 의해 여러 개의 입력 중 하나의 입력만이 선택됨 ㆍ 디멀티플렉서(Demultiplexer) ­ 하나의 입력 신호를 선택 신호에 의해 여러 개의 출력 중 하나로 보내는 장치

1) 멀티플렉서와 디멀티플렉서의 관계                                             선택 신호 선택 신호 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  73   ▶ 멀티플렉서(Multiplexer) ­ 다중 입력 데이터를 단일 출력하므로 데이터 선택기(data selector)라고도 함 ­ N개의 입력이 있는 경우 log2N개 만큼의 선택 신호가 필요 ⋅ 4개의 입력(Input 0 ~ Input
3)은 선택선(S0, S1)에 의해 입력선 중 하나만이 출력으 로 전달됨 ㆍ 4개의 입력이 존재하는 4 × 1 멀티플렉서의 진리표   출력   0 0 입력0 0 1 입력1 1 0 입력2 1 1 입력3 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 4 × 1 멀티플렉서의 논리회로 / 논리기호 입력0 입력1 입력 출력 출력 입력2 입력3 선택 4X1 멀티플랙서의 논리회로 4X1 멀티플랙서(MUX)의 논리기호     ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 디멀티플렉서(Demultiplexer) ­ 멀티플렉서의 역기능을 수행하는 조합 논리 회로 ­ 선택선을 통해 여러 개의 출력선 중 하나의 출력선에만 출력을 전달(단일 입력, 다중 출력) ⋅ 두 선택 신호의 조합에 의해서 입력 신호가 출력될 곳이 결정됨 ㆍ 1 × 4 디멀티플렉서의 진리표   출력   0 0 출력0 0 1 출력1 1 0 출력2 1 1 출력3 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 1 × 4 디멀티플렉서의 논리회로 / 논리기호 출력0 출력1 입력 출력 출력2 입력 출력3 선택 1X4 디멀티플랙서(DEMUX)의 논리회로 1X4 디멀티플랙서의 논리회로     ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  74   ▶ 패리티 검사기
1) 패리티 비트(parity bit) ­ 데이터 전송과정에서 오류 검사를 위해서 추가한 비트 ㆍ 짝수 패리티 비트 ­ 데이터에서 1의 개수를 짝수로 맞추기 위해서 사용하는 비트(오류 정정 못함, 2개 동시 발생) ㆍ 홀수 패리티 비트 ­ 데이터에서 1의 개수를 홀수로 맞추기 위해서 사용하는 비트
2) 3비트 2진수에 대한 홀수 패리티 비트와 짝수 패리티 비트 진리표 3비트 입력 홀수 패리티 비트 짝수 패리티 비트        0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 0 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 패리티 비트 v 패리티 비트(Parity bit): 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트 ⋅ 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송하는 방법으로 2가지 종류의 패리티 비트(홀수, 짝수)가 있음 ⋅ 오류 검출 부호에서 가장 간단한 형태로 쓰임 ⋅ 짝수(even) 패리티는 전체 비트에서 1의 개수가 짝수가 되도록 패리티 비트를 정하는 것인데, 이를테면 데이터 비트에서 1의 개수가 홀수이면 패리티 비트를 1로 정함 ⋅ 홀수(odd) 패리티는 전체 비트에서 1의 개수가 홀수가 되도록 패리티 비트를 정하는 방법 ▶ 짝수와 홀수 패리티 비트
1) 짝수 패리티 발생기 ­ 짝수 패리티 발생기의 진리표를 통해서 부울 대식을 표현하면 다음과 같음  ⊕⊕  ㆍ 논리회로      ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  75  
2) 홀수 패리티 발생기 ­ 홀수 패리티 발생기의 진리표를 통해서 부울 대식을 표현하면 다음과 같음(짝수 패리티와 보수 관계)   ⊕⊕  ㆍ 논리회로      ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  76   순차 논리 회로
1. 순차 논리 회로 중 레지스터에 대해서 학습하고 이를 설명할 수 있다. 3주차  수업목표  
2. 순차 논리 회로 중 카운터에 대해서 학습하고 이를 설명할 수 3교시  있다.
1. 레지스터 세부내용 
2. 카운터 1. 레지스터  ▶ 레지스터(Register) ­ 플립플롭 여러 개를 일렬로 배열하고 적당히 연결함 ­ 여러 비트의 2진수를 일시적으로 저장하거나 저장된 비트를 좌측 또는 우측으로 하나씩 이 동할 때 사용함
1) 이동(shift) 레지스터 ­ 데이터를 좌우로 이동시키는 레지스터 ⋅ 직렬 입력, 병렬 출력과 병렬 입력, 직렬 출력 형태를 포함하여 직렬과 병렬의 입출력 조합을 가지고 있음 ⋅ 양방향성 이동 레지스터, 순환 레지스터도 있음
2) 직렬처리와 병렬처리의 특징 ㆍ 병렬방식 ­ 모든 비트의 데이터를 한 번에 전송하며, 하나의 클록 펄스(Clock Pulse) 시간 동안에 전송되므로 전송 속도가 빠름 ­ 레지스터의 비트 수만큼 데이터 전송 경로를 가지므로 직렬 방식에 비하여 복잡함 ㆍ 직렬방식 ­ 레지스터에 직렬 입력과 직렬 출력을 연결하여 한 번에 한 비트씩 전송 ­ 데이터를 전송할 때 전송 속도가 느리지만 하드웨어의 규모가 간단함 ▶ 이동 레지스터의 동작 유형에 따른 종류
① 직렬 입력 ­ 병렬 출력 /
② 병렬 입력 ­ 병렬 출력 제어 데이터 입력 데이터 입력 제어 데이터 출력 데이터 출력 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  77  
③ 병렬 입력 ­ 직렬 출력 /
④ 직렬 입력 ­ 직렬 출력 제어 데이터 입력 데이터 입력 데이터 출력 데이터 출력 데이터 출력 데이터 입력 제어 제어 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
⑤ 데이터 순환(left / right) 데이터 순환(left) 데이터 순환(right) 제어 제어 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 직렬 입력, 직렬 출력 이동 레지스터 ­ 가장 간단한 종류의 이동 레지스터이며, 단일 선으로 한 번에 한 비트씩 데이터를 받아 들 이고, 저장된 정보를 직렬로 출력함 ­ 클록 펄스는 데이터를 이동시키는 제어 신호로, 클록 펄스가 이동 레지스터에 입력될 때마 다 이동 레지스터에 저장되어 있는 데이터가 출력됨

1) 4비트로 구성된 직렬 입력, 직렬 출력의 이동 레지스터 ­ 각 플립플롭에 기억된 내용은 왼쪽에서 오른쪽으로 이동   직렬 입력 직렬 출력  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 4비트의 직렬 입력, 직렬 출력의 이동 레지스터의 이동 과정                    직렬 입력. 직렬 출력 이동 레지스터에서 데이터 비트의 이동 과정 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  78   ㆍ 4비트의 직렬 입력, 직렬 출력의 이동 레지스터의 타이밍도            입력 데이터                   직렬 입력, 직렬 출력 이동 레지스터의 타이밍도 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 직렬 입력, 병렬 출력 이동 레지스터 ­ 입력 데이터 비트는 직렬로 레지스터 내에 들어가고, 출력 비트들은 레지스터의 각 단에서 출력되어 병렬 형태가 됨 ­ 직렬 출력처럼 한 비트씩 출력되지 않고 모든 비트가 동시에 각각의 플립플롭 출력선을 타 고 출력됨
1) 4비트의 직렬 입력, 병렬 출력 이동 레지스터 구성 병렬 출력          직렬 입력  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 4비트의 직렬 입력, 병렬 출력의 이동 레지스터의 이동 과정                    직렬 입력, 병렬 출력 이동 레지스터에서 데이터 비트의 이동 과정 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  79   ㆍ 4비트의 직렬 입력, 병렬 출력의 이동 레지스터의 타이밍도            입력 데이터                   직렬 입력, 병렬 출력 이동 레지스터의 타이밍도 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 병렬 입력, 직렬 출력 이동 레지스터 ­ 각 플립플롭 단에 병렬로 동시에 입력 ­ 첫 플립플롭에서는 하나의 입력만이 존재, 그 이후의 플립플롭에서는 이전 플립플롭의 출력 과 새로운 입력이 존재 ­ 레지스터는 이 두 종류 입력에 대한 선택적인 판단이 필요, 이때 필요한 조합 논리 회로는 2×1 멀티플렉서임
1) 2×1 멀티플렉서 ­ 선택 단자 S에 의해서 입력이 결정 즉, S가 0이면 입력 I가 선택되고 Y로 출력되며, S가 1 이면 입력 Q가 선택되고 Y를 통해서 출력됨 ㆍ 진리표 선택선 출력 S Y 0 1 1 Q ㆍ 논리회로 / 논리기호         ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 각 플립플롭으로 입력되는 4개의 데이터 입력선 I 와 이동 레지스터 안으로 데이터를 병렬  로 들어가게 하기 위한  입력이 있음(이전 플립플롭의 출력) 
2)  입력 ­ 0이면 새로운 데이터가 레지스터에 입력되고 클록 펄스에 의해서 마지막 플립플롭에서 한  80   비트를 출력 ­ 1이면 클록 펄스에 의해 한 비트씩 오른쪽으로 이동됨 ㆍ 병렬 입력, 직렬 출력 이동 레지스터의 회로도            직렬 데이터 출력  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 병렬 입력, 직렬 출력 이동 레지스터의 출력 파형도     출력           ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 병렬 입력, 병렬 출력 이동 레지스터 ­ 데이터의 병렬 입력과 병렬 출력의 방법을 결합시킨 이동 레지스터 ⋅ 데이터 비트들이 동시에 입력되면 클록 펄스에 의해서 바로 병렬 출력이 나타남
1) 4비트 병렬 입력, 병렬 출력 이동 레지스터 논리 회로 ­ 4비트의 입력 D D D D 가 각 플립플롭에 입력되고 클록 펄스가 들어오면 각 플립플롭은 A B C D 즉각적으로 Q Q Q Q 를 출력 A B C D 데이터 입력          데이터 출력         ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 병렬 입력, 병렬 출력 이동 레지스터는 다중 비트를 저장하는 기억장치로도 사용이 가능  81   ▶ 재순환 이동 레지스터(Recirculating Shift Register) ­ 출력되는 데이터가 다시 처음으로 입력되는 레지스터임
1) 4비트의 재순환 이동 레지스터 ­ 데이터 제어 단자에 1이 입력되면 직렬 데이터가 입력되고, 0이면 이동 동작을 통해서 재 순환 데이터가 입력됨 데이터 제어 High=직렬 데이터 입력 Low=재순환 데이터 직렬 데이터 입력 직렬 데이터 입력  ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 입력 데이터 1101가 입력되어 순환되는 과정을 클록 펄스와 상태 파형으로 나타낸 것(입 력, 순환)  직렬 데이터=1 재순환=0 입력 데이터                   직렬 데이터 입력 재순환 데이터 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 양방향 이동 레지스터 ­ 좌측과 우측방향으로 데이터를 이동시킬 수 있음  ­ 이동방향을 결정하는  제어 입력의 회로는 2×1 멀티플렉서임 ­ 1이면 우측으로 데이터가 이동되고, 0이면 좌측으로 이동 ㆍ 2×1 멀티플렉서 논리회로와 논리기호             ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  82  
1) 양방향 이동 레지스터의 논리기호  ­ 이 1이면 데이터가 SRI를 통해서 입력되고 오른쪽으로 이동하면서 SRO(serial right out)에서 출력되며, 0이면 데이터는 SLI에 입력되고 왼쪽으로 이동하면서 SLO(Serial Left Out)에서 출력됨
2) 4비트의 양방향 이동 레지스터의 회로               ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ­ 4개의 플립플롭 입력에 2×1 멀티플렉서가 연결되어 있고, 이것에 의해서 이동 방향이 결정 됨 ­ 우측으로 이동하는 경우에서는 출력 단자는 O 가 되고, 좌측으로 이동하는 하는 경우에는 D O 가 됨 A ­ 2진수의 연산에서 비트의 이동은 2배수의 덧셈과 나눗셈 연산을 수행하며, 좌측으로 이동 하면 2를 곱한 결과가 되고 우측으로 이동하면 2를 나눈 결과와 같음 ­ 양방향 이동 레지스터는 2진수의 곱셈과 나눗셈 연산기로 사용할 수 있음 ▶ 카르노 도표(Karnaugh Map) v 조직적인 도표를 사용하여 부울 대수를 최적으로 간략화 할 수 있으며, 카르노 도표는 부 울 대수식을 간소화 하기 위한 가장 체계적이고, 간단한 방법임 ⋅ 최적의 간략화에 근거한 디지털 회로설계만이 게이트 수를 최소화 할 수 있으며, 이에 따라 디지털 회로는 회로의 경제성, 소비 전력의 효율성, 회로의 신뢰성, 제품의 소형화 가 가능해짐 ⋅ 변수 2개, 변수 3개, 변수 4개, 변수 5개로 이루어진 입력 변수에 적용할 수 있고, 그 이상의 변수가 존재하는 경우에는 다른 방법을 사용함
1) 변수가 2개인 카르노 도표(AB 위치 주의) B A 0 1 0 1 A B 0       0      1    1     ­ 출력이 0인 경우에는 빈칸으로 표시하지 않고 1인 경우에만 표시 B A 0 1 0 1 A B 0 1 0 1 1 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  83  
2) 변수가 3개인 카르노 도표 BC AB 00 01 11 10 00 01 11 10 A C 0              0             1          1           ­ 카르노 도표를 가장 간단한 형태로 표현 ­ 출력이 0인 경우에는 빈칸으로 표시하지 않고 1인 경우에만 표시 BC AB 00 01 11 10 00 01 11 10 A C 0 1 1 0 1 1 1 1 1 1 1 1 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
3) 변수가 4개인 카르노 도표 CD AB 00 01 11 10 00 01 11 10 AB CD 00              00               01                  01               11          11           10              10               ­ 카르노 도표를 가장 간단한 형태로 표현 ­ 출력이 0인 경우에는 빈칸으로 표시하지 않고 1인 경우에만 표시 CD AB 00 01 11 10 00 01 11 10 AB CD 00 1 1 00 1 01 1 01 1 1 11 1 1 11 1 1 10 10 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
4) 부울 대수식을 이용한 카르노 도표의 작성 ­ 카르노 도표를 작성할 때, 진리표에 근거하여 작성 ­ 변수가 4개인 표준형의 부울 대수식에 대한 카르노 도표의 작성          ⦁⦁⦁⦁⦁⦁⦁⦁⦁⦁⦁⦁⦁⦁⦁              CD 00 01 11 10 AB 00 1 1 01 1 11 1 1 10 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  84  
5) 카르노 도표에서 행과 열의 이웃 관계 ­ 이웃과의 그룹화는 부울 대수를 간략화하는 방법을 제시 ­ 카르노 도표는 평면 형태로 보여지나 이웃 관계는 상하좌우 모두를 포함하므로 실제로는 원통 형태나 구(球) 형태임 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 카르노 도표를 이용하여 간략화하는 과정 ⋅ 1단계 ­ 주어진 부울식이나 진리표에 근거하여 카르노 도표를 작성 ⋅ 2단계 ­ 그룹화를 수행함 ⋅ 카르노 도표에서 1로 표시된 이웃들을 1, 2, 4, 8, 16 개씩 그룹화 함(2의 배수) ⋅ 가능하면 큰 개수로 그룹화하는 것이 간략화의 효과가 큼 ⋅ 각각 다른 그룹에 여러 번 중복하여 그룹화 할 수 있음 ⋅ 그룹화할 이웃이 없는 경우 단독으로 그룹화되고 이것은 간략화 되지는 않음 ⋅ 3단계 ­ 각 그룹을 간략화 함 ⋅ 4단계 ­ 각의 간략화된 부울식들 끼리 OR 연산을 함 ▶ 카르노 도표의 그룹화 ㆍ 2개항의 그룹화               ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  85   ㆍ 4개항의 그룹화            ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 8개항의 그룹화      ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ㆍ 중복 그룹화                 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 무관 조건 v 무관 조건(Don’t Care) : 출력에 관여하지 않는 입력이 존재할 수 있으며, 이렇게 출력에 관여하지 않는 입력 변수를 말함 ⋅ 무관 조건은 이웃 영역을 그룹화할 때 가장 간단한 표현을 얻기 위해 임의로 채워질 수 있으며, 간략화 과정에서 그룹화 할 수도 있고 그룹화 하지 않을 수도 있음
1) 카르노 도표에서의 무관 조건 ­ 무관 조건을 활용해서 그룹화하는 방법 ­ 무관 조건은 카르노 도표에서 X로 표기  86    : 무관 조건 (a) 무관 조건을 사용하지 않은 경우 (b) 무관 조건을 사용한 경우 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 2. 카운터  ▶ 카운터(Counter, 계수기) v 계수기(counter, 카운터) : 클럭 펄스를 세어서 수치를 처리하기 위한 논리 회로(디지털 회로) ⋅ 계수기가 계수한 이진수나 이진화 십진수가 디코더를 통해서 7 세그먼트 발광 다이오 드에 표시되는 숫자로 변환하여 인간이 알아볼 수 있는 정보가 됨(자판기) ⋅ 또한 인코더가 정보를 이진수로 변환한 것을 계수기를 통해 계수 처리를 실시 할 수 있음 ⋅ 수정진동자를 이용한 발진 회로에서 만들어진 높은 주파수(예 : 32.768KHz)의 전기신 호를 낮은 주파수(예시 : 1 Hz)의 신호로 변환하기 위해서도 사용(주파수 변환) ⋅ 그렇기 때문에 이런 회로를 분주기라고 부름 ­ 클록 펄스에 따라 수를 세는 계수 능력을 갖는 논리 회로 ­ 컴퓨터가 여러 가지 동작을 수행하는 데에 필요한 타이밍 신호를 제공함 ㆍ 카운터는 동기식과 비동기식으로 분류 ­ 동기식 카운터는 입력 펄스의 입력 시간에 동기 되어 각 플립플롭이 동시에 동작하기 때 문에 모든 플립플롭의 단에서 상태변화가 일어남 ­ 비동기식 카운터는 앞 단의 출력을 받아서 각 플립플롭이 차례로 동작하기 때문에 첫 단 에만 클록 펄스가 필요하며, 직렬 카운터 또는 리플(ripple) 카운터라 함 ㆍ 카운터는 비트 수에 따라서 최대 카운트가 결정 ­ 4비트 카운터의 최대 카운트 범위는 , 즉 0~15(0000 ~ 1111)이며, 8비트 카운터의 최대 카운트 범위는  = 0~255(0000 0000 ~ 1111 1111)가 됨 ­ 카운트를 시작해서 카운트를 끝낸 후, 다시 처음 상태로 돌아올 때까지의 상태 수를 카 운터 계수(modulus of a count)라고 함 ­ 10진 카운터는 0 ~ 9까지의 10개의 상태가 존재, 카운터 계수는 10이 됨 ­ 일반화 해서 표현하면, 카운터에서 구별되는 상태의 수가 m일 때 modulo
-m(간단히 mod
-m; m 진)의 카운터라고 함  87   ▶ 상향 비동기식 카운터

1) 4비트의 2진 상향 카운터 ­ 0부터 시작해서 클록의 수가 증가하면 15까지 증가, 16개의 상태를 가지므로 mod
-16 카 운터임 ㆍ 상태도 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미

2) 4비트의 2진 상향 카운터(JK의 입력이 11일때, Q’) ㆍ 논리회로  LSB    MSB       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
3) 4비트의 2진 상향 카운터(falling edge) ㆍ 타이밍도          상태 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 하향 비동기식 카운터 ­ 클록 펄스의 수가 증가함에 따라 카운터의 수가 감소하는 카운터
1) 4비트 하향 비동기식 카운터 ­ 최대값 15부터 시작해서 클록 펄스의 수가 증가하면서 하나씩 그 값이 감소하고, 카운터의 값이 0이면 되면 다시 15부터 시작하게 됨 ㆍ 상태도 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  88  
2) 4비트 하향 비동기식 카운터(JK의 입력이 11일때, Q’) ㆍ 논리회로  LSB    MSB       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미
3) 4비트 하향 비동기식 카운터(rising edge) ㆍ 타이밍도          상태 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 3비트 동기식 2진 카운터 ­ 8개의 순차적인 상태(000, 001, 010, 011, 100, 101, 110, 111)를 갖음(동기식 ­ 클럭 펄스 모두 인가) ㆍ 상태도와 논리회로 논리회로  LSB        상태도 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 3비트 동기식 2진 카운터(falling edge) ㆍ 타이밍도        상태 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  89   ▶ 링 카운터(Ring Counter) ­ 플립플롭들이 하나의 고리 모양으로 연결
1) 4비트 링 카운터의 상태도 ­ 논리 1의 값이 왼쪽으로 이동하면서 순환 ㆍ 상태도 ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미 ▶ 링 카운터(Ring Counter)(D flip
-flop) ㆍ 논리회로와 타이밍도         논리회로      타이밍도       ※ 컴퓨터 구조와 원리, 신종홍, 한빛아카데미  90   컴퓨터 정보의 저장

1. 컴퓨터 내부에 정보를 저장하기 위해 컴퓨터 기본 내부를 학습하고 이를 설명할 수 있다. 4주차  수업목표  
2. 컴퓨터 내부에서 정보의 저장 방법에 대해서 이해하고 설명할 1교시  수 있다.
1. 컴퓨터 기본 세부내용 
2. 정보의 저장 1. 컴퓨터 기본   ▶ 컴퓨터시스템의 구성 응용 소프트웨어 (application software) (게임, 워드) 시스템 소프트웨어(system software) (운영체제, 컴파일러, DBMS) 하드웨어(hardware) (변경 X, CPU, Memory, I/O) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 하드웨어와 소프트웨어
1) 하드웨어(hardware) ­ 컴퓨터 정보들의 전송 통로를 제공(버스)해 주고, 그 정보에 대한 처리가 실제 일어나게 해 주는 물리적인 실체들(CPU, Memory, I/O)(vs. 펌웨어)
2) 소프트웨어(software) ­ 정보들이 이동하는 방향(I/O)과 정보 처리의 종류(add)를 지정해주고, 그러한 동작들이 일 어나는 시간(clock)을 지정해주는 명령(command)들의 집합(소
-프
-명
-마) ㆍ 시스템 소프트웨어(System Software) ­ OS(Windows 10, Unix, Linux, 등), 각종 유틸리티 프로그램들(프린터 드라이버, 등), DBMS, 컴파일러 ㆍ 응용 소프트웨어(Application Software) ­ 워드프로세서, 웹브라우저, MS
-Excel, 등(특수 목적) ▶ 컴퓨터 하드웨어의 주요 요소들  91  
① 메인보드(main board)
② CPU 및 GPU 칩
③ 주기억장치 모듈(DRAM)
④ 확장 보드 : 사운드 카드 등
⑤ 전원공급장치(power supply)
⑥ 광 저장장치 : CD
-ROM, DVD
⑦ 하드 디스크, SSD
⑧ 키보드
⑨ 마우스
⑩ 디스플레이 모니터 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 컴퓨터의 기본 구조

1) 컴퓨터의 기능 ­ 프로그램 코드(명령어)를 정해진 순서대로 수행(순차적) ⋅ 데이터를 읽어서(read), 처리(processing)하고, 저장(store)
2) 주요 구성요소들 ­ 중앙처리장치(CPU), 기억장치(주
-보조), 입출력장치(I/O) 중앙처리장치 (CPU) 시스템 버스(주
-데
-제) 기억장치 입출력장치 (Memory) (I/O Devices) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 컴퓨터의 기본적인 구성요소들 – CPU ㆍ 중앙처리장치(Central Processing Unit : CPU) ­ 프로세서(processor) : 레지스터, ALU(연산), 제어장치 ­ '프로그램 실행'과 '데이터 처리'라는 중추적인 기능의 수행을 담당하는 요소(주기억장치 의 명령어를 처리) v 중앙처리장치(中央處理裝置) 또는 CPU(central processing unit)는 컴퓨터 시스템을 통제 하고 프로그램의 연산을 실행하는 가장 핵심적인 컴퓨터의 제어 장치, 혹은 그 기능을 내 장한 칩을 말함 ⋅ 컴퓨터 안의 중앙 처리 장치(CPU)는 외부에서 정보를 입력 받고, 기억하고, 컴퓨터 프 로그램의 명령어를 해석하여 연산하고, 외부로 출력하는 역할을 함(명령어) ⋅ 따라서 중앙 처리 장치(CPU)는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 시스템 전체 를 제어하는 장치로, 모든 컴퓨터의 작동 과정이 중앙 처리 장치(CPU)의 제어를 받기 때문에 컴퓨터의 두뇌에 해당한다고 할 수 있음(두뇌)  92  

1) 중앙처리장치(CPU)의 특징 ­ 실제의 CPU 칩엔 실행 부분(연
-제
-레)뿐만 아니라 캐시 등의 부가 장치가 통합된 경우가 많음(on
-chip cache) ­ CPU에는 MCU(Micro Control Unit)와 주변 장치(외부 확장 장치에 관한 IC)가 다 들어있 는 SOC(System On Chip)가 있으며, 주변 IC가 따로 달려 있을 경우, 그것은 MCU라고 할 수 있음 ­ CPU는 기계어로 쓰인 컴퓨터 프로그램의 명령어를 해석하여 실행하는데, 프로그램에 따라 외부에서 정보를 입력 받아, 이를 기억하고, 연산하며, 결과를 외부로 출력 ­ CPU는 컴퓨터 부품(Memory, I/O)과 정보를 교환하면서 컴퓨터 전체의 동작을 제어함(제 어장치 ­ 두뇌의 두뇌)

2) 중앙처리장치(CPU)의 기본 구성 ­ 기본 구성으로는 CPU에서 처리할 명령어를 저장하는 역할을 하는 프로세서 레지스터, 비 교, 판단, 연산을 담당하는 산술논리연산장치(ALU), 명령어의 해석과 올바른 실행을 위하여 CPU를 내부적으로 제어하는 제어부(control unit)와 내부 버스 등이 있음 ­ 각종 전자 부품과 반도체 칩을 하나의 작은 칩에 내장한 전자 부품을 마이크로프로세서라 고 하며, 전기 밥통에 쓰이는 낮은 성능의 제품부터 컴퓨터에 쓰이는 높은 성능의 제품까지 매우 다양함 ­ 마이크로프로세서들 가운데 가장 복잡하고 성능이 높은 제품은 컴퓨터의 연산 장치로 쓰이 며, 이것을 중앙 처리 장치(CPU)라고 함 ▶ 컴퓨터의 기본적인 구성요소들 – 기억장치 ㆍ 주기억장치(main memory) ­ CPU 가까이 위치하며, 반도체 기억장치 칩들로 구성 ­ 고속 액세스 : RAM(random access), ROM(read only) ­ 가격이 높고 면적을 많이 차지 → 저장 용량의 한계 ­ 영구 저장 능력이 없기 때문에, 일시적 저장장치로만 사용 v 주기억장치(主記憶裝置) 또는 컴퓨터 메모리(computer memory)는 컴퓨터에서 수치·명령· 자료 등을 기억하는 컴퓨터 하드웨어 장치를 가리킴 ⋅ 이 용어는 1차(primary) 기억 장치와 동의어인데, 예를 들어 램(RAM)처럼 빠른 속도 로 동작하는데, 높은 용량을 제공하는 프로그램 및 데이터 기억 공간을 제공하는 기억 장치(2차 기억 장치, secondary)와는 구별함 ⋅ 필요한 경우, 컴퓨터 메모리(주기억)의 내용은 보조기억장치로 전송할 수 있는데 이는 가상 메모리(논리적 메모리)라 불리는 메모리 관리 기법을 통해 가능 하며, 메모리의 고전적인 동의어 표현은 스토어(store)임 ㆍ 보조저장장치(auxiliary storage device) ­ 2차 기억장치(secondary memory) ­ 저장 밀도가 높고, 비트 당 가격이 낮음 ­ 읽기 / 쓰기 속도가 느림  93   ­ 영구 저장 능력을 가진 저장장치 : 하드 디스크(hard disk, HDD), 플래시 메모리(flash memory), SSD(solid
-state drive), CD
-ROM 등(vs. 클라우드) ▶ 컴퓨터의 기본적인 구성요소들 – 입출력장치 ㆍ 입출력장치(I/O device) ­ 입력장치(input device)와 출력장치(output device)의 통칭 ­ 사용자
- 컴퓨터 간의 상호작용(interaction)을 위한 장치들 ­ CPU는 해당 장치 제어기(device controller)를 통하여 동작 제어(I/O 모듈
-속도/변환, DMA
-버스, IOP
-별도) ­ 주변장치(peripheral device)라고도 부름 2. 정보의 저장   ▶ 정보의 표현과 저장 ­ 컴퓨터 정보: 2진수 비트들로 표현된 프로그램 코드(명령어)와 데이터

1) 프로그램 코드 ㆍ 기계어(machine language) ­ 기계 코드(machine code)라고도 함(저급 언어) ­ 컴퓨터 하드웨어 부품들이 이해할 수 있는 언어로서, 2진 비트들로 구성(속도가 빠르나 이해하기 어려움) ㆍ 어셈블리 언어(assembly language) ­ 고급 언어와 기계어 사이의 중간 언어(속도 중간, 이해 중간) ­ 어셈블러(assembler)로 번역되며, 기계어와 일대일 대응 ㆍ 고급 언어(high
- level language) ­ 영문자와 숫자로 구성되어 사람이 이해하기 쉬운 언어(고급) ­ C, C++, PASCAL, ex)ORTRAN, JAVA 등(이해 쉬우나 속도 느림) ­ 컴파일러(compiler)를 이용하여 기계어로 변역(인터프리터, 하이브리드) ▶ 정보의 표현과 저장 – 기계어 v 기계어(機械語) 는 CPU가 직접 해독하고 실행할 수 있는 비트 단위로 쓰인 컴퓨터 언어 를 통틀어 일컬음 ⋅ 기계어는 프로그램을 나타내는 가장 낮은 단계의 개념임 ⋅ 기계어는 어셈블리어와 1 : 1로 쓰일 수 있음 ⋅ 다시 말해 컴퓨터 프로그래밍에서 기계어는 대부분 어셈블리어를 거쳐 짜여지게 됨 ⋅ 어셈블리어가 아직 만들어지기 전에는 기계어를 직접 입력하여 프로그램을 작성하기도 했으며, 오늘날에도 흔치는 않지만 그렇게 하는 사람이 있음(운영체제) ⋅ 기계어는 CPU의 종류에 따라서 서로 다른 코드를 갖게 됨  94   ▶ 정보의 표현과 저장 – 어셈블리 언어 v 어셈블리어(assembly language) 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급(중간) 언어임 ⋅ 컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지 는 어셈블리어도 각각 다르게 됨 ⋅ 컴퓨터 CPU마다 지원하는 오퍼레이션(덧셈, AND)의 타입과 개수는 제각각이며, 레지 스터의 크기와 개수, 저장된 데이터 형의 표현도 각기 다름 ⋅ 모든 범용 컴퓨터는 기본적으로 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행 할지는 다를 수 있으며, 이런 차이는 어셈블리어에 반영되게 됨 ⋅ 게다가 단일 명령 집합(SISD)에 대해 여러 니모닉(ADD, SUB)과 통사론(구문 분석)이 대응될 수 있으며, 그런 경우에는 제조사가 만든 문서에서 쓰이는 것이 가장 자주 쓰이 게 됨 ▶ 정보의 표현과 저장 – 고급 언어 v 고급 프로그래밍 언어 또는 하이 레벨 프로그래밍 언어(high
-level programming language)란 사람이 이해하기 쉽게 작성된 프로그래밍 언어로서, 저급 프로그래밍 언어 보다 가독성이 높고 다루기 간단하다는 장점이 있음 ⋅ 컴파일러나 인터프리터에 의해 저급 프로그래밍 언어로 번역되어 실행되며, C 언어, 자 바, 베이직 등 대부분의 프로그래밍 언어들은 고급 언어에 속하고, 추상화(구현)의 정도 는 얼마나 프로그래밍 언어가 높은 수준인지를 정의 ⋅ 1960년대에 컴파일러를 이용한 고급 프로그래밍 언어들은 보통 오토코드라 불렀으며, 오토코드의 예는 코볼과 포트란이 있음 ▶ 프로그램 언어의 번역 과정 ­ 예)  ⋅ LOAD  : 기억장치 X번지의 내용을 읽어서, 레지스터 A에 적재(load) ⋅ ADD  : 기억장치 Y번지 내용을 읽어서, 레지스터 A에 적재된 값과 더하고, 결과 를 다시 A에 적재(add) ⋅ STOR  : 그 값(A)을 기억장치 Z번지에 저장(store) 고급 언어 어셈블리 기계어 프로그램 프로그램 프로그램 Z=X+Y LOAD A, X 00100101 ADD A, Y 10000110 STOR Z, A 01000111 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 프로그램 언어 번역 소프트웨어 ㆍ 컴파일러(compiler) ­ 고급언어 프로그램을 기계어 프로그램으로 번역하는 소프트웨어(인터프리터, 하이브리드)  95   ㆍ 어셈블러(assembler) ­ 어셈블리 프로그램을 기계어 프로그램으로 번역하는 소프트웨어 ­ 니모닉스(mnemonics) ⇨ 어셈블리 명령어가 지정하는 연산을 가리키는 알파벳 기호 ⇨ ‘LOAD’, ‘ADD’, ‘STOR’ 등 ▶ 프로그램 언어 번역 소프트웨어 – 컴파일러 v 컴파일러(compiler, 순화 용어 : 해석기, 번역기)는 특정 프로그래밍 언어로 쓰여 있는 문 서를 다른 프로그래밍 언어로 옮기는 프로그램을 말함(인터프리터, 하이브리드) ⋅ 원래의 문서를 소스 코드 혹은 원시 코드라고 부르고, 출력된 문서를 목적 코드라고 부 름 ⋅ 목적 코드는 주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만 사람이 읽을 수 있는 문서 파일이나 그림 파일 등으로 옮기는 경우도 있음 ⋅ 원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 순화 용어 : 옮김, 번역, 문화어 : 콤파일) 이라고 함

1) 컴파일러의 특징 ­ 컴파일러는 소스 프로그램을 읽어서 즉시 결과를 출력하는 인터프리터와는 구분되지만, 현 대에 들어 많은 인터프리터가 JIT(just in time, 실행 시점) 컴파일 등의 기술로 실시간 컴 파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세임 ­ 소스 코드를 컴파일하는 이유는 대부분 사람에게 이해하기 쉬운 형태의 고수준 언어로부터 실행 가능한 기계어 프로그램을 만들기 위해서임 ­ 좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기 계어 등)로 번역하는 프로그램을 가리킴 ▶ 프로그램 언어 번역 소프트웨어 – 어셈블러 v 어셈블러(assembler)는 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램을 말함. 어셈블러는 기본 컴퓨터 명령어들을 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이며, 몇몇 사람들 은 이러한 명령어들을 어셈블러 언어나 어셈블리 언어라고 부름 ⋅ 이것은 어셈블리 명령 부호(니모닉)를 오피코드로 해석할 뿐만 아니라 메모리의 위치들 을 이름으로 표시하는 기능, 매크로를 통한 문장 치환 기능 등을 함께 제공함(오퍼랜 드) ⋅ 높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높 은 수준의 자료형 추상화(구현) 같은 높은 수준의 언어 추상화 기능을 제공함
1) 어셈블러의 특징 ­ MIPS, Sun Sparc, HP/PA
-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함 수 스케줄링 기능(의존성에 따라)을 가지고 있어서 중앙처리장치의 파이프라인(병렬 수행 효과)을 효과적으로 사용할 수 있음  96   ­ 이 어셈블러는 1950년대부터 계속 쓰여 왔으며, 고급 언어를 위한 컴파일러에 견주어 보 면 구조가 매우 간단 ­ 크로스 어셈블러는 다른 프로세서(CPU)를 위한 코드를 만들며, 어셈블러가 실행되는 단계 를 어셈블리 타임이라고 함 ▶ 기계 명령어의 형식 ­ 예) 연산코드 오퍼랜드 001 00101 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 연산 코드(op code) ­ CPU가 수행할 연산을 지정해 주는 비트들(오피코드) ­ 비트 수 = ‘3’ 이라면, 지정될 수 있는 연산의 최대 수 :  = 8개(ADD, SUB) ㆍ 오퍼랜드(operand) ­ 연산에 사용될 데이터 혹은 그것이 저장되어 있는 기억장치 주소(memory address) ­ 비트 수 = ‘5’ 라면, 주소지정(addressing) 할 수 있는 기억 장소의 최대 수 :  = 32 개(0번지 ~ 31번지)(간접) ▶ 프로그램 코드와 데이터의 기억장치 저장 ­ 프로그램 코드(명령어)와 데이터는 지정된 기억 장소에 저장(보조기억장치
-주기억장치) ­ 단어(word) 단위로 저장(32비트 vs. 64비트 컴퓨터) ⋅ 단어 : 각 기억 장소에 저장되는 정보의 기본 단위로서, CPU에 의해 한 번에 처리될 수 있는 비트들의 그룹 ⋅ 단어 길이의 예 : 8비트, 32비트, 64비트, 128비트 ⋅ 주소 지정 단위 : 단어 단위 혹은 바이트(byte) 단위(granularity) 주소 0 00100101 1 10000110 2 01000111 명령어들 3 4 … ⁝ ⁝  00011011  11010111 데이터들  … ⁝ ※ 컴퓨터구조론, 생능출판사, 2019  97   시스템 구성

1. 컴퓨터 시스템 구성 중 CPU와 기억장치의 관계를 이해하고 설명할 수 있다. 4주차  수업목표  
2. 컴퓨터 시스템 구성 중 CPU와 I/O 장치의 관계를 이해하고 2교시  설명할 수 있다.
1. CPU와 기억장치 세부내용 
2. CPU와 I/O 장치 1. CPU와 기억장치   ▶ 버스 v 버스(영어 : bus, 문화어 : 모선)는 컴퓨터 안의 부품들 간에, 또는 컴퓨터 간에 데이터를 전송하는 통신 시스템으로, 이러한 표현에는 관련된 모든 하드웨어 부품들(선, 광 파이버 등) 및 통신 프로토콜을 포함한 소프트웨어를 아우름(주소, 데이터, 제어) ⋅ 초기의 컴퓨터 버스들은 여러 연결들을 갖춘 병렬의 전기적 선들이었으나, 현재 이 용 어는 병렬 전기적 버스와 동일한 논리적 기능을 제공하는 물리적인 배치에 사용됨 ⋅ 현대의 컴퓨터 버스들은 병렬 및 비트 시리얼 연결(직렬)을 둘 다 지원하며, 이들 모두 멀티드롭(전기적 병렬) 또는 데이지 체인 토폴로지로 선을 구성하거나 USB처럼 스위치 허브에 의해 연결할 수도 있음 ▶ CPU와 기억장치의 접속
1) 시스템 버스(system bus) ­ CPU와 시스템 내의 다른 요소들 사이에 정보를 교환하는 통로(주소, 데이터, 제어) ㆍ 기본 구성 ­ 주소 버스(address bus) : 단방향(CPU
-메모리) ­ 데이터 버스(data bus) : 양방향(데이터, 명령어) ­ 제어 버스(control bus) : 양방향(읽기/쓰기, 인터럽트) ▶ 시스템 버스

1) 주소 버스(address bus) ­ CPU가 외부로 발생하는 주소 정보를 전송하는 신호 선들의 집합(메모리, I/O) ­ 주소 선의 수는 CPU와 접속될 수 있는 최대 기억장치 용량을 결정 ⋅ 예) 주소 버스의 비트 수 = 16비트라면, 최대  = 64K 개의 기억 장소들의 주소 지 정 가능 ­ 주소 버스(address bus)는 일정한 메모리 번지를 찾는데 사용되는 신호를 운반하는 컴퓨터 내의 배선 버스인데, 간단히 말해 물리 주소를 지정하는 데 쓰임 ­ 주소 버스의 대역은 시스템이 할당할 수 있는 메모리의 양을 결정하는데, 이를테면 32비트  98   주소 버스를 지닌 시스템은 (4,294,967,296)개의 메모리 위치를 할당할 수 있음 ­ 각 메모리가 하나의 바이트를 보유한다면 할당 가능한 메모리 공간은 4 GiB(4Gx1)가 됨
2) 데이터 버스(data bus) ­ CPU가 기억장치 혹은 I/O 장치와의 사이에 데이터를 전송하기 위한 신호 선들의 집합(명 령어/데이터) ­ 데이터 선의 수는 CPU가 한 번에 전송할 수 있는 비트 수를 결정(워드) ⋅ 예) 데이터 버스 폭 = 32비트라면, CPU와 기억장치 간의 데이터 전송은 한 번에 32 비트씩 가능
3) 제어 버스(control bus) ­ CPU가 시스템 내의 각종 요소들의 동작을 제어하기 위한 신호 선들의 집합 ⋅ 예)
- 기억장치 읽기 / 쓰기(Memory Read / Write) 신호
- I/O 읽기 / 쓰기(I/O Read / Write) 신호
- 인터럽트(Interrupt) 신호(request/acknowledge)
- 버스 제어(Bus Control) 신호(request/grant), 클럭, 리셋 ▶ CPU와 시스템 버스 간의 접속 ㆍ 주소 버스(단방향성(unidirectional)) ­ 주소는 CPU로부터 기억장치 혹은 I/O 장치들로 보내지는 정보 ㆍ 데이터 버스, 제어 버스(양방향성(bidirectional)) ­ 읽기와 쓰기 동작을 모두 지원 주소 버스 데이터 버스 제어 버스 주소 버스 중앙처리장치 데이터 버스 (CPU) 제어 버스 시스템 버스 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ CPU와 기억장치 간의 접속

1) 필요한 버스 및 제어신호(제어
-주소
-데이터) ­ 주소 버스 / 데이터 버스(300번지, add 250 명령어) ­ 제어 신호 : 기억장치 읽기(memory read) 신호, 기억장치 쓰기(memory write) 신호(제어 버스) 주소 버스 데이터 버스 CPU 쓰기 신호 기억장치 읽기 신호 ※ 컴퓨터구조론, 생능출판사, 2019  99   ㆍ 기억장치 쓰기 동작 ­ CPU가 데이터를 저장할 기억 장소의 주소와 저장할 데이터를 각각 주소 버스와 데이터 버스를 통하여 보내는 동시에, 쓰기 신호(제어 버스)를 활성화(300번지, 1000) ㆍ 기억장치 쓰기 시간(memory write time) ­ CPU가 주소와 데이터를 보낸 순간부터 저장(쓰기)이 완료될 때까지의 시간 ㆍ 기억장치 읽기 동작 ­ CPU가 기억장치 주소를 주소 버스를 통하여 보내는 동시에, 읽기 신호(제어 버스)를 활 성화 ­ 일정 지연 시간이 경과한 후에 기억장치로부터 읽혀진 데이터가 데이터 버스 상에 실리 고, CPU는 그 데이터를 버스 인터페이스 회로를 통하여 읽음(300번지, add 250) ㆍ 기억장치 읽기 시간(memory read time) ­ 주소를 발생한 시간부터 기억장치의 데이터가 CPU에 도착할 때까지(읽는)의 시간 ▶ 기억장치 엑세스(읽기/쓰기) 동작의 시간 흐름도 ㆍ 기억장치 쓰기 동작의 시간 흐름도 주소 버스 주소 데이터 버스 데이터 쓰기 신호(제어) ㆍ 기억장치 읽기 동작의 시간 흐름도 주소 버스 주소 데이터 버스 데이터 읽기 신호(제어) ※ 컴퓨터구조론, 생능출판사, 2019 2. CPU와 I/O 장치   ▶ CPU와 I/O 장치의 접속

1) 필요한 버스 및 제어신호 ­ 주소 버스 / 데이터 버스 ­ 제어 신호 : I/O 읽기 신호, I/O 쓰기 신호(제어 버스)
2) 접속 경로 ­ CPU ↔ 시스템 버스 ↔ I/O 장치 제어기(I/O 모듈) ↔ I/O 장치(속도, 변환)  100   ▶ I/O 장치 접속 사례 : CPU – 키보드&프린터 주소 버스 데이터 버스 I/O 쓰기 신호 I/O 읽기 신호 키보드 프린터 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ I/O 장치 제어기(I/O device controller) 또는 입출력 모듈
1) I/O 장치 제어기(I/O 모듈)의 기능 ­ CPU로부터 I/O 명령을 받아서, 해당 I/O 장치를 제어하고, 데이터를 이동함으로써 명령을 수행하는 전자회로 장치 ⋅ 예) 키보드 제어기, 프린터 제어기 등 ㆍ 상태 레지스터 ­ I/O 장치의 현재 상태를 나타내는 비트들을 저장한 레지스터 ­ 준비 상태(RDY, BUSY) 비트, 데이터 전송 확인(ACK) 비트 등 ㆍ 데이터 레지스터 ­ CPU와 I/O 장치 간에 이동되는 데이터를 일시적으로 저장하는 레지스터(버퍼, 속도 완 충) ▶ 입출력 모듈의 기능 v 입출력장치는 중앙처리장치와 컴퓨터의 사용자 사이에 자료와 정보를 교환하는 장치로 컴 퓨터 외부에 존재하므로 주변장치(peripheral device)라고 함 ⋅ 주변장치 종류가 매우 다양하므로 전송 데이터 길이, 전송 속도, 데이터의 형식 등이 서로 다르며, 이들을 제어할 수 있는 장치가 필요한데, 입출력 모듈이 수행함 ⋅ 주변장치들(I/O)은 중앙처리장치와 주기억장치(RAM)에 비하여 속도가 매우 느리기 때 문에 중앙처리장치와 주기억장치와의 직접적인 통신이 불가능함 ⋅ 이 경우에도 입출력 모듈이 중간에서 제어를 통해서 통신이 가능하게 함(속도, 변환) ⋅ 입출력 인터페이스, 입출력 제어기(controller), 장치 제어기(device controller) 등의 여러 가지 이름으로 불림(IOP
- 입출력 채널(channel), 입출력 프로세서) ㆍ 기능 ­ 입출력장치의 제어(control)와 타이밍(timing) 조정 ­ 중앙처리장치(프로세서)와의 통신  101   ­ 입출력장치들과의 통신 ­ 데이터 버퍼링(data buffering) 기능을 수행 ­ 오류 검출(error detection) ▶ 입출력장치의 제어와 타이밍 조정 ­ 내부 장치들과 외부 장치들 사이의 데이터 흐름을 조정하기 위한 기능(CPU
-고속
-입출력 모 듈
-저속
-I/O) v 외부 장치에서 중앙처리장치(CPU)로 데이터가 전송되는 것을 제어하는 순서 ⋅ 1단계 : 중앙처리장치가 입출력 모듈에게 입출력장치의 상태를 검사하도록 요청 ⋅ 2단계 : 입출력 모듈이 상태를 보고함 ⋅ 3단계 : 만약 입출력장치가 준비 상태(ready)라면, 중앙처리장치가 데이터 전송을 요청 ⋅ 4단계 : 입출력 모듈이 입출력장치로부터 데이터를 수신 ⋅ 5단계 : 입출력 모듈이 중앙처리장치로 데이터를 보냄 ⇨ 앞의 5단계 과정에서 입출력 모듈은 입출력장치에 대하여 제어 기능을 수행하고 적절한 시기에 데이터를 전송할 수 있도록 타이밍 조정기능을 수행함(제어와 타이밍 조정) ▶ 중앙처리장치와의 통신 ­ 중앙처리장치(CPU)와 외부 장치 간의 통신을 수행하기 위한 입출력 모듈의 기능 ㆍ 명령 해석(Command Decoding) ­ 입출력 모듈은 CPU에서 받은 명령을 해석하고, 제어 버스를 통해서 I/O에게 제어 신호 로 명령을 보냄 ­ CPU에서 하드디스크나 CD
-ROM으로 전달되는 명령은 데이터의 저장이나 인출을 위한 것으로 READ SECTOR, WRITE SECTOR, SEEK track number, SCAN record ID와 같은 명령들임 ㆍ 데이터(Data) 교환 ­ CPU 입출력 모듈의 가장 근본적인 기능으로 데이터 교환은 데이터 버스를 통하여 이루 어짐 ­ 중앙처리장치와 외부 장치(I/O) 간의 통신을 수행하기 위한 입출력 모듈의 기능 ㆍ 상태 보고(Status Reporting) ­ 주변장치들이 저속으로 동작하기 때문에 입출력 모듈의 상태를 확인하는 것은 중요함 ­ 입출력 모듈은 상태를 확인하여 BUSY, READY, 결함상태 등의 상태 보고를 수행함 ㆍ 주소 인식(Address Recognition) ­ 여러 종류의 입출력장치들을 구별하기 위해서는 주소가 필요함(각 I/O는 주소를 가짐) ­ 따라서 입출력 모듈은 제어하는 여러 주변장치의 주소를 인식하고 있어야 함 ▶ 입출력장치들과의 통신 ­ 입출력 모듈은 또한 입출력장치 간 통신이 가능해야 함 ⋅ 입출력장치 간 통신에서도 명령들과 상태 정보 및 데이터가 포함  102   ▶ 데이터 버퍼링과 오류검출

1) 데이터 버퍼링(Data Buffering) ­ 컴퓨터 내부에서 입출력 모듈로 전달되는 데이터의 전송 속도는 고속이고, 이렇게 전달된 데이터는 입출력 모듈 내의 버퍼에 일시적으로 저장되었다가 적절한 전송 속도(저속)로 주 변 장치로 보내지는 버퍼링 기능을 수행함 ­ 입출력장치에서 컴퓨터 내부로 전달되는 저속의 데이터는 주기억장치 또는 중앙처리장치의 동작에 영향을 주지 않도록 입출력 모듈의 버퍼에 고속의 데이터 전송률이 될 수 있도록 저장되었다가 전송됨 ­ 입출력 모듈은 저속의 전송률과 고속의 전송률에 모두 동작 할 수 있어야 함
2) 오류 검출 ­ 입출력장치들의 오류를 검사하고 오류가 발생하면 중앙처리장치(CPU)로 보고 할 수 있어야 함 ­ 입출력장치에서 발생하는 오류는 기계 및 전기적 오류와 데이터 전송 중에 발생되는 비트 오류 등이 있음 ­ 기계 및 전기적 오류에는 프린터의 종이 걸림, 하드디스크의 불량 디스크 트랙 등이 대표적 이고, 전송 오류를 검출하는데 사용되는 오류
-검출 코드는 일반적으로 패리티 비트를 사용 함(짝수/홀수, 정정x) ▶ 입출력 모듈의 조직 시스템 버스 외부장치 인터페이스 인터페이스 데이터 데이터 선 상태신호 데이터 선 제어신호 주소 선 데이터 상태신호 제어 선 제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍, 한빛아카데미 ­ 데이터 레지스터 : 버퍼링 기능을 위해서 일시적으로 저장됨 ­ 상태 / 제어 레지스터 : 현재의 상태와 오류를 저장하기 위한 레지스터로, 중앙처리장치에 서 보낸 제어 정보를 저장하기 위한 제어 레지스터로도 동작함 ­ 제어 line들 : 중앙처리장치(CPU)가 입출력 모듈로 명령을 보내는데 사용 ­ 주소 line들 : 중앙처리장치(CPU)가 주소선을 통해서 입력한 여러 입출력 모듈의 주소들 중에서 자신만의 주소를 인식, 연결된 입출력장치들의 주소도 알 수 있어야 함 ­ 연결된 입출력장치를 제어하기 위한 데이터, 상태 신호, 제어 신호를 가지고 있음(외부장치 인터페이스) ⇨ 입출력 모듈은 연결된 입출력장치를 제어하는데 필요한 세부적인 사항들을 모두 처리해주 기 때문에 중앙처리장치의 부담을 덜어줌(IOP로 발전)  103   ▶ 키보드의 데이터 입력 과정

1) 키보드 제어기 ­ 키보드의 어떤 한 키(key)를 누르면, 그 키에 대응되는 ASCII 코드가 키보드 제어기의 데이 터 레지스터에 저장되고, 동시에 상태 레지스터의 In_RDY 비트가 1로 세트
2) CPU
① 키보드 제어기로부터 상태 레지스터의 내용을 읽어서 In_RDY 비트가 세트 되었는지 검사 (In_RDY 비트 : 데이터 레지스터에 외부로부터 데이터가 적재되었는지를 표시)
② 만약 세트 되지 않았으면, 1번을 반복하며 대기(polling)만약 세트 되었다면, 데이터 레지 스터의 내용을 읽음 아니오 예 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 프린터의 데이터 출력 과정

1) CPU
① 프린터 제어기의 상태 레지스터의 내용을 읽어서 Out_RDY 비트 검사(Out_RDY 비트 : 프린터가 출력할 준비가 되었는지를 표시)
② 만약 세트 되지 않았으면, 1번을 반복하며 대기(polling)만약 세트 되었다면, 프린트할 데 이터를 프린터 제어기의 데이터 레지스터에 저장(데이터 블록 전체를 제어기 내의 데이터 기억장치에 저장하는 것도 가능 : spooling)

2) 프린터 제어기
① 데이터 레지스터(혹은 데이터 기억장치)의 내용을 프린터로 보냄(보조기억장치
-스풀링)
② 프린터의 하드웨어를 제어하면서 인쇄 동작 수행 ▶ CPU와 보조저장장치의 접속 ­ 보조저장장치들(디스크, 플래시 메모리, SSD, CD
-ROM, DVD 등)도 각 장치를 위한 제어 기를 통하여 키보드나 프린터와 유사한 방법으로 접속 ­ 차이점 : 데이터 전송 단위 ⋅ 키보드 : 바이트 단위 전송(character device) ⋅ 보조저장장치 : 블록(512 / 1024 / 4096 바이트) 단위로 전송(block device) ⇨ 제어기 내에 한 블록 이상을 임시 저장할 수 있는 데이터 기억장치(버퍼) 필요  104   ▶ 컴퓨터 시스템의 전체 구성 주소 버스 데이터 버스 제어 버스 디스크 SSD ※ 컴퓨터구조론, 생능출판사, 2019 시스템 버스 ▶ 컴퓨터의 기본적인 기능들 ㆍ 프로그램 실행 ­ CPU가 주기억장치로부터 프로그램 코드를 읽어서 실행 ㆍ 데이터 저장 ­ 프로그램 실행 결과로서 얻어진 데이터를 주기억장치에 저장 ㆍ 데이터 이동 ­ 디스크 혹은 CD
-ROM에 저장되어 있는 프로그램과 데이터 블록을 기억장치로 이동 ㆍ 데이터 입력/출력 ­ 사용자가 키보드를 통하여 보내는 명령이나 데이터를 읽어 들이고(입력), CPU가 처리한 결과값이나 기억장치의 내용을 프린터(혹은 모니터)로 출력 ㆍ 제어 ­ 프로그램이 순서대로 실행되도록 또는 필요에 따라 실행 순서를 변경하도록 조정하며, 각종 제어 신호들을 발생(CPU
-제어장치
-핵심요소)  105   컴퓨터 구조

1. 초기 컴퓨터들과 이들이 사용한 주요 부품에 대해서 학습하고 4주차  수업목표   이를 설명할 수 있다.
2. 컴퓨터의 발전 동향을 학습하고 이를 설명할 수 있다. 3교시 
1. 초기 컴퓨터들 세부내용 
2. 주요 부품
3. 발전 동향 1. 초기 컴퓨터들   ▶ 주요 부품들의 발전 과정 ­ 릴레이(relay) → 진공관 → 트랜지스터 → 반도체 집적회로(IC) ㆍ 발전 과정에서 개선된 특성들 ­ 처리속도 향상 ­ 저장용량 증가 ­ 크기 감소 : PC의 탄생, 누구나 사용 가능하게 됨 ­ 가격 하락 ­ 신뢰도 향상 ⇨ 초기 컴퓨터들의 근본적인 설계 개념과 동작 원리가 현대의 컴퓨터들과 거의 같음 ▶ 최초의 컴퓨터 ㆍ 1642년 : Blaise Pascal(블레즈 파스칼, 프랑스) ­ 덧셈과 뺄셈을 수행하는 기계적 카운터 ­ 다이얼의 위치에 의하여 십진수를 표시하는 6개의 원형판 세트들로 구성 ­ 각 원형판은 일시적으로 숫자를 기억하는 레지스터로 사용(레지스터의 개념) ※ https://ko.wikipedia.org/wiki/파스칼_계산기 ▶ Leibniz의 기계 ㆍ 1671년 : Gottfried Leibniz(고트프리트 라이프니츠,독일) ­ 덧셈과 뺄셈 및 곱셈과 나눗셈도 할 수 있는 계산기 ­ Pascal의 계산기에 두 개의 원형판들을 추가하여 반복적 방법으로 곱셈과 나눗셈을 수행 ­ 이후 많은 계산 기계들의 조상이 됨(시초의 개념)  106   ※ https://ko.wikipedia.org/wiki/고트프리트_빌헬름_라이프니츠 ▶ Difference Engine(차분 엔진) ㆍ 19세기 초 : Charles Babbage(찰스 배비지, 영국, 현대 컴퓨터의 할아버지) ­ 표에 있는 수들을 자동적으로 계산하고(연산), 그 결과를 금속천공기를 거쳐서 프린트(출 력) ­ 덧셈과 뺄셈만 수행 가능(연산, 출력의 개념) ※ https://ko.wikipedia.org/wiki/차분기관 ▶ Analytical Engine(분석 엔진) ㆍ 19세기 초 : Charles Babbage(영국) ㆍ 주요 특징들 ­ 어떤 수학 연산도 자동적으로 수행할 수 있는 일반 목적용 계산 기계(컴퓨터의 외부구 조) ­ 프로그래밍 가능 : 프로그램 언어 사용 ­ 프로그램의 실행 순서 변경 가능 ⋅ 수의 부호 검사를 이용한 조건 분기 ⋅ 제어 카드를 이용한 실행 순서 변경 ㆍ 문제점 ­ 주요 부품들이 기계적 장치라 속도가 느리고 신뢰도가 낮았음 ▶ Analytical Engine의 기본 구조 ­ 산술연산장치 : MILL(현재 : CPU) ­ 기억장치 : STORE(현재 : 주기억, 보조기억) ­ 입력장치 : 카드 판독기(현재 : 키보드, 마우스) ­ 출력장치 : 카드 천공기, 프린터(현재 : 모니터, 프린터)  107   연산 명령 주소 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ ENIAC ㆍ 1940년대 초 : von Neumann(폰 노이만)이 개발 ­ Electronic Numerical Integrator And Computer ­ 펜실바니아 대학에서 개발한 진공관을 사용한 최초의 전자식 컴퓨터(ABC
-최초전자 vs. 마크1
-최초기계) ­ 문제점 : 프로그램의 저장 및 변경 불가능 ­ 폰 노이만의 설계 개념(stored
- program 원리) 발표 ⋅ 프로그램과 데이터를 내부에 저장(프로그램 내장 방식) ⋅ 2진수 체계(binary number system) 사용 ⋅ 1945년 발표 후, EDVAC(Electronic Discrete Variable Computer) 개발에 실제 적 용(컴퓨터의 내부구조) ▶ IAS 컴퓨터 ㆍ 1946년~1952년 : 폰 노이만이 IAS에서 개발 ⋅ 폰 노이만 : 프린스턴 대학 및 IAS(Institute for Advanced Studies)의 수학 교수 ­ 프로그램 저장과 변경이 가능한 최초의 디지털 컴퓨터 ㆍ 주요 구성요소 ­ 프로그램 제어 유니트(Program Control Unit) : 명령어 인출 / 해독 ­ 산술논리연산장치(ALU) ­ 주기억장치 : 명령어와 데이터를 모두 저장 ­ 입출력장치(I/O) ▶ IAS 컴퓨터의 구조

1) 폰 노이만 아키텍처(von Neumann Architecture) ­ 프로그램 코드들을 기억장치에 저장된 순서대로 실행하며, 그 주소는 CPU의 내부 레지스터 인 프로그램 카운터(program counter)에 의해 저장됨  108   ▶ IAS 컴퓨터의 구조(PC, MBR, IR, AC) 산술논리연산장치 프로그램 제어 유니트 ※ 컴퓨터구조론, 생능출판사, 2019 2. 주요 부품   ▶ 주요 컴퓨터 부품들의 발전 경위
1) 트랜지스터(transistor) ­ 초기(제1세대) 전자식 컴퓨터의 핵심 부품인 진공관을 대체한 전자 부품 ­ 진공관보다 작고 싸며 더 적은 열을 발산 ­ 반도체 재료인 실리콘(Si)으로 만들어진 고체(solid
-state) 장치(원자번호 14, 규소) ­ 제2세대 컴퓨터들의 핵심 부품 ­ 초기 컴퓨터들은 약 1000개의 트랜지스터들로 구성

2) 직접 회로(Integrated Circuit : IC) ­ 수만 개 이상의 트랜지스터들을 하나의 반도체 칩에 집적시킨 전자 부품(컴퓨터 역사에 끼 친 영향) ­ 제3세대 컴퓨터들의 핵심 부품 ▶ IC의 제조 과정(웨이퍼–IC 제작을 위한 반도체 소재의 얇은 조각) 실리콘 웨이퍼 IC 칩 패키지된 칩 게이트/기억소자 ※ 컴퓨터구조론, 생능출판사, 2019  109   ▶ 집적도에 따른 IC의 분류 ㆍ SSI(Small Scale IC) ­ 수십 개의 트랜지스터들이 집적되는 소규모 IC ­ 최근에는 주로 기본적인 디지털 게이트(digital gate)들을 포함하는 칩으로만 사용됨 (AND, OR, NOT) ㆍ MSI(Medium Scale IC) ­ 수백 개의 트랜지스터들이 집적되는 IC ­ 카운터(counter), 해독기(decoder) 또는 시프트 레지스터(shift register)와 같은 조합 회로나 순차 회로를 포함하는 칩(기억 소자 포함 여부) ㆍ LSI(Large Scale IC) ­ 수천 개의 트랜지스터들이 집적되는 대규모 IC ­ 8
-비트 마이크로프로세서 칩이나 소규모 반도체 기억장치 칩 ㆍ VLSI(Very Large Scale IC) ­ 수만 내지 수십만 개 이상의 트랜지스터들이 집적되는 초대규모 IC ­ 제4세대 컴퓨터들의 부품 ­ 마이크로프로세서 칩들(CPU)과 대용량 반도체 기억장치 칩 ㆍ ULSI(Ultra Large Scale IC) ­ 수백만 개 이상의 트랜지스터들이 집적되는 32
-비트급 이상 마이크로프로세서 칩들과 수백 메가비트 이상의 반도체 기억장치 칩들 및 앞으로 출현할 고밀도 반도체 칩들을 지 칭하기 위한 용어로서, VVLSI(VeryVery Large Scale IC)라고도 불림 ▶ IC 사용에 따른 이점 ­ 전기적 통로가 짧아짐 → 동작 속도가 크게 상승 ­ 컴퓨터 크기의 감소 : 더 작은 고성능 PC의 개발이 가능 ­ 칩 내부의 회로들 간의 상호연결 → 부품들의 신뢰도 향상 ­ 전력소모 감소 및 냉각장치 소형화 ­ 컴퓨터 가격 하락 * VLSI의 출현으로 개인용 컴퓨터(PC)가 개발됨 3. 발전 동향   ▶ 개인용 컴퓨터(PC)

1) 특징 ­ 소형이며, 가격은 저가 ­ 성능 : 수십 년 전의 대형 메인프레임 컴퓨터의 성능을 능가
2) 주요 발전 동향 ­ 성능이 개선된 새로운 마이크로프로세서들(CPU)의 등장에 따라 PC의 성능은 계속 향상 (스마트폰)  110   ­ 8
-비트, 16
-비트, 32
-비트 CPU 사용으로 단어 길이 증가. 64
-비트 단위의 데이터 처리 및 기억장치 주소 사용 PC들도 출시 중(128
-비트) ­ 칩의 집적도가 높아지면서 주변 요소들이 CPU 칩 내부에 포함됨에 따라, 속도와 신뢰도가 크게 향상 ­ 프로세서가 다수의 명령어 실행 유니트들 혹은 CPU 코어들을 포함하는 슈퍼스칼라(파이프 라인), 듀얼
-코어 및 멀티
-코어 구조로 발전(스마트폰) ­ GPU(Graphic Processing Unit)2를 계산보조장치로 사용함으로써 고속 그래픽 처리뿐 아 니라 복잡한 과학 계산들도 높은 속도로 처리할 수 있게 됨(비트코인
-채굴) ­ 주기억장치와 보조저장장치의 용량 증가, 종류 다양화

3) 종류(유형) ­ 데스크탑(desktop) 컴퓨터, 노트북(notebook) 컴퓨터, 넷북(netbook), 태블릿(tablet) PC, 포켓(pocket) PC 등 ▶ 임베디드 컴퓨터 * Embedded Computer(내장 컴퓨터라고도 부름) ­ 기계 장치나 전자 장치들의 내부에 포함되어, 그 장치들의 동작을 제어(control)하는 컴퓨 터들(냉장고) ⋅ 예) 가전제품, 컴퓨터 주변기기, 모바일폰, 비디오 게임기 등 ­ 8
-비트 마이크로컨트롤러(micro
-controller)를 이용한 초소형부터 32
-비트 컴퓨터에 이르기 까지 다양 ­ 최소의 비용으로 필요한 만큼의 성능 제공 ­ 실시간 처리(real
-time processing)(반응 시간이 고정) ­ IOT(Internet of Things) 및 지능형 로봇의 핵심 요소로 사용되어 더욱 다양해지고 보급도 확대될 전망(IoE, AI) ▶ 서버급 컴퓨터시스템 ㆍ 워크스테이션(work station) ­ CPU : 64
-비트 마이크로프로세서 사용(중형) ­ 고속 그래픽 처리 하드웨어 포함(GPU) ­ 주요 응용 : 3차원 동영상 처리, 시뮬레이션, 컴퓨터 이용 설계(CAD) 등(특수목적) ­ OS : UNIX(Multics), LINUX(Unix) ㆍ 슈퍼 미니 컴퓨터(Super
- mini computer) ­ 시스템 구조 : 다중프로세서(multiprocessor) 구조 ­ CPU의 수 : 20 ~ 30개 ­ 성능 : VAX
-11 미니 컴퓨터 성능의 수십 배 이상(DEC, 70’) ­ OS : UNIX ­ 서버(server)급 시스템의 다운사이징(downsizing)화 주도 ⋅ 네트워크에 접속된 다수의 중형급 컴퓨터 시스템들을 응용(혹은 용도)별로 구분하여  111   사용하는 컴퓨팅 환경이 가능해지게 함 ▶ 다중프로세서 시스템의 구조(멀티 코어 – 데이터 불일치) 시스템 버스 I/O 버스 디스크 SSD 컴퓨터 프린터 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 메인프레임 컴퓨터(mainframe computer) * 중앙집중식 컴퓨팅을 위한 대형 컴퓨터 ­ IBM 360 및 370 계열, 3081, 3090 등으로 계속 발전하였으며, 최근 시스템 보안 및 통 신 기능이 대폭 보강된 IBM zEnterprise 계열 출현 ­ 대용량 저장장치 보유 ­ 다중 I/O 채널을 이용한 고속 I/O 처리 능력 보유 ­ 대규모 데이터베이스를 저장 및 관리용으로 사용 ­ 정부기관, 은행, 대형 인터넷포탈사이트 등에서 대규모 데이터베이스(빅데이터) 저장 및 관 리용으로 사용 ▶ 슈퍼 컴퓨터(super computer) ­ 현존하는 컴퓨터들 중에서 처리 속도와 기억장치 용량이 다른 컴퓨터들에 비하여 상대적으 로 월등한 컴퓨터 시스템들(매년 6월, 11월
-500) ­ 분류 기준 : 계속적으로 상승(Mega ­ , Peta ­ ) ⋅ 최초의 슈퍼컴퓨터인 CRAY
-1의 속도는 100 Mex)LOPS ⋅ 최근의 슈퍼컴퓨터들의 속도는 Pex)LOPS급(수백만 배 향상) ㆍ 주요 응용 분야들 ­ VLSI 회로 설계, 항공우주공학, 천문학(일기 예보), 구조 공학, 유전 탐사, 핵공학, 인공 지능, 입체 영상처리 등과 같은 대규모 과학 계산 및 시뮬레이션 ▶ 구조적 특징에 따른 슈퍼컴퓨터의 분류

1) 파이프라인 슈퍼컴퓨터(pipeline supercomputer) ­ 초기의 슈퍼컴퓨터 구조 ­ 복잡한 초고속 연산 회로들이 포함된, 적은 수의 CPU들로 구성(병렬 처리 개념)  112   ㆍ 연산장치 ­ 슈퍼파이프라인 구조를 이용하여 고속 벡터 계산 수행 ㆍ 대표적인 시스템들 ­ CRAY Y
-MP, CRAY
-2, ex)ujitsu VP2000, VPP500 등

2) 대규모 병렬 컴퓨터(massively parallel computer : MPP) ­ 상호 연결된 수백 혹은 수천 개 이상의 범용 프로세서들로 구성 ­ 프로세서들이 하나의 큰 작업을 분담하여 동시에 처리하는 병렬처리(parallel processing) 기술 이용 ­ 시스템 사례 : IBM BlueGene / Q 슈퍼컴퓨터 ⋅ 2018년 11월 국제공인 슈퍼컴퓨터 TOP500 리스트(www.top500.org) 최상위 랭크 ⋅ 1,572,864개의 64
-비트 PowerPC 프로세서들 탑재 ⋅ 속도 : 20 Pex)LOPS, 기억장치 : 1.57 PByte ⋅ 96 캐비닛 x 512 노드 x 32 프로세서 ▶ IBM BlueGene/Q 슈퍼컴퓨터(96 캐비넷
-512 노드
-32 프로세서) 전체 시스템 (96 캐비닛) 랙(rack) (32 노드 보드) 노드 보드 (32 컴퓨터 카드) 컴퓨터 카드 프로세서 칩 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ IBM Summit 슈퍼컴퓨터 ­ 2018년 11월 TOP500 List 세계 1위 ⋅ 컴퓨트 노드 : 24
-코어 POWER9 CPU 및 NVIDIA Volta GPU들로 구성 → 노드당 40 Tex)LOPS 성능(Tera ­ ) ⋅ 전체 3400 노드 → 코어 수 = 240만 개 ⋅ 최고 속도 : 200 Pex)LOPS ⋅ 초고속 연결망인 NVLink를 이용하여 CPU
- GPU 결합 ⋅ 혼합형 계산(heterogeneous computing) 방식 이용(한종류 이상의 코어를 사용) ▶ 클러스터 컴퓨터(cluster computer) ­ 고속 LAN이나 네트워크스위치에 의해 서로 연결된 PC들 혹은 워크스테이션들의 집합체(동 일기종, 별도 프로토콜x)  113   ­ 클러스터 미들웨어(Cluster middleware)를 이용하여 노드(단위 컴퓨터)들에 포함된 모든 자원들을 단일 시스템 이미지(Single System Image: SSI)로 통합 ­ 저렴한 가격으로 고성능, 고신뢰 병렬컴퓨팅 환경 구축 가능(분산 컴퓨팅 ­ 그리드 컴퓨팅 (이기종, 별도 프로토콜)) ­ 대형 웹서버 및 슈퍼컴퓨터 설계 개념으로 널리 사용 중(슈퍼컴퓨터에 비해 저비용)  114   CPU의 기본 구조

1. CPU가 가지는 기본 기능에 대해서 학습하고 이를 설명할 수 있다. 5주차  수업목표  
2. CPU가 가지는 기본 구조에 대해서 학습하고 이를 설명할 수 1교시  있다.
1. CPU 기능 세부내용 
2. CPU 구조 1. CPU 기능   ▶ CPU의 기능 ㆍ 명령어 인출(Instruction ex)etch) ­ 기억장치로부터 명령어를 읽어 옴(300번지, add 250) ㆍ 명령어 해독(Instruction Decode) ­ 수행해야 할 동작을 결정하기 위하여 명령어를 해독함 ⇨ 모든 명령어들에 대하여 공통적으로 수행(add 250) ㆍ 데이터 인출(Data ex)etch) ­ 명령어 실행을 위하여 데이터가 필요한 경우에는 기억장치 혹은 I/O 장치로부터 그 데이 터를 읽어 옴(250) ㆍ 데이터 처리(Data Process) ­ 데이터에 대한 산술적 혹은 논리적 연산을 수행(add) ㆍ 데이터 저장(Data Store) ­ 수행한 결과를 저장(AC, Memory) ⇨ 명령어에 따라 필요한 경우에만 수행 ▶ CPU의 명령어
1) 명령어 사이클(Instruction cycle) ­ CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정으로서, CPU가 프로그램 실 행을 시작한 순간부터 전원을 끄거나 회복 불가능한 오류가 발생하여 중단될 때까지 반복 ㆍ 두 개의 부사이클(subcycle)들로 분리 ­ 인출 사이클(fetch cycle) : CPU가 기억장치로부터 명령어를 읽어오는 단계(300번지) ­ 실행 사이클(execution cycle) : 명령어를 실행하는 단계(add 250) ▶ 명령어 사이클 v 명령 주기(instruction cycle, machine cycle)는 마이크로 프로세서(CPU)가 메모리로부터 프로그램 된 한 개의 기계어 명령어를 가져와 어떠한 동작을 요구하는지를 결정하고 명령 어가 요구하는 동작들을 수행하는 과정(300번지,add 250) ⋅ 컴퓨터의 기본적인 동작 순환(사이클) 임  115   ⋅ 한 개의 기계어 명령어가 완료되면 다음 메모리의 기계어가 수행되므로 중앙 처리 장치 (CPU)는 시동에서부터 컴퓨터가 꺼질 때까지 이러한 순환(사이클)을 계속 되풀이함 ⋅ 따라서 이를 CPU 사이클 이라고도 부름 ⋅ CPU의 동작을 하는 한 명령 주기(사이클)는 계속 반복되어 전력을 소비함 ⋅ 전력소모를 줄이거나 기타 CPU를 멈출 필요가 있다면, 아이들모드(idle mode) 또는 슬립모드(sleep mode) 기계어 명령을 실행하면 CPU는 인터럽트가 들어올 때까지 멈 추어 명령 주기를 멈추게 할 수 있음
1) 기계어 명령어 ­ 기계어 명령어 하나를 실행하기 위해 최대 4개의 단계가 필요하며, 각 단계는 CPU의 클럭 신호에 동기되어 동작함(rising edge, falling edge) ­ 각 단계는 각각 몇개의 클럭 펄스가 필요하며, 각 마이크로프로세서마다 다름(마이크로 오 퍼레이션) ­ 하나의 명령어를 실행하기 위해 단계적으로 나뉜 과정이 한 사이클이 됨 ­ 각 단계는 마이크로코드의 프로그램(ex)W)과 제어 회로인 마이크로시퀀서(microsequencer) 에 의해 실행됨(순서) ­ RISC는 각 단계가 단순화 되어 있지만, 블럭 전송 명령어(메모리 블럭 전송)이 존재하는 CPU가 있으므로 마지막 사이클에서 다량의 데이터 전송이 되는 경우도 있음(단순 IS) ­ 이런 경우 많은 클럭이 필요함 ­ CISC에는 없는 기능임(복잡 IS)
2) 프리페치(pre ­ fetch) ­ 초기의 마이크로프로세서(4004,8080,Z80, 6800,…)는 한개의 기계어 명령어의 명령 주기 가 완료될 때까지 다음 명령을 읽지 않았음 ­ 그러나 발전과정에서 속도를 높이기 위해 한개의 명령어가 완료되기 전에 다음 명령어를 읽는 프리페치(pre
-fetch)를 하고 연속적으로 요구 동작을 하도록 동작함(지역성 ­ 순차적 실행) ­ 보통 메모리의 기계어 코드가 끝나면 다음 번지의 메모리 기계어 명령어가 실행되므로 PC 레지스터(Program Counter,또는 IP 레지스터라고도 함)를 사용하여 다음 명령어를 미리 읽음(지역성) ­ 그러나 조건 점프 명령(인텔 x86의 JEQ, ARM의 BEQ 명령어, if equal, jump or branch)은 다음 주소로 점프하지 않을 수도 있으므로 다시 페치해야 함(지역성 깨짐) ­ 인텔의 80486, ARM 등의 CPU에서 프리페치를 사용함  116   ▶ CPU의 명령어(사이클 – 인출 & 실행, 300번지, add 250) 인출 사이클 실행 사이클 ※ 컴퓨터구조론, 생능출판사, 2019 2. CPU의 구조   ▶ CPU의 내부 구성요소 ­ 산술논리장치(Arithmetic and Logical Unit : ALU) : 연산 ­ 레지스터 세트(Register Set) : 임시 저장 ­ 제어 유니트(Control Unit) : 제어 신호 주소 데이터 제어 버스 버스 버스 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ CPU의 내부 구성요소 – ALU ㆍ ALU(Arithmetic and Logical Unit : ALU) ­ 각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈(웹 서핑, 게임, 워드 ­ 결국 연산을 통해 수행됨) ­ 산술 연산 : +,
-, ×, ÷ ­ 논리 연산 : AND, OR, NOT, XOR 등 v 산술 논리 장치(arithmetic logic unit)는 두 숫자의(덧셈, 뺄셈같은) 산술연산과(배타적  117   논리합, 논리곱, 논리합같은) 논리연산을 계산하는 디지털 회로임 ⋅ 산술논리장치는 컴퓨터 중앙처리장치의 기본 설계 블록 임(컴퓨터의 모든 수행은 연산 을 기반) ⋅ 많은 종류의 전자 회로는 어떤 형태의 산술연산을 계산하는 데 필요한데, 심지어 디지 털 시계에 있는 작은 회로조차도 현재 시간에 1을 더하고, 언제 알람을 울려야 하는지 를 검사하는 작은 산술논리장치를 지녔음

1) 산술 논리 장치의 사용 ­ 명백히, 가장 복잡한 전자 회로는 펜티엄 같은 현대의 마이크로프로세서 칩 내부의 설계일 것임 ­ 그러므로 이런 프로세서는 내부에 강력하고 매우 복잡한 산술논리장치를 가지고 있음 ­ 사실, 현대의 마이크로프로세서(혹은 메인프레임)은 멀티코어, 다중의 실행 장치, 다중의 산 술논리장치를 가지고 있음(중대형 컴퓨터) ­ 대다수의 다른 회로는 내부에 산술논리장치를 포함하고 있음 ­ 엔비디아나 ATI의 그래픽 카드 같은 그래픽 처리 장치(GPU), 오래된 80387 보조 처리기 같은 부동 소수점 장치, 사운드 블래스터 사운드 카드에서 발견할 수 있는 디지털 신호 처 리기, CD 재생기, 고선명 텔레비전 등이 있음(ALU가 사용됨) ­ 이런 모든 것은 내부에 몇 개의 강력하고 복잡한 산술논리장치를 가지고 있음 ▶ CPU의 내부 구성요소 
- 레지스터 ㆍ 레지스터(register) ­ 액세스 속도가 가장 빠른 기억장치(최상위 계층) ­ CPU 내부에 포함할 수 있는 레지스터들의 수가 제한됨(특수 목적용 레지스터들과 적은 수의 일반 목적용 레지스터들)(고속, 비쌈, 데이터/명령어/주소) v 프로세서 레지스터(영어: processor register, 순화 용어 : 기록기) 또는 단순히 레지스터 는 컴퓨터의 프로세서 내에서 자료를 보관하는 아주 빠른 기억 장소임(최상위 계층) ⋅ 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용됨(임시 저장) ⋅ 대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와(로드) 데이터 를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로 저장하는(스토어) 로드
- 스 토어 설계를 사용하고 있음 ⋅ 레지스터는 메모리 계층의 최상위에 위치하며, 가장 빠른 속도로 접근 가능한 메모리임 (레
-캐시
-주
-보조) ⋅ 최신 프로세서에서 레지스터는 대개 레지스터 파일로 구현되지만, 과거에는 플립플롭, 마그네틱 코어, 박막 필름 메모리 등으로 구현되기도 했음(고속 하드웨어) ▶ CPU의 내부 구성요소 – 제어 유니트&CPU 내부 버스 ㆍ 제어 유니트(Control Unit) ­ 프로그램 코드(명령어)를 해석하고, 그것을 실행하기 위한 제어 신호들(control signals) 을 순차적으로 발생하는 하드웨어 모듈(메모리 읽기/쓰기, 300번지, add 250)  118   ㆍ CPU 내부 버스(CPU internal bus) ­ ALU와 레지스터들 간의 데이터 이동을 위한 데이터 선들과 제어 유니트로부터 발생되는 제어 신호 선들로 구성된 내부 버스 ­ 외부의 시스템 버스들과는 직접 연결되지 않으며, 반드시 버퍼 레지스터들(MAR, MBR) 혹은 시스템 버스 인터페이스 회로를 통하여 시스템 버스와 접속 ▶ CPU의 내부 레지스터들 – PC

1) 프로그램 카운터(program Counter : PC) ­ 다음에 인출할 명령어의 주소를 가지고 있는 레지스터 ­ 각 명령어가 인출된 후에는 자동적으로 일정 크기(한 명령어 길이)만큼 증가(300번지 ­ add 250 명령어) ­ 분기(branch) 명령어가 실행되는 경우에는 목적지 주소로 갱신(jump 400) ­ 프로그램 카운터(Program counter, PC)는 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드 의 위치를 지정함 ­ 때문에 명령어 포인터라고도 하며, 인텔의 x86계열의 CPU에서는 IP(instruction Pointer) 라고 함(PC/IP)
2) 프로그램 계수기(Program Counter) ­ 프로그램 계수기는 각 명령 주기에 따라 자동으로 증가하여, 메모리에 있는 명령어들이 순 차적으로 실행될 수 있도록 함(지역성 ­ 순차적 실행) ­ 단, 분기 또는 서브루틴 호출 / 복귀 등의 특정 명령어는 프로그램 카운터에 실행해야 할 위치가 바로 다음 코드가 아니라 새로운 기계어 코드의 위치 값이 들어감(jump 400) ­ 한편, 재설정 가능한 컴퓨터 시스템의 기본 모델(비 폰노이만 모델)에서는 프로그램 계수기 대신 데이터 계수기를 사용함(명령어와 데이터 분할)
3) 명령어의 인수(분기) ­ 대부분의 프로세서에서는 명령어를 반입하고 난 직후에 명령어 포인터를 증가시킴(PC = PC +
1) ­ 경우에 따라 분기 명령어의 목표가 되는 주소를, 그 분기 명령어의 인수(operand)에서 지 정하는 경우도 있음 ­ 명령어의 인수값이 절대 주소값인 경우는 인수값을 프로그램 카운터 값에 설정하면 그 주 소를 점프함(JUMP) ­ 명령어의 종류에 따라 인수가 현재 위치에서의 상대적으로 지정하는 경우도 있는데 이런 경우 현재 프로그램 카운터 값에 인수값을 더하는 방식을 사용(상대) ­ 즉, 다음에 실행될 명령어의 주소는 명령어에 따라 명령어의 인수에 지정되는 경우도 있음 (jump 400) ▶ CPU의 내부 레지스터들 – AC&IR ㆍ 누산기(Accumulator : AC)  119   ­ 데이터를 일시적으로 저장하는 레지스터 ­ 레지스터의 길이는 CPU가 한 번에 처리할 수 있는 데이터 비트 수(단어 길이)와 동일 (add 250) ㆍ 명령어 레지스터(Instruction Register : IR) ­ 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터(명령어 해독의 출발점) ▶ CPU의 내부 레지스터들 – MAR&MBR ㆍ 기억장치 주소 레지스터(Memory Address Register : MAR) ­ PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주 소 레지스터(속도차) ㆍ 기억장치 버퍼 레지스터(Memory Buffer Register : MBR) ­ 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터(속도차) ▶ CPU의 내부 데이터 통로(PC – MAR – MBR – IR – AC, add 250) 주소 데이터 제어 버스 버스 버스 ※ 컴퓨터구조론, 생능출판사, 2019  120   명령어 실행
1. 명령어 실행에 필요한 명령어 사이클에 대해서 이해하고 이를 설명할 수 있다. 5주차  수업목표  
2. 명령어의 세부 명령어인 마이크로 연산을 이해하고 이를 2교시  설명할 수 있다.
1. 명령어 사이클 세부내용 
2. 마이크로 연산 1. 명령어 사이클   ▶ 인출 사이클
1) 인출 사이클의 마이크로 연산(micro ­ operation)  : MAR ← PC   : MBR ← M[MAR], PC ← PC + 1   : IR ← MBR  ⇨ 단,  ,  및  는 CPU 클록(clock)의 주기    ⋅ 첫 번째 주기 ­ 현재의 PC내용을 CPU 내부 버스를 통하여 MAR로 전송 ⋅ 두 번째 주기 ­ 그 주소가 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터 버스를 통하여 MBR 로 적재되며, PC의 내용에 1을 더함(다음 명령어 주소) ⋅ 세 번째 주기 ­ MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동 ⋅ 예) CPU 클록 = 1GHz (클록 주기 = 1ns) ⇨ 인출 사이클 : 1ns x 3 = 3ns 소요 ▶ 인출 사이클의 주소 및 명령어 흐름도(PC – MAR – MBR – IR, add 250) 주소 데이터 제어 버스 버스 버스 ※ 컴퓨터구조론, 생능출판사, 2019  121   ▶ 실행 사이클 ­ CPU는 실행 사이클 동안에 명령어 코드를 해독(decode)하고, 그 결과에 따라 필요한 연산 들을 수행 ㆍ CPU가 수행하는 연산들의 종류 ­ 데이터 이동 : CPU와 기억장치 간 혹은 I/O장치 간에 데이터를 이동 ­ 데이터 처리 : 데이터에 대하여 산술 혹은 논리 연산을 수행 ­ 데이터 저장 : 연산 결과 데이터 혹은 입력장치로부터 읽어 들인 데이터를 기억장치에 저장 ­ 프로그램 제어 : 프로그램의 실행 순서를 결정(JUMP) ­ 실행 사이클에서 수행되는 마이크로
-연산들은 명령어의 연산 코드(op code)에 따라 결정됨 (operand) ▶ 기본적인 명령어 형식의 구성 ㆍ 연산 코드(Operation code) ­ CPU가 수행할 연산을 지정(ADD, SUB…) ㆍ 오퍼랜드(Operand) ­ 명령어 실행에 필요한 데이터가 저장된 주소(addr)(간접) 연산 코드 오퍼랜드(addr) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 사례1 : LOAD addr 명령어(load 500) v 기억장치에 저장되어 있는 데이터를 CPU 내부 레지스터인 AC로 이동하는 명령어  : MAR ← IR(addr)   : MBR ← M[MAR]   : AC ← MBR  ⋅ 첫 번째 주기 ­ 명령어 레지스터 IR에 있는 명령어의 주소 부분을 MAR로 전송 ⋅ 두 번째 주기 ­ 그 주소가 지정한 기억장소로부터 데이터를 인출하여 MBR로 전송(500번지 ­ 600) ⋅ 세 번째 주기 ­ 그 데이터를 AC에 적재(600) ▶ 사례2 : STA addr 명령어(sta 500) v AC 레지스터의 내용을 기억장치에 저장하는 명령어  : MAR ← IR(addr)   : MBR ← AC   : M[MAR] ← MBR   122   ⋅ 첫 번째 주기 ­ 데이터를 저장할 기억장치의 주소를 MAR로 전송(500) ⋅ 두 번째 주기 ­ 저장할 데이터를 버퍼 레지스터인 MBR로 이동(600) ⋅ 세 번째 주기 ­ MBR의 내용을 MAR이 지정하는 기억 장소에 저장 ▶ 사례3 : ADD addr 명령어(add 250) v 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어  : MAR ← IR(addr)   : MBR ← M[MAR]   : AC ← AC + MBR  ⋅ 첫 번째 주기 ­ 데이터를 저장할 기억장치의 주소를 MAR로 전송(250) ⋅ 두 번째 주기 ­ 저장할 데이터를 버퍼 레지스터인 MBR로 이동(300) ⋅ 세 번째 주기 ­ 그 데이터와 AC의 내용을 더하고 결과값을 다시 AC에 저장 ▶ ADD 명령어 실행 사이클의 정보 흐름(IR – MAR – MBR – AC, add 250) 주소 데이터 제어 버스 버스 버스 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 사례4 : JUMP addr 명령어(jump 400) v 오퍼랜드(addr)가 가리키는 위치의 명령어로 실행 순서를 변경하는 분기(branch) 명령어  : PC ← IR(addr)  ­ 명령어의 오퍼랜드(분기할 목적지 주소)를 PC에 저장(400) ­ 다음 명령어 인출 사이클에서 그 주소의 명령어가 인출되므로, 분기가 발생  123   ▶ 어셈블리 프로그램 실행 과정의 예 ㆍ 연산 코드에 임의의 정수 배정 ­ LOAD : 1 ­ STORE : 2 ­ ADD : 5 ­ JUMP : 8

1) 어셈블리 프로그램의 예(op code + operand) 주소 명령어 기계 코드 100 LOAD 250 1250 101 ADD 251 5251 102 STA 251 2251 103 JUMP 170 8170 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 100번지의 첫 번째 명령어 코드(1250)가 인출되어 IR에 저장, 250번지의 데이터(0004)를 AC로 이동(load) ­ PC = PC + 1 = 101 기억장치 CPU 레지스터 기억장치 CPU 레지스터 [단계1] LOAD 명령어 인출 [단계2] LOAD 명령어 실행 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 두 번째 명령어(5251)가 101번지로부터 인출되어 IR에 저장, AC의 내용과 251번지의 내 용(0003)을 더하고(add), 결과(0007)를 AC에 저장, PC의 내용은 102로 증가 기억장치 CPU 레지스터 기억장치 CPU 레지스터 [단계3] ADD 명령어 인출 [단계4] ADD 명령어 실행 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 세 번째 명령어(2251)가 102 번지로부터 인출되어 IR에 저장, AC의 내용(0007)이 251 번지에 저장(sta) ­ PC의 내용은 103으로 증가  124   기억장치 CPU 레지스터 기억장치 CPU 레지스터 [단계5] STA 명령어 인출 [단계6] STA 명령어 실행 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 네 번째 명령어(8170)가 103 번지로부터 인출되어 IR에 저장(jump) ­ 분기될 목적지 주소, 즉 IR의 하위 부분(170)이 PC로 적재, (다음 명령어 인출 사이클에서 는 170 번지의 명령어 인출) 기억장치 CPU 레지스터 기억장치 CPU 레지스터 [단계7] JUMP 명령어 인출 [단계8] JUMP 명령어 실행 ※ 컴퓨터구조론, 생능출판사, 2019 2. 마이크로 연산   ▶ 인터럽트 ㆍ 인터럽트 ­ 프로그램 실행 중에 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 요구 하는 시스템 동작(vs. 폴링) ⋅ 외부로부터 인터럽트 요구가 들어오면, : CPU는 원래의 프로그램 수행을 중단하고, : 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행 ⋅ 인터럽트 서비스 루틴(Interrupt service routine : ISR) : 인터럽트를 처리하기 위하 여 수행되는 프로그램 루틴 v 마이크로프로세서에서 인터럽트(interrupt, 문화어 : 중단, 새치기)란 마이크로프로세서 (CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외 상황이 발생하여 처리가 필요할 경우에 마이크로프로세서(CPU)에게 알려 처리할 수 있도록 하는 것을 말함 ⋅ 폴링이 대상을 주기적으로 감시하여 상황이 발생하면 해당 처리 루틴을 실행해 처리한 다면, 인터럽트는 상대가 마이크로프로세서에게 일을 처리해 달라고 요청하는 수단 ⋅ 따라서 폴링과 대비되는 개념임(CPU 낭비) ⋅ 폴링은 주기적으로 마이크로프로세서(CPU)가 상태를 파악하기 위해 장치의 상태 레지 스터를 읽어야 하는데, 이 작업이 진행되는 동안은 다른 장치는 체크가 힘듦 ⋅ 그리고 이런 작업은 장치의 상태를 읽는데 마이크로프로세서의 자원이 낭비됨  125   ▶ 인터럽트에 의한 제어의 이동(PC, PSW 저장, 다중 인터럽트) 주 프로그램 인터럽트 서비스 루틴 호출 인터럽트 발생 복귀 종료 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 인터럽트 처리 과정 ­ 인터럽트가 들어왔을 때 CPU는 ⇨ 어떤 장치가 인터럽트를 요구했는지 확인하고, 해당 ISR을 호출(PC, PSW 저장) ⇨ 서비스가 종료된 다음에는 중단되었던 원래 프로그램의 수행을 계속(PC, PSW 복원)
1) CPU 인터럽트 처리의 세부 동작
① 현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소(PC의 내용)를 스택(stack) 에 저장(중요) ⇨ 일반적으로 스택은 주기억장치의 특정 부분
② ISR을 호출하기 위하여 그 루틴의 시작 주소를 PC에 적재, 이때 시작 주소는 인터럽트를 요구한 장치로부터 전송되거나 미리 정해진 값으로 결정 ⇨ 자세한 사항은 인터럽트를 이용한 I/O에서 설명 ▶ 인터럽트 사이클이 추가된 명령어 사이클(interrupt enable bit) 연출 사이클 실행 사이클 인터럽트 사이클 ※ 컴퓨터구조론, 생능출판사, 2019  126   ▶ 인터럽트 사이클의 마이크로 연산(300번지, add 250, ISR
-700)  : MAR ← PC   : MAR ← SP, PC ← ISR의 시작 주소   : M[MAR] ← MBR  ⇨ 단, SP는 스택 포인터(stack pointer) ⋅ 첫 번째 주기 ­ PC의 내용을 MBR로 전송(301) ⋅ 두 번째 주기 ­ SP의 내용을 MAR로 전송하고, PC의 내용은 인터럽트 서비스 루틴의 시작 주소로 변경 (700) ⋅ 세 번째 주기 ­ MBR에 저장되어 있던 PC의 내용을 스택에 저장(301) ▶ 인터럽트 사이클의 마이크로 연산 : 예 ­ 아래 프로그램의 첫 번째 명령어인 LOAD 250 명령어가 실행되는 동안에 인터럽트가 들어 왔으며, 현재 SP = 999이고, 인터럽트 서비스 루틴의 시작 주소는 650번지라고 가정 100 LOAD 250 101 ADD 251 102 STA 251 103 JUMP 170 ▶ 인터럽트가 들어온 경우의 상태 변화(SP : 0101, PC : 0650) 기억장치 CPU 레지스터 기억장치 CPU 레지스터 ISR 주소 원래 PC 내용 (a) LOAD 명령어의 실행 사이클이 (b) 인터럽트 사이클이 종료된 상태 종료된 상태(일단 명령어 종료) (101,650) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 다중 인터럽트(Multiple interrupt) ­ 인터럽트 서비스 루틴을 수행하는 동안에 다른 인터럽트 발생 ㆍ 다중 인터럽트의 처리방법(두 가지)
① CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에는 새로운 인터럽트 요구가 들어  127   오더라도 인터럽트 사이클을 수행하지 않는 방법 ⋅ 인터럽트 플래그(interrupt flag) ← 0 : 인터럽트 불가능(interrupt disabled) 상태 ⋅ 시스템 운영상 중요한 프로그램이나 도중에 중단할 수 없는 데이터 입출력 동작 등을 위한 인터럽트를 처리하는데 사용
② 인터럽트의 우선순위를 정하고, 우선순위가 낮은 인터럽트가 처리되고 있는 동안에 우 선순위가 더 높은 인터럽트가 들어온다면, 현재의 인터럽트 서비스 루틴의 수행을 중단하 고 새로운 인터럽트를 처리 ­ 장치 X를 위한 ISR X를 처리하는 도중에 우선 순위가 더 높은 장치 Y로부터 인터럽트 요 구가 들어와서 먼저 처리되는 경우에 대한 제어의 흐름(PC, PSW 저장 반복) 주 프로그램 ISR X ISR Y ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 간접 사이클의 마이크로 연산(add 250, 250
-300, 300
-400) ­ 명령어에 포함되어 있는 주소를 이용하여, 그 명령어 실행에 필요한 데이터의 주소를 인출 하는 사이클(vs. 직접) ⇨ 간접 주소 지정 방식(indirect addressing mode)에서 사용 ­ 인출 사이클과 실행 사이클 사이에 위치(아니면 수행 안함) v 간접 사이클에서 수행될 마이크로
- 연산  : MAR ← IR(addr)   : MBR ← M[MAR]   : IR(addr) ← MBR  ­ 인출된 명령어의 주소 필드 내용을 이용(250)하여 기억장치로부터 데이터의 실제 주소를 인출(300)하여 IR의 주소 필드에 저장(메모리 2번 접근, 주소 확장)  128   명령어 파이프라이닝

1. 2단계 및 4단계 명령어 파이프라이닝을 학습하고 이를 설명할 수 있다. 5주차  수업목표  
2. 명령어 파이프라이닝의 특수한 형태인 슈퍼스칼라를 이해하고 3교시  설명할 수 있다.
1. 2단계 및 4단계 세부내용 
2. 슈퍼스칼라 1. 2단계 및 4단계   ▶ 명령어 파이프라이닝(instruction pipelining) ­ CPU의 프로그램 처리 속도를 높이기 위하여 CPU 내부 하드웨어를 여러 단계로 나누어 동 시에 처리하는 기술
1) 2단계 명령어 파이프라인(two
-stage instruction pipeline) ­ 명령어를 실행하는 하드웨어를 인출 단계(fetch stage)와 실행 단계(execute stage)라는 두 개의 독립적인 파이프라인 모듈로 분리 ­ 두 단계들에 동일한 클록을 가하여 동작 시간을 일치시키면, ⋅ 첫 번째 클록 주기에서는 인출 단계가 첫 번째 명령어를 인출 ⋅ 두 번째 클록 주기에서는 인출된 첫 번째 명령어가 실행 단계로 보내져서 실행되며, 그 와 동시에 인출 단계는 두 번째 명령어를 인출 ▶ 2단계 명령어 파이프라인과 시간 흐름도(병렬 수행, add 250) 명령어 명령어 실행 결과 클록 주기 명령어1 명령어2 명령어3 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 2단계 명령어 파이프라인 ­ 2단계 파이프라인을 이용하면 명령어 처리 속도가 두 배 향상(이론적 ­ 해저드) ㆍ 문제점 ­ 두 단계의 처리 시간이 동일하지 않으면 두 배의 속도 향상을 얻지 못함(파이프라인 효 율 저하, 낮은 쪽에 종속) ㆍ 해결책  129   ­ 파이프라인 단계의 수를 증가시켜 각 단계의 처리 시간을 같게 함(단계를 증가하면 처리 시간이 비슷하게 됨) ⇨ 파이프라인 단계의 수를 늘리면 전체적으로 속도 향상이 더 높아짐 ▶ 4단계 명령어 파이프라인 ㆍ 명령어 인출(Iex)) 단계 ­ 다음 명령어를 기억장치로부터 인출(add 250) ㆍ 명령어 해독(ID) 단계 ­ 해독기(decoder)를 이용하여 명령어를 해석(add) ㆍ 오퍼랜드 인출(Oex)) 단계 ­ 기억장치로부터 오퍼랜드를 인출(250
-300) ㆍ 실행(EX) 단계 ­ 지정된 연산을 수행(AC = AC + 300) ▶ 4단계 명령어 파이프라인과 시간 흐름도(병렬 수행, add 250, 4배) 실행 명령어 결과 클록 주기 명령어1 명령어2 명령어3 명령어4 명령어5 명령어6 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 파이프라인에 의한 전체 명령어 실행 시간 ­ 파이프라인 단계 수 = k ­ 실행할 명령어들의 수 = N ­ 각 파이프라인 단계가 한 클럭 주기씩 걸린다고 가정한다면, v 파이프라인에 의한 전체 명령어 실행 시간 (Tk) TK = k + (N ­

1) ­ 즉, 첫 번째 명령어를 실행하는데 k 주기가 걸리고, ­ 나머지 (N
-

1) 개의 명령어들은 각각 한 주기씩만 소요 v 파이프라인 되지 않은 경우의 N개의 명령어들을 실행 시간 (T1) T1 = k × N  130   ▶ 파이프라인에 의한 속도 향상(speedup, k배)  ×            ▶ 예제 : 파이프라인에 의한 속도 향상 ◼ 예제 ­ 파이프라인 단계 수 = 4 파이프라인 클록 = 1GHz (각 단계에서의 소요시간 = 1ns)일 때, 10개의 명령어를 실 행하는 경우의 속도 향상은? ⋅ 풀이 ­ 첫 번째 명령어 실행에 걸리는 시간 = 4ns 다음부터는 1ns마다 한 개씩의 명령어 실행 완료 10개의 명령어 실행 시간 = 4 + (10 ­
1) = 13ns ⇨ 속도 향상(speedup : Sp ) = (10 ×
4) / 13 ≒ 3.08배 ­ N : CPU가 실행하는 명령어 수라면, N = 100일 때, Sp = 400 / 103 = 3.88 N = 1000일 때, Sp = 4000 / 1003 = 3.988 N = 10000일 때, Sp = 40000 / 10003 = 3.9988 N = ∞ 일 때, Sp → 4(이론적 속도 향상) ▶ 파이프라인의 효율 저하 요인들(해저드) ­ 모든 명령어들이 파이프라인 단계들을 모두 거치지는 않음 ⋅ 어떤 명령어에서는 오퍼랜드를 인출할 필요가 없지만, 파이프라인의 하드웨어를 단순화 시키기 위해서는 모든 명령어가 네 단계들을 모두 통과하도록 해야 함 ­ 파이프라인의 클록은 처리 시간이 가장 오래 걸리는 단계를 기준으로 결정됨(늦은 시간에 종속) ­ Iex) 단계와 Oex) 단계가 동시에 기억장치를 액세스하는 경우에, 기억장치 충돌(memory conflict)이 일어나면 지연이 발생함(구조적 해저드 ­ 자원 추가) ­ 조건 분기(conditional branch) 명령어가 실행되면, 미리 인출하여 처리하던 명령어들이 무효화됨(분기 해저드) ▶ 조건 분기가 존재하는 경우의 시간 흐름도 ­ 예) 명령어 3 : JZ 12 ; JUMP (if zero) to address 12 클록 주기 명령어1 명령어2 명령어3 명령어4 명령어5 명령어6 ※ 컴퓨터구조론, 생능출판사, 2019 명령어12 명령어13  131   ▶ 분기 발생에 의한 성능 저하의 최소화 방법 ㆍ 분기 예측(branch prediction) ­ 분기가 일어날 것인지를 예측하고, 그에 따라 명령어를 인출하는 확률적 방법 ­ 분기 역사 표(branch history table)를 이용하여 최근의 분기 결과를 참조 ㆍ 분기 목적지 선인출(prefetch branch target) ­ 조건 분기가 인식되면, 분기 명령어의 다음 명령어 뿐만 아니라 분기의 목적지 명령어도 함께 인출하여 실행하는 방법(조건 확인 후, 유효 명령어 결과를 선택) ㆍ 루프 버퍼 사용(loop buffer) ­ 파이프라인의 명령어 인출 단계에 포함되어 있는 작은 고속 기억장치인 루프 버퍼에 가 장 최근 인출된 n개의 명령어들을 순서대로 저장해두는 방법(고속 장치) ㆍ 지연 분기(delayed branch) ­ 분기 명령어의 위치를 재배치함으로써 파이프라인의 성능을 개선하는 방법(어차피 수행 할 명령어 미리 수행) ▶ 상태 레지스터(status register) ­ 조건분기 명령어가 사용할 조건 플래그(condition flag)들 저장
1) 조건 플래그의 종류 ㆍ 부호(S) 플래그 ­ 직전에 수행된 산술 연산 결과값의 부호 비트를 저장 ㆍ 영(Z) 플래그 ­ 연산 결과값이 0이면 1(제로 체크) ㆍ 올림수(C) 플래그 ­ 덧셈이나 뺄셈에서 올림수(carry)나 빌림수(borrow)가 발생한 경우에 1로 세트 S Z C X E V I P ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 동등(E) 플래그 ­ 두 수를 비교한 결과가 같게 나왔을 경우에 1로 세트 ㆍ 오버플로우(V) 플래그 ­ 산술 연산 과정에서 오버플로우가 발생한 경우에 1로 세트 ㆍ 인터럽트(I) 플래그 ­ 인터럽트 가능(interrupt enabled) 상태이면 0으로 세트 ­ 인터럽트 가능(interrupt enabled) 상태이면 0으로 세트 ㆍ 슈퍼바이저(P) 플래그 ­ CPU의 실행 모드가 슈퍼바이저 모드(supervisor mode)이면 1로 세트(시스템 수준의 작업이나 스레드에 필요) ­ 사용자 모드(user mode)이면 0으로 세트 2. 슈퍼스칼라    132   ▶ 슈퍼스칼라(superscalar) ㆍ 슈퍼스칼라 ­ CPU의 처리 속도를 더욱 높이기 위하여 내부에 두 개 혹은 그 이상의 명령어 파이프라 인들을 포함시킨 구조 ­ 매 클록 주기마다 각 명령어 파이프라인이 별도의 명령어를 인출하여 동시에 실행할 수 있기 때문에, 이론적으로는 프로그램 처리 속도가 파이프라인의 수만큼 향상 가능 ­ 파이프라인의 수 = m : m
-way 슈퍼스칼라 v 슈퍼스칼라(superscalar)는 CPU 내에 파이프라인을 여러 개 두어 명령어를 동시에 실행하 는 기술 ⋅ ILP(Instruction Level Parallelism)를 최대한 적용하여 실행하면 CPU 처리 속도가 빨 라짐 ⋅ 파이프라인이 하나라면 클럭당 하나의 명령어만 완료할 수 있었음(다시 말해 IPC가

1) (Instruction Per Cycle) ⋅ 이 값을 높이려면 파이프라인을 여러 개 두어 명령어를 동시에 실행시켜야 하는데, 파 이프라인이 2개라면 이상적으론 클럭 마다 최대 2 개의 명령어를 처리할 수 있어 IPC=2가 됨 ⋅ 보통 슈퍼스칼라 프로세서는 동시에 처리(투입/완료)가 가능한 명령어 개수에 따라 N
- 이슈, N
-와이드(wide), N
-웨이(way) 슈퍼스칼라라고 표현 ⋅ 이상적으로는 N개의 명령어를 읽어 파이프 라인에 넣을 수 있지만(fetch), 실제로는 명 령어 캐시의 제약, 명령어 사이의 의존성, 분기문 때문에 N개보다 작은 명령어만 넣을 수 있을 때가 일반적임(이론/실제) ⋅ 명령어 사이에 데이터 의존성, 자원 의존성, 프로시저 의존성이 존재하는 경우에는 동 시 실행에 제한이 있음 ▶ 2
-way 슈퍼스칼라의 명령어 실행 흐름도(병렬 수행)             (a) 일반적인 파이프라인의 명령어 실행 시간도                     (b) 2
-way 슈퍼스칼라의 명령어 실행 시간도 ※ 컴퓨터구조론, 생능출판사, 2019  133   ▶ 슈퍼스칼라에 의한 속도 향상(speedup : Sp, N
-10, m
-2, k
-4) ㆍ 단일 파이프라인에 의한 실행 시간(N : 실행할 명령어 수)  ㆍ m
-way 슈퍼스칼라에 의한 실행 시간(k : 파이프라인 단계)     ㆍ 속도 향상               ㆍ 명령어 수 N → ∞, Sp → m ▶ 슈퍼스칼라의 속도 저하

1) 슈퍼스칼라의 속도 저하(Sp < m) 요인 ­ 명령어들 간의 데이터 의존 관계 ­ 하드웨어(ALU, 레지스터 등) 이용에 대한 경합 발생 ⇨ 동시 실행 가능한 명령어 수 < m
2) 해결책 ­ 명령어 실행 순서 재배치 ⇨ 명령어들 간의 데이터 의존성 제거 ­ 하드웨어 추가(중복) 설치 ⇨ 하드웨어(ALU, 레지스터 등)에 대한 경합 감소 ▶ 듀얼
-코어 및 멀티
-코어 ㆍ CPU 코어(core) ­ 명령어 실행에 필요한 CPU 내부의 핵심 하드웨어 모듈(슈퍼스칼라 H/W, ALU, 레지스 터 등) ㆍ 멀티­코어 프로세서(multi­core processor) ­ 여러 개의 CPU 코어들을 하나의 칩에 포함시킨 프로세서 ⋅ 듀얼­코어(dua
-core) : 두 개의 CPU 코어 포함 ⋅ 쿼드­코어(quad­core) : 네 개의 CPU 코어 포함 ⋅ 헥사­코어(hexa­core), 옥타­코어(octa­core)도 출시 중 ­ 칩
-레벨 다중프로세서(chip
-level multiprocessor) 혹은 단일
-칩 다중프로세서 (multiprocessor
-on
-a
-chip)이라고도 부름

1) 듀얼­코어 프로세서 ­ 단일
-코어 슈퍼스칼라 프로세서에 비하여 2배의 속도 향상 기대 ­ 코어들은 내부 캐시와 시스템 버스 인터페이스만 공유 ­ 코어 별로 독립적 프로그램 실행 → 멀티­태스킹(multi­tasking) 혹은 멀티­스레딩(multi­ threading) 지원  134   ※ 컴퓨터구조론, 생능출판사, 2019

2) 멀티
-스레딩 ­ 스레드(thread) : 독립적으로 실행될 수 있는 최소 크기의 프로그램 단위 ­ 단일­스레드 모델(그림ⓐ) : 각 코어가 스레드를 한 개씩 처리 ⋅ 처리 중의 스레드에 대한 시스템 상태, 데이터 및 주소 정보(TCB)를 레지스터 세트 (RS)에 저장 ⋅ RS : 프로그램 카운터(PC), 스택 포인터(SP), 상태 레지스터, 데이터 레지스터, 주소 레 지스터 등 ­ 멀티­스레딩(각 코어가 스레드 한 개씩 처리, RS : 레지스터 세트) (a) 단일 ­ 스레드 모델 ※ 컴퓨터구조론, 생능출판사, 2019

3) 멀티­스레드 모델(그림ⓑ) ­ 각 코어는 두 개의 RS들을 포함하며, 스레드를 두 개씩 처리 ­ 두 스레드들이 CPU 코어의 H/W 자원들(ALU, 부동소수점유니트, 온
-칩 캐시, TLB 등)을 공유(translation lookaside buffer : 논리 주소/물리 주소 변환 속도 개선) ­ 처리 중의 각 스레드에 대한 시스템 상태, 데이터 및 주소 정보(TCB)는 서로 다른 레지스 터 세트(RS)에 저장 ­ 멀티­스레드 모델(그림ⓑ)(스레드를 두 개씩 처리, RS : 레지스터 파일) ※ 컴퓨터구조론, 생능출판사, 2019 (b) 멀티 ­ 스레드 모델

4) 멀티­스레드 프로세서 ­ ‘두 개의 물리적 프로세서(physical processor)들이 네 개의 논리적 프로세서(logical  135   processor)들로 구성되어 있다.’라고 정의하기도 함(물리/논리) ㆍ 멀티­코어, 멀티­스레딩 프로세서의 사례 ­ Intel i7
-8500Y : 2
-코어 4
-스레드 프로세서 ­ Intel i7
-8565U : 4
-코어 8
-스레드 프로세서  136   명령어 세트

1. 명령어 세트가 가지는 연산의 종류를 이해하고 설명할 수 있다. 6주차  수업목표  
2. 명령어 세트가 가지는 명령어 형식을 이해하고 설명할 수 1교시  있다.
1. 연산의 종류 세부내용 
2. 명령어 형식 1. 연산의 종류   ▶ 명령어 세트(instruction set) ­ 어떤 CPU를 위하여 정의되어 있는 명령어들의 집합
1) 명령어 세트 설계를 위해 결정되어야 할 사항들 ㆍ 연산 종류(operation repertoire) ­ CPU가 수행할 연산들의 수와 종류(add) 및 복잡도(cisc, risc) ㆍ 데이터 형태(data type) ­ 연산을 수행할 데이터들의 형태, 데이터의 길이(비트 수), 수의 표현 방식 등(int, char, double) ㆍ 명령어 형식(Instruction format) ­ 명령어의 길이, 오퍼랜드 필드들의 수(1
-3)와 길이 등 ㆍ 주소지정 방식(addressing mode) ­ 오퍼랜드의 주소를 지정하는 방식(직접, 간접) v 명령어 집합(instruction set) 또는 명령어 집합 구조(instruction set architecture, ISA) 는 마이크로프로세서(CPU)가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어를 말함 ⋅ 마이크로프로세서(CPU)마다 기계어 코드의 길이와 숫자 코드가 다름 ⋅ 명령어의 각 비트는 기능적으로 분할하여 의미를 부여하고 숫자화함(1250) ⋅ 프로그램 개발자가 숫자로 프로그램하기가 불편하므로 기계어와 일대일로 문자화한 것 이 어셈블리어임(add 250)

2) 명령어 세트 특징 ­ 최하위 레벨의 프로그래밍 인터페이스로, 프로세서(CPU)가 실행할 수 있는 모든 명령어들 을 포함 ­ 명령어 집합(IS), 곧 명령어 집합 구조(ISA)는 자료형, 명령어, 레지스터, 어드레싱 모드, 메 모리 구조, 인터럽트, 예외 처리, 외부 입출력을 포함한 프로그래밍 관련 컴퓨터 아키텍처 의 일부임 ­ ISA는 특정한 CPU 디자인으로 추가된 순수 명령어인 opcode의 집합 규격(기계어)을 포함 (add, sub) ­ RISC CPU는 명령어의 구조와 명령어의 숫자를 단순화 하여 빠른 실행이 가능하고 하드웨  137   어를 줄일 수 있음 ­ ARM의 경우 단순화를 통해 실행속도와 전력소모에 유리하므로 이동전화와 같은 이동장치 에 많이 사용함 ­ ARM의 명령어 길이는 32비트(16비트 Thumb 제외)로 구성되고, 오퍼랜드(operand)가 32비트 내에 존재함 ­ CISC의 오퍼랜드가 op 코드 다음에 오는 구조와 대조적임 ­ 대신 32비트 모두를 지정할 수 없으므로 원거리 주소나 데이터 지정이 불가능해져 복수의 명령어를 사용할 필요가 생길 수 있음(RISC)
3) 명령어 세트와 기계어 ­ 각 기계어 명령어를 실행하는 명령 주기 단계 별 처리를 위해 마이크로코드로 작성된 프로 그램이 마이크로프로세서 내의 메모리(ROM
-제어 메모리)에 고정되므로 이미 결정되어 있 어 변경할 수 없음 ­ 개발자가 인식하는 데 불편하므로 어셈블리어로 프로그램 코드를 작성하고 어셈블러에 의 해 기계어 코드로 전환되어 메모리에 넣고 실행함 ­ 하이레벨 프로그램 언어도 컴파일러에 의해 기계어 명령어로 바뀜(C언어) ­ C언어로 프로그래밍할 경우, C언어는 같은 코드라도 다른 CPU에서 실행하려면 다른 숫자 의 기계어로 전환되어야 하므로 다른 컴파일러 도구가 필요함(자바)

4) 마이크로아키텍처 ­ 명령어 집합 구조(ISA)를 물리적으로 구현하는 방법을 마이크로아키텍처 혹은 컴퓨터 조직 이라고 하며, 같은 명령어 집합 구조를 서로 다른 마이크로아키텍처로 구현하기도 함 ­ 예를 들어, 인텔의 펜티엄과 AMD의 애슬론은 거의 같은 명령어 집합 구조를 서로 다른 마이크로아키텍처로 구현한 것 ▶ 연산의 종류 ㆍ 데이터 전송 ­ 레지스터와 레지스터 간, 레지스터와 기억장치 간, 혹은 기억장치와 기억장치 간에 데이 터를 이동하는 동작 ㆍ 산술 연산 ­ 덧셈, 뺄셈, 곱셈 및 나눗셈과 같은 기본적인 산술 연산들 ㆍ 논리 연산 ­ 데이터의 각 비트들 간에 대한 AND, OR, NOT 및 exclusive
-OR(XOR) 연산(논리 연 산) ㆍ 입출력(I/O) ­ CPU와 외부 장치(I/O)들 간의 데이터 이동을 위한 동작들 ㆍ 프로그램 제어 ­ 명령어 실행 순서를 변경하는 연산들 : 복귀 주소 저장 ­ 분기(branch), 서브루틴 호출(subroutine call)  138   ▶ 서브루틴 호출을 위한 명령어들 ㆍ CALL 명령어 ­ 현재의 PC 내용을 스택에 저장하고 서브루틴의 시작 주소로 분기하는 명령어 : 복귀 주 소 저장 ㆍ RET 명령어 ­ CPU가 원래 실행하던 프로그램으로 복귀(return)시키는 명령어 ▶ 서브루틴이 포함된 프로그램이 수행되는 순서(PC
-스택) 주 프로그램 (a) 프로그램 (b) 제어의 구성 흐름도 서브루틴 SUB1 서브루틴 SUB2 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ CALL/RET 명령어의 마이크로 연산 v CALL X 명령어에 대한 마이크로
- 연산  : MBR ← PC   : MAR ← SP, PC ← X   : M[MAR] ← MBR, SP ← SP
- 1  ­ 현재의 PC 내용(서브루틴 수행 완료 후에 복귀할 주소)을 SP가 지정하는 스택의 최상위 (top of stack)에 저장 ­ 만약 주소지정 단위가 바이트이고 저장될 주소는 16비트라면, SP ← SP ­ 2 로 변경 : 스 택의 주소는 감소 v RET 명령어의 마이크로
-연산  : SP ← SP + 1   : MAR ← SP   : PC ← M[MAR]   139   ▶ 프로그램 수행 과정에서 스택의 변화(Stack – LIex)O) (a) 초기 상태 (b) SUB1이 (c) SUB2가 (d) SUB2로부터 호출된 후 호출된 후 복귀한 후 (e) SUB2가 (f) SUB2로부터 (g) SUB1로부터 호출된 후 복귀한 후 복귀한 후 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 스택 v 스택(stack)은 제한적으로 접근할 수 있는 나열 구조임 ⋅ 그 접근 방법은 언제나 목록의 끝에서만 일어남 ⋅ 끝먼저내기 목록(Pushdown list)이라고도 함 ⋅ 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIex)O
- Last In ex)irst Out)으로 되어 있음 ⋅ 자료를 넣는 것을 '밀어 넣는다' 하여 푸시(push)라고 하고 반대로 넣어둔 자료를 꺼내 는 것을 팝(pop)이라고 하는데, 이때 꺼내지는 자료는 가장 최근에 보관한 자료부터 나오게 됨(큐
-ex)Iex)O, 트리
-비선형 구조) ⋅ 이처럼 나중에 넣은 값이 먼저 나오는 것을 LIex)O 구조라 함 ⋅ 이를테면, a부터 b와 c를 순서대로 넣은 다음 자료를 하나씩 꺼내면 c부터 b와 a의 순 서로 나오게 됨 ⋅ 컴퓨터에서 포인터라고 하는 자료의 위치 표시자(SP)와 넣고 빼는 명령어를 사용해서 스택을 이용함(push/pop) ⋅ 주로 함수를 호출할 때 인수의 전달 등에 이용됨(복귀주소) ⋅ LIex)O의 특징을 이용하여 역폴란드 표기법을 이용한 프로그래밍 언어인 포스(ex)orth) 등 에서도 이용됨(ab+) 2. 명령어 형식   ▶ 명령어의 구성요소들 ㆍ 연산 코드(Operation Code) ­ 수행될 연산을 지정(예 : LOAD, ADD 등) ㆍ 오퍼랜드(Operand) ­ 연산을 수행하는 데 필요한 데이터 혹은 데이터의 주소 ­ 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 포함 ­ 데이터는 CPU 레지스터, 주기억장치, 혹은 I/O 장치에 위치  140   ㆍ 다음 명령어 주소(Next Instruction Address) ­ 현재의 명령어 실행이 완료된 후에 다음 명령어를 인출할 위치 지정 ­ 분기 혹은 호출 명령어와 같이 실행 순서를 변경하는 경우에 필요 ▶ 명령어 형식 ㆍ 명령어 형식(instruction format) ­ CPU가 수행할 연산의 수와 종류(add) 및 복잡도(cisc, risc) ㆍ 필드(field) ­ 명령어의 각 구성 요소들에 소요되는 비트들의 그룹 ­ 명령어의 길이 = 단어(word) 길이 = CPU가 메모리로부터 ⋅ 예) 세 개의 필드들로 구성된 16­비트 명령어 16비트 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 명령어 형식의 결정에서 고려할 사항들

1) 연산 코드 필드 길이 ­ 연산의 개수를 결정(add와 같은 연산이 몇 개 있는가?) ⋅ 예) 4비트 →  = 16가지의 연산 정의 가능 ⋅ 만약 연산 코드 필드가 5비트로 늘어나면,  = 32가지 연산들 정의 가능 → 다른 필 드의 길이가 감소
2) 오퍼랜드 필드의 길이 ­ 오퍼랜드의 범위 결정 ­ 오퍼랜드의 종류에 따라 범위가 달라짐 ⋅ 데이터 : 표현 가능한 수의 범위 결정(250이라는 숫자) ⋅ 기억장치 주소 : CPU가 오퍼랜드 인출을 위하여 직접 주소를 지정 할 수 있는 기억장 치 용량 결정(간접) ⋅ 레지스터 번호 : 데이터 저장에 사용될 수 있는 레지스터의 개수 결정(8개 중에 3번) ▶ 오퍼랜드 필드의 범위의 예  ­ 오퍼랜드1은 레지스터 번호를 지정하고, 오퍼랜드2는 기억장치 주소를 지정하는 경우 ⋅ 오퍼랜드1 : 4비트 → 16개의 레지스터 사용 가능 ⋅ 오퍼랜드2 : 8비트 → 기억장치의 주소 범위 : 0~255 번지 ­ 두 개의 오퍼랜드들을 하나로 통합하여 사용하는 경우 ⋅ 오퍼랜드가 2의 보수로 표현되는 데이터라면, 표현 범위 :
- 2048 ~ + 2047 ⋅ 오퍼랜드가 기억장치 주소라면,  = 4096개의 기억장치 주소들 지정 가능  141   ▶ 오퍼랜드의 수에 따른 명령어 분류 ㆍ 1­주소 명령어(one­address instruction) ­ 오퍼랜드를 한 개만 포함하는 명령어(다른 한 오퍼랜드는 묵시적으로 AC가 됨) ⋅ 예) ADD X ; AC ← AC + M[X] ㆍ 2­주소 명령어(two­address instruction) ­ 두 개의 오퍼랜드를 포함하는 명령어 ⋅ 예) ADD R1, R2 ; R1 ← R1 + R2 MOV R1, R2 ; R1 ← R2 ADD R1, X ; R1 ← R1 + M[X] ㆍ 3­주소 명령어(three­address instruction) ­ 세 개의 오퍼랜드들을 포함하는 명령어 ⋅ 예) ADD R1, R2, R3 ; R1 ← R2 + R3 ▶ 1
-주소 명령어의 예  ­ 길이가 16비트인 1
-주소 명령어에서 연산 코드가 5비트인 경우의 명령어 형식을 정의하고, 주소지정 가능한 기억장치 용량을 결정하라 ⋅ 주소지정 가능한 기억장치 용량 : × = 4096바이트 ⋅ 명령어 형식(instruction format) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 2
-주소 명령어의 예  ­ 2
-주소 명령어 형식을 사용하는 16
-비트 CPU에서 연산 코드가 5비트이고, 레지스터의 수 는 8개이다. (a) 두 오퍼랜드들이 모두 레지스터 번호인 경우와, (b) 한 오퍼랜드는 기억장 치 주소인 경우의 명령어 형식을 정의하라 (a) 두 개의 레지스터 오퍼랜드들을 가지는 경우 (b) 한 오퍼랜드는 기억장치 주소인 경우 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 3
-주소 명령어의 예  (a) 명령어 형식  142   (b) ADD R1, R2, R3 명령어의 비트 배열 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 명령어 형식이 프로그래밍에 미치는 영향(예)  ­ 예) X = (A + B) × (C ­ D) 계산을 위한 어셈블리 프로그램 작성 ­ 아래와 같은 니모닉을 가진 명령어들을 사용 ⋅ ADD : 덧셈 ⋅ SUB : 뺄셈 ⋅ MUL : 곱셈 ⋅ DIV : 나눗셈 ⋅ MOV : 데이터 이동 ⋅ LOAD : 기억장치로부터 데이터 적재 ⋅ STOR : 기억장치로 데이터 저장 ▶ 1
-주소 명령어를 사용한 프로그램  LOAD A ; AC ← M[A] ADD B ; AC ← AC + M[B] STOR T ; M[T] ← AC LOAD C ; AC ← M[C] SUB D ; AC ← AC ­ M[D] MUL T ; AC ← AC × M[T] STOR X ; M[X] ← AC ­ 단, M[A]는 기억장치 A번지의 내용, T는 기억장치 내 임시 저장 장소의 주소 * 프로그램의 길이 = 7 ▶ 2
-주소 명령어를 사용한 프로그램  MOV R1, A ; R1 ← M[A] ADD R1, B ; R1 ← R1 + M[B] MOV R2, C ; R2 ← M[C] SUB R2, D ; R2 ← R2
- M[D] MUL R1, R2 ; R1 ← R1 × R2 MOV X, R1 ; M[X] ← R1 * 프로그램의 길이 = 6  143   ▶ 3
-주소 명령어를 사용한 프로그램  ADD R1, A, B ; R1 ← M[A] + M[B] SUB R2, C, D ; R2 ← M[C] ­ M[D] MUL X, R1, R2 ; M[X] ← R1 × R2 ­ 장점 : 명령어의 길이가 감소(메모리 적게 소요가 장점?) ­ 단점 : 명령어 해독 과정이 복잡해짐(cisc) * 프로그램의 길이 = 3  144   주소 지정 방식

1. 컴퓨터에서 사용되는 주소 지정 방식의 기본적인 내용들에 대해서 학습하고 이를 설명할 수 있다. 6주차  수업목표  
2. 컴퓨터에서 사용되는 주소 지정 방식의 다양한 종류에 대해서 2교시  학습하고 이를 설명할 수 있다.
1. 주소 지정 개요 세부내용 
2. 주소 지정 종류 1. 주소 지정 개요   ▶ 주소 지정 방식(addressing mode) ­ 명령어 실행에 필요한 오퍼랜드의 주소를 결정하는 방식 ­ 다양한 주소 지정 방식을 사용하는 이유 ⇨ 제한된 수의 명령어 비트들을 이용하여, 사용자(프로그래머)가 여러 가지 방법으로 오 퍼랜드의 주소를 결정하도록 해주며(속도), 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위함 ㆍ 명령어 내 오퍼랜드 필드의 내용 ­ 기억장치 주소 : 데이터가 저장된 기억장치의 위치를 지정 ­ 레지스터 번호 : 데이터가 저장된 레지스터를 지정 ­ 데이터 : 명령어의 오퍼랜드 필드에 데이터가 포함 ▶ 기호 ㆍ EA: 유효 주소(Effective Address), 데이터가 저장된 기억장치의 실제 주소 ㆍ A : 명령어 내의 주소 필드 내용(오퍼랜드 필드의 내용이 기억장치 주소인 경우) ㆍ R : 명령어 내의 레지스터 번호(오퍼랜드 필드의 내용이 레지스터 번호인 경우) ㆍ ( A ) : 기억장치 A번지의 내용 ㆍ ( R ) : 레지스터 R의 내용 2. 주소 지정 종류   ▶ 주소 지정 방식의 종류 ­ 직접 주소 지정 방식(direct addressing mode) ­ 간접 주소 지정 방식(indirect addressing mode) ­ 묵시적 주소 지정 방식(implied addressing mode) ­ 즉시 주소 지정 방식(immediate addressing mode) ­ 레지스터 주소 지정 방식(register addressing mode) ­ 레지스터 간접 주소 지정 방식(register
-indirect addressing mode)  145   ­ 변위 주소 지정 방식(displacement addressing mode) ⋅ 상대 주소 지정 방식(relative addressing mode) ⋅ 인덱스 주소 지정 방식(indexed addressing mode) ⋅ 베이스
- 레지스터 주소 지정 방식(base
- register addressing mode) ▶ 직접 주소 지정 방식(direct addressing mode) v 오퍼랜드 필드의 내용이 유효 주소(EA)가 되는 방식 EA = A : add 250 ⋅ 장점 ­ 데이터 인출을 위하여 한 번의 기억장치 액세스만 필요 ⋅ 단점 ­ 연산 코드를 제외하고 남은 비트들만 주소 비트로 사용될 수 있기 때문에 직접 지정할 수 있는 기억장소의 수가 제한 기억장치 EA ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 예제 2
-6 ­ CPU 내부 레지스터들과 주기억장치에 그림 2­24와 같은 값들이 저장되어 있다고 가정 하자. 여기서, CPU 레지스터 및 각 기억 장소의 폭(width)은 16비트이며, 그림에서 모 든 값들은 편의상 10진수로 표시하였다.(그림 2­24는 [예제 2
-7] 및 [예제 2­9] 에서도 공통적으로 사용됨) CPU 레지스터 주소 기억장치 [그림 2
-24] 예제 2
-6, 2
-7, 2
-9를 위한 그림 ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 문제
① 직접 주소 지정 방식을 사용하는 명령어의 주소 필드(A)에 저장된 내용이 150일 때, 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라.
② 명령어 길이가 16비트이고 연산 코드가 5비트라면, 이 명령어에 의해 직접 주소 지정 될 수 있는 기억장치 용량은 얼마인가?  146   ⋅ 풀이
① EA = 150이므로, 기억 장치 150번지에 저장된 데이터 ‘1234’가 인출된다.
② 주소 필드가 11비트이므로, 직접 주소 지정 할 수 있는 기억장치 용량은  = 2048 단어가 된다. 그런데 각 기억 장소에 저장되는 데이터의 비트 수가 16비트(2바이트)이 므로, 기억장치 용량은 4096(=2048x2)바이트로 표현할 수도 있다. ▶ 간접 주소 지정 방식(indirect addressing mode) v 오퍼랜드 필드에 기억장치 주소가 저장되어 있지만, 그 주소가 가리키는 기억 장소에 데이 터의 유효 주소를 저장해두는 방식 EA = ( A ) : add 250 기억장치 EA ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 장점 ­ 최대 기억장치용량이 단어의 길이에 의하여 결정 ⇨ 주소 지정 가능한 기억장치 용량 확장 ⋅ 단어 길이가 ■ 비트라면, 최대 개의 기억 장소에 대한 주소 지정이 가능 ⋅ 단점 ­ 실행 사이클 동안에 두 번의 기억장치 액세스가 필요 ⋅ 첫 번째 액세스 : 주소 인출(EA) ⋅ 두 번째 액세스 : 그 주소가 지정하는 기억 장소로부터 실제 데이터 인출 ㆍ 명령어 형식에 간접비트(I) 필요 ­ 만약 I = O 이면, 직접 주소 지정 방식 ­ 만약 I = 1 이면, 간접 주소 지정 방식 → 간접 사이클 실행 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 다단계(multi ­ level) 간접 주소 지정 방식 ­ EA= ( ( . . (A) . . ) )  147   ◼ 예제 2
-7 ­ CPU 레지스터들과 주기억장치에 그림 2
-24와 같은 값들이 저장되어 있을 때 다음 물음 에 답하라. CPU 레지스터 주소 기억장치 [그림 2
-24] 예제 2
-6, 2
-7, 2
-9를 위한 그림 ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 문제
① 간접 주소 지정 방식을 사용하는 명령어의 주소 필드(A)에 저장된 내용이 ‘172’라고 가 정했을 때, 유효 주소(EA) 및 그에 의해 인출되는 데이터를 구하라.
② 이 명령어에 의해 주소 지정될 수 있는 기억장치 용량은 얼마인가? ⋅ 풀이
① EA는 그림 2
-24의 기억장치 172번지에 저장되어 있는 ‘202’이다(EA). 따라서 명령어 실행에 사용될 데이터로는 기억장치 202번지에 저장되어 있는 ‘3256’이 인출된다.
② 주소(EA)의 길이는 16비트가 되므로, 주소 지정할 수 있는 기억장치 용량은  = 64K word(128KByte)가 된다. ▶ 묵시적 주소 지정 방식(implied addressing mode) v 명령어 실행에 필요한 데이터의 위치가 묵시적으로 지정되는 방식 ⋅ 예)
- ‘SHL’ 명령어 : 누산기의 내용을 좌측으로 시프트(shift)
- PUSH R1’ 명령어 : 레지스터 R1의 내용을 스택에 저장(SP가 가리키는 기억장소 에 R1의 내용을 저장한다는 것이 묵시적으로 정해져 있음) ­ 명령어 길이가 김(메모리 많이 소요) ­ 단점 : 종류가 제한됨 ▶ 즉시 주소 지정 방식(immediate addressing mode) v 데이터가 명령어에 포함되어 있는 방식(오퍼랜드 필드의 내용이 연산에 사용할 실제 데이 터) ⋅ 용도 ­ 프로그램에서 레지스터나 변수의 초기 값을 어떤 상수값(constant value)으로 세트하는 데 사용(초기화) : add 250 ⋅ 장·단점 ­ 장점 : 데이터를 인출하기 위하여 기억장치를 엑세스할 필요가 없음(속도가 가장 빠름)  148   ­ 단점 : 상수값의 크기가 오퍼랜드 필드의 비트 수에 의해 제한됨 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 레지스터 주소 지정 방식(register addressing mode) v 연산에 사용될 데이터가 내부 레지스터에 저장되어 있는 경우, 명령어의 오퍼랜드가 해당 레지스터를 가리키는 방식 EA = R : add 3 ­ 주소 지정에 사용될 수 있는 레지스터들의 수 = k 개(단, k는 R 필드의 비트 수) EA 레지스터 세트 ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 장점 ­ 오퍼랜드 필드의 비트 수가 적어도 됨 ­ 데이터 인출을 위하여 기억장치 엑세스가 필요 없음(빠름) ⋅ 단점 ­ 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터들로 제한(적은 개수만 사용 가능) ▶ 레지스터 간접 주소 지정 방식(register indirect addressing mode) v 오퍼랜드 필드(레지스터 번호)가 가리키는 레지스터의 내용을 유효 주소로 사용하여 실제 데이터를 인출하는 방식 EA = ( R ) : add 3 기억장치 EA 레지스터 세트 ※ 컴퓨터구조론, 생능출판사, 2019  149   ◼ 예제 2
-9 ­ CPU 내부 레지스터들과 주기억장치에 그림 2
-24와 같은 값들이 저장되어 있고, 그림 2
-28과 2
-29의 명령어 형식에서 레지스터 필드 R에는 ‘2’가 저장되어 있다고 가정하자. CPU 레지스터 주소 기억장치 [그림 2
-24] 예제 2
-6, 2
-7, 2
-9를 위한 그림 ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 문제
① 레지스터 주소 지정 방식이 사용된다면, 연산 처리 과정에서 어떤 데이터가 사용될 것 인가?
② 레지스터 간접 주소 지정 방식이 사용된다면, 어떤 데이터가 사용될 것인가? ⋅ 풀이
① R2에 저장되어 있는 데이터 ‘151’이 사용된다.
② 기억장치 151번지에 저장되어 있는 데이터 ‘5678’이 사용된다. ⋅ 장점 ­ 주소 지정 할 수 있는 기억장치 영역이 확장 ⋅ 레지스터의 길이 = 16비트라면, 주소 지정 영역 :  = 64K 바이트 ⋅ 레지스터의 길이 = 32비트라면, 주소 지정 영역 :  = 4G 바이트 ▶ 변위 주소 지정 방식(displacement addressing mode) v 직접 주소 지정과 레지스터 간접 주소 지정 방식의 조합 EA = A + ( R ) ­ 사용되는 레지스터에 따라 여러 종류의 변위 주소 지정 방식 가능 ⋅ PC → 상대 주소 지정 방식(relative addressing mode) ⋅ 인덱스 레지스터 ← 인덱스 주소 지정 방식(indexed addressing mode) ⋅ 베이스 레지스터 → 베이스­레지스터 주소 지정 방식(base­register addressing mode) ▶ 상대 주소 지정 방식(relative addressing mode) v 프로그램 카운터(PC)를 레지스터로 사용하여 EA를 계산 EA = A + ( PC ) / 단, A 는 2의 보수 ­ 주로 분기 명령어에서 사용(원래 0번지부터 분기)  150   ⋅ A
> 0 : 앞(forward) 방향으로 분기 ⋅ A < 0 : 뒷(backward) 방향으로 분기 PC EA ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 예제 2
-10 ­ 상대 주소 지정 방식을 사용하는 JUMP 명령어가 450번지에 저장되어 있다. ◼ 문제
① 만약 오퍼랜드 A = ‘21’이라면, 몇 번지로 점프하는가?
② 만약 오퍼랜드 A = ‘
-50’이라면, 몇 번지로 점프하는가? ⋅ 풀이
① 이 명령어가 인출된 후에는 PC의 내용이 451로 증가된다. 따라서 451 + 21 = 472 번지로 점프하게 된다.
②
①번과 같은 원리로, 451 ­ 50 = 401번지로 점프하게 된다. ⋅ 장점 ­ 전체 기억장치 주소가 명령어에 포함되어야 하는 일반적인 분기 명령어(0번지)보다 적은 수의 비트만 필요 ⋅ 단점 ­ 분기 범위가 오퍼랜드 필드의 길이에 의해 제한(오퍼랜드 비트들로 표현 가능한 2의 보 수 범위) ▶ 인덱스 주소 지정 방식(indexed addressing mode) v 인덱스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정 EA = ( IX ) + A ­ 인덱스 레지스터(IX) : 인덱스(index) 값을 저장하는 특수­목적 레지스터 ⋅ 주요 용도 ­ 배열 데이터 액세스 ⋅ 예) ­ 데이터 배열이 기억장치의 500 번지부터 저장되어 있고, 명령어의 주소 필드에 ‘500’ 이 포함되어 있을 때, 인덱스 레지스터의 내용 ­ (IX) = 3이라면 → 데이터 배열의 네 번째 데이터 액세스  151   기억장치 인덱스 데이터 레지스터 배열 ※ 컴퓨터구조론, 생능출판사, 2019

1) 자동 인덱싱(auto ­ indexing) ­ 명령어가 실행될 때마다 인덱스 레지스터의 내용이 자동적으로 증가 혹은 감소 ­ 이 방식이 사용된 명령어가 실행되면 아래의 두 연산이 연속적으로 수행됨 : 배열 “abcd” 를 대문자로 바꾸시오 EA = ( IX ) + A IX ← IX + 1 ▶ 베이스 레지스터 주소 지정 방식(base register addressing mode) v 베이스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정 EA = ( BR ) + A ⋅ 주요 용도 ­ 프로그램의 위치 지정(혹은 변경)에 사용(program relocation) ⋅ 예) 다중프로그래밍(multiprogramming) 환경에서 프로그램 코드 및 데이터를 다른 위치로 이동시켜야 할 때, 분기 명령어나 데이터 액세스 명령어들의 주소 필드 내용 을 바꿀 필요 없이, BR 레지스터의 내용만 변경하면 됨  152   상용 명령어 형식
1. 상용 명령어 형식 중 펜티엄 계열에 대해서 학습하고 이를 설명할 수 있다. 6주차  수업목표  
2. 상용 명령어 형식 중 ARM 계열에 대해서 학습하고 이를 3교시  설명할 수 있다.
1. 펜티엄 계열 세부내용 
2. ARM 계열 1. 펜티엄 계열   ▶ 실제 상용 프로세서들의 명령어 형식 – CISC ㆍ CISC(Complex Instruction Set Computer) 프로세서 ­ 명령어들의 수가 많음 ­ 명령어 길이가 일정하지 않음(명령어 종류에 따라 달라짐) ­ 주소 지정 방식이 매우 다양함 ⋅ 예) PDP 계열 프로세서(DEC), Intel Pentium 계열 프로세서
1) CISC의 특징 ­ 명령어가 복잡하기 때문에 명령어를 해석하는 데 시간이 오래 걸리며, 명령어 해석에 필요 한 회로도 복잡함 ­ 보통 풍부한 어드레싱 기능을 갖추고 있어 명령의 직교성이 좋으며, 어느 어드레싱 모드에 서도 임의의 연산을 수행할 수 있음(기능 중첩x, 최소 명령어) ­ 연산에 대해서는 레지스터와 레지스터 연산, 레지스터와 메모리 연산, 메모리와 메모리 연 산을 모두 갖추고 있는 것이 보통임 ­ 피연산자(operand)는 2개에서 3개까지 지정할 수 있는 경우가 많음 ­ 즉, 메모리 1의 내용과 메모리 2의 내용의 논리곱을 취해 메모리 3에 넣는 일을 하나의 명 령어로 수행할 수 있음 ­ C 언어의 연산자는 CISC인 PDP
-11이 갖추고 있던 명령에서 나온 것임(DEC, 1970~90, 16비트 미니컴퓨터) ­ 인덱스 어드레싱시의 오프셋도 명령의 데이터의 길이에 맞추어 바뀌는 것이 많음 ­ 또, 길이가 다른 데이터 사이의 연산에서도 연산 전에 자동적으로 부호 확장 등이 수행되기 때문에, 데이터 길이를 가지런히 하는 명령어가 필요 없는 경우가 많음 ­ 하나의 명령어를 수행하는 처리가 복잡하기 때문에, 마이크로 프로그램 방식을 채택하는 경 우가 많음(펌웨어) v 복잡 명령어 집합 컴퓨터(Complex Instruction Set Computer, CISC)는 복잡한 명령어 집합을 갖는 CPU 아키텍처임 ⋅ 주로 메인프레임이나 X86 호환 프로세서, 모토로라사의 MC 680x0 (68K)계열 프로세 서에서 이 방식을 사용하고 있음(대형컴퓨터, IBM
-s/360) ⋅ 펜티엄 시리즈와 같은 CISC CPU도 내부적으로는 복잡한 명령들을 다시 단순한 명령들  153   로 나누어 명령어 파이프라인에서 처리하기 때문에, 실제 내부 작동원리는 RISC와 같 다고 할 수 있음 ▶ 실제 상용 프로세서들의 명령어 형식 
- RISC ㆍ RISC(Reduced Instruction Set Computer) 프로세서 ­ 명령어들의 수를 최소화 ­ 명령어 길이를 일정하게 고정 ­ 주소 지정 방식의 종류를 단순화 ⋅ 예) ATmega microcontroller(Atmel), ARM 계열 프로세서 v 축소 명령어 집합 컴퓨터(Reduced Instruction Set Computer, RISC)는 CPU 명령어의 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만드는 방식으로, 마이크로프로세서(CPU)를 설계하는 방법 가운데 하나이며, SPARC, MIPS 등의 아키텍처에서 사용됨 ⋅ 전통적인 CISC CPU에는 프로그래밍을 돕기 위한 많은 수의 명령어와 주소 모드가 존 재했음 ⋅ 그러나 그 중에서 실제로 쓰이는 명령어는 몇 개 되지 않는다는 사실을 바탕으로, 적은 수의 명령어만으로 명령어 집합을 구성한 것이 RISC임 ⋅ 그래서, RISC는 CISC보다 구조가 더 단순함 ⋅ 복잡한 연산도 적은 수의 명령어들을 조합하는 방식으로 수행이 가능함 : 프로그램 길 이가 길어짐 ⋅ 그리고 CISC 형식의 CPU내 ROM에 소프트웨어적으로 적재된 내부 명령어(펌웨어)들 을 하드웨어적으로 구성하여 제어기가 제거된 부분에 프로세서 레지스터 뱅크와 캐시를 둠(레지스터 개수) ⋅ 이렇게 함으로써 CPU가, 상대적으로 느린 메인 메모리에 접근하는 횟수를 줄여주어 파 이프라이닝 등 시스템 수행속도가 전체적으로 향상됨

1) RISC의 특징 ­ 고정 길이의 명령어를 사용하여 더욱 빠르게 해석할 수 있음 ­ 모든 연산은 하나의 클럭으로 실행되므로 파이프라인을 기다리게 하지 않음(실행 시간 동 일) ­ 레지스터 사이의 연산만 실행하며, 메모리 접근은 로드(load), 스토어(store) 명령어로 제한 되는데, 이렇게 함으로써 회로가 단순해지고, 불필요한 메모리 접근을 줄일 수 있음 ­ 마이크로코드 논리(펌웨어)를 사용하지 않아 높은 클럭을 유지할 수 있음(하드웨어) ­ 많은 수의 레지스터를 사용하여 메모리 접근을 줄임 ­ 지연 실행 기법을 사용하여 파이프라인의 위험을 줄임 : 어차피 수행할 명령어 미리 처리 ­ CISC에서는 하드웨어가 스택을 지원, RISC에는 SW 지원 ­ 스택 제어(데이터의 PUSH, POP이 발생할 때 레지스터의 사용, 서브루틴에 점프했을 때의 리턴 주소의 보존, 복귀) 의 처리는 단순한 명령을 조합하여 소프트웨어로 구현됨 ­ 명령어의 순서로 인해 발생할 수 있는 파이프라인의 위험은 컴파일하는 동안 최적화되어 사라짐(지연 실행)  154   ­ 명령어의 길이를 고정하면 파이프라인 처리의 고속화를 꾀할 수 있지만, 컴파일러의 최적화 과정이 복잡해지기 쉬움 ­ RISC는 대부분의 현대 프로세서 디자인에 채택되고 있고, 또 비교적 전력 소모가 적기 때 문에 임베디드 프로세서에도 채택되고 있음 ­ 펜티엄과 같은 CISC CPU도 내부적으로는 복잡한 명령들을 단순한 명령들로 나누어 파이프 라인에서 처리하기 때문에, 실제 작동 원리는 RISC와 같음 ▶ 실제 상용 프로세서들의 명령어 형식  ㆍ PDP­10 프로세서 ­ 고정 길이의 명령어 형식 사용(DEC, 1980) ­ 단어의 길이 = 36비트, 명령어의 길이 = 36비트 ­ 연산 코드 = 9비트 → 최대 512 종류의 연산 허용(실제 365개) 간접 비트 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ PDP­11 프로세서 ­ 다양한 길이의 명령어 형식들 사용(DEC, 1990) ­ 연산 코드 = 4 ~ 16비트 ­ 주소 개수 : 0, 1, 2개 ▶ PDP
-11의 명령어 형식들(레지스터, 상대주소, 부동소수점, 조건)  ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 펜티엄 계열 프로세서의 명령어 형식  ㆍ 선형 주소(Linear address : LA) ­ 프로세서가 발생하는 주소(실제 기억장치 액세스)  155   = 유효 주소 + 세그먼트의 시작 주소(각 세그먼트의 시작 주소는 해당 Segment Register(SR)에 저장) 주소 지정 방식 유효 주소(EA) 선형 주소(LA) 즉시방식 데이터 = A 레지스터 방식 EA = R LA = R 변위 방식 EA = A LA = (SR) + EA 베이스 방식 EA = (BR) LA = (SR) + EA 변위를 가진 베이스 방식 EA = (BR) + A LA = (SR) + EA 변위를 가진 인덱스 방식 EA = (IX) + A LA = (SR) + EA 인덱스와 변위를 가진 베이스 방식 EA = (IX) + (BR) + A LA = (SR) + EA 상대 방식 EA = (PC) + A LA = EA ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 즉시 방식(immediate mode) ­ 데이터가 명령어에 포함되는 방식 ⋅ 데이터의 길이 = 바이트, 단어(word) 혹은 2중 단어(double word) ㆍ 레지스터 방식(register mode) ­ 유효 주소(EA)가 레지스터에 들어 있는 방식 ㆍ 변위 방식(displacement mode) ­ 명령어에 포함된 변위(주소)가 유효 주소로 사용되는 방식으로서, 직접 주소 지정 방식 에 해당 ㆍ 베이스 방식(base mode) ­ 레지스터 간접 주소 지정에 해당 ㆍ 상대 방식(relative mode) ­ 변위값과 프로그램 카운터의 값을 더하여 다음 명령어의 주소로 사용하는 방식 ▶ 펜티엄 계열 명령어 형식의 필드들 ㆍ 연산 코드(Op code) ­ 연산의 종류 지정 ­ 길이 = 1 or 2 바이트 ㆍ MOD / RM ­ 주소 지정 방식 지정 ㆍ SIB ­ MOD / RM 필드와 결합하여 주소 지정 방식을 완성 ㆍ 변위(displacement) ­ 부호화된 정수(변위)를 저장 ㆍ 즉시(immediate) ­ 즉시 데이터를 저장  156   바이트 수 : ※ 컴퓨터구조론, 생능출판사, 2019 ­ MOD + R/M : 32가지 주소 지정 방식 ­ Reg/Op Code : 레지스터 번호 또는 MOD와 결합 ­ SS : 인덱싱을 위한 스케일 계수 ­ Index : 인덱스 레지스터, Base : 베이스 레지스터 2. ARM 계열   ▶ ATmega Microcontroller 명령어 형식

1) ATmega128 microcontroller의 CPU 코어 ­ 8­비트 CPU(Atmel) ­ 명령어 길이 = 16비트 ­ 기억장치 액세스 명령어들(LOAD, STORE)은 32비트 ­ RISC 프로세서 ㆍ 특징 ­ 연산 코드의 비트 수가 명령어에 따라 달라짐 ­ 오퍼랜드의 위치가 유동적 ▶ ATmega Microcontroller 명령어 형식의 예
① ADD Rd, Rr ; Rd ← Rd + Rs
② ASR Rd ; 레지스터 Rd에 대하여 산술적 우측 시프트 수행(부호 비트)
③ JMP K ; K 번지로 무조건 점프
④ BRVS K ; V 플래그가 세트 되었다면, K 번지로 분기
⑤ LDS Rd, K ; K 번지의 내용을 읽어서 Rd에 적재 (a) ADD Rd.Rr 명령어 (b) ASR Rd 명령어  157   (c) JMP K 명령어 (d) BRVS K 명령어 (e) LDS Rd.K 명령어 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ ARM(Advanced RISC Machine) 계열 프로세서 ­ 32
-비트 RISC 프로세서(ARM) ­ 개방형 아키텍처(Open Architecture) : 기술 공유, 이식 ­ 모바일 시스템용 프로세서로 널리 사용 ㆍ 명령어 필드들 ­ 분기조건 필드, 연산 필드, 오퍼랜드 필드 등 ­ 조건 플래그 : N(음수), Z, C, V ­ 레지스터 필드 : Rn(베이스), Rd(목적지), Rs(근원지) ­ P, U, W 비트 : 주소 지정 방식 결정 ­ B 비트 : 연산처리 단위 결정, 바이트(B=1) 혹은 단어 (B=0)

1) ARM 프로세서의 명령어 형식들 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 3비트 : 명령어의 연산 유형 분류(데이터 처리, 조건 분기..) ­ S : 조건 플래그 갱신, offset : 분기, L : load or store ▶ ARM(Advanced RISC Machine) 계열 프로세서 – 역사 v ARMv4 아키텍처는 32비트 주소 영역에서 32비트 ISA(Instruction Set Architecture) 동 작이 가능함 ⋅ 16비트 Thumb 명령어 셋을 탑재한 ARMv4T 아키텍처는 32비트 코드의 이점을 그대 로 살리고, 메모리 공간을 35% 이상 절약할 수 있도록 해주었음(비즈니스)  158  
1) ARMv5TE(1999년) 아키텍처 ­ ARMv5TE(1999년) 아키텍처는 개선된 thumb 아키텍처와 ‘Enhanced’ DSP 명령어 셋을 ARM ISA에 추가하였음(Digital Signal Processing) ­ 이러한 Thumb의 변화에는 소수의 명령어 추가와 함께 ARM/Thumb 인터워킹 (interworking)의 개선, 컴파일 성능의 대폭적인 향상, ARM/Thumb 루틴의 혼합 사용, 코 드 크기와 성능에 대한 균형도 포함되어 있음 ­ 또한 ‘Enhanced’ DSP 명령어들은 복잡한 수치연산에서 70%의 성능 개선을 보여주었음
2) ARMv5TEJ(2000년) 아키텍처 ­ ARMv5TEJ(2000년) 아키텍처에는 Jazelle(제이젤, 자바 하드웨어 가속기) 확장명령어가 추 가되었으며, 이로써 자바 가속 기술을 탑재한 아키텍처가 탄생하게 됨 ­ ARMv5TJE 아키텍처는 Jazelle(제이젤)이 탄생함에 따라 가속 기술을 사용하지 않은 JVM(Java Virtual Machine) 보다 속도 면에서 8배가 향상되었으며, 소비전력의 측면에서 도 80%를 줄일 수 있게 됨(호환성, 이식성)
3) ARMv6(2001년) 아키텍처 ­ ARMv6(2001년) 아키텍처가 발표되면서 여러 방면에서 기능 개선이 이루어졌음 ­ 특히 메모리 시스템, 예외 처리의 개선, 멀티프로세싱 환경을 위한 더 많은 지원 등이 이에 해당함 ­ 이것 이외도 ARMv6 아키텍처에는 SIMD(Single Instruction Multiple Data) 소프트웨어 실행을 지원하는 미디어 명령이 포함되어 있으며, SIMD 명령들은 오디오 및 비디오 코덱 을 포함하는 응용 프로그램들의 사용 확대를 위해 최적화되었음(벡터 계산, GPU)
4) ARM1136J(ex))
-8 코어(2002년) 아키텍처 ­ 스트롱암(StrongARM) CPU는 DEC(Digital Equipment Corporation)에 의해서 ARM과 함께 개발되었음(더 빠른) ­ 이것이 최초의 modified
- Harvard 아키텍처(명령어 캐시와 데이터 캐시를 분리해서 사용) 를 채용한 제품이며, modified
- Harvard 아키텍처로 ARM의 쓰기 처리 능력의 고속화가 가능하게 되었음 ­ 스트롱암의 주요 특징 중에는 5단계 파이프라인의 채용, 64비트 곱셈 및 일부 곱셈 기능을 제외한 모든 일반 명령어들의 싱글 사이클 처리 등이 포함되어 있음(1 클럭)  159   ALU의 구성 요소

1. 산술논리연산장치인 ALU의 기본적인 구성에 대해서 학습하고 이를 설명할 수 있다. 7주차  수업목표  
2. ALU의 구성 요소 중 논리 장치에 대해서 학습하고 이를 1교시  설명할 수 있다.
1. ALU의 구성 세부내용 
2. 논리 장치 1. ALU의 구성   ▶ ALU의 구성 요소 ㆍ 산술 연산장치 ­ 산술 연산들(+,
-, ×, ÷)을 수행 ㆍ 논리 연산장치 ­ 논리 연산들(AND, OR, XOR, NOT 등)을 수행 ㆍ 시프트 레지스터(shift register) ­ 비트들을 좌측 혹은 우측으로 이동 : 2로 곱하거나 나누는 효과 ㆍ 보수기(complementer) ­ 2진 데이터를 2의 보수로 변환(음수화) : 덧셈을 이용한 뺄셈 ㆍ 상태 레지스터(status register) ­ 연산 결과의 상태를 나타내는 플래그(flag)들을 저장하는 레지스터 : CSZV ▶ ALU의 구성 요소 – 상태 레지스터 ㆍ Z ­ 제로 플래그 ­ 연산 결과가 0일 경우에 참이 됨 ㆍ C ­ 캐리 플래그 ­ 부호 없는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 참이 됨 ㆍ A ­ 보조 캐리 플래그 ­ 연산 결과 하위 니블(4bits)에서 비트 범위를 넘어섰을 때 참이 되며, 이진화 십진법 (BCD) 연산(4bits)에 사용됨 ㆍ V / O / W ­ 오버플로 플래그 ­ 부호 있는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 참이 됨 ㆍ N / S ­ 네거티브 플래그, 사인 플래그 ­ 연산 결과가 음수일 때 참이 됨 ㆍ I / E ­ 인터럽트 플래그 ­ 이 플래그가 참일 경우에만 인터럽트 요구를 받아들이며, 일반적으로 관리자 모드에서만 값을 변경 할 수 있음 ㆍ P ­ 패리티 플래그  160   ­ 1로 된 비트의 수가 짝수일 경우 참이 됨 : 홀수 패리티 ㆍ D ­ 디렉션 플래그 ­ 문자열 조작에서 참일 경우 주소 레지스터 값이 자동으로 감소하고, 거짓일 경우 자동으 로 증가함 : 인덱스 ㆍ D / T ­ 디버그 플래그, 트랩 플래그 ­ 참일 경우 한 명령이 실행할 때마다 인터럽트가 발생하며, 디버깅에 사용됨 ▶ ALU의 내부 구성 요소들 : 플래그들(조건 분기 명령어), 제어신호(add) 입력 데이터 입력 데이터 출력 데이터 플레그들 제어 신호들 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ ALU의 내부 구성 요소들 ­ 컴퓨터에서 수행하는 산술 연산과 논리 연산을 수행하는 장치 ­ ALU를 어떻게 설계하느냐에 따라서 연산의 개수가 결정됨

1) 간단하게 설계된 ALU : 4x1 MUX 연산 선택 입력선   Sel 2 Sel 1 연산 결과 산술연산 처리기 이동 처리기 연산 논리연산 처리기 결과 (a) ALL의 내부 구조 (b) 멀티플렉서의 연결 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ­ (a)는 산술 연산을 위한 처리기, 논리 연산을 위한 처리기 그리고 이동 처리를 위한 이동 처리기가 있음 ­ (b)는 처리기들이 4 x 1 멀티플렉서(MUX)를 통해서 연산의 결과를 출력하는 (a)의 우측 부분을 확대해서 나타낸 것  161  
2) 산술연산 처리기 : XOR
-보수, 기억장치 없음 ­ 4비트의 덧셈과 뺄셈 연산을 수행하도록 설계되었음 ­ 전가산기(ex)A) 4개를 가지고 조합논리회로를 구성됨 Sel 0                          ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미

3) 논리연산 처리기 ­ AND, OR, XOR, 보수 연산을 수행 ­ 각 해당 산술 연산의 논리 게이트가 4X1 멀티플랙서에 연결 Sel 0 Sel 1       ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미
4) 이동 처리기 ­ 양쪽으로 이동하는 레지스터로 2의 곱셈과 나눗셈 연산을 수행함 ­ 레지스터는 4개의 D 플립플롭을 가지고 설계된 순차 논리회로임 : 기억장치(D 플립플롭) ㆍ 이동 처리기 : 2번째 D 플립플롭의 입력을 보자 Sel 0 왼쪽 입력         오른쪽 입력 D 플리플롭 ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미  162  
5) 레지스터 : 명령어, 데이터, 주소 임시 기억 ­ CPU에서 사용되는 데이터 정보를 임시적으로 저장하는 장치 ­ 플립플롭(D)의 연결을 기본으로 하는 순차 논리회로 ­ 4비트 데이터를 병렬로 읽기와 쓰기가 가능한 레지스터 데이터 입력         클록 펄스 데이터 출력         ※ 컴퓨터 구조와 원리2.0, 신종홍, 한빛아카데미 ▶ 정수의 표현 v 2진수 체계 0, 1, 부호 및 소수점으로 수를 표현 ⋅ 예)     v 부호 없는 정수 표현의 예 00111001 = 57 00000000 = 0 00000001 = 1 10000000 = 128 11111111 = 255 v ■ ­ 비트 2진수를 부호 없는 정수 A로 변환하는 방법  × ×  × ×   ⋯   ▶ 소수와 음수의 표현 v 최상위 비트인  의 좌측에 소수점이 있는 소수의 10진수 변환 방법   × ×  × ×   ⋯   ⋅ 예)        : 자리수(weight) 1 1 0 1 . 1 0 1 ×××××××  v 음수 표현 방법 ­ 부호화
- 크기 표현(signed
- magnitude representation) ­ 1의 보수 표현(1's complement representation) ­ 2의 보수 표현(2's complement representation)  163   ▶ Sign–magnitude representation ­ 맨 좌측 비트는 부호(sign) 비트, 나머지(n
-1)개의 비트들은 수의 크기(magnitude)를 나타 내는 표현 방식 ⋅ 예) + 9 = 0 0001001 + 35 = 0 0100011
- 9 = 1 0001001
- 35 = 1 0100011 * 부호화 ­ 크기로 표현된 2진수  ⋯  를 10진수로 변환      × ×  × ×   ⋯   ⋅ 예) 0 0100011 ×××××××  1 0001001 ××××××× 

1) 결점 ­ 덧셈과 뺄셈을 수행하기 위해서는 부호 비트와 크기를 비교하여 처리하는 복잡한 과정 필 요(별도 처리 필요) ­ 0에 대한 표현이 두 개 존재(표현 가능한 수 감소) 0 0000000 = + 0 1 0000000 =
- 0 ⇨ ■ ­ 비트 단어로 표현할 수 있는 수들이 개가 아닌, 개로 감소 ▶ Complement representation ㆍ 1의 보수(1's complement) 표현 ­ 모든 비트들을 반전(0 → 1, 1 →

0) ㆍ 2의 보수(2's complement) 표현 ­ 모든 비트들을 반전하고, 결과값에 1을 더함 ⋅ 예) + 9 = 0 0001001 + 35 = 0 0100011
- 9 = 1 1110110(1의 보수)
- 35 = 1 1011100(1의 보수)
- 9 = 1 1110111(2의 보수)
- 35 = 1 1011101(2의 보수) ㆍ 8­비트 2진수로 표현할 수 있는 10진수의 범위 ­ 1의 보수 :  ~  : 0이 2개 ­ 2의 보수 :  ~  : 많이 사용  164   10진수 1의 보수 2의 보수 127 01111111 01111111 126 01111110 01111110 ⋮ ⋮ ⋮ 2 00000010 00000010 1 00000001 00000001 +0 00000000 00000000
-0 11111111
-
-1 11111110 11111111
-2 11111101 11111110 ⋮ ⋮ ⋮
-126 10000001 10000010
-127 10000000 10000001
-128
- 10000000 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 2의 보수 → 10진수 변환 v 2의 보수로 표현된 양수 를 10진수로 변환하는 방법   × ×  × ×   ⋯   v 2의 보수로 표현된 음수 를 10진수로 변환하는 방법   × ×⋯ × ×     ⋅ 예) 10101110 ××××  ⋅ 다른 방법) 10101110 → 01010010으로 먼저 변환한 후, 음수 표시 01010010 ×××  : 2의 보수 후 ­(부호) ▶ Bit extension

1) 데이터의 길이(비트 수)를 늘리는 방법 ㆍ 필요성 ­ 데이터를 더 많은 비트의 레지스터에 저장하거나, 더 긴 데이터와 연산을 수행하기 위해 필요(32
-64비트) ◼ 예제 3
-7 ­ 10진수 ‘21’과 ‘
-21’에 대한 8 ­ 비트 길이의 부호화 ­ 크기 표현을 16 ­ 비트 길이로 확장하라(부호를 최상위, 나머지

0) ⋅ 풀이 + 21 = 00010101 (8 ­ 비트 부호화 ­ 크기 표현) + 21 = 0000000000010101 (16 ­ 비트 부호화 ­ 크기 표현)
- 21 = 10010101 (8 ­ 비트 부호화 ­ 크기 표현)
- 21 = 1000000000010101 (16 ­ 비트 부호화 ­ 크기 표현) ※ 컴퓨터구조론, 생능출판사, 2019  165   ▶ Sign 
- Bit extension

1) 2의 보수 표현의 경우 ­ 확장되는 상위 비트들을 부호 비트와 같은 값으로 세트 ­ 부호
- 비트 확장(sign
-bit extension)이라 함 ◼ 예제 3
-8 ­ 10진수 ‘21’과 ‘
-21’에 대한 8 ­ 비트 길이의 2의 보수 표현을 16 ­ 비트 길이로 확장 하라 ⋅ 풀이 + 21 = 00010101 (8 ­ 비트 2의 보수) + 21 = 0000000000010101 (16 ­ 비트 2의 보수)
- 21 = 11101011 (8 ­ 비트 2의 보수)
- 21 = 1111111111101011 (16 ­ 비트 2의 보수) ※ 컴퓨터구조론, 생능출판사, 2019 2. 논리 장치   ▶ 기본적인 논리 연산들 : XOR
-용도 다양 A B NOT A NOT B A AND B A OR B A XOR B 0 0 1 1 0 0 0 0 1 1 0 0 1 1 1 0 0 1 0 1 1 1 1 0 0 1 1 0 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 논리 연산을 위한 하드웨어 모듈

1) 하드웨어의 구성 ­ 입력 비트들은 모든 논리 게이트들을 통과 ­ 선택 신호들에 의하여 4X1 멀티플렉서(MUX)의 네 입력들 중의 하나를 출력   S S 출력 연산   0 0 ex) = A∧B AND  0 1 ex) = A∨B OR 1 0 ex) = A⊕B XOR 1 1 ex) =   NOT     ※ 컴퓨터구조론, 생능출판사, 2019  166   ▶ N
-비트 논리 연산장치

1) N­비트 데이터들을 위한 논리 연산장치 ­ 기본 논리 모듈들을 병렬로 접속 ⋅ 예) 4­비트 논리 연산장치                             ※ 컴퓨터구조론, 생능출판사, 2019 ▶ AND 연산 / OR 연산 ㆍ AND 연산 ­ 두 데이터 단어들의 대응되는 비트들 간에 AND 연산을 수행 (연산 결과) ㆍ OR 연산 ­ 두 데이터 단어들의 대응되는 비트들 간에 OR 연산 수행 (연산 결과) ▶ XOR 연산 / NOT 연산 ㆍ XOR 연산 ­ 두 데이터 단어들의 대응되는 비트들 간에 exclusive
-OR(XOR) 연산을 수행 : 1의 개수 가 홀수 개 (연산 결과) ㆍ NOT 연산 ­ 데이터 단어의 모든 비트들을 반전(invert) : 입력 1비트 (연산 전) (연산 결과)  167   ▶ Selective 
- set / Selective – complement 연산 ㆍ 선택적 ­ 세트(selective ­ set) 연산 ­ B 레지스터의 비트들 중에서 1로 세트 된 비트들과 같은 위치에 있는 A 레지스터의 비 트들을 1로 세트 <OR 연산 이용> (연산 전) (연산 결과) ㆍ 선택적 ­ 보수(selective ­ complement) 연산 ­ B 레지스터의 비트들 중에서 1로 세트 된 비트들에 대응되는 A 레지스터의 비트들을 보수로 변환 <XOR 연산 이용> (연산 전) (연산 결과) ▶ Mask 연산 ㆍ 마스크(Mask) 연산 ­ B 레지스터의 비트들 중에서 값이 0인 비트들과 같은 위치에 있는 A 레지스터의 비트 들을 0으로 바꾸는(clear하는) 연산 <AND 연산 이용> ⋅ 용도
- 단어 내의 원하는 비트들을 선택적으로 clear하는데 사용 ⋅ 예) (연산 전) (연산 결과) ▶ Insert 연산 ㆍ 삽입(Insert) 연산 ­ 새로운 비트 값들을 데이터 단어 내의 특정 위치에 삽입 ⋅ 방법
① 삽입할 비트 위치들에 대하여 마스크(AND) 연산 수행
② 새로이 삽입할 비트들과 OR 연산을 수행 ⋅ 예) 마스크(AND 연산) 첫 단계 결과 삽입(OR 연산) 최종(삽입) 결과  168   ▶ Compare 연산 ㆍ 비교(compare) 연산 ­ A와 B 레지스터의 내용을 비교 → XOR 연산 ⋅ 만약 대응되는 비트들의 값이 같으면, A 레지스터의 해당 비트를 ‘0’으로 세트 ⋅ 만약 서로 다르면, A 레지스터의 해당 비트를 ‘1’로 세트 ⋅ 모든 비트들이 같으면(A = 00000000), Z 플래그를 1로 세트 ⋅ 예) (연산 결과)  169   정수 산술 연산

1. 정수의 산술 연산을 위한 시프트 연산의 동작 원리를 이해하고 설명할 수 있다. 7주차  수업목표  
2. 컴퓨터 내에서 수행되는 정수 연산에 대해서 학습하고 이를 2교시  설명할 수 있다.
1. 시프트 연산 세부내용 
2. 정수 연산 1. 시프트 연산   ▶ Logical shift
1) 논리적 시프트(logical shift) ­ 레지스터 내의 데이터 비트들을 왼쪽 혹은 오른쪽으로 한 칸씩 이동 ㆍ 좌측 시프트(left shift) ­ 모든 비트들을 좌측으로 한 칸씩 이동 ­ 최하위 비트()로는 ‘0’이 들어오고, 최상위 비트()는 버림   ← ← ← ← 0        버림 0 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 우측 시프트(right shift) ­ 모든 비트들이 우측으로 한 칸씩 이동 ­ 최상위 비트()로 ‘0’이 들어오고, 최하위 비트()는 버림   ▶ Shift register : 2번째 플립플롭의 입력을 보자
1) 시프트 기능을 가진 레지스터의 내부 회로         클록 좌측 우측 시프트 시프트 ※ 컴퓨터구조론, 생능출판사, 2019  170   ▶ Circular shift
1) 순환 시프트(circular shift) ­ 회전(rotate)이라고도 부르며, 최상위 혹은 최하위에 있는 비트를 버리지 않고 반대편 끝에 있는 비트 위치로 이동 ㆍ 순환 좌측
- 시프트(circular shift
- left) ­ 최상위 비트인 가 최하위 비트 위치인 으로 이동   (← ← ← ←)         ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 순환 우측
- 시프트(circular shift
- right) ­  → ,  → ,  → ,  →          ▶ 직렬 데이터 전송(serial data transfer) ­ 시프트 연산을 데이터 비트 수만큼 연속적으로 수행함으로써 두 레지스터들 사이에 한 개 의 선을 통하여 전체 데이터를 이동하는 동작(A 레지스터 : 피드백) 클록(우측
-시프트 제어 신호)  레지스터  레지스터 ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 예제 3
-18 ­ 그림 3 ­ 7과 같이 두 개의 4 ­ 비트 레지스터들이 직렬로 접속된 상태에서 A 레지스 터에 저장되어 있는 데이터인 ‘1011’을 네 클록 주기 후에 모두 B 레지스터로 전송하 고, A 레지스터는 원래의 데이터를 그대로 유지하게 되는 과정을 표시하라 ⋅ 풀이 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ Arithmetic shift

1) 산술적 시프트(arithmetic shift)  171   ­ 수(number)를 나타내는 데이터에 대한 시프트 ◼ 방법 ­ 시프트 과정에서 부호 비트는 그대로 유지시키고, 수의 크기를 나타내는 비트들만 시프 트 ㆍ 산술적 좌측
- 시프트(arithmetic shift
- left) ­ A4(불변), A3 ← A2, A2 ← A1, A1 ← 0 ㆍ 산술적 우측
- 시프트(arithmetic shift
- right) ­ A4(불변), A4 → A3, A3 → A2, A2 → A1 ◼ 예제 3
-19 ­ 10진수
-2에 대한 4 ­ 비트 2진수에 대하여 산술적 좌측 ­ 시프트를 수행한 후, 그 결 과 값에 대하여 두번의 산술적 우측 ­ 시프트를 수행하라 ⋅ 풀이
- A = 1110 (
-

2) (초기 상태) 1100 (
-

4) (산술적 좌측 ­ 시프트 결과) 1110 (
-

2) (첫 번째 산술적 우측 ­ 시프트 결과) 1111 (
-

1) (두 번째 산술적 우측 ­ 시프트 결과) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ C 플래그를 포함한 시프트 연산 ­ C 플래그를 포함한 좌측 ­ 시프트(SHLC : shift left with carry) ­ C 플래그를 포함한 우측 ­ 시프트(SHRC : shift right with carry) (a) SHLC 연산 (b) SHRC 연산 ※ 컴퓨터구조론, 생능출판사, 2019 ­ RLC(rotate left with carry) : C 플래그를 포함하는 좌측 순환 시프트(회전) 연산 ­ RRC(rotate right with carry) : C 플래그를 포함하는 우측 순환 시프트(회전) 연산 (a) RLC 연산 (b) RRC 연산 ※ 컴퓨터구조론, 생능출판사, 2019 2. 정수 연산   ▶ 정수의 산술 연산
1) 기본적인 산술 연산들
- A ←   + 1 ; 보수화(2의 보수 변환)
- A ← A + B ; 덧셈
- A ← A ­ B ; 뺄셈  172  
- A ← A × B ; 곱셈
- A ← A ÷ B ; 나눗셈
- A ← A + 1 ; 증가(increment)
- A ← A ­ 1 ; 감소(decrement) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 덧셈

1) 2의 보수로 표현된 수들의 덧셈 방법 ­ 두 수를 더하고, 만약 올림수가 발생하면 버림 ◼ 예제 3
-20 ­ 아래와 같은 2진수 덧셈들을 수행하고, 10진수 덧셈의 결과와 비교하라 ⋅ 풀이 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 병렬 가산기(parallel adder) ­ 덧셈을 수행하는 하드웨어 모듈 ­ 비트 수만큼의 전가산기(full
-adder)들로 구성 ­ 덧셈 연산 결과에 따라 해당 조건 플래그들(condition flags)을 세트 ⋅ C 플래그 : 올림수(carry) ⋅ S 플래그 : 부호(sign) ⋅ Z 플래그 : 0(zero) ⋅ V 플래그 : 오버플로우(overflow) ▶ 4
-비트 병렬 가산기와 상태 비트 제어회로 : XOR, NOR               (올림수 입력)         ※ 컴퓨터구조론, 생능출판사, 2019  173   ▶ 덧셈 오버플로우 ­ 덧셈 결과가 그 범위를 초과하여 결과값이 틀리게 되는 상태 ㆍ 검출 방법 ­ 두 올림수(carry)들 간의 exclusive
- OR를 이용 ⊕   ◼ 예제 3
-21 ­ 아래의 덧셈에서 오버플로우가 발생하는지 확인하라 ⋅ 풀이 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 뺄셈

1) 덧셈을 이용하여 수행 ­ A : 피감수(minuend), B : 감수(subtrahend) ⋅ A
- (+ B) = A + (
- B) ⋅ A
- (
- B) = A + (+ B) ◼ 예제 3
-22 ­ 2의 보수를 이용하여 아래와 같은 2진수 뺄셈들을 수행하라 : 올림수가 발생하면 버림 ⋅ 풀이 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 덧셈과 뺄셈 겸용 하드웨어의 블록 구성도 : 보수기 선택 신호(+,
-) 입력 데이터들 합 ※ 컴퓨터구조론, 생능출판사, 2019  174   ▶ 4
-비트 병렬 가감산기 ­ 4
-비트 데이터들 간의 덧셈(A+B) 및 뺄셈(A
-B)을 모두 수행하는 조합회로 ­ 제어신호 M = 0 : 덧셈, M = 1 : 뺄셈(입력 B의 비트들을 반전하고, 최하위 올림수로서 M을 입력) : XOR ­ 오버플로우(V) 검사 비트 : ⊕                             ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 뺄셈 오버플로우 ­ 뺄셈 결과가 그 범위를 초과하여 결과값이 틀리게 되는 상태 ㆍ 검출 방법 ­ 덧셈과 동일(⊕)   ◼ 예제 3
-23 ­ 2의 보수를 이용하여 수행하는 아래의 뺄셈들에서 오버플로우가 발생하는지 검사하라 ⋅ 풀이 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 부호 없는 정수의 곱셈 ㆍ 방법 ­ 각 비트에 대하여 부분 적(partial product) 계산 ­ 부분 적들을 모두 더하여 최종 결과를 얻음 ◼ 예제 3
-24 ­ 2진수 곱셈(1101 × 1011)을 수행하고, 결과값이 10진수 곱셈의 결과(13 × 11 = 143)와 일치하는지 확인하라  175   ⋅ 풀이 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 부호 없는 정수 승산기의 하드웨어 구성도 ­ M 레지스터 : 피승수(multiplicand) 저장(1101) ­ Q 레지스터 : 승수(multiplier) 저장(1011) ­ 두 배 길이의 결과값은 A 레지스터와 Q 레지스터에 저장 (피승수) 제어 신호 제어 신호 합   (승수) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 곱셈이 수행되는 과정에서의 레지스터 내용들 C A Q 초기 상태 0 0000 1011 사이클1 0 1101 1011 ;  = 1이므로, A ← A + M(1101)  0 0110 1101 ; 우측 시프트(C ­ A ­ Q) 사이클2 1 0011 1101 ;  = 1이므로, A ← A + M(1101)  0 1001 1110 ; 우측 시프트(C ­ A ­ Q) 사이클3 0 0100 1111 ;  = 0이므로, 우측 시프트(C ­ A ­ Q)만 수행  사이클4 1 0001 1111 ;  = 1이므로, A ← A + M(1101)  0 1000 1111 ; 우측 시프트(C ­ A ­ Q) : 최종 결과 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 2의 보수들 간의 곱셈 ­ Booth 알고리즘(Booth's algorithm) 사용  176  

1) 하드웨어 구성 ­ 부호 없는 정수 승산기의 하드웨어에 다음 부분을 추가 ⋅ M 레지스터와 병렬 가산기 사이에 보수기(complementer) 추가 ⋅ Q 레지스터의 우측에  이라고 부르는 1
-비트 레지스터를 추가하고, 출력을  와   함께 제어 회로로 입력 ▶ Booth 알고리즘의 흐름도 아니오 예 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ Booth 알고리즘을 이용한 곱셈의 예(
-7×3) (M) 1001 초기값 : A = 0000,  = 0, 계수 = 4  (Q) X 0011  계수  ; ( ) = (1

0)이므로, A로부터 피승수(1001)을 뺀다.   (AQ) 0111 0011 0 (실제로는 그 보수인 0111을 더한다.) 0011 1001 1 3 ;  을 산술적 우측 ­ 쉬프트 하고, 계수에서 1을 뺀다.  ; ( ) = (1
1)이므로,  에 대한    0001 1100 1 2 산술적 우측 ­ 쉬프트만 하고, 계수에서 1을 뺀다. 1010 1100 1 ; ( ) = (0
1)이므로, A에 피승수(1001)를 더한다.   1101 0110 0 1 ;  을 산술적 우측 ­ 쉬프트 하고, 계수에서 1을 뺀다.  ; ( ) = (0
0)이므로,  을 산술적 우측 ­ 쉬프트    1110 1011 1 0 한다. 계수에서 1을 빼면 0이므로 계산이 종료되었다.
-21 (곱셈 결과) ※ 컴퓨터구조론, 생능출판사, 2019  177   ▶ 나눗셈

1) 나눗셈의 수식 표현 ­ A ÷ B = q ····· r ⋅ 단, A : 피제수(dividend), B : 제수(divisor) q : 몫(quotient), r : 나머지 수(remainder)
2) 부호 없는 2진 나눗셈 몫 제수 피제수 부분 나머지 수 나머지 수 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 부호 없는 2진 나눗셈 알고리즘의 흐름도 : 나눌 수 있는지? 아니오 예 아니오 ( 레지스터) ( 레지스터) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 2의 보수 나눗셈 방법 ㆍ 초기 상태 ­ 제수는 M레지스터에, 피제수는 A와 Q 레지스터에 저장하며, 각 레지스터가 n비트일 때, 피제수는 2n비트 길이의 2의 보수로 표현함 ㆍ 사이클 1 ­ A와 Q레지스터를 좌측으로 한 비트씩 시프트 함 ㆍ 사이클 2 ­ 만약 M과 A의 부호가 같다면 A ← A
- M을 수행, 다르다면 A ← A + M을 수행함 ㆍ 사이클 3  178   ­ 연산 전과 후에서 A의 부호가 같다면, 위의 연산은 성공임 : 나눌 수 있는지? ⒜ 연산이 성공이거나 A = 0이면,  ← 1로 세트  ⒝ 연산이 실패이고 A ≠ 0이면,  ← 0으로 세트하고, A를 이전의 값으로 복구함  ㆍ 사이클 4 ­ Q레지스터에 비트가 남아있다면, 단계 2에서 4까지를 반복함 : 계수 ㆍ 사이클 5 ­ 나머지 수는 A에 남음 만약 제수와 피제수의 부호가 같다면 몫은 Q레지스터의 값이 되고, 그렇지 않다면 Q레 지스터의 내용에 대한 2의 보수가 몫이 됨  179   부동소수점 산술 연산

1. 컴퓨터 내부에서 부동소수점을 표현하는 방식에 대해서 학습하고 이를 설명할 수 있다. 7주차  수업목표  
2. 컴퓨터 내부에서 수행되는 부동소수점 연산에 대해서 학습하고 3교시  이를 설명할 수 있다.
1. 부동소수점 표현 세부내용 
2. 부동소수점 연산 1. 부동소수점 표현   ▶ ex)loating
-point representation ㆍ 부동소수점 표현(floating
- point representation) ­ 소수점의 위치를 이동시킬 수 있는 수 표현 방법 → 수 표현 범위 확대 ㆍ 부동소수점 수(floating
-point number)의 일반적인 형태 × ⋅ 단, S : 부호(sign), M : 가수(mantissa, 2진수면 0 or

1), B : 기수(base), E : 지수(exponent) v 부동소수점(浮動小數點, floating point) 또는 떠돌이 소수점 방식은 실수를 컴퓨터 상에 서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적 는 것으로, 유효숫자를 나타내는 가수(假數)와 소수점의 위치를 풀이하는 지수(指數)로 나 누어 표현함 ⋅ 컴퓨터에서는 고정 소수점 방식보다 넓은 범위의 수를 나타낼 수 있어 과학기술 계산에 많이 이용되지만, 근삿값으로 표현되며 고정 소수점 방식보다 연산 속도가 느리기 때문 에 별도의 전용 연산 장치를 두는 경우가 많음 ⋅ 고정 소수점과 달리 정수 부분과 소수 부분의 자릿수가 일정하지 않으나, 유효 숫자의 자릿수는 정해져 있음
1) 부동소수점 표현 방식 ­ 부동 소수점 표현 방식은 수를 가수×밑수지수와 같이 유효숫자를 사용한 곱셈 형태로 표현 ⋅ 예를 들어,
- 0.4를 밑수가 10인 부동 소수점으로 나타내면 ×이 되며 밑수가 2이면 ×가 되는데, 가수 부분을 한자리 자연수를 갖도록 바꾸면 ×과 같이 됨 ­ 이처럼 가수의 첫째 자리가 밑수보다 작은 한자리 자연수가 되도록 바꾸는 것을 정규화라 고 함 ⋅ 예를 들어, 앞의 값은 밑수가 2이면 ×이 되는데 이것을 정규화하면 ×이 됨(여기서 볼 수 있듯이 밑수가 2일 때 정규화하면 가수 부분의 첫째 숫 자는 항상 1이 됨)  180  

2) 가수부와 지수부
① ­ 컴퓨터 프로그래밍이나 전자계산기 등에서는 밑수가 10인 경우에 로마자 E 또는 e를 사용 하여 함수 형태로 표시하기도 하는데,
- 0.4는
- 0.04E + 1 또는
- 0.04e + 1이 되며, 정규화하면
- 4E
- 1 또는
- 4e
- 1로 씀 ­ 만약, 사용할 밑수를 미리 정해 놓는다면 가수와 지수만으로 실수를 표현할 수 있는데, 앞 의 보기에서 밑수를 10으로 고정한다면 실수
- 0.4는 가수
- 4와 지수
- 1의 조합으로 나 타낼 수 있음 ­ 보다 정형화된 형태로는 가수부와 지수부의 자릿수를 고정할 수 있는데, 만약 밑수는 10이 고 부호는 따로 표시하며, 가수부 5자리, 지수부 3자리로 하는 형식이라면 앞의 값
- 0.4 는 '부호
-, 가수 40000, 지수
- 005'로 나타낼 수 있음 ­ 밑수가 2일 때에 정규화 결과 가수의 첫째 자리는 항상 1이 되므로 표시를 생략할 수 있음 ­ 따라서, 고정된 형식에서 가수부에 1자리를 더 표시할 수 있게 되므로, 처리할 수 있는 유 효숫자가 1자리만큼 늘어나며, 앞의 예 ×를 이 방식으로 표현하면 '부호 +, 가수 60000, 지수
- 002'가 됨(밑수가

2)
3) 가수부와 지수부
② ­ 지수부에는 따로 부호 비트가 없기 때문에 음수 지수를 처리하기 위해 보통 바이어스 표현 법을 사용하는데, 즉, 할당된 자릿수로 표현 가능한 전체 영역을 반으로 나누어, 작은 영역 에는 음수값 및 0, 큰 영역에는 양수값이 차례대로 1:1 대응되도록 함(바이어스 127 or 128) ⋅ 예를 들어, 지수부를 8비트로 표현한다면 모두 256가지 수를 나타낼 수 있는데 이것을 반으로 나누어 음수 127개와 0, 양수 128개를 차례대로 대응시킴 ­ 따라서, 비트열 00000000은 지수
- 127을 나타내고, 01111111은 지수 0, 11111111은 지수 128을 나타냄 ­ 일반적으로는 지수부가 n비트일 때 ( / 2
- 1 = 
-

1)을 지수 값에 더하며 이것을 바이어스 상수라고 함(다만, 지수부의 모든 자리가 모두 0 또는 1인 경우는 각각 0 또는 무한대를 나타내는 등 종종 특수한 목적으로 예약되어 있음) ­ 가수부에서는 정규화 결과 유효숫자의 첫째 자리는 언제나 1이므로 표시하지 않고, 소수 부분만 표현함 v 10진 부동소수점 수(decimal floating
- point number) ⋅ 예) 274,000,000,000,000 → × 0.00000000000274 → × v 2진 부동소수점 수(binary floating
- point number) ­ 기수 B = 2 ⋅ 예) 11.101 → × 0.00001101 → × ­ 단일 ­ 정밀도(single
- precision) 부동소수점 수 : 32 비트 ­ 복수 ­ 정밀도(double
- precision) 부동소수점 수 : 64 비트  181   ▶ 단일
-정밀도 부동소수점 수 형식의 예 ­ S : 1비트, E : 8비트, M : 23비트 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 지수(E) 필드의 비트 수 증가 → 표현 가능한 수의 범위 확장 ­ 가수(M) 필드의 비트 수 증가 → 정밀도(precision) 증가 v 표현 가능한 수 크기의 범위 × ~ × ≈ × ~ × v [비교] 32
- 비트 고정 소수점(fixed
- point) 표현 방식의 경우 × ~ × ≈ × ~ × ▶ 같은 수에 대한 부동소수점 표현 ­ 같은 수에 대한 부동소수점 표현이 여러 가지가 존재 ⋅ × × × ­ 정규화된 표현(Normalized representation) ⋅ 수에 대한 표현을 한 가지로 통일하기 위한 방법 ±⋯×E ⋅ 위의 예에서 정규화된 표현은 × ▶ 부동소수점 표현의 예(×) ­ 부호(S) 비트 = 0 ­ 지수(E) = 00000101 ­ 가수(M) = 1101 0000 0000 0000 0000 000    데이터 표현 : ※ 컴퓨터구조론, 생능출판사, 2019 ­ 소수점 아래 첫 번째 비트는 항상 1이므로, 반드시 저장할 필요는 없음 ⇨ 가수 23비트를 이용하여 소수점 아래 24자리 수까지 표현 가능 ▶ 바이어스된 지수(biased exponent) ­ 지수를 바이어스된 수(biased number)로 표현 ㆍ 사용 목적 ­ 0(혹은 0에 매우 가까운 값)에 대한 표현에서 모든 비트들이 0이 되도록 함(바이어스)으 로써, 0
- 검사(zero
- test)가 용이하게 하기 위함 ⇨ 0 ­ 검사가 정수 경우와 같은 방법으로 가능해짐  182   ▶ 8
-비트 바이어스된 지수값들(8
-bit biased exponents) 실제 지수 값 지수 비트 패턴 절대값 바이어스 =127 바이어스 =128 11111111 255 +128 +127 11111110 254 +127 +126 ⋮ ⋮ ⋮ ⋮ 10000001 129 +2 +1 10000000 128 +1 0 01111111 127 0
-1 01111110 126
-1
-2 ⋮ ⋮ ⋮ ⋮ 00000001 1
-126
-127 00000000 0
-127
-128 ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 예제 3
-27 ­ 10진수 N =
- 13.625에 대한 32 ­ 비트 부동소수점 표현을 구하라 ⋅ 풀이   ×   부호(S) 비트 = 1(
-) 지수(E) = 00000100 + 10000000 = 10000100 (바이어스 128을 더한다) 가수(M) = 10110100000000000000000 (소수점 우측의 첫 번째 ‘1’은 제외) ⋅ 결과    ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 부동소수점 수의 표현 범위 v 부동소수점 수의 표현 범위 ⋅ × ~ × 사이의 양수들 (대략 × ~ ×) ⋅ × ~ × 사이의 음수들 v 제외되는 범위 ⋅ × 보다 작은 음수 → 음수 오버플로우(negative overflow) ⋅ × 보다 큰 음수 → 음수 언더플로우(negative underflow) ⋅ × 보다 작은 양수  183   → 양수 언더플로우(positive underflow) ⋅ × 보다 큰 양수 → 양수 오버플로우(positive overflow) ▶ 32
-비트 데이터 형식의 표현 가능한 수의 범위 표현가능한 정수들 (a) 2의 보수 정수의 표현 범위 음수 음수 언더플로우 양수 언더플로우 양수 오버플로우 표현가능한 수들 표현가능한 수들 오버플로우 (b) 부동소수점 수의 표현 범위 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 국제 표준 부동소수점 수의 형식 ­ 부동소수점 수의 표현 방식의 통일을 위하여 미국전기전자공학회(IEEE)에서 정의한 표준 v 32
- 비트 단일
- 정밀도 부동소수점 수의 표현 E (1.M) ⋅ 가수 : 부호화
- 크기 표현 사용 ⋅ 지수 필드 : 바이어스 127 사용 ⋅ 1.M × 2E의 형태를 가지며, 소수점 아래의 M 부분만 가수 필드에 저장(소수점 왼 쪽의 저장되지 않는 1을 hidden bit라고 부름) v 64
- 비트 복수
- 정밀도 부동소수점 수의 표현 E (1.M) (a) 단일
-정밀도 형식(single
-precision format) (b) 복수
-정밀도 형식(double
-precision format) ※ 컴퓨터구조론, 생능출판사, 2019  184   ◼ 예제 3
-28 ­ 10진수 ­ 13.625를 IEEE 754 단일 ­ 정밀도 표준 형식으로 표현하라 ⋅ 풀이   ×   부호(S) 비트 = 1(
-) 지수(E) = 00000011 + 01111111 = 10000010 (바이어스 127을 더한다) 가수(M) = 10110100000000000000000 (소수점 좌측의 1은 제외한다) ⋅ 결과    ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 예외(exception) 경우를 포함한 국제 표준 v 예외 경우를 포함한 정의(32
- 비트 형식) ⋅ 만약 E = 255이고 M ≠ 0이면, N = NaN ⋅ 만약 E = 255이고 M = 0이면, N = S ∞ ⋅ 만약 0 < E < 255 이면, N = SE (1.M) ⋅ 만약 E = 0이고 M ≠ 0이면, N = S (0.M) ⋅ 만약 E = 0이고 M = 0이면, N = S 0 v 예외 경우를 포함한 정의(64
- 비트 형식) ⋅ 만약 E = 2047이고 M ≠ 0이면, N = NaN ⋅ 만약 E = 2047이고 M = 0이면, N = S ∞ ⋅ 만약 0 < E < 2047 이면, N = SE (1.M) ⋅ 만약 E = 0이고 M ≠ 0이면, N = S (0.M) ⋅ 만약 E = 0이고 M = 0이면, N = S 0 ▶ 국제 표준(2008)에서 추가된 정의 v 4배수
- 정밀도(quadruple ­ precision : 128
- 비트) 부동소수점 수의 표현 ※ 컴퓨터구조론, 생능출판사, 2019 E (1.M) ⋅ 가수 : 부호화
- 크기 표현 사용 ⋅ 지수 필드 : 바이어스 16383 사용(범위 :
- 16383 ~ + 16383)  185   ▶ 국제 표준 형식의 주요 파라미터들

1) IEEE 754 형식의 주요 파라미터들 부동소수점형식 파라미터 단일 정밀도 복수 정밀도 4배수 정밀도 비트 수 32 64 128 지수 필드 폭(비트) 8 11 15 가수 필드 폭(비트) 23 52 112 지수 바이어스 127 1023 16383 최대 지수값 127 1023 16383 최소 지수값
-126
-1023
-16383 정수의 대략적 표현 범위 ~ ±  ~ ±  ~ ±  (최소/최대) /±  /±  /±  ※ 컴퓨터구조론, 생능출판사, 2019 2. 부동소수점 연산  ▶ 덧셈과 뺄셈 ­ 지수들이 일치되도록 조정(alignment) ­ 가수들 간의 연산(더하기 혹은 빼기) 수행 ­ 결과를 정규화(normalization) ㆍ [참고] 10진 부동소수점 산술의 예 × × ◼ 예제 3
-29 ­ 부동소수점 수들 간의 덧셈××을 수행하라 : 정규화 ⋅ 풀이 ­ 이 덧셈은 아래와 같은 세 단계를 통하여 수행될 수 있다. ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 부동소수점 산술의 파이프라이닝 ­ 연산 과정을 독립적 단계들로 분리 가능 ­ 단계 수만큼의 속도 향상 : 3단계 ­ 대규모의 부동소수점 계산을 처리하는 거의 모든 슈퍼컴퓨터들에서 채택  186   ⋅ 예) 수 배열(number array)들 간의 덧셈 C( I ) = A( I ) + B( I )   단계1 : 단계2 : 단계3 :  (덧셈 결과) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 곱셈과 나눗셈

1) 2진수 부동소수점 곱셈 과정
① 가수들을 곱함
② 지수들을 더함
③ 결과값을 정규화 ⋅ 예) 부동소수점 곱셈의 예
- ×××
- <가수 곱하기> 1011 × 1001 = 01100011
- <지수 더하기> 3 + 5 = 8
- <정규화> × × (결과값)

2) 2진수 부동소수점 나눗셈 과정
① 가수들을 나눔
② 피제수의 지수에서 제수의 지수를 뺌
③ 결과값을 정규화 ▶ 부동소수점 연산 과정에서 발생 가능한 문제점 ㆍ 지수 오버플로우(exponent overflow) ­ 양의 지수값이 최대 지수값을 초과 ⇨ 수가 너무 커서 표현될 수 없는 상태이므로, + ∞ 또는
- ∞로 세트 ㆍ 지수 언더플로우(exponent underflow) ­ 음의 지수값이 최대 지수값을 초과 ⇨ 수가 너무 작아서 표현될 수 없는 상태이므로, 0으로 세트 ㆍ 가수 언더플로우(mantissa underflow) ­ 가수의 소수점 위치 조정 과정에서 비트들이 가수의 우측 편으로 넘치는 상태 ⇨ 반올림(rounding) 적용  187   ㆍ 가수 오버플로우(mantissa overflow) ­ 같은 부호를 가진 두 가수들을 덧셈하였을 때 올림수가 발생 ⇨ 재조정(realignment) 과정을 통하여 정규화  188   제어 장치의 기능

1. CPU를 구성하는 제어 장치의 기본 구조에 대해서 학습하고 이를 설명할 수 있다. 9주차  수업목표  
2. 제어 장치를 만들기 위한 마이크로 프로그래밍 방법에 대해서 1교시  학습하고 이를 설명할 수 있다.
1. 제어 장치 구조 세부내용 
2. 마이크로 프로그래밍 1. 제어 장치 구조   ▶ 제어 유니트의 기능
1) 제어 유니트(제어 장치, Control Unit)의 기능 ­ 명령어 코드의 해독 ­ 명령어 실행에 필요한 제어 신호들의 발생 ㆍ 마이크로 명령어(micro
- instruction) ­ 명령어 사이클의 각 주기에서 실행되는 각 마이크로 연산을 지정해주는 2진 비트들로, 제어 단어(control word)라고도 함 ㆍ 마이크로프로그램(microprogram) ­ 마이크로 명령어들의 집합 ㆍ 루틴(routine) ­ CPU의 특정 기능을 수행하기 위한 마이크로 명령어들의 그룹 ⋅ 예) 인출 사이클 루틴, 실행 사이클 루틴, 인터럽트 사이클 루틴 ▶ 제어 유니트의 기능 – 마이크로 프로그래밍 v 마이크로 프로그래밍(펌웨어 방식) (microprogramming, 이를테면 마이크로코드(microcode)의 기록)은 CPU 안에 기계어를 상대적으로 쉽게 추가할 수 있도록 이용하는 방식으로, 다른 방식들에 비해 하드웨어를 덜 사용함 ⋅ 이것은 매우 상세하면서도 기초가 되는 가장 낮은 수준의 루틴(add)의 모임이며 이러 한 루틴은 특정한 명령어를 수행하는 데 필요한 동작들을 제어하고 나열하며, 또 이따 금 이들을 해석하기도 함 ⋅ 그러므로 일련의 마이크로 명령어가 추가한 기계어는 인터프리터가 기계어를 사용하여 고급 프로그래밍 언어의 명령문을 추가하는 방식과 비슷하다고 볼 수 있음

1) 마이크로 프로그래밍 특징 ­ 마이크로코드(일련의 마이크로 명령어)는 디자인 단계에서 일반적으로 CPU 기술자가 기록 하나, 일반 프로그래머, 심지어는 어셈블리 프로그래머도 이를 보면서 바꿀 수 있다는 것을 뜻하지는 않음 ­ 왜냐하면 설계상 마이크로코드는 새로운 마이크로 아키텍처(CPU 아키텍처)가 만들어질 때  189   마다 극적으로 바뀔 수 있기 때문이며, 기계어는 하위 호환성을 유지 ­ 마이크로코드는 마이크로아키텍처가 다른 강력한 아키텍처를 에뮬레이트(복제)하는 데 사용 해왔음 ­ 또, IBM과 같은 일부 하드웨어 업체들은 실제로 프로세서의 마이크로프로그래밍의 도입 여 부에 관계 없이 마이크로코드(microcode)라는 용어를 펌웨어와 동의어로 사용함 ­ 심지어 하드 드라이브에 쓰이는 것과 같은 단순한 펌웨어라도 이따금씩 마이크로코드로 서 술함 ▶ 제어 유니트의 구조
1) 구성 요소들 ㆍ 명령어 해독기(instruction decoder) ­ 명령어 레지스터(IR)로부터 들어오는 명령어의 연산 코드를 해독하여 해당 연산을 수행 하기 위한 루틴의 시작 주소(제어 메모리)를 결정 ㆍ 제어 주소 레지스터(control address register : CAR) ­ 다음에 실행할 마이크로명령어의 주소를 저장하는 레지스터 → 이 주소는 제어 기억장치 의 특정 위치를 지칭 ㆍ 제어 기억장치(control memory) ­ 마이크로명령어들로 이루어진 마이크로프로그램을 저장하는 내부 기억장치(루틴) ㆍ 제어 버퍼 레지스터(control buffer register : CBR) ­ 제어 기억장치로부터 읽혀진 마이크로명령어 비트들을 일시적으로 저장하는 레지스터 ㆍ 서브루틴 레지스터(subroutine register : SBR) ­ 마이크로프로그램에서 서브루틴이 호출되는 경우에 현재의 CAR 내용을 일시적으로 저 장하는 레지스터 ㆍ 순서제어 모듈(sequencing module) ­ 마이크로명령어의 실행 순서를 결정하는 회로들의 집합 ▶ 제어 유니트의 내부 구성도(CAR
-Control Memory
-CBR) 조건 플래그들 내부 제어신호들 외부 제어신호들 ※ 컴퓨터구조론, 생능출판사, 2019  190   ▶ CPU의 명령어 세트 설계 과정 : Instruction Set
① 명령어들의 종류 및 비트 패턴 정의
② 명령어들의 실행에 필요한 하드웨어 설계
③ 각 명령어를 위한 실행 사이클 루틴 작성(마이크로프로그래밍)
④ 마이크로프로그램 코드들을 제어 기억장치에 저장 ▶ 제어 기억장치의 내부 구성

1) 마이크로프로그램 루틴들을 제어 기억장치에 저장한 예 ­ 제어 기억장치 용량 : 128단어 ­ 전반부(0 ~ 63번지) : 공통 루틴들 저장(인출, 간접, 인터럽트) ­ 후반부(64 ~ 127번지) : 각 명령어의 실행 사이클 루틴들(add) 저장 ­ 제어 기억장치의 내부 구성(공통 투틴, 실행 사이클 루틴) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 명령어 해독 ­ 명령어의 연산 코드가 지정하는 연산을 위한 실행 사이클 루틴의 시작 주소를 결정하는 동 작
1) 사상(mapping)을 이용한 해독 방법 ­ 명령어의 연산 코드를 특정 비트 패턴과 조합 ⋅ 예) 16
-비트 길이의 명령어가 4비트의 연산 코드, 1비트의 간접 주소지정(I) 비트 및 11비트의 주소로 구성된 경우 명령어 코드 : 사상 함수 : ※ 컴퓨터구조론, 생능출판사, 2019 ­ 연산코드 = 0001 → 실행 사이클 루틴의 시작 주소 = 1000100 ( )  ­ 연산코드 = 0110 → 실행 사이클 루틴의 시작 주소 = 1011000 ( )   191   ▶ 마이크로 명령어의 형식 ­ 연산 필드가 두 개이면, 두 개의 마이크로 연산들을 동시에 수행 가능 ­ 조건(CD) 필드는 분기에 사용될 조건 플래그를 지정 ­ 분기(BR) 필드는 분기의 종류와 다음에 실행할 마이크로 명령어의 주소를 결정하는 방법을 명시 ­ 주소 필드(ADex))의 내용은 분기가 발생하는 경우에 목적지 마이크로명령어의 주소로 사용 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 마이크로 연산들에 대한 2진 코드 및 기호(예)

1) ‘연산필드 1’ 에 위치할 마이크로 ­ 연산들 코드 마이크로
-연산 기호 000 None NOP 001 MAR ← PC PCTAR 010 MAR ← IR(addr) IRTAR 011 AC ← AC + MBR ADD 100 MBR ← M[MAR] READ 101 AC ← MBR BRTAC 110 IR ← MBR BRTIR 111 M[MAR] ← MBR WRITE ※ 컴퓨터구조론, 생능출판사, 2019

2) ‘연산필드 2’ 에 위치할 마이크로 ­ 연산들 코드 마이크로
-연산 기호 000 None NOP 001 PC ← PC + 1 INCPC 010 MBR ← AC ACTBR 011 MBR ← PC PCTBR 100 PC ← MBR BRTPC 101 MAR ← SP SPTAR 110 AC ← AC ­ MBR SUB 111 PC ← IR(addr) IRTPC ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 조건 필드의 코드 지정

1) 조건 필드 ­ 두 비트로 구성되며, 분기의 조건으로 사용 ⋅ U : 무조건 분기 ⋅ I : 만약 I = 1이면, 간접 사이클 루틴을 호출 ⋅ S : 누산기에 저장된 데이터의 부호가 1이면, 분기 ⋅ Z : 누산기에 저장된 데이터가 0(Z =
1)이라면, 분기  192   코드 조건 기호 설명 00 1 U 무조건 분기 01 I 비트 I 간접 주소지정 10 AC (S) S 누산기(AC)에 저장된 데이터의 부호 11 AC = 0 Z AC에 저장된 데이터 = 0 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 분기 필드의 코드 지정
1) 분기 필드 ­ 두 비트로 구성되며, 분기 동작을 지정 ⋅ 조건 필드의 조건이 만족되면, ADex) 필드의 내용을 CAR로 적재 → 그 주소로 분기 (JUMP 혹은 CALL) ⋅ RET : 서브루틴으로부터 복귀(SBR에 저장된 내용을 CAR로 적재) ⋅ MAP : 사상 방식(변환)에 의하여 분기 목적지 주소 결정
2) 분기 필드(CALL ­ 복귀 주소 저장) 코드 기호 설명 만약 조건 = 1이면, CAR ← ADex) 00 JMP 만약 조건 = 0이면, CAR ← CAR + 1 만약 조건 = 1이면, SBR ← CAR + 1, CAR ← ADex) 01 CALL 만약 조건 = 0이면, CAR ← CAR + 1 10 RET CAR ← SBR(서브루틴으로부터의 복귀) 11 MAP CAR(1) ← 1, CAR(2 ­
5) ← IR(op), CAR(6,
7) ← 0 ※ 컴퓨터구조론, 생능출판사, 2019 2. 마이크로 프로그래밍   ▶ 인출 사이클 루틴의 마이크로 명령어 루틴 ORG 0 ex)ETCH: PCTAR U JMP NEXT ; MAR ← PC, 다음 마이크로명령어 실행 READ, INCPC U JMP NEXT ; MBR ← M[MAR], PC = PC + 1, 다음 마이크로명령어 실행 ; IR ← MBR, 해당 실행 사이클 루틴으로 BRTIR U MAP 분기
1) 2진 비트 패턴 주소 μ
-ops CD BR ADex) 0000000 001 000 00 00 0000001 0000001 100 001 00 00 0000010 0000010 110 000 00 11 0000000 ※ 컴퓨터구조론, 생능출판사, 2019 ­ 주소 : 각 마이크로명령어가 저장될 제어 기억장치 주소, μ
-ops : 두 개의 마이크로 연산들, CD : 조건 필드, BR : 분기 필드, ADex) : 주소 필드  193   ▶ 간접 사이클 루틴 ORG 4 INDRT: IRTAR U JMP NEXT ; MAR ← IR(addr) ; 다음 마이크로명령어 실행 READ U JMP NEXT ; MBR ← M[MAR] ; 다음 마이크로명령어 실행 BRTIR U RET ; IR(addr) ← MBR ; 실행 사이클 루틴으로 복귀

1) 2진 비트 패턴 주소 μ
-ops CD BR ADex) 0000100 010 000 00 00 0000101 0000101 100 000 00 00 0000110 0000110 110 000 00 10 0000000 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 실행 사이클 루틴 ­ 사상 방식(변환)을 이용하여 각 연산 코드에 대한 실행 사이클 루틴의 시작 주소를 결정하 고, 각 명령어 실행을 위한 루틴을 작성

1) 각 연산 코드에 대한 사상(mapping)의 결과 명령어 연산 코드 루틴의 시작 주소 NOP 0000 1000000 =   LOAD(I) 0001 1000100 =   STORE(I) 0010 1001000 =   ADD 0011 1001100 =   SUB 0100 1010000 =   JUMP 0101 1010100 =   ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 각 명령어에 대한 실행 사이클 루틴들  ORG 64 NOP: INCPC U JMP ex)ETCH ; PC ← PC + 1 ORG 68 LOAD: NOP I CALL INDRT ; I = 1이면, 간접 사이클 루틴 호출 IRTAR U JMP NEXT ; MAR ← IR(addr) READ U JMP NEXT ; MBR ← M[MAR] BRTAC U JMP ex)ETCH ; AC ← MBR ORG 72 STORE: NOP I CALL INDRT ; I = 1이면, 간접 사이클 루틴 호출 IRTAR U JMP NEXT ; MAR ← IR(addr) ACTBR U JMP NEXT ; MBR ← AC WRITE U JMP ex)ETCH ; M[MAR] ← MBR ORG 76  194   ADD: IRTAR U JMP NEXT ; MAR ← IR(addr) READ U JMP NEXT ; MBR ← M[MAR] ADD U JMP ex)ETCH ; AC ← AC + MBR ORG 80 SUB: IRTAR U JMP NEXT ; MAR ← IR(addr) READ U JMP NEXT ; MBR ← M[MAR] SUB U JMP ex)ETCH ; AC ← AC ­ MBR RG 84 JUMP: IRTPC U JMP ex)ETCH ; PC ← IR(addr) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 마이크로 프로그램의 순서제어 ㆍ 순서제어(sequencing) ­ 다음에 실행할 마이크로명령어의 주소 결정 ㆍ CAR의 초기값 ­ CAR의 초기값 = 0(인출 사이클 루틴의 첫 번째 마이크로명령어의 주소) ㆍ MUX1 ­ 다음에 실행할 마이크로명령어의 주소 선택 ㆍ MUX2 ­ 조건 플래그를 선택하여 주소 선택 회로로 전송 ▶ 순서제어 회로가 포함된 제어 유니트의 구성도(MUX1, MUX2) 루틴 주소(사상 결과) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 주소 선택 방법 ­ BR = 00(JUMP) 혹은 01(CALL)일 때, C = 0, 다음 위치의 마이크로명령어 선택  195   C = 1, 주소 필드(ADex))가 지정하는 위치로 점프(jump) 혹은 호출(call)(단, 호출 시에는 CAR 내용을 SBR에 저장) ­ BR = 10(RET)일 때는 SBR 내용을 CAR로 적재 : 복귀 ­ BR = 11(MAP)일 때는 사상 결과를 CAR에 적재 ▶ 주소 선택 회로의 입력 및 출력 신호들 BR 조건 MUX선택 SBR CAR로 적재될     설명           MUX1의 입력 0 0 0 0 0 0 0 CAR ← CAR + 1 0 0 1 0 1 0 1 CAR ← ADex) <Jump> 0 1 0 0 0 0 0 CAR ← CAR + 1 SBR ← CAR + 1, 0 1 1 0 1 1 1 CAR ← ADex) 1 0 x 1 0 0 2 CAR ← SBR <Return> CAR ← 1XXXX00 1 1 x 1 1 0 3 <Mapping> ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 제어 신호의 생성 ­ 제어 기억장치로부터 인출된 마이크로명령어 내 연산 필드의 비트들이 제어 유니트(제어 장 치)의 외부로 출력되어, 각각 제어 신호로 사용됨(CPU 내부/외부) ▶ Vertical microprogramming ­ 마이크로명령어의 연산 필드에 적은 수의 코드화된 비트들(encoded bits)을 포함시키고, 해독기를 이용하여 그 비트들을 필요한 수 만큼의 제어 신호들로 확장하는 방식 ⋅ 장점
- 마이크로명령어의 길이(비트 수) 최소화 → 제어 기억장치 용량 감소 ⋅ 단점
- 해독 동작에 걸리는 만큼의 지연 시간 발생 ▶ Vertical microprogramming에서의 제어 신호 발생 방법(해독기) 제어 신호들 제어 신호들 ※ 컴퓨터구조론, 생능출판사, 2019  196   ▶ Horizontal microprogramming ­ 연산 필드의 각 비트와 제어 신호를 1:1로 대응시키는 방식 ­ 필요한 제어 신호 수만큼의 비트들로 이루어진 연산 필드 비트들이 마이크로명령어에 포함 되어야 함 ⋅ 장점
- 하드웨어가 간단하고, 해독에 따른 지연 시간이 없음 ⋅ 단점
- 마이크로명령어의 비트 수가 길어지기 때문에 제어 기억장치의 용량이 증가  197   마이크로 오퍼레이션

1. 마이크로 프로그램을 구성하는 마이크로 오퍼레이션의 개념에 대해서 학습하고 이를 설명할 수 있다. 9주차  수업목표  
2. 마이크로 프로그램을 구성하는 마이크로 오퍼레이션의 구현에 2교시  대해서 이해하고 이를 설명할 수 있다.
1. 마이크로 오퍼레이션 개념 세부내용 
2. 마이크로 오퍼레이션 구현 1. 마이크로 오퍼레이션 개념   ▶ 제어장치의 개념 ­ 제어장치는 주기억장치에 저장된 명령을 해독하고, 해독한 명령이 지시하는 연산이 수행되 도록 해당 장치에 제어 신호를 전달함(add 명령어) ⋅ 제어장치의 동작을 이해하면 어떤 과정을 통해서 명령어가 처리되지 알 수 있고 결과적 으로 컴퓨터의 동작을 이해할 수 있음 ­ 제어장치는 구현하는 방법에 따라서 하드 와이어드(Hard Wired) 제어(HW)와 마이크로 프 로그램(Micro Programmed) 제어(ex)W), 두 가지 방법으로 분류 ⋅ 하드 와이어드 제어방식은 일반적인 논리회로인 논리 게이트와 플립플롭으로 제어장치 를 설계한 것으로 마이크로 연산을 빠르게 수행할 수 있으나, 속도적인 장점에도 불구 하고 융통성이 없음(속도, 융통성) ⋅ 현대의 컴퓨터에서는 마이크로 프로그래밍 기법을 사용하여 제어장치를 구성하는 마이 크로 프로그램 제어를 사용하고 있음(속도, 융통성) ⋅ 이 방법은 제어 함수나 제어 단어와 같은 제어 정보를 특별한 제어 기억장치에 0과 1 로 기억시킨 구조로서, 제어 기억장치의 내용을 변경할 수 있어 융통성이 좋음 ▶ 제어장치의 구성 ­ 제어장치는 명령어가 저장된 기억장치에서 명령어를 인출하기 위한 레지스터와 명령어 해 독기 그리고 명령어의 순서를 제어하기 위한 프로그램 카운터를 비롯한 각종 장치가 필요 함
1) 제어장치의 내부 구성 ­ 제어장치는 기억장치 버퍼 레지스터(MBR), 기억장치 주소 레지스터(MAR), 명령 레지스터 (IR), 명령 해독기, 프로그램 카운터(PC)로 구성됨 ­ 제어장치의 구성(PC
-MAR
-MBR
-IR)  198   ­ 프로그램 카운터(PC)를 통해서 다음 명령어를 결정하고, 주기억장치에서 명령을 인출하여 기억장치 버퍼 레지스터(MBR)와 명령 레지스터(IR)에 임시저장 과정을 거쳐서, 명령 해독 기에서 명령어를 해독하게 되며, 마지막으로 해독된 내용들은 연산장치(ALU)로 전달됨 ▶ 제어장치에서 명령어 사이클 수행 ­ 명령어 사이클은 명령어 인출 단계와 실행 단계로 구성되며, 제어장치에서 수행되는 명령어 인출과 명령어 실행을 통해서 명령의 해독과 실행과정을 파악 가능함

1) 명령어 인출 ­ 명령어를 해독하려면 해독할 명령을 주기억장치에서 제어장치로 읽어와야 하는데, 이것을 명령어 인출이라고 함
2) 명령어 인출 과정(PC
-MAR
-MBR
-IR, 300번지
-add 250) 기억장치 버퍼 레지스터 프로그램 카운터 형식 레지스터 명령 레지스터 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 명령어 실행 ­ 명령어 인출이 완료되면 명령어 실행 사이클이 시작되며, 명령 실행단계에서는 이미 명령 코드가 명령 레지스터에 저장되어 있음

1) 명령어 실행 과정(IR
-MAR
-MBR
-AC, 300번지
-add 250) 연산될 데이터 번지 연산될 데이터 주소 부 피가수 결과 IR ※ 컴퓨터 구조와 원리 2.0, 신종홍  199   ▶ 명령어 주기 ­ 명령 주기는 명령어에 따라 특성이 다르므로 4개의 명령어 주기를 다 필요하지 않는 경우 도 있음 ­ 초기의 CISC 마이크로프로세서는 다음의 명령 주기가 확연히 구분됨 ­ RISC로 발달하며 명령어를 단순화하면서 각 사이클을 단순화 하는 경향이 있음 ­ 각 컴퓨터의 CPU는 서로 다른 명령어 집합에 기반하여 각기 다른 사이클을 지니고 있으나 다음과 비슷한 순환을 가짐(이 주기는 계속 반복됨
- 사이클) ㆍ 명령어 페치 ­ 첫 번째 단계인 명령어 페치 단계를 페치 사이클(fetch cycle)로 부르며, 이 단계는 각 명령에 동일한 작업을 수행함 ­ 페치 사이클은 opcode를 포함하는 명령어(instruction word)로부터 명령(instruction) 을 처리 ㆍ 명령어 디코딩 ­ 두 번째 단계는 디코딩으로 부르며, 메모리로부터 페치된 opcode는 다음 단계를 위해 디코딩되며 적절한 레지스터로 이동됨 ㆍ 유효한 주소 읽기 ­ 세 번째 단계인 유효한 주소 읽기는 어떠한 명령인지를 결정하는 단계임 ­ 이것이 메모리 명령이라면 이 컴퓨터 단계에서 직접 메모리 명령인지 간접 메모리 명령 인지를 확인함 ­ 직접 메모리 명령
- 아무 것도 처리하지 않음 ­ 간접 메모리 명령
- 유효 주소를 메모리로부터 읽어들임 ­ 이것이 입출력 명령이나 레지스터 명령이라면 컴퓨터는 이에 대한 종류를 확인하고 명령 을 실행함 ㆍ 명령 실행 ­ 네 번째 단계는 실행 사이클이며, 이 단계는 각 명령에 따라 변동됨 ­ 실행 사이클의 첫 번째 단계는 프로세스 ­ 메모리(Process
- Memory)이며, 데이터는 CPU와 입출력 모듈 사이를 오고감 ­ 그 다음 단계는 데이터 ­ 프로세싱(Data ­ Processing)이며, 데이터 참조에서 논리 명령 뿐 아니라 수치 명령도 이용함 ­ 그 다음 단계는 중심 변경(Central alteration)으로, 점프(jump) 명령과 같은 명령의 연 속임 ­ 마지막 단계는 다른 모든 단계에서 나온 모든 명령을 아우름 ▶ 마이크로 명령어의 코드화(encoding) 방식들 ­ 제어장치는 전혀 코드화되지 않은 마이크로 명령어 형식이나 수평 마이크로 명령어 형식을 사용해서 설계되지 않음(직접, 간접) ⋅ 제어 기억장치의 폭을 줄이고 마이크로 프로그래밍을 단순화하기 위하여 적어도 어느 정도의 코드화는 사용됨  200   ⋅ 마이크로 명령어의 여러 개의 필드들은 코드를 가지고 있으며, 해독되어 하나 혹은 다 수의 제어 신호들을 활성화시킴 ­ 직접 코드화 방식과 간접 코드화 방식으로 구분됨 ⋅ 직접 코드화 방식은 마이크로 명령어가 실행될 때, 각 필드가 해독되어 제어 신호들을 발생함 ⋅ 간접 코드화 방식은 간접 주소 지정 방식의 개념과 유사하게 한 필드가 다른 필드를 해석하는 방법을 지정하는데 사용됨 ▶ 직접 코드화 방식과 간접 코드화 방식의 개념 제어신호 (a) 직접 코드화 (b) 간접 코드화 제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ㆍ 직접 코드화 방법 ­ 마이크로 명령어의 각 필드들이 코드화된 데이터를 가지고 있다가 제어 신호를 생성하기 위해서 해당하는 해독 논리(decode Logic)장치를 이용하여 해독 과정을 거치며, 해독된 신호들은 최종의 제어 신호가 됨 ㆍ 간접 코드화 방법 ­ 각각의 마이크로 명령어 필드들이 코드화된 데이터를 가지고 있음 ­ 첫 번째 단계에서는 각각의 필드에 대한 해독 과정을 수행하고, 두 번째 단계에서는 필 요에 따라서 한 필드의 해독된 내용이 다른 필드들의 또 다른 해독의 방법을 지정하기 위해서 사용됨 ­ 두 번째 필드가 두 번의 해독을 통해서 제어 신호가 생성되는 것을 확인할 수 있음 2. 마이크로 오퍼레이션 구현   ▶ 마이크로 연산의 형식 ­ 프로그램 실행 과정에서 각 명령은 명령어 사이클에 의해서 수행됨 ­ 명령어 사이클은 부 사이클인 명령어 인출과 실행 사이클로 구성되며, 부 사이클도 여러 단 계로 이루어짐 ­ 부 사이클의 각 단계에서 수행되는 동작은 프로그램 수행에서 가장 기본 단위의 수행으로  201   마이크로 연산이라고 하며, 이러한 이유로 원자 연산이라고도 함(더 이상 나눌 수 없음) ­ 따라서 마이크로 연산을 통해서 제어과정을 이해할 수 있음 ­ 마이크로 연산을 표현하기 위해서는 동작 기호를 사용함 ▶ 마이크로 연산의 형식(동작 기호) 기호 적용되는 곳 표현의 예 대문자와 숫자 레지스터 R, MAR, R2 아래첨자 레지스터 내에 있는 비트 R R   괄호 () 레지스터 내의 위치 I(1 ­

5), M(MAR) 화살표 ← 정보의 전달 R ← B 콜론 : 제어 기능 P: 쉼표 , 2개의 마이크로 오퍼레이션 구분 R ← B, MAR ← K ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 마이크로 연산의 동작 기호 ㆍ 대문자 또는 대문자와 숫자가 함께 표현된 경우 ­ 레지스터를 문자 기호로 나타낸 것이며, 표현의 예에서 R은 R레지스터를 나타내고 MAR은 기억장치 주소 레지스터를 나타내고, R2는 두 번째 레지스터라는 의미로 표현 된 것 ㆍ 레지스터를 표현하는 문자 기호의 아래 첨자 ­ 레지스터 내의 비트 위치를 나타내며, 표현의 예에서 R 은 R레지스터의 1번째 비트를  나타내고, B 는 B레지스터의 2번째 비트를 나타냄  ㆍ 그침표 ( :) ­ 제어를 수행하는 기능을 표시하며, 따라서 P : R ← B는 제어 기능 P에 의해 B의 레지 스터 데이터가 R의 레지스터로 이동한다는 의미를 갖음 ㆍ 괄호 ( ) ­ 레지스터 내의 위치를 나타낸 것으로, 기억장치 경우에서는 주소가 지정하는 기억장치 위치를 나타내는 용도로 많이 사용됨 ­ I(1
-

5)는 I레지스터의 1 ~ 5번 위치의 데이터를 나타내며, M(MAR)에서는 MAR에 저 장된 번지의 기억장치의 위치를 나타내고, MAR에 100을 저장하고 있다면 M(MAR)은 기억장치 100번지를 나타냄 ㆍ 화살표 ­ 정보가 전달되는 것을 나타낸 것으로 R ← B는 B레지스터의 데이터를 R레지스터로 이 동하는 것을 나타냄 ㆍ 쉼표 (,) ­ 2개 이상의 마이크로 연산을 구분하는데 사용됨 ▶ 마이크로 사이클의 마이크로 연산(인출, 간접, 실행, 인터럽트)
1) 명령들의 집합인 프로그램은 계층 구조를 형성  202   ­ 프로그램이 실행된다는 것은 프로그램을 구성하는 명령어들이 순차적으로 중앙처리장치 (CPU)에서 해독되고 제어 신호를 발생하여서 실행함 ­ 완전한 명령어 사이클은 네 개의 부 사이클로 구성 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 마이크로 사이클의 마이크로 연산
1) 명령들의 집합인 프로그램은 계층 구조를 형성 ⋅ 인출 사이클은 기억장치에서 명령어를 중앙처리장치로 읽어오는 과정임 ⋅ 간접 사이클은 간접 주소 지정 방법을 사용하는 경우에 유효 주소를 찾는 사이클임 ⋅ 실행 사이클은 실제적으로 명령어가 실행되며, 여러 종류의 명령어가 존재하므로 해당 명령어에 맞게 동작을 실행하는 단계임 ⋅ 인터럽트 사이클은 프로그램 수행 중에 인터럽트 발생여부를 파악하고, 인터럽트가 발 생했으면 인터럽트 서브 루틴이 수행 될 수 있도록 해주는 사이클임 ⋅ 각 부 사이클의 실행은 여러 단계의 마이크로 연산으로 구성됨 ▶ ex)etch cycle의 마이크로 연산 ­ 명령어 인출 사이클의 마이크로 연산과정에서 필요한 레지스터들(PC
-MAR
-MBR
-IR) ⋅ 기억장치 주소 레지스터(MAR)는 주소 데이터를 전달하는 주소 버스와 접속되며, 읽기 또는 쓰기 동작을 위해서 사용되는 주소를 임시로 저장함 ⋅ 기억장치 버퍼 레지스터(MBR)는 데이터를 전송하는 데이터 버스와 접속되며, 읽기 또 는 쓰기 동작을 수행할 데이터를 임시로 저장함 ⋅ 인출과정에서는 다음에 인출될 명령어의 주소를 가지고 있는 프로그램 카운터(PC)와 인출된 명령을 임시로 저장하는 명령어 레지스터(IR)를 이용함

1) 인출 과정의 마이크로 연산 ­ 첫 번째 클록 t 에서는 다음 명령어의 주소가 저장된 PC 내용을 MAR로 이동시킴  ­ 두 번째 클록 t 에서는 MAR에 저장된 주소에 근거하여, 해당 기억장치에 저장되어 있는  명령어를 MBR로 이동시키며, 이와 동시에 PC를 명령어 바이트 수만큼 증가시켜서 다음 명령어의 주소를 표시해 줌 ­ MBR에 저장된 명령어 내용을 실행하기 위해서 IR로 이동하고 명령어 인출 단계를 완료하 는데, 인출 사이클에서 PC의 증가 단계는 세 번째 클록 t 에서 수행될 수도 있음   203  
2) 인출 과정의 마이크로 연산 : t 에서 PC를 증가할 수 있는가?  CPU 클록 마이크로 연산 CPU 클록 마이크로 연산 t MAR ← PC t MAR ← PC   MBR ← M(MAR) t MBR ← M(MAR) t   PC ← PC + 1 IR ← MBR t t  IR ← MBR  PC ← PC + 1 <인출 사이클의 마이크로 연산> <PC 증가 과정이 포함된 마이크로 연산> ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ Indirect cycle의 마이크로 연산 ­ 간접 사이클은 간접 주소 지정 방식을 사용하는 명령어에서 오퍼랜드부분의 유효 주소를 결정하는데 사용 ⋅ 간접 주소 지정 방식을 사용한 명령어의 오퍼랜드 필드에는 읽거나 쓰기 동작을 수행할 데이터가 저장되어 있는 기억장치의 주소를 표시함 ⋅ 오퍼랜드 필드에 저장된 주소가 지시하는 기억 장소에 유효 주소(effective address)가 저장되어 있음
1) 기억간장접치 에주서소지의정 간 방접식 주소 지정 방식과 레지스터 간접 주소 지정 방식(속도 보완) 기억장치 EA 레지스터 간접 주소지정 방식 레지스터 세트 기억장치 EA ※ 컴퓨터 구조와 원리 2.0, 신종홍
① 첫 번째 클록 t 에서는 IR에 저장되어 있는 명령어의 오퍼랜드 부분 즉, 주소 부분을  MAR로 이동하며, 이 주소는 유효 주소(직접)이거나, 유효 주소가 저장되어 있는 곳의 주 소(간접)를 나타냄
② 두 번째 클록 t 에서는 유효 주소가 저장된 기억장치 또는 레지스터의 내용을 MBR에 저  장함
③ 세 번째 클록 t 에서는 MBR의 저장되어 있는 유효 주소를 IR의 주소부분으로 이동시킴  따라서 명령어 레지스터의 명령어 오퍼랜드 부분에 유효 주소가 자리를 잡게 되고, 실행 사이클로 넘어갈 것임  204   CPU 클록 마이크로 연산 t MAR ← IR(addr)  t MBR ← M(MAR) OR R(MAR)  t IR(addr) ← MBR(addr)  ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ Execute cycle의 마이크로 연산 ­ 컴퓨터에는 다양한 명령이 존재하며, 이 명령을 실행하는 실행 사이클에서 처리되는 마이크 로 연산 또한 다양함

1) 덧셈 연산 ­ 덧셈 연산을 수행하는 ADD 명령어의 어셈블리 언어 표현 ADD R, X ; R ← R + Memory (X) ⋅ 기억장치 X번지의 내용과 레지스터 R이 덧셈 연산을 수행하고 그 결과는 다시 레지스 터 R에 저장함 CPU 클록 마이크로 연산 t MAR ← IR(addr)  t MBR ← M(MAR)  t R ← R + MBR  ※ 컴퓨터 구조와 원리 2.0, 신종홍 ­ 이 명령어가 실행되는 것을 마이크로 연산으로 표현하면 ⋅ t : 인출과정에서 얻은 명령어를 저장하고 있는 명령어 레지스터의 주소 부분만을  MAR로 이동시키며, 이 과정은 액세스할 데이터가 저장된 기억장치 주소를 얻는 과정 임 ⋅ t : 해당 주소의 기억장치 내용을 MBR로 이동시킴즉, 덧셈 연산을 수행하게 될 데이  터가 기억장치 버퍼 레지스터(MBR)로 이동하게 되는 것임 ⋅ t : 기억장치에서부터 이동된 데이터가 저장된 MBR의 내용과 R의 내용을 더하고, 그  결과값을 다시 R에 저장하게 됨(AC를 사용해도 됨)
2) ISZ ­ ISZ 명령어는 ‘Increment and Skip ­ if
- Zero’의 약자로, 오퍼랜드의 값을 하나 증가시키 고 그 결과 값이 0이면 다음 명령어를 실행하지 않고 건너뛰는 명령어임 ISZ X ­ X번지의 내용을 1증가시키고, 그 결과가 0이면 다음 명령어를 실행하지 않고 건너뛰는 명 령어 실행이 되는데 마이크로 연산은 네 개의 사이클로 구성됨 ⋅ t : 명령어 레지스터(IR) 내의 주소부분 내용(어셈블리 표현에서 X 번지)을 MAR에 적  재함 ⋅ t : MAR에서 제시된 기억장치 주소에 의거하여, 기억장치에 저장된 데이터를 MBR로  적재함 ⋅ t : MBR의 내용을 하나 증가시킴   205   ⋅ t : 증가된 MBR의 내용을 원래의 기억장치에 저장하며, 이와 동시에, MBR의 내용을  검사하여서 그 값이 0이면 프로그램 카운터(PC)를 증가시켜 다음의 명령어를 하나 건 너뛰고 그 다음 명령어를 수행함 CPU 클록 마이크로 연산 t MAR ← IR(addr)  t MBR ← M(MAR)  t MBR ← MBR + 1  M(MAR) ← MBR t  If (MBR =

0) then (PC ← PC +
1) ※ 컴퓨터 구조와 원리 2.0, 신종홍
3) BSA ­ ‘Branch and Save return address’로 분기하고 복귀할 주소를 저장하는 명령어로 서브 루 틴 프로그램으로 분기하기 위해 사용되며, 어셈블리 표현은 다음과 같음 BSA X ­ 이 명령어는 BSA 다음 명령어(주소)를 X번지에 저장하고, 새로운 X + 1번지부터 실행을 계속하라는 의미인데, 이 때, X번지에 저장된 데이터는 복귀 주소를 나타내고, 서브 루틴의 시작 주소는 X+1번지이며, 마이크로 연산은 세 개의 클록으로 이루어짐 ⋅ t : 명령어 레지스터의 주소 부분 내용(어셈블리 표현에서 X)을 MAR에 적재하고, 동  시에 프로그램 카운터의 내용(다음 명령어 주소)를 MBR에 적재함 ⋅ t : 명령어 레지스터(IR)의 주소 부분 내용을 프로그램 카운터(PC)에 적재하고, X번지  에 MBR의 내용을 저장함즉, 복귀 주소가 저장됨 ⋅ t : 서브 루틴을 시작하기 위해서 X + 1번지가 되도록 프로그램 카운터(PC)를 증가시  킴 CPU 클록 마이크로 연산 MAR ← IR(addr) t  MBR ← PC PC ← IR(addr) t  M(MAR) ← MBR t PC ← PC + 1  ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ Interrupt cycle의 마이크로 연산 ­ 중앙처리장치가 현재 처리 중인 프로그램 루틴을 중단하고, 다른 프로그램을 수행하도록 하 는 것이 인터럽트임 ­ 명령어 사이클에서 인터럽트를 수행하려면 명령어 실행 사이클이 수행된 후 인터럽트 요청 이 있는지 여부를 판단하고, 요청이 있을 경우 인터럽트 서비스 루틴이 시작되도록 해야 함 ­ 이러한 사이클을 인터럽트 사이클이라 함다음은 인터럽트 사이클의 마이크로 연산을 나타 낸 것으로, 세 개의 클록으로 구성됨 ⋅ t : 복귀 주소를 저장하기 위해서 프로그램 카운터(PC) 내용을 MBR로 이동 시킴  ⋅ t : SP(스택 포인터)를 MAR로 이동시키고 인터럽트 처리 루틴 시작 주소를 PC에 적   206   재하며, SP는 MBR에 저장되어 있는 내용을 스택에 저장하기 위해서 저장할 위치를 지 정하는 데 사용됨 : 복귀 주소를 스택에 저장 ⋅ t : MBR의 내용을 MAR에 근거하여 해당 스택 포인터의 스택에 저장됨  CPU 클록 마이크로 연산 t MBR ← PC  MAR ← SP t  PC ← Routine
- address T M(MAR) ← MBR  ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ Interrupt cycle의 마이크로 연산 – 종류 ㆍ 슈퍼바이저 호출 인터럽트(Supervisor Call Interrupt) ­ 사용자가 프로그램에서 SVC 명령을 호출 하였을 경우, I/O 수행, 기억 장치 할당 등의 역할을 하는 인터럽트 ㆍ 입출력 인터럽트(I/O Interrupt) ­ 입출력의 종료나, 입출력의 오류에 의해 CPU의 기능이 요청되는 인터럽트 ㆍ 외부 인터럽트(External Interrupt) ­ 오퍼레이터나 타이머에 의해 의도적으로 프로그램이 중단되는 인터럽트 ㆍ 재시작 인터럽트(Restart Interrupt) ­ 오퍼레이터 및 다른 프로세스에 의해 재시작 명령이 도착했을 때 실행되는 인터럽트 ㆍ 프로그램 검사 인터럽트(Program Check Interrupt) ­ 프로그램 실행 중 보호된 기억 공간 내에 접근하거나, 불법적인 명령 수행과 같은 프로 그램의 문제가 발생한 경우 호출되는 인터럽트 ㆍ 장치 검사 인터럽트(Machine check interrupt) ­ 하드웨어 구조로 인해 발생됨 ▶ 명령어 사이클 코드(Instruction Cycle Code) ­ 중앙처리장치가 프로그램을 수행하면서 명령어가 명령어 사이클의 어느 부분을 수행하고 있는지 나타내는 코드를 명령어 사이클 코드라고 하며, 다음과 같이 명령어의 부 사이클을 이진수로 정의함 00 : 인출, 01 : 간접, 10 : 실행, 11 : 인터럽트

1) 명령어 사이클의 흐름도(ICC : 00, 01, 10,
11) ※ 컴퓨터 구조와 원리 2.0, 신종홍  207   마이크로 프로그램
1. 마이크로 프로그램을 이용한 제어 장치 모델에 대해서 학습하고 이를 설명할 수 있다. 9주차  수업목표  
2. 마이크로 프로그램을 제어하는 기법에 대해서 학습하고 이를 3교시  설명할 수 있다.
1. 제어 장치 모델 세부내용 
2. 마이크로 프로그램 제어 1. 제어 장치 모델   ▶ 중앙처리장치를 제어하기 위해 필요한 기능적 요구 사항
1) 중앙처리장치가 갖추어야 할 필수적인 구성 요소 ­ 산술 및 논리 연산장치(ALU) ­ 레지스터 집합 ­ 내부 및 외부 데이터 통로(버스) ­ 제어장치(CU)
2) 중앙처리장치가 수행할 마이크로 연산의 정의 ­ 레지스터들 간의 데이터 전송 ­ 레지스터에서 외부로의 데이터 전송 ­ 외부에서 레지스터로의 데이터 전송 ­ 산술 및 논리 연산 수행
3) 제어장치가 수행할 기능의 정의 ㆍ 순서제어(Sequencing) 기능 ­ 중앙처리장치가 마이크로 연산을 적절한 순서대로 처리하도록 해주는 기능이 필요함 ㆍ 실행(Execution) 기능 ­ 다양한 마이크로 연산에 대한 수행 기능이 필요함 ▶ 제어 장치 모델 ­ 중앙처리장치를 제어하는 제어장치에는 여러 종류의 입력이 존재하며, 이 입력들의 조합으 로 제어 신호를 생성하고 출력하게 됨
1) 기본적인 제어장치의 모델 ­ 제어장치의 입력에는 클록, 명령어 레지스터에서의 연산코드, 플래그(flag) 신호, 제어 버스 를 통해 입력되는 제어 신호가 있음 ­ 제어장치의 출력에는 중앙처리장치로 보내는 제어 신호와 제어 버스를 통해서 외부로 보내 는 제어 신호가 존재함  208   ▶ 제어 장치 모델 : 제어신호(내부/외부)
1) 기본적인 제어장치의 모델(입력과 출력) 플래그 클록 제어 버스 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 제어 장치의 입출력 신호
1) 제어장치로 들어오는 입력 신호 ㆍ 클록(Clock) 신호 ­ 제어장치의 동작 타이밍 기준이 되는 신호로서, 하나의 클록 펄스마다 하나의 마이크로 연산 혹은 마이크로 연산의 집합이 수행됨 ㆍ 명령어 레지스터 ­ 명령어의 연산 코드 필드를 제어장치에 입력하여 수행해야 할 연산을 결정하게 함 ㆍ 플래그(flag) 들 ­ 중앙처리장치의 상태를 나타내거나 이전 산술 및 논리 연산 장치의 연산 결과를 검사하 기 위해서 사용됨 ㆍ 제어 버스에서 입력되는 제어 신호 ­ 인터럽트 처리의 요구 신호 및 확인 신호 등 외부에서 들어오는 제어 신호임
2) 제어장치에서 내보내는 출력 신호 ㆍ 중앙처리장치로 전달되는 제어 신호 ­ 레지스터 간 데이터를 전송할 때 발생되며, 특정 산술 및 논리 연산의 기능을 활성화할 때 출력 됨(add) ㆍ 제어 버스를 통해 외부로 출력되는 제어 신호 ­ 중앙처리장치 밖의 기억장치나 입출력장치 모듈로 보내는 제어 신호가 존재함(주기억장 치 읽기/쓰기 제어신호) ▶ 명령어 사이클에서의 제어 신호
1) 인출 사이클에서 발생되는 제어 신호 ­ t 의 ‘MAR ← PC’ 과정에서는 PC에서 전달된 MAR의 내용이 주소 버스에 적재되려면 게  이트를 열어주는 제어 신호가 필요하므로, 다음 명령어의 주소가 주소 버스에 실리게 됨 ­ t 의 ‘MBR ← M(MAR)’ 과정에서는 제어 버스상의 ‘기억장치 읽기 제어 신호’를 활성화 하   209   고, 데이터 버스의 내용이 MBR에 저장되도록 게이트를 열어주는 제어 신호가 발생됨 ­ 같은 t 의 ‘PC ← PC + 1’ 과정에서는 프로그램 카운터의 내용에 1을 더하고 그 결과를  다시 프로그램 카운터에 저장하는 제어가 필요함 ­ t 의 ‘IR ← MBR’ 과정에서는 MBR과 IR 사이에 있는 게이트를 열기 위한 제어 신호가 필  요함
2) 간접 사이클에서 발생되는 제어 신호 ­ 간접 사이클은 간접 주소지정 방식에서만 이용되므로 먼저, 간접 주소 지정 방식인지의 여 부를 명령어 레지스터에서 검사하고 간접 사이클을 수행할지를 판단하는 제어 신호가 필요 ­ t 의 ‘MAR ← IR(Address)’ 과정에서는 명령어 레지스터의 주소가 MAR로 전달되려면 게  이트를 열어주기 위한 제어 신호가 필요함 ­ t 의 ‘MBR ← M(MAR)’ 과정에서는 시스템 버스에서 읽기 제어 신호가 활성화되고, 데이  터 버스의 내용이 MBR에 저장되도록 게이트를 열어주는 제어 신호 발생됨 ­ t 의 ‘IR(Address) ← MBR(Address)’ 과정에서는 인출 사이클과 마찬가지로 MBR과 IR 사  이에 있는 게이트를 열어주기 위한 제어 신호가 사용됨
3) 실행 사이클에서 발생되는 제어 신호 ­ 제어장치는 연산 코드(operation code)를 먼저 검사하고, 그 결과에 근거하여 실행 사이클 수행을 위한 마이크로 연산 순서를 결정함(ADD, ISZ, BSA etc) ­ 그리고 이에 알맞은 제어 신호가 발생할 것임즉, 다양한 명령 실행에 적합한 제어 신호를 발생함
4) 인터럽트 사이클에서 발생된 제어 신호 ­ 인터럽트 발생여부에 따라서 인터럽트 사이클의 수행여부가 결정되서 인터럽트를 제어하는 신호가 필요함 만약, 인터럽트가 수행되면 세 개의 클록에 의해 동작이 수행됨 ­ t 의 ‘MBR ← PC’ 과정에서는 MAR의 내용을 주소 버스에 싣도록 게이트를 열어주는 제어  신호가 사용됨 ­ t 의 ‘MAR ← SP’ 과정과 ‘PC ← Routine ­ address’ 과정에서는 주소가 전달되므로 주소  버스를 제어하는 과정이 필요함 그래서 주소 버스의 게이트를 열어주는 제어 신호가 사용 됨 ­ t 의 ‘M(MAR) ← MBR’ 과정에서는 시스템 버스에서 쓰기 제어 신호가 활성화되고 데이터  버스의 내용이 기억장치에 저장되도록 게이트를 열어주는 제어 신호가 발생됨 ▶ 데이터 통로상의 제어 신호 ­ 데이터 통로상에서 제어 신호들이 종료되는 곳을 C로 표시 i ­ 제어장치는 클록, 명령어 레지스터 그리고 플래그들에서 입력을 받고, 모든 입력을 조합하 여 제어 신호를 발생함  210                             플래그   제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 명령어 사이클과 제어 신호 명령어 사이클 마이크로
-연산 발생 제어신호 t : MAR ← PC C   t : MBR ← M(MAR) C C   Read 인출 PC ← PC + 1 t : IR ← MBR C   t : MAR ← IR(Address) C   간접 t : MBR ← M(MAR) C C   Read t : IR(Address) ← MBR(Address) C   t : MBR ← PC C   t : MAR ← SP  인터럽트 PC ← Routine
- address t : M(MAR) ← MBR C C   write ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 제어 장치의 구현 방법 ­ 제어장치는 하드웨어적인 방법과 펌웨어적인 방법, 두 가지 형태의 구현 방법이 존재함

1) 하드 와이어드 구현(hard wired implementation) ­ 제어 신호 생성을 위해서 순차와 조합논리의 설계를 통해서 구성됨(속도, 융통성) ­ 이 회로의 입력 신호는 출력 신호로 변환됨 ㆍ 하드 와이어드의 구조 ­ 제어장치를 중심으로 명령어 레지스터(IR)에서 입력이 해독될 수 있도록 해독기 (Decoder)가 존재함 ­ 클록을 입력으로 받아서 수행되는 시간발생기가 존재하며, 제어장치의 입력 신호 중 플 래그와 제어 버스 신호들은 각 비트들 마다 규정된 의미를 갖음 ­ 명령어 레지스터(IR)는 연산 코드를 해독하여 각 명령들이 여러 가지 연산을 수행할 수 있도록 함 ­ 해독기는 각 연산 코드를 고유의 논리 입력을 가지도록 변환해주는 역할을 함  211   ­ 클록은 마이크로 연산의 주기를 측정하는데 사용되며, 클록 펄스의 주기는 신호가 데이 터 경로와 중앙처리장치 회로를 통과하는 데 걸리는 시간만큼 길어야 함 클록 플래그 제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍
2) 마이크로 프로그램을 이용한 구현(micro programmed implementation) : 펌웨어 ­ 마이크로 명령어를 제어 기억장치에 저장하고 이것을 실행시켜서 제어 신호를 발생하는 방 법임 ­ 마이크로 프로그램을 이용하여 구현된 대표적인 제어장치로는 마이크로 순서기 (Micro
-sequencing)가 있음 ㆍ 마이크로 순서기의 구조 ­ 명령어 레지스터의 연산코드, 플래그, 마이크로 코드 기억장치의 출력이 다음 명령의 주 소를 결정 ­ 얻어진 마이크로 코드 기억장치의 주소는 레지스터에 임시로 저장되었다가 다시 이 주소 에 근거하여, 마이크로 코드가 실행 ­ 이 실행 결과의 출력이 제어 신호가 됨

3) 마이크로 프로그램을 이용한 구현(micro programmed implementation) : CAR 연산 코드 플래그 마이크로 연산 ※ 컴퓨터 구조와 원리 2.0, 신종홍  212   2. 마이크로 프로그램 제어   ▶ 마이크로 프로그램을 이용한 제어 ­ 하드 와이어드 제어 방식은 마이크로 연산의 실행 순서 제어와 수행을 위한 회로 그리고 연산 코드의 해석 및 ALU 플래그들의 검사 등을 위한 논리 회로를 포함해야 함 ⋅ 이 과정에서 하드웨어의 설계와 검사는 복잡한 과정이며, 회로의 융통성도 낮다고 할 수 있음 ⋅ 새로운 명령을 추가하기 위하여 설계를 변경하는 것이 쉬운 일이 아님(속도, 융통성, 가격) ­ 오늘날 제어장치의 구현은 하드 와이어드 구현보다는 마이크로 프로그램을 이용함
1) 중앙처리장치에서 마이크로 프로그램을 이용하는 제어장치의 구성 ­ 제어장치는 순서제어 논리장치, 제어장치 레지스터들, 명령어 해독기, 제어 기억장치로 구 성되며, 제어장치 레지스터는 제어 주소 레지스터(CAR), 제어 버퍼 레지스터(CBR), 서브루 틴 레지스터(SBR) 등으로 구성됨 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 마이크로 명령어(micro instruction) ㆍ 마이크로 프로그래밍 언어(micro ­ programming language) ­ 마이크로 연산은 기계어이므로 이진 비트로 표현되지만, 사용의 편리성을 위해서 기호들 (symbols)을 이용해서 표현하는데, 이것을 마이크로 프로그래밍 언어라고 함 ㆍ 마이크로 명령어(micro instruction) ­ 명령어 사이클에서 인출 사이클, 간접 사이클, 실행 사이클, 인터럽트 사이클은 여러 단 계의 마이크로 연산들로 표현되는데 동시에 수행되는 마이크로 연산 집합을 마이크로 명 령어라고 함 ­ 그래서 명령어 사이클은 마이크로 명령어들로 표현됨 ㆍ 마이크로 프로그램(micro ­ program) ­ 마이크로 명령어들을 이용하여 작성된 프로그램을 마이크로 프로그램이라고 하는데, 이 것은 펌웨어(firmware) 라고도 불림 ㆍ 루틴(routine) ­ 마이크로 프로그램에서 중앙처리장치의 특정 기능을 수행하기 위한 마이크로 명령어들의 그룹을 루틴(routine)이라고 함(add)  213   ▶ 마이크로 명령어 형식 ­ 마이크로 명령어 형식에는 수평적 마이크로 명령어와 수직적 마이크로 명령어가 있음 분기조건 시스템 버스 ⋅ 무조건 제어신호 ⋅ zero ⋅ 오버플로우 ⋅ 간접비트 (a) 수평적 마이크로 명령어 분기 조건 (b) 수직적 마이크로 명령어 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 수평적 마이크로 명령어 ­ 마이크로 명령어의 각 필드가 각 제어 신호에 대응되는 방식으로, 중앙처리장치 내부의 각 제어 신호들과 시스템 버스의 각 제어 신호들에 필드가 할당됨 ­ 분기에서 사용될 조건을 나타내는 조건 필드와 분기 발생시 다음에 실행될 마이크로 명령 어의 주소를 가지고 있는 필드가 있음
1) 수평 마이크로 명령어의 장단점(지연, 용량) ­ 하드웨어가 간단하고, 해독에 따른 지연 시간이 없다는 장점을 갖음 ­ 마이크로 명령어의 비트 수가 길어서 큰 용량의 제어 기억장치가 필요함
2) 수평 마이크로 명령어의 동작 ­ 마이크로 명령어 실행을 위하여 비트 값이 1로 표시된 모든 제어 선을 ON ­ 비트 값이 0인 모든 제어 선을 Oex)ex) 시키며, 이 결과로 발생되는 제어 신호들은 한 개 이 상의 마이크로 연산을 수행시킬 것임 ­ 만약 분기 조건 비트의 값이 만족되지 않으면, 다음에 위치한 마이크로 명령어가 순서대로 실행됨 ­ 만약 조건 비트의 값이 만족되면, 다음에 실행될 마이크로 명령어는 주소 필드에 의하여 지 정됨 ▶ 수직적 마이크로 명령어 ­ 코드화된 비트들을 이용하여 마이크로 명령어의 각 기능 코드를 구성 ­ 마이크로 명령어의 연산 필드에 적은 수의 코드화된(encoded) 비트들을 포함시켜 제어 기 억장치의 용량을 줄이고, 해독기를 이용하여 코드를 필요한 수만큼의 제어 신호들로 확장하 는 방식임 ­ 마이크로 명령어의 비트 수가 감소되는 장점을 가지지만, 제어 신호 발생을 위하여 코드화  214   된 비트들을 해독하기 위한 지연이 발생함(용량, 속도)
1) 수직적 마이크로 명령어의 제어 신호 발생 방법 ­ 각 연산 필드의 내용은 코드화된 비트이고 해독기에서 그 내용이 해독되고 제어 신호들이 발생함 ­ 3 X 8 해독기는 코드화된 3비트를 입력으로 받아들여서 8비트의 제어 신호가 되도록 코드 를 해독함 제어신호 제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 제어장치의 구조와 동작 ­ 마이크로 프로그램 제어장치는 명령어 해독기, 제어주소 레지스터(CAR), 제어 기억장치, 제 어버퍼 레지스터(CBR), 서브루틴 레지스터(SBR), 순서제어 모듈로 구성됨 조건 플래그 내부 제어 외부 제어 신호들 신호들 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ㆍ 명령어 해독기(Instruction decoder) ­ 명령어 레지스터(IR)가 보낸 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작 주소를 결정하는 역할을 함 ㆍ 제어 주소 레지스터(CAR, Control Address Register) ­ 다음에 실행할 마이크로 명령어의 주소를 저장하는 레지스터이며, 저장된 주소는 제어 기억장치의 특정 위치를 지칭함 ㆍ 제어 기억장치(Control memory) ­ 마이크로 명령어들로 이루어진 마이크로 프로그램을 저장하는 내부 기억장치임  215   ㆍ 제어 버퍼 레지스터(CBR, Control Buffer Register) ­ 제어기억장치에서 읽은 마이크로 명령어 비트들을 일시적으로 저장하는 레지스터임 ㆍ 서브루틴 레지스터(SBR, Subroutine Register) ­ 마이크로 프로그램에서 서브루틴이 호출되는 경우에 현재의 CAR 내용을 일시적으로 저 장하는 레지스터임 ㆍ 순서제어 모듈(Sequencing module) ­ 마이크로 명령어의 실행 순서를 결정하는 회로들의 집합 ▶ Control memory ­ 마이크로 프로그램 코드들은 최종적으로 제어 기억장치에 저장
1) 제어 기억장치의 내부 구성 ­ 전반부에는 명령어 사이클의 인출, 간접, 인터럽트 등의 부 사이클에 해당하는 공통 루틴들 을 저장함 ­ 후반부는 각 명령어의 실행 사이클 루틴들이 저장됨 ­ 각 루틴 내의 마이크로 명령어들은 순차적으로 실행되며, 각 루틴은 다음에 실행할 위치를 나타내는 분기 혹은 점프 명령어로 끝남 인출 사이클 루틴 간접 사이클 루틴 인터럽트 사이클 루틴 실행 사이클 시작 AND 루틴 ADD 루틴 IOex) 루틴 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ Control memory에 저장된 마이크로 명령어 형식 ­ 연산 필드가 두 개이므로, 두 개의 마이크로 연산을 동시에 수행 가능함 ­ 그리고 조건 필드는 분기에 사용될 조건 플래그를 지정하고 분기 필드는 분기의 종류와 다 음에 실행할 마이크로 명령어의 주소를 결정하는 방법을 명시함 ­ 마지막으로 주소 필드의 내용은 분기가 발생하는 경우에 목적지 마이크로 명령어 주소로 사용됨 3비트 3비트 2비트 2비트 8비트 ※ 컴퓨터 구조와 원리 2.0, 신종홍  216   ▶ 마이크로 프로그램을 이용한 제어 장치의 동작 과정
1) 마이크로 프로그램을 이용한 제어 장치의 동작 흐름도 ­ 순서제어 논리장치 또는 순서제어 모듈이 제어 기억장치로 READ 명령어를 보냄 ­ 제어 주소 레지스터 CAR에 명시된 제어 기억장치 주소에 저장되어 있는 단어가 읽혀져 제 어 버퍼 레지스터 CBR로 옮겨짐 ­ 제어 버퍼 레지스터 CBR의 내용에 따라 제어 신호들과 다음 주소 정보가 발생됨 ­ 순서제어 논리장치 또는 순서제어 모듈은 CBR의 내용과 ALU 플래그들에 근거하여 새로운 주소를 CAR에 적재하고, 다시 위의 과정을 반복하게 됨 ALU 플래그 클록 CPU 내부로의 시스템 버스로의 제어신호 제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 순서제어 논리장치와 해독기
1) 순서제어 논리장치 또는 순서제어 모듈 ­ 입력되는 ALU 플래그들과 제어 버퍼 레지스터(CBR) 내용은 여러 동작을 결정함 ­ 가장 기본적으로 다음 명령어를 인출하기 위해서 제어 주소 레지스터의 내용에 1을 더하는 결정을 내림 ­ 그리고 제어 버퍼 레지스터(CBR)의 주소 필드 값을 제어 주소 레지스터(CAR)에 적재하여 서, 점프 마이크로 명령어에 의하여 새로운 루틴으로 점프하게 함 ­ 또한, 명령어 레지스터 IR에 있는 연산 코드에 근거하여 해당 루틴의 주소를 제어 주소 레 지스터(CAR)에 적재해서 명령어 루틴으로 점프하게 함
2) 해독기 ­ 제어장치에는 해독기 2개가 존재함 ­ 명령어 레지스터의 바로 아래에 존재하는 해독기는 명령어 레지스터 IR의 연산 코드를 제 어 기억장치 주소로 변경하는 역할을 함 ­ 다음으로 제어 버퍼 레지스터 밑에 존재하는 해독기는 수직 마이크로 명령어에서 코드화된 비트를 해독하는 데에 사용됨  217   ▶ 마이크로 명령어의 순서제어
1) 제어장치의 기본 동작 ­ 제어기억장치에서 다음 마이크로 명령어를 읽어오는 마이크로 명령어 순서 제어임 ­ 마이크로 명령어 실행에 필요한 제어 신호들을 발생하는 마이크로 명령어의 실행
2) 순서제어 논리장치를 포함하고 있는 제어장치 ­ MUX 1은 다음에 실행할 마이크로 명령어의 주소를 선택하는 장치임 ­ MUX 2는 조건 플래그를 선택하여 주소 선택 회로로 전송
3) 순서제어 논리장치를 포함하고 있는 제어장치(MUX1, MUX2) 루틴 주소(사상 결과)  주소 조건 ※ 컴퓨터 구조와 원리 2.0, 신종홍 ▶ 마이크로 명령어의 실행 ㆍ 마이크로 명령어의 사이클 ­ 명령어의 사이클처럼 마이크로 명령어도 사이클로 구성됨 ­ 마이크로 프로그램을 이용하는 프로세서에서 가장 기본적인 사건(event)으로, 두 개의 사건들로 구성됨 ㆍ 인출(ex)etch) 사건 ­ 마이크로 명령어를 제어 기억장치에서 제어 버퍼 레지스터(CBR)로 읽어 오는 과정임 ㆍ 실행(Execute) 사건 ­ 제어 신호들을 발생하는 과정임 ­ 생성된 제어 신호는 프로세서 내의 각 부분들을 제어하며, 나머지 신호들은 외부 제어 버스나 다른 외부 인터페이스로 보내짐(CPU 내부/외부) ­ 실행 사건의 부수적인 기능으로 다음 마이크로 명령어의 주소를 결정함 ▶ 제어장치에서 마이크로 명령어의 실행 ­ 순서제어 논리 모듈은 명령어 레지스터, ALU 플래그들, 제어 주소 레지스터 그리고 제어 버퍼 레지스터를 입력으로 사용하여 다음 마이크로 명령어의 주소를 생성함 ­ 제어 버퍼 레지스터(CBR)는 실제 주소나 제어 비트들 또는 두 가지 모두를 제공함  218   ­ 제어 논리 모듈은 마이크로 명령어 내의 몇몇 비트들의 값에 근거하여 제어 신호들을 발생 하게 됨 ▶ 제어장치에서 마이크로 명령어의 실행(순서제어, 제어논리) 명령어 레지스터 ALU 플래그 클록 내부 제어신호 외부 제어신호 ※ 컴퓨터 구조와 원리 2.0, 신종홍  219   기억장치의 분류와 특성
1. 컴퓨터에서 사용하는 기억장치들의 분류들을 학습하고 이를 설명할 수 있다. 10주차  수업목표  
2. 컴퓨터 내부에서 기억장치를 계층적으로 만드는 이유에 대해서 1교시  학습하고 이를 설명할 수 있다.
1. 기억장치 분류 세부내용 
2. 계층적 기억장치 1. 기억장치 분류   ▶ 기억장치의 분류와 특성 ㆍ 기억장치 액세스(memory access) ­ CPU가 어떤 정보를 기억장치에 쓰거나 기억장치로부터 읽는 동작(read/write)
1) 기억장치의 액세스 유형 ㆍ 순차적 액세스(sequential access) ­ 저장된 정보를 처음부터 순서대로 액세스하는 방식 [예 : 자기 테이프] ㆍ 직접 액세스(direct access) ­ 액세스할 위치 근처로 직접 이동한 다음에, 순차적 검색을 통하여 최종 위치에 도달하는 방식 [예 : 디스크, CD ­ ROM] ㆍ 임의 액세스(random access) ­ 주소에 의해 직접 기억 장소를 찾아 액세스하며, 어떤 기억 장소든 액세스하는 시간이 동일 [예 : 반도체 기억장치] ㆍ 연관 액세스(associative access) ­ 저장된 내용의 특정 비트들을 비교하여, 일치하는 내용을 액세스 [예 : 연관 기억장치 (associative memory)] ▶ 기억장치의 설계/전송 단위/주소지정 단위 ㆍ 기억장치 시스템을 설계하는 데 있어 고려해야 할 주요 특성들 ­ 용량(capacity) ­ 액세스 속도(access time) ㆍ 전송 단위(unit of transfer) ­ CPU가 한 번의 기억장치 액세스에 의하여 읽거나 쓸 수 있는 비트 수 ⋅ 주기억장치 : 단어(word) 단위(32bit or 64bit) ⋅ 보조저장장치 : 블록(512 바이트 혹은 1K 바이트) 단위 ㆍ 주소지정 단위(addressable unit) ­ 주소가 지정된 각 기억 장소 당 저장되는 데이터 길이 ⋅ 바이트 단위 혹은 단어 단위 → 주소 비트의 수 A 와 주소지정 단위의 수 N 과의 관계 :   220   ▶ 액세스 속도와 관련된 피라미터들 ㆍ 액세스 시간(Access time) ­ 주소와 쓰기 / 읽기 신호가 도착한 순간부터 데이터 액세스가 완료되는 순간까지의 시간 ㆍ 데이터 전송률(data transfer rate) ­ 기억장치로부터 초당 액세스 되는 비트 수 (1 / 액세스 시간) × (한번에 읽혀지는 데이터 비트 수) ⋅ 액세스 시간 = 100ns, 액세스 단위 = 32비트인 경우 데이터 전송률 = (1 / 100ns) × 32 / 8 = 40 [Mbytes / sec] ▶ 기억장치의 유형
1) 기억장치의 제조 재료에 따른 유형 ㆍ 반도체 기억장치(semiconductor memory) ­ 반도체 물질인 실리콘(Si) 칩을 이용한 기억장치 [예 : RAM, ROM, 플래시 메모리, SSD] ㆍ 자기 ­ 표면 기억장치(magnetic ­ surface memory) ­ 자화 물질로 코팅된 표면에 정보를 저장하는 기억장치 [예 : 디스크(HDD)]
2) 데이터를 저장하는 성질에 따른 유형 ㆍ 휘발성 기억장치(volatile memory) ­ 전원 공급이 중단되면 내용이 지워지는 기억장치 [예 : RAM](비휘발성 RAM도 존재) ㆍ 비휘발성 기억장치(nonvolatile memory) ­ 전원 공급에 관계없는 영구 저장장치 [예: ROM, 디스크(HDD), SSD]
3) 삭제불가능 기억장치(non ­ erasable memory) ­ 내용 변경이 불가능한 기억장치 [예: ROM](어렵지만 가능) ▶ ROM(Read Only Memory) ­ 영구 저장이 가능한 반도체 기억장치 ­ 읽는 것만 가능하고, 쓰는 것은 불가능(EPROM) ­ 아래 내용들의 저장에 사용 ⋅ 시스템 초기화 및 진단 프로그램(BIOS) ⋅ 빈번히 사용되는 함수들을 위한 서브루틴들 ⋅ 제어 유니트의 마이크로프로그램(CU) 칩 선택 신호 읽기 신호 데이터 버스 주소버스 ※ 컴퓨터구조론, 생능출판사, 2019  221   v 고정 기억 장치(읽기 전용 기억기) 또는 롬(ROM, read ­ only memory)은 반도체 기억 장치의 하나로 사람의 본능에 비유할 수 있으며, 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있음 ⋅ 그리고 그 정보들을 기억하기 위해 다른 정보들은 기억하지 않음 ⋅ 그러나 램(RAM)은 읽고 쓰기가 가능한데, 대신 전원을 끄면 데이터가 지워짐(휘발성) ⋅ 하지만 롬은 전원을 꺼도 데이터가 지워지지 않기 때문에 바이오스(BIOS)나 운영 체제 (OS)또는 펌웨어의 저장에 쓰였으나 최근에는 일부분이 읽고 쓰기가 가능한 플래시 메 모리 등으로 일부 대체되었음 ⋅ ROM에 데이터를 저장하는 도구로 ROM 라이터가 쓰였음
1) ROM의 특징 ­ 고정 기억 장치는 자카드식 문직기용으로 사용되었음(직물) ­ 가장 단순한 형태의 솔리드 스테이트 롬은 반도체 기술 그 자체만큼 오래되었음 ­ 조합 논리 게이트는 n비트 주소 입력을 임의의 값의 m비트 데이터 출력(순람표)으로 수동 할당할 수 있었음
2) 마스크 롬(MROM) ­ 집적 회로가 발명되면서 마스크 롬이 탄생되었음 ­ 마스크 롬은 일련의 워드 줄(주소 입력)과 비트 줄(데이터 출력)으로 구성되어 있으며, 선택 적으로 트랜지스터 스위치와 함께 결합되며, 정규적인 물리적 설계와 예측 가능한 전달 지 연이 있는 임의의 순람표를 표현할 수 있음 ­ 마스크 롬의 경우, 데이터는 물리적으로 회로에 인코딩되므로 제조 시에만 프로그래밍이 가 능하였는데, 이는 수많은 심각한 단점을 불러일으켰음(제조사
-1번)

3) 마스크 롬의 단점
① 대량으로 마스크 롬을 구매해야 경제적, 사용자들이 자신 들의 설계대로 파운드리와 계약 해야 하기 때문(위탁)
② 같은 이유로 마스크 롬의 설계를 완성하고 완성된 제품을 받는 소요 시간이 김
③ 마스크 롬은 연구개발 작업에 비현실적이며, 개발자들이 설계를 개선하기 위해 자주 메모 리의 콘텐츠를 수정할 필요가 있기 때문임
④ 결함이 있는 마스크 롬을 제품에 장착할 경우, 수정하는 유일한 방법은 제품 리콜을 통해 물리적으로 롬을 교체하는 것임

4) ROM의 연도별 특징 ㆍ 1956년 ­ PROM이 발명되어 사용자들이 고전압 펄스를 응용하여 물리적으로 구조를 딱 한 번 변 경함으로써 콘텐츠를 프로그래밍할 수 있었음(사용자
-1번) ­ 여기에는 상기의 1, 2번 문제를 다루게 되는데, 회사가 단순히 다량의 신규 PROM 칩 들을 주문하고 디자이너의 편의에 따라 원하는 콘텐츠로 프로그래밍할 수 있기 때문임 ㆍ 1971년 ­ EPROM이 발명되었으며, 위의 3번 문제가 해결되었는데, PROM과 달리 EPROM은 강 한 자외선에 노출시킴으로써 프로그래밍되지 않은 상태로 반복적으로 초기화가 가능함  222   ㆍ 1983년 ­ EEPROM이 발명되었고, 위의 문제 4번이 해결되었음 ㆍ 1980년대 중반 ­ 도시바가 플래시 메모리를 발명 ㆍ 1990년대 초 ­ 도시바가 발명한 플래시 메모리가 상용화 되었으며, 이는 EEPROM의 일종으로서 손상 을 일으키지 않고 수천 번이나 삭제와 재프로그래밍을 가능하게 하였음 ­ 가장 최근의 개발은 낸드(nand) 플래시이며, 이 또한 도시바가 발명하였음 ▶ ROM의 종류 ㆍ PROM(Programmable ROM) ­ 사용자가 한 번은 쓰는 것이 가능한 ROM ㆍ EPROM(Erasable Programmable ROM) ­ 자외선(UVEPROM)을 이용하여 내용을 지우는 것이 가능한 PROM, 여러 번 쓰기가 가 능(사용자
-N번) ㆍ EEPROM(Electrically Erasable PROM) ­ 전기적으로 지울 수 있는 EPROM, 데이터 갱신 횟수 제한(수만 번 정도) ㆍ 플래시 메모리(flash memory) ­ NAND형 : 페이지(2KB / 4KB) 단위 읽기 / 쓰기 가능, 블록(64 / 128페이지) 단위 삭 제, [비교 : NOR형은 바이트 단위 읽기 / 쓰기 가능] ­ EEPROM에 비하여 삭제 시간이 더 빠르고, 집적 밀도도 더 높음 ­ 삭제 횟수 제한(100,000~1,000,000회) ­ 하드 디스크를 대체하는 SSD(solid state disk)의 구성요소 ▶ 16진수(Hexadecimal number) 
- 주소 0 0000 00H 0000 0000 000H 0000 0000 0000 1 0001 01H 0000 0001 001H 0000 0000 0001 2 0010 02H 0000 0010 002H 0000 0000 0010 : : : : : : 9 1001 0EH 0000 1110 00EH 0000 0000 1110 A 1010 0ex)H 0000 1111 00ex)H 0000 0000 1111 B 1011 10H 0001 0000 010H 0000 0001 0000 C 1100 : : 01ex)H 0000 0001 1111 D 1101 1ex)H 0001 1111 100H 0001 0000 0000 E 1110 3ex)H 0011 1111 1ex)ex)H 0001 1111 1111 ex) 1111 7ex)H 0111 1111 3ex)ex)H 0011 1111 1111 ex)ex)H 1111 1111 7ex)ex)H 0111 1111 1111 ex)ex)ex)H 1111 1111 1111  223   2. 계층적 기억장치   ▶ 계층화의 필요성과 효과 ㆍ 필요성 ­ 기억장치들은 속도, 용량 및 가격 측면에서 매우 다양 ­ 적절한 성능(속도), 용량 및 가격의 기억장치 구성 필요 ㆍ 효과 ­ 기억장치시스템의 성능 대 가격비(performance/cost ratio) 향상(경제학)

1) 기억장치 특성 ­ 액세스 속도가 높아질수록, 비트당 가격은 높아짐 ­ 용량이 커질수록, 비트당 가격은 낮아짐 ­ 용량이 커질수록, 액세스 시간은 길어짐
2) 계층적 기억장치시스템의 기본 구성 방법 ㆍ 첫 번째 계층 기억장치 ­ 속도가 빠르지만 가격은 높은 기억장치 사용(용량 작음) ㆍ 두 번째 계층 기억장치 ­ 속도는 느리지만 가격이 낮은 기억장치 사용(용량 큼) ▶ 2단계 계층적 기억장치(1단계 : 고속, 소용량, 2단계 : 저속, 대용량) ㆍ 동작원리 ­ 원하는 데이터가 첫 번째 계층 기억장치에 있다면 즉시 액세스하고, 만약 없다면, 두 번 째 계층의 기억장치를 액세스(히트율이 중요 : 지역성) ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 예)
- 첫 번째 계층 기억장치의 액세스 시간 = 10ns
- 두 번째 계층 기억장치의 액세스 시간 = 100ns(10ns 포함)
- 액세스할 정보가 첫 번째 계층 기억장치에 있을 확률 = 50 % ⇨ 평균 기억장치 액세스 시간 = (0.5 × 10ns) + (0.5 × 100ns) = 55ns  224  

1) 데이터가 첫 번째 계층의 기억장치(M )에 있는 비율에 따른 평균 액세스 시간(히트율이 L 중요 : 지역성) 비율 평균 액세스 시간 28% 82ns 40% 64ns 60% 46ns 80% 28ns 100% 10ns ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 지역성의 원리(principle of locality) v 지역성의 원리는 기억장치의 액세스가 몇몇 특정 영역에 집중되는 현상(시간, 공간) ­ 짧은 시간을 기준으로 보면, 프로세서가 기억장치의 한정된 몇몇 위치들을 집중적으로 액세 스하면서 작업을 수행 ­ 프로그램이 실행되는 동안에 일반적으로 지역성의 원리에 의해, 첫 번째 계층의 기억장치에 대한 액세스 횟수가 두 번째 계층의 기억장치에 대한 액세스보다 훨씬 더 많음 ⇨ 지역성의 원리가 적용되는 경우, 평균 기억장치 액세스 시간이 단축됨(적용 안되면 역효 과) ▶ 기억장치 계층 : 외장 HDD, 클라우드
1) 상위 계층으로 갈수록 ­ 비트당 가격이 높아지고, 용량은 감소하며 ­ 액세스 시간이 짧아지고, CPU에 의한 액세스 빈도는 상승 내부 기억장치 속도 상승 용량 증가 외부 기억장치 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 기억장치 계층 
1) 하위 계층으로 내려갈수록 ­ 용량이 더 커지고 ­ 비트당 가격은 떨어지며 ­ 지역성의 원리로 인하여 액세스 빈도는 더 낮아짐  225  
2) 캐시 메모리(cache memory) ­ 주기억장치의 액세스 속도가 CPU에 비하여 현저히 느리기 때문에 주기억장치로부터 데이 터를 읽어오는 동안에 CPU가 오랫동안 기다려야 하므로, 그에 따른 성능 저하를 줄이기 위하여 CPU와 주기억장치 사이에 설치하는 고속의 반도체 기억장치 ㆍ 내부 기억장치(internal memory) ­ CPU가 직접 액세스할 수 있는 기억장치들 ⋅ 예) CPU 레지스터, 캐시 기억장치, 주기억장치 ㆍ 외부 기억장치(external memory) ­ CPU가 직접 액세스할 수 없고, 장치 제어기(device controller)를 통해서만 액세스할 수 있는 기억장치들 ⋅ 예) 디스크(HDD), SSD, CD
-ROM ▶ 기억장치 랭크(memory rank) v 기억장치 랭크(memory rank)는 데이터 입출력 폭이 64비트가 되도록 구성한 기억장치 모듈(다수의 기억장치 칩들로 구성) ­ 기억장치 산업표준그룹(memory industry standard group) 인 JEDEC에 의해 정의됨 ­ x4 혹은 x8 조직의 칩들을 여러 개 사용하여 데이터 입출력 폭이 64비트가 되도록 함 ⋅ 예)
- ×4 조직의 SDRAM 사용 → 16개를 병렬접속
- ×8 조직의 SDRAM 사용 → 8개를 병렬 접속 ­ 기억장치 모듈은 주 기판(main board)의 기억장치 슬롯(memory slot)에 장착 ㆍ 단면 모듈(single­side module) ­ 기판의 한 면에만 칩들을 장착하며, 접속 핀(connection pin) 들도 한 면에만 설치하거 나 양면에 중복적으로 설치 ­ SIMM(single in
-line memory module)이라고도 부름 ㆍ 양면 모듈(double­side module) ­ 기판의 양 면에 칩들을 장착하며, 접속 핀들도 양면에 설치하여 많은 신호 입출력 가능 ­ DIMM(double in
-line memory module)이라고도 부름 ▶ 512MB DIMM의 사례 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 기억장치 랭크(memory rank) ㆍ 단일
-랭크 모듈(single­rank module) ­ 단면 모듈(SIMM) 상에 x8 조직의 SDRAM 8개를 병렬접속 하여 하나의 랭크를 구성함 으로써, 64비트 데이터가 한 번에 버스를 통하여 전송되도록 구성한 기억장치 모듈  226   (a) 단면 단일
-랭크 모듈(single
-side single
-rank module) ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 각 SDRAM 칩의 용량이 2Gbit(즉, 256M x 8비트)라면, SIMM의 전체 용량 = (256M x

8) x 8개 = 2GByte ㆍ 2중­랭크 모듈(dual­rank module) ­ 양면 모듈(DIMM)에서, x8 조직의 SDRAM들을 각 면에 8개씩 병렬접속 하여 두 개의 랭크를 구성한 기억장치 모듈 앞면 뒷면 (b) 양면 2중
-랭크 모듈(double
-side dual
-rank module) ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 각 SDRAM 칩의 용량이 2Gbit(즉, 256M x 8비트)라면, DIMM의 전체 용량 = (256M x

8) x 8개 x 2면 = 4GByte ㆍ ×4 조직의 SDRAM들을 사용하는 경우 ­ 16개를 병렬접속하여 양면 모듈(DIMM)에 하나의 랭크를 구성 앞면 뒷면 (c) 양면 단일
-랭크 모듈(double
-side single
-rank module) ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 읽기 동작 시, 주소가 인가되면 각 칩에서 4비트씩 인출되어 전체적으로 64비트가 데이터 버스로 전송 ⋅ 각 SDRAM 칩의 용량이 2Gbit(즉, 512M x 4비트)라면, DIMM의 전체 용량 = (512M x

4) x 16개 = 4GByte ㆍ 4중­랭크 모듈(quad­rank module) ­ x8 조직의 SDRAM 칩들을 사용 ­ 면당 두 랭크씩으로 구성 ­ 용량은 앞의 조직들과 동일 ㆍ 높은 신뢰도가 요구되는 서버 및 슈퍼컴퓨터의 경우 ­ 데이터 8비트당 한 비트씩의 오류검출코드(error correction code: ECC) 추가 ⋅ 각 랭크의 입출력 데이터 폭 : (64 +
8) = 72비트 ⋅ 면당 9개의 칩들을 장착(x8 8개 + ECC)  227   기억장치 모듈의 설계
1. 컴퓨터 내부의 반도체 기억장치에 대해서 학습하고 이를 설명할 수 있다. 10주차  수업목표  
2. 컴퓨터 내부에서 사용하는 기억장치 모듈을 설계하는 방법에 2교시  대해서 학습하고 이를 설명할 수 있다.
1. 반도체 기억장치 세부내용 
2. 모듈 설계 1. 반도체 기억장치   ▶ RAM(Random Access Memory)
1) 특성 ­ 임의 액세스 방식(언제나 접근 속도 동일) ­ 반도체 집적회로 기억장치(semiconductor IC memory) ­ 데이터 읽기와 쓰기가 모두 가능 ㆍ 휘발성(volatile) ­ 전원 공급이 중단되면 내용이 지워짐(보조 전원) v 컴퓨터에서 랜덤 액세스 메모리(Random Access Memory, 임의 접근 기억 장치, 자유기 억기, 읽기쓰기기억기, 자유접근기억기) 즉 램(RAM)은 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치임 ⋅ 반도체 회로로 구성되어 있으며, 흔히 RAM을 ‘읽고 쓸 수 있는 메모리’라는 뜻으로 알 고 있는데, 이것은 오해임 ⋅ RAM은 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸 리는 메모리이기에 ‘랜덤(Random, 무작위)’이라는 명칭이 주어짐 ⋅ 반면 하드 디스크, 플로피 디스크 등의 자기 디스크나 자기 테이프는 저장된 위치에 따 라 접근하는 데 걸리는 시간이 다름(직접 접근, 순차 접근)
2) 연도별 특징 ­ 초기의 컴퓨터는 주 메모리 기능에 전자계전기(릴레이)나 기계식 카운터, 지연선을 사용하 였음 ­ 최초의 실용적인 형태의 랜덤 액세스 메모리는 1947년 음극선관에서 비롯됨 ­ 음극선관의 단면에 전기적으로 채워진 점들로 데이터를 저장하였고, CRT의 전자빔이 어느 순서로든 관 위의 점들을 읽고 쓸 수 있었으므로 메모리는 임의 접근(랜덤 액세스)이 가능 했음 ­ 자기 코어 메모리가 1947년 발명되어 1970년대 중반까지 개발되었으며, 널리 쓰이는 형 태의 랜덤 액세스 메모리가 되었고, 자화된 링들의 배열에 의존함 ­ 링의 자화의 성질을 변경시켜 데이터를 링 하나 당 한 비트로 저장할 수 있었음 ­ 자기 코어 메모리는 1970년대 초 시작된 집적 회로의 솔리드 스테이트 메모리로 대체되기 까지 메모리 시스템의 표준 형태로 자리잡혔음  228   ­ 1968년 로버트 H. 데나드가 동적 램(DRAM)을 발명하였음(콘덴서
-재충전) ­ 집적 고정 기억 장치(ROM) 회로가 개발되기 전, 영구적인 (읽기 전용의) 랜덤 액세스 메 모리가 주소 디코더에 의해 구동되는 다이오드(전류 한쪽 방향) 매트릭스나 특별하게 감겨 진 코어 로프 메모리 플레인을 이용하여 제조되었음 ▶ 1K x 8 RAM 칩과 제어 신호들 칩 선택 신호 읽기 신호 데이터 버스 쓰기 신호 주소버스 (a) RAM의 블록선도 CS RD WR RAM의 동작 0 X X 선택되지 않음 1 1 0 읽기 동작 1 0 1 쓰기 동작 (b) 제어 신호들에 따른 RAM의 동작 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 제조 기술에 따른 분류 ㆍ DRAM(Dynamic RAM) ­ 캐패시터(capacitor)에 전하(charge)를 충전하는 방식으로 데이터를 저장하는 기억 소자 들(memory cells) 로 구성 → 집적 밀도가 높음 ­ 데이터의 저장 상태를 유지하기 위하여 주기적인 재충전(refresh) 필요(방전) : dynamic ­ 집적 밀도가 더 높으며, 같은 용량의 SRAM(캐시) 보다 비트당 가격이 더 저렴 ­ 용량이 큰 주기억장치로 사용 ㆍ SRAM(Static RAM) ­ 기억 소자로서 플립
- 플롭(flip
- flop)을 이용 → 집적 밀도가 낮음 ­ 전력이 공급되는 동안에는 재충전 없이도 데이터 계속 유지 가능 : dynamic의 반대 static ­ DRAM보다 다소 더 빠름 ­ 높은 속도가 필요한 캐시 메모리로 사용 ▶ 64
-bit RAM의 내부 조직 예 : 8 × 8 비트 조직 ­ 8비트로 이루어진 8개의 기억 장소들로 구성 ­ 주소 비트 수 = 3, 데이터 입출력 선의 수 = 8  229    데이터  주소       ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 용량에 따른 주소 비트 수 : 중요 ⋅ 예) 8Kbit RAM ⇨ 1Kⅹ8비트 조직인 경우, 주소 = 10비트 필요 ⋅ 예) 1Mbit RAM ⇨ 128Kⅹ8비트 조직인 경우, 주소 = 17비트 필요 ⋅ 예) 1Gbit RAM ⇨ 128Mⅹ8비트 조직인 경우, 주소 = 27비트 필요 ▶ 64
-bit RAM의 내부 조직 예 : 16 × 4 조직 ­ 4비트로 이루어진 16개의 기억 장소들로 구성 ­ 주소 비트 수 = 4, 데이터 입출력 선의 수 = 4   데이터   주소       ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 용량에 따른 주소 비트 수 : 중요 ⋅ 예) 8Kbit RAM ⇨ 2Kⅹ4비트 조직인 경우, 주소 = 11비트 필요 ⋅ 예) 1Mbit RAM ⇨ 256Kⅹ4비트 조직인 경우, 주소 = 18비트 필요  230   ⋅ 예) 1Gbit RAM ⇨ 256Mⅹ4비트 조직인 경우, 주소 = 28비트 필요 ▶ 64
-bit RAM의 내부 조직 예 : 64 × 1 조직 ­ 한 비트 씩 저장하는 64 개의 기억 장소들로 구성 ­ 6개의 주소 비트들이 필요( =

64) ⋅ 상위 3 비트들은 8개의 행(row)들 중에서 한 개를 선택 ⋅ 하위 3 비트들은 8개의 열(column)들 중에서 한 개를 선택 ­ 두 개의 3 × 8 해독기 필요(decoder) ­ 데이터 입출력 선의 수 = 1 주소=010110  데이터 행(row)    주소           열(column) 주소 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 용량에 따른 주소 비트 수 : 중요 ⋅ 예) 8Kbit RAM ⇨ 8Kⅹ1비트 조직인 경우, 주소 = 13비트 필요 ⋅ 예) 1Mbit RAM ⇨ 1Mⅹ1비트 조직인 경우, 주소 = 20비트 필요 ⋅ 예) 1Gbit RAM ⇨ 1Gⅹ1비트 조직인 경우, 주소 = 30비트 필요 ▶ RAM 내부 조직의 예 : 16M × 4 조직(64Mbit) ­ 기억 소자들이 4096 × 4096 × 4비트 형태로 배열 ⋅ 4096개의 열과 4096개의 행들로 이루어진 장방형 구조 ⋅ 각 기억 장소에는 4 개의 데이터 비트들을 저장 ­ 기억 장소의 수 = 16M 개 ⇨ 전체 24비트의 주소 선들이 필요  231   v RAS(Row Address Strobe) 신호와 CAS(Column Address Strobe) 신호를 이용하여, 칩 으로 실제 입력되는 주소 비트(선)의 수는 12개만 되도록 함  데이터    주소   ※ 컴퓨터구조론, 생능출판사, 2019 ▶ DRAM 읽기 동작의 타이밍도 : RAS, CAS (CPU) 주소 (DRAM) 주소 RAS CSA RD 데이터 버스 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 64M(16M×4) bit DRAM 패키지의 입출력 핀 구성                                             ※ 컴퓨터구조론, 생능출판사, 2019  232   2. 모듈 설계   ▶ 기억장치 모듈의 설계 ­ 기억장치 칩의 데이터 I/O 비트 수가 단어 길이보다 적은 경우 ⇨ 여러 개의 칩들을 병렬로 접속하여 기억장치 모듈을 구성 ⋅ 단어의 길이 = N비트, 기억장치 칩의 데이터 I/O 비트 수 = B 라면 ⇨ N/B 개의 칩들을 병렬 접속 ⋅ 예) N = 8(단어 길이)일 때, 16×4비트 RAM 칩들을 이용한 기억장치 모듈의 설계
- 방법 : 2개의 RAM 칩들을 병렬 접속
- 모듈의 용량 : (16×4) × 2개 = 16×8비트 = 16바이트
- 주소 비트(4개 : A ~ A ) : 두 칩들에 공통으로 접속  
- 칩 선택(CS) 신호도 두 칩들에 공통으로 접속
- 주소 영역 : 0000 ∼   ▶ 16×4비트 RAM 칩들을 이용한 16×8비트 기억장치 모듈(병렬)     주소버스                 데이터 버스         ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 1K×8비트 RAM 칩들을 이용한 1K×32비트 기억장치 모듈의 설계 ­ 방법 : 4개의 RAM 칩들을 병렬 접속 ­ 모듈의 용량 : (1K×8) × 4개 = 1K×32비트 = 1Kword ­ 주소 비트(10개 : A ~ A ) : 모든 칩들에 공통으로 접속   ­ 주소 영역 : 000H ∼ 3ex)ex)H(단, H는 16진수 표시) ­ 데이터 저장 : 동일한 기억장치 주소에 대하여 칩 당(32비트들 중의) 8 비트씩 분산 저장  233   ▶ 1K×32비트 기억장치 모듈 : 병렬 주소   데이터 버스(32비트) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 기억장치 모듈의 설계 ­ 필요한 기억 장소의 수가 각 기억장치 칩의 기억 장소 수보다 많은 경우 ⇨ 여러 개의 칩들을 직렬 접속하여 기억장치 모듈을 구성 ⋅ 예) 두 개의 16×4비트 칩들을 이용한 32×4비트 기억장치 모듈의 설계
- 방법 : 2개의 RAM 칩들을 직렬 접속
- 모듈의 용량 : 2개 × (16×4) = 32×4비트
- 주소 비트 수 : 5개(A ~ A )   ⋅ A : 칩 선택(CS) 신호로 사용  ⋅ A ~ A : 두 칩들에 공통으로 접속  
- 주소 영역(다름) ⋅ RAM1 : 00000 ∼   ⋅ RAM2 : 10000 ~   ▶ 16×4비트 RAM 칩들을 이용한 32×4비트 기억장치 모듈 : 직렬      주소버스            데이터 버     ※ 컴퓨터구조론, 생능출판사, 2019 ­ 주소영역 : RAM1 = 00000 ~   RAM2 = 10000 ~    234   ▶ 기억장치 모듈의 설계 ⋅ 예) 1K×8 비트 RAM 칩들을 이용한 4K×8 비트 기억장치 모듈
- 방법 : 4개의 RAM 칩들을 직렬 접속
- 모듈의 용량 : (1K×8) × 4개 = 4K×8 비트 = 4KByte
- 주소 비트(12개 : A ~ A ) 접속 방법   ⋅ 상위 2비트(A , A ) : 주소 해독기를 이용하여 네 개의 칩 선택(CS) 신호 발   생 ⋅ 하위 10비트(A ~ A ) : 모든 칩들에 공통으로 접속  
- 전체 주소 영역(다름) : 000H ~ ex)ex)ex)H
- 데이터 버스 : 모든 기억장치 칩에 공통 접속 → 한 번에 8비트씩 액세스

1) 각 RAM에 지정되는 주소 영역 : 직렬 주소 영역 칩 번호 16진수 표기 A    0000 0000 0000 (000H)번지부터 RAM1 0011 1111 1111 (3ex)ex)H)번지까지 0100 0000 0000 (400H)번지부터 RAM2 0111 1111 1111 (7ex)ex)H)번지까지 1000 0000 0000 (800H)번지부터 RAM3 1011 1111 1111 (Bex)ex)H)번지까지 1100 0000 0000 (C00H)번지부터 RAM4 1111 1111 1111 (ex)ex)ex)H)번지까지 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 4K×8비트 기억장치 모듈 : 직렬 A A A    데이터   ※ 컴퓨터구조론, 생능출판사, 2019  235   ▶ 기억장치 모듈의 설계
1) 기억장치 모듈의 설계 순서
① 컴퓨터시스템에 필요한 기억장치 용량 결정
② 사용할 칩들을 결정하고, 주소 표(address table; address map이라고도 함)를 작성
③ 세부 회로 설계 ⋅ 예) 8
-비트 마이크로컴퓨터를 위한 기억장치의 설계
- 용량 : 1KByte ROM, 2KByte RAM
- 주소 영역 : ROM = 0번지부터, RAM = 800H 번지부터
- 사용 가능한 칩들 : 1K × 8bit ROM, 512 × 8bit RAMs

2) 기억장치 주소 표(memory address map) 기억장치 주소 영역 주소 비트들 칩 (16진수) A A A A A A A A A A A A             ROM 000H ~ 3ex)ex)H 0 0 X X X X X X X X X X RAM1 800H ~ 9ex)ex)H 1 0 0 X X X X X X X X X RAM2 A00H ~ Bex)ex)H 1 0 1 X X X X X X X X X RAM3 C00H ~ Dex)ex)H 1 1 0 X X X X X X X X X RAM4 E00H ~ ex)ex)ex)H 1 1 1 X X X X X X X X X ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 8
-비트 마이크로컴퓨터를 위한 기억장치 설계의 예 : 직렬 ※ 컴퓨터구조론, 생능출판사, 2019  236   최신 및 차세대 기억장치

1. 현재 나와 있는 최신 기억장치에 대해서 학습하고 이를 설명할 수 있다. 10주차  수업목표  
2. 앞으로 나올 차세대 기억장치에 대해서 학습하고 이를 설명할 3교시  수 있다.
1. 최신 기억장치 세부내용 
2. 차세대 기억장치 1. 최신 기억장치   ▶ 최신 기억장치 기술 ­ 기억장치의 액세스 속도는 CPU에 비하여 현저히 낮음 ­ 동영상 처리, 음성 / 영상 압축과 같은 대규모 데이터 처리 응용 증가 → 주기억장치 병목 현상 심화 → 새로운 유형의 기억장치 개발을 통한 고속화 필요 ⋅ SDRAM ⋅ DDR SDRAM ⋅ PRAM ⋅ ex)RAM ⋅ MRAM ▶ SDRAM ㆍ 동기식 DRAM(Synchronous DRAM : SDRAM) ­ 액세스 동작들이 시스템 클록에 맞추어(동기화 되어) 수행되는 DRAM ⋅ 예) 읽기 동작
① CPU는 한 클록 주기 동안에 시스템 버스를 통하여 주소와 읽기 신호를 기억 장치로 보낸 후, 그 결과를 기다리지 않고 내부적으로 다른 연산을 수행
② SDRAM은 주소와 읽기 신호를 받은 즉시 읽기 동작을 시작하며, 그 동작이 완료되면 시스템 버스 사용권을 획득한 후, 다음 클록 주기 동안에 버스를 통 하여 CPU로 데이터 전송
③ CPU는 그 데이터를 받아서, 다음 연산을 수행 ▶ SDRAM의 내부 조직 ­ 다수의 뱅크(bank)들로 구성 : 뱅크 별로 동시 액세스 가능 ⋅ 예) 512Mbit SDRAM ⇨
- 4개의 16Mⅹ8bit 뱅크들로 구성 : 4ⅹ16Mbyte = 64Mbyte = 512Mbit
- 주소 비트 수 = 26, 최상위 2비트 : 뱅크 선택(bank select)에 사용  237   v SDRAM의 내부 조직(512Mbit, 128Mbit) 16Kbits 기억소자 배열 (8K 개) 데이터 버스 (a) 네 개의 뱅크들로 구성된 SDRAM (b) 각 뱅크의 내부 조직 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ SDRAM ㆍ 행(row) : 8K 개의 기억소자 배열(memory cell array) ­ 각 배열에는 16Kbit(2KBytes) 씩 저장 ­ 칩의 입출력(데이터) 선의 수 : 8 ⇨ 행 주소(row addr) = 13비트(8K), 열 주소(column addr) = 11비트(2K) ­ 읽기 동작 시, 각 배열의 데이터(2KByte) 전체가 감지 증폭기(sense amplifier)로 이동 = ‘행 열기(opening the row)’ ⇨ 그런 다음에, 열 주소에 의해 바이트(8 비트) 단위로 데이터 버스에 실림 ㆍ 버스트 모드(burst mode) ­ 여러 바이트들을 연속적으로 전송하는 동작 ㆍ 버스트 길이(burst length) ­ 각 버스트 동작 동안에 전송되는 데이터 바이트들의 수 v 버스트 읽기 동작의 타이밍 도(버스트 길이 =

4) 클록     주소 데이터  지연 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ CAS 지연(latency) ­ CAS 신호와 열 주소가 들어온 순간부터 데이터가 인출되어 버스에 실릴 때까지의 시간 (주소 해독 및 액세스 시간)  238   ㆍ 버스트 모드의 효과 ­ 버스 사용권을 한 번 획득한 후, 여러 클록 동안 연속 전송 가능(앞 그림의 경우 : 버스 트 길이 =
4)
1) 기억장치 모듈(memory module) 구성의 필요성 ­ SDRAM의 데이터 입출력 폭 = 8비트 ­ 단어 단위의 데이터 액세스를 위하여 여러 개의 SDRAM 칩들을 병렬로 접속하여 기억장치 모듈을 구성 ⋅ 예) 64 ­ 비트 컴퓨터 시스템을 위한 기억장치 모듈
- 8개의 64M × 8bit SDRAM 칩들을 병렬 접속 → 64비트씩 읽기 / 쓰기 가능 한 512MByte 기억장치 모듈 ­ 기억장치 모듈 당 SDRAM 칩 한 개를 추가 ⇨ 8
- 비트 길이의 ECC(error
-correction code)를 같이 저장 v 512MB 기억장치 모듈의 모습(8개의 64M × 8bit SDRAM) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ DDR SDRAM ­ SDRAM 기억장치 모듈의 대역폭(bandwidth)을 향상시키기 위한 기술 ⋅ 대역폭 : 단위 시간 당 전송되는 데이터 량 단위 : [bytes/sec] ㆍ DDR(double data rate) SDRAM ­ 버스 클록 당 두 번의 데이터 전송(클록 펄스의 상승
- 에지 및 하강
- 에지에서 각각 전송) ⋅ 비교) SDRAM : SDR(single data rate) SDRAM에 해당 ㆍ DDR2 SDRAM ­ DDR SDRAM과 같으며, 버스 클록 주파수를 두 배로 높여 대역폭 향상  239   v DDR SDRAM : SDR, DDR, DDR2 ㆍ DDR SDRAM 읽기 동작의 타이밍(버스트 길이 =

8) 읽기시작 클록 (133MHz) 데이터 (a) SDR SDRAM(PC133) 읽기시작 클록 (133MHz) 데이터 (b) DDR SDRAM(DDR
-266) 읽기시작 클록 (266MHz) 데이터 (c) DDR2 SDRAM(DDR2
-533) ※ 컴퓨터구조론, 생능출판사, 2019

1) 읽기 시간 비교(예 : 버스트 길이 =
8) ㆍ SDR @ 133 MHz [PC133] ­ 버스 클록 = 133MHz ­ 매 클록 주기(7.5ns)마다 64비트씩 전송 ­ 8번의 데이터 전송에 걸리는 시간 = CAS 지연(15ns) + (7.5nsⅹ8) = 75ns ㆍ DDR @ 133 MHz [DDR
-266] ­ 상승 및 하강 에지에서 64비트씩 전송 ­ 8번의 데이터 전송에 걸리는 시간 = CAS 지연(15ns) + {(7.5ns/2)ⅹ8} = 45ns ㆍ DDR
-2 @ 266 MHz [DDR
-533] ­ 버스 클록 = 266 MHz(주기 = 1.875ns) ­ 상승 및 하강 에지마다 64비트씩 전송 ­ 8번의 데이터 전송에 걸리는 시간 = CAS 지연(15ns) + {(3.75ns/2)ⅹ8} = 30ns ­ 데이터 전송시간(CAS 지연 제외) 비교 : 60ns(SDR) → 30ns(DDR) → 15ns(DDR ­

2)
2) DDR 기술의 기본 원리 ­ 버스 클록의 상승 에지와 하강 에지에서 각각 데이터 전송 ­ 기억장치 제어기(memory controller) 및 버스 인터페이스 회로의 개선을 통하여 버스 클 록 주파수 향상 ­ DDR3 및 DDR4도 같은 원리를 적용하여 설계
3) 기억장치 대역폭(memory bandwidth) ­ 단위 시간 당 데이터 전송량  240   ­ 버스 폭(bus width) x 클록 주파수 ⋅ 예) 데이터 버스 = 64비트, 버스 클록 주파수 = 100MHz ⇨ 대역폭 : (100MHz x
64) / 8비트 = 800[Mbytes/sec]
- SDR @133MHz : (133MHz x

64) / 8 = 1064[Mbytes/sec]
- DDR @133MHz : (133MHz x 2 x

64) / 8 = 2128[Mbytes/sec]
- DDR2 @266MHz : (266MHz x 2 x

64) / 8 = 4256[Mbytes/sec]
4) CAS 지연(주기로 표현) ­ DDR : SDRAM 칩의 CAS 지연 = 15ns 일 때, 클록 주기가 7.5ns이므로, CAS 지연 = 2 주기 ­ DDR2 : f = 266MHz(클록 주기 = 3.75ns) → CAS 지연 = 4주기(15ns / 3.75ns = 4 주기) ­ DDR3 및 DDR4에 사용되는 SDRAM 칩들의 CAS 지연 = 10ns ⋅ DDR3
-1600 @800MHz : CAS 지연 = 8주기 ⋅ DDR4
-3600 @1800MHz : CAS 지연 = 16주기 2. 차세대 기억장치   ▶ 차세대 비휘발성 기억장치 ㆍ PRAM, ex)RAM, MRAM ­ 비휘발성(nonvolatile) ­ 플래시 메모리에 비하여 액세스 속도가 1000배 가량 높음 ­ DRAM보다 느리지만, 집적도는 비슷하며, 전력 소모가 더 낮음 구분 PRAM ex)RAM MRAM 특정 물질의 강유전체의 전극의 동작 원리 상태 변화 분극 특성 자화 방향 쓰기 시간 500ns 50ns 10ns 비휘발성 고속, 비휘발성 고속, 비휘발성 고속, 장점 고집적도 저전력 내구성 단점 느린 쓰기 속도 내구성 취약 상대적 고비용 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ PRAM(Phase–change RAM) ­ 상태(phase)가 변하는 특수 물질을 이용하여 제조한 RAM ㆍ 물질 : 게르마늄 안티몬 텔룰라이드(GST) ­ 인가되는 전압의 높이에 따라 내부 구조가 변하여 저항이 낮은 고체 상태 혹은 저항이 높 은 액체 상태가 됨 ⋅ 고체 상태 : 결정 상태(polycrystalline phase) ⋅ 액체 상태 : 비정질 상태(amorphous phase) ㆍ 기억 셀(memory cell)  241   ­ 두 개의 전극 사이에 특수 물질(GST)을 삽입

1) PRAM 메모리 셀의 내부 구조 상단 전극 화합물 반도체(GST) 전열체 절연체 하단 전극 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 데이터 저장 ­ 두 전극들 사이에 짧은 시간 동안 상대적으로 높은 전압 인가GST → 낮은 저항의 결정 상태 : ‘1’을 저장 ­ 두 전극들 사이에 긴 시간 동안 상대적으로 낮은 전압 인가GST → 높은 저항의 비정질 상태 : ‘0’을 저장 ㆍ 데이터 읽기 ­ 상태 변화를 야기하지 않을 정도의 낮은 전압 인가 ­ 저항의 차이에 따른, 두 전극 간에 흐르는 전류 양의 차이에 따라 데이터 값을 구분 → 저항이 낮으면 전류 양이 많아짐 : ‘1’ → 저항이 높으면 전류 양이 적어짐 : ‘0’
2) PRAM의 장점 ­ 낮은 전압 범위에서 모든 전기적 동작이 수행됨 ­ 회로가 간단함 ­ 전력 소모가 적음 ­ 차세대 기억장치들 중에서 가장 빠르게 기술이 발전되고 있으며, 시장성도 높이 평가 받고 있음 v 피램(또는 상변화 메모리, Phase
-change Memory, PCM, PCME, PRAM, PCRAM, C
-RAM)은 비휘발성 메모리의 한 종류이며, 플래시 메모리의 비휘발성과, RAM의 빠른 속도의 장점을 모두 가지고 있는 차세대 메모리 반도체임 ⋅ 피램은 열을 가함에 따라 비정질상태와 결정질상태로 바뀌는 칼코게나이드 유리의 독특 한 특성을 이용하여 데이터를 저장함 ▶ ex)RAM(ex)erroelectric RAM) ­ 강유전체의 특성을 이용하는 반도체 기억장치 ⋅ 강유전체 : 전기를 인가하지 않은 자연 상태에서도 전기적 극성을 띠고 있는 물질 ⋅ 플럼범 지르코늄 티타늄 산화물(PZT)을 이용하여 제조 ⋅ 양(+) 전극 및 음(
-) 전극에 전기를 인가하면 전극의 위치가 바뀌며, 전기 공급이 중단 되어도 그대로 유지 ㆍ 데이터 저장  242   ­ 전기를 인가하지 않음 → 원래의 전극 유지 : ‘0’ 저장 ­ 전기 인가 → 전극 위치 변경 : ‘1’ 저장 ㆍ 데이터 읽기 ­ 기억 셀에 전기장(electric field)을 인가 ­ 감지되는 전하(electric charge)의 양에 따라 ‘0’과 ‘1’을 구분 ㆍ ex)RAM 메모리 셀 강유전체 ※ 컴퓨터구조론, 생능출판사, 2019 v 에프램 또는 강유전체 램(ex)erroelectric Random Access Memory : ex)RAM, ex)
- RAM, 또는 ex)eRAM)은 비휘발성 컴퓨터 메모리의 한 종류이며, 컴퓨터의 주기억장치로 많이 쓰 이는 디램(DRAM)과 비슷한 구조를 갖고 있으나 강유전체를 이용하여 비휘발성을 가진 점이 다름 ⋅ ex)eRAM은 현재 비휘발성 메모리 시장의 대부분을 차지하고 있는 플래시 메모리에 비 해 낮은 전력 소모, 빠른 속도, 높은 쓰기 / 지우기 횟수 등의 여러가지 장점을 갖고 있음

1) ex)RAM의 특징 ­ 에프램은 엠램(MRAM), 피램(PRAM) 등과 함께 차세대 비휘발성 메모리로 주목받고 있으 며, MRAM, PRAM에 비해 대량생산 기술이 더욱 성숙되어 있는 것이 ex)eRAM의 장점임 ­ ex)reescale Semiconductor 사가 2006년 4메가비트 MRAM의 제한적인 대량생산을 시작 하였고 PRAM은 아직 대량생산이 불가능하나, ex)eRAM은 2006년 후지쯔와 램트론 인터내 셔널(Ramtron International) 사가 1메가비트 칩의 대량생산을 시작하였음 ­ 그러나 아직까지 어떤 차세대 비휘발성 메모리도 플래시 메모리의 집적도(수 기가비트 이 상)나 낮은 가격을 실현하지는 못하고 있음 ­ 현재까지 ex)eRAM은 스마트 카드 등의 몇몇 특수한 분야에만 경쟁력이 있을 뿐임 ▶ MRAM(Magnetic RAM) ­ 자기장(magnetic field)을 이용하여 정보를 저장하는 반도체 기억장치 ⋅ 강자성체에 가해지는 자기장의 방향으로 자화되며, ⋅ 자기장이 제거되어도 자성이 그대로 유지 ㆍ 기본 구조 ­ 상부와 하부에 설치되는 두 개의 강자성체들 사이에 절연체를 삽입 ­ 하부 강자성체 : 고정층, 자화 방향이 고정되어 있음 ­ 절연체 : 터널링 자기저항 현상이 일어나도록 얇게 제조(전도도가 바뀜) ­ 상부 강자성체 : 기록층, 전류 인가 방향에 따라 자화되는 방향이 결정됨  243   ㆍ 데이터 저장 ­ 그림(a)와 같은 방향으로 전류 인가 → 상부 및 하부 강자성체의 자화 방향 일치 : ‘0’ 저장 ­ 그림(b)와 같은 방향으로 전류 인가 → 상부 및 하부 강자성체의 자화 방향이 반대 : ‘1’ 저장 전류 전류 기록층 절연층 고정층 자화 방향 (a) 동일 방향으로 자화(‘0’ 저장) (b) 반대 방향으로 자화(‘1’ 저장) ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 데이터 읽기 ­ 두 강자성체들 간에 전류 인가 ­ 강자성체들 간의 자화 방향이 동일 → 절연층 저항이 적어져 터널링 전류(tunneling current)가 흐르므로, 상하부 층 간의 전위차가 낮아짐 : ‘0’으로 인식 ­ 강자성체들 간의 자화 방향이 반대 → 절연층 저항이 높아져 터널링 전류가 흐르지 않으 므로, 상하부 층 간의 전위차가 높아짐 : ‘1’로 인식 v 자기 저항 메모리(Magnetoresistive random
- access memory, MRAM, 엠램)은 비휘 발성 컴퓨터 메모리 기술이며 1990년대부터 개발이 진행 중임 ⋅ 현재의 메모리, 특히 플래시 램과 디램의 밀도가 꾸준히 늘어나면서, 시장에서 MRAM 은 틈새 제품이라는 위치를 벗어나지 못하였음 ⋅ 그러나 MRAM을 지지하는 사람들은 MRAM의 뛰어난 이점 때문에 MRAM이 결국 시 장을 지배하여 유니버설 메모리가 될 것으로 믿고 있음 ⋅ 에버스핀에서 생산 중이며 글로벌파운드리와 삼성을 포함한 다른 기업들은 제품 계획을 발표하였음  244   지역성(Locality)

1. 캐시기억장치에서 지역성을 이용한 적중률에 대해서 학습하고 이를 설명할 수 있다. 11주차  수업목표  
2. 캐시기억장치에서 캐시 크기 및 인출 방식에 대해서 학습하고 1교시  이를 설명할 수 있다.
1. 적중률 세부내용 
2. 캐시 크기 및 인출 방식 1. 적중률   ▶ 캐시 메모리(Cache memory) ㆍ 사용 목적 ­ CPU와 주기억장치의 속도 차이로 인한 CPU 대기 시간을 최소화 시키기 위하여 CPU와 주기억장치 사이에 설치하는 고속 반도체 기억장치 ㆍ 특징 ­ 주기억장치(DRAM)보다 액세스 속도가 더 높은 칩(SRAM) 사용(콘덴서
-캐패시터 vs. 플 립플롭) ­ 가격 및 제한된 공간 때문에 용량이 적음 v 캐시 메모리(Cache memory) : CPU 대기시간 최소화 CPU 주기억장치 ※ 컴퓨터구조론, 생능출판사, 2019

1) CPU 캐시(CPU cache) ­ CPU 캐시(CPU cache)는 CPU 구조에 메모리로 사용하도록 구성되었음(고속) ­ CPU 캐시는 메인 메모리에서 가장 자주 사용되는 위치의 데이터를 갖고 있는 크기는 작지 만 빠른 메모리임 ­ 대부분의 메모리 접근은 특정한 위치의 근방에서 자주 일어나는 경향이 있기 때문에, 데이 터를 크기는 작지만 속도가 빠른 캐시메모리에 복사해 두면 평균 메모리 접근 시간을 아낄 수 있음(지역성 : 시간, 공간)
2) 프로세서와 메인 메모리 ­ 프로세서가 메인 메모리를 읽거나 쓰고자 할 때는, 먼저 그 주소에 해당하는 데이터가 캐시 에 존재하는지를 살핌 ­ 만약 그 주소의 데이터가 캐시에 있으면 데이터를 캐시에서 직접 읽고, 그렇지 않으면 메인  245   메모리에 직접 접근함 ­ 이때 대부분의 프로세서는 메인 메모리에 직접 접근해서 전송된 데이터를 캐시에 복사해 넣음으로써 다음 번에 같은 주소에 프로세서가 접근할 때 캐시에서 직접 읽고 쓸 수 있도 록 함(지역성)
3) 파이프라인 CPU ­ 파이프라인 CPU는 파이프라인 안의 여러 포인트(여러 단계)로부터 메모리를 접근함 ⋅ 명령어 페치, 가상을 물리로 변환하는 주소 번역(가상기억), 데이터 페치 ­ 이 자연스러운 디자인은 이러한 포인트 각각에 다른 물리 캐시를 사용하기 위한 것이며 어 떠한 물리 리소스도 이 파이프라인 안의 두 포인트를 서비스하도록 설계되어 있지는 않음 (동시 접근이 가능) ­ 그러므로 파이프라인은 자연스레 적어도 세 개의 구분된 캐시(명령어, TLB, 데이터)에서 작 업이 끝나며 각각 저마다 특정한 역할을 수행함
4) 빅팀 캐시(victim cache) ­ 빅팀 캐시(victim cache)는 충돌이나 용량 문제로 CPU 캐시에서 빠져나간 블록을 유지시 키는 데 이용하는 캐시임 ­ 빅팀 캐시는 메인 캐시와 리필(refill) 패스 사이에 위치해 있으며 캐시 쪽에서 나온 문제가 된 블록만 유지시킴 ­ 이 기술은 캐시에서 초래한 불리한 조건을 줄이기 위해 사용함(발생 가능한 문제) ­ HP PA7200에 있던 원래의 빅팀 캐시는 작고 완전히 연결되어 있는 캐시였음 ­ 나중에 AMD K7과 K8과 같은 프로세서들은 더 큰 2차 캐시를 빅팀 캐시로 이용하였으며 커다란 1차 캐시의 콘텐츠에 데이터가 중복되는 현상을 제거하였음
5) 트레이스 캐시(trace cache) ­ 트레이스 캐시(trace cache)는 인텔 펜티엄 4 마이크로프로세서에서 찾을 수 있음 ­ 트레이스 캐시는 이미 페치되었거나 디코딩된 명령어의 트레이스(dynamic stream)를 저장 함으로써 명령어 페치 대역을 늘리고 전력 소비량을 줄이도록 설계되어 있음 ­ 맨 초기에 널리 트레이스 캐시를 알렸던 사람들은 에릭 로텐버그, 스티브 베네트, 제임스 스미스로, 1996년 "Trace Cache: a Low Latency Approach to High Bandwidth Instruction ex)etching"에 출판하면서 알려졌음 ­ 처음 출판했을 때의 미국 특허 5,381,533에서는 인텔사의 알렉스 펠레그와 우리 와이저가 "Dynamic flow instruction cache memory organized around trace segments independent of virtual address line" 라는 설명으로 1994년 3월 30일에 공표하였지만 1992년에 이에 대한 응용 분야가 계속 변화면서 버려지게 되었음 ­ 트레이스 캐시는 인텔 펜티엄 4와 같은 프로세서에서 쓰이며 이미 디코딩된 마이크로 연산 들을 저장하거나 복잡한 x86 명령어를 번역하며, 추후 명령어가 필요하면 다시 디코딩할 필요가 없어짐(미리 해놈) ­ 트레이스 캐시는 디코딩 된 뒤나 빠져나온 뒤의 명령어를 저장(that have already been fetched and decoded) ­ 일반적으로 명령어들은 개별 기본 블록이나 동적 명령어 트레이스를 대표하는 그룹에서 트  246   레이스 캐시들에 추가됨 ­ 기본 블록은 분기가 있는 비분기 명령어들의 한 그룹으로 구성되어 있음(분기) ­ 동적 트레이스(트레이스 패스)는 결과가 실제로 사용된 명령어들만 포함하고 있으며 분기들 을 따라가는 명령어들을 제거(실행 중이 아니기 때문에) ­ 동적 트레이스는 여러 개의 기본 블록이 모인 것으로 표현할 수 있음 ­ 이로써 실행 중에 있는 분기들을 걱정하지 않아도 프로세서의 명령어 페치 장치가 여러 개 의 기본 블록을 페치할 수 있음
6) 캐시의 레이턴시(latency)와 히트 속도(hit rate) ­ 또다른 문제는 캐시의 레이턴시(latency)와 히트 속도(hit rate)를 어떻게 조절해야 하느냐 임 ­ 커다란 캐시는 히트 레이트는 높지만 레이턴시가 김 ­ 수많은 컴퓨터는 여러 수준의 캐시를 사용하고 있으며 작고 빠른 캐시와 크고 느린 캐시를 가지고 있음 ­ 여러 수준의 캐시는 일반적으로 가장 작은 1차 캐시(L1 캐시)를 먼저 검사하면서 운영을 하는 것이 보통 ­ 이때 캐시를 사용하면 프로세서는 최고 속도로 진행함 ­ 캐시 문제가 적으면 외부 메모리 검사 전에 L2 캐시를 검사하게 됨 ­ 메인 메모리와 가장 빠른 캐시 사이의 레이턴시 차이가 클수록 일부 프로세서는 세 가지 수준의 칩 위의 캐시들을 최대한 이용하기 시작함 ­ 이를테면 2003년에 아이테니엄 2가 6 MiB 비공유 3차(L3) 캐시를 칩 위에 장착하기 시 작함(MiB x 1.049 = MB) ­ IBM 파워 4 시리즈는 256 MiB L3 캐시를 칩 위에 장착하기 시작했음(on
-chip cache) ­ 새로운 AMD 페넘 시리즈는 L3 캐시 다이에 2MB를 장착

7) 내부 캐시와 외부 캐시 ­ 여러 수준의 캐시는 새로운 설계를 도입하고 있는데, 이를테면 일부 프로세서에서 L1 캐시 안에 있는 모든 데이터는 L2 캐시 어딘가에도 존재해야 함 ­ 이러한 캐시들을 철저한 내부 캐시(strictly inclusive)라고 부름 ­ AMD 애슬론과 같은 다른 프로세서들은 외부 캐시를 가지고 있으며 데이터는 1차 캐시와 2차 캐시 중 한 곳에만 있을 것을 보증하며 두 곳에 동시에 존재하지는 않음 ­ 그러나 펜티엄 II, III, 4와 같은 다른 프로세서들은 1차 캐시의 데이터가 L2 캐시에도 상주 할 것을 요구하지는 않지만 상주 가능성은 언제든 존재함 ­ 전반적으로 이러한 중간 정책에 따른 명칭이 존재하는 것은 아니지만 대개 이 경우 기본적 인 내부 캐시(mainly inclusive)라고 부름 ­ 외부 캐시의 이점은 더 많은 데이터를 저장할 수 있다는 데 있음 ­ 이러한 이점은 외부 1차 캐시가 2차 캐시와 비슷할 때 크지만 2차 캐시가 1차 캐시에 비 해 여러 배 더 크다면 그 이점은 줄어듦 ­ 1차 캐시에 들어가지 못하고 2차 캐시에 접근할 때 L2 캐시의 라인은 L1 캐시의 라인과 교환하게 됨  247   ­ 이러한 교환은 단순히 내부 캐시가 하는 것과 같이 L2 라인을 L1으로 복사하는 것보다 더 일이 복잡함 ­ 철저한 내부 캐시의 한 가지 이점은 외부 장치나 다른 프로세서(멀티프로세서 시스템에서) 가 프로세서로부터 캐시 라인을 제거하기를 바랄 때 프로세서가 2차 캐시를 검사하면 된다 는 것임(중복) ­ 내부 캐시를 수행하지 않는 캐시 계급에서는 1차 캐시 또한 검사해야 함(중복 없음) ­ 한 가지 단점으로는 L1 캐시와 L2 캐시의 연동의 관계가 있다는 것임 ­ 2차 캐시가 적어도 1차 캐시만큼 여러 경로가 없을 경우 1차 캐시의 효과적인 연동은 제 한을 받음 ­ 내부 캐시의 또다른 이점은 캐시가 클수록 더 커다란 캐시 라인을 사용할 수 있어서 2차 캐시 태그의 크기를 줄일 수 있다는 데 있음 ­ 외부 캐시는 두 개의 캐시 모두 같은 크기의 캐시 라인을 가질 것을 요구하며 이 요구를 만족하면 캐시 라인은 L2에 접근할 수 있게 됨 ­ 2차 캐시가 1차 캐시보다 등급 순서가 더 높다면 캐시 데이터는 캐시 태그보다 등급 순서 가 더 높게 됨
8) 다른 캐시 ­ 커다란 컴퓨터는 가끔 2차 캐시, 그리고 3차 캐시라 불리는 메인 메모리 사이에 다른 캐시 가 존재하기도 함 ­ 이러한 캐시는 CPU의 별도 칩에 추가되어 있으며 2004년 기준으로 2~256 메가바이트의 크기가 존재했음 ­ 칩 외부에 3차 캐시가 존재할 때의 이점은 응용 프로그램의 접근 패턴에 따라 달라짐 ­ 고급형 x86 워크스테이션과 서버는 3차 캐시를 마이크로프로세서 다이에 옵션으로 사용할 수 있으며 속도를 높이고 비용을 상당히 낮출 수 있음(on
-chip) ­ 이를테면 인텔의 제온 MP 제품의 코드 이름 Tulsa는 16 MiB 용량의 3차 캐시를 다이에 놓고 있으며 두 개의 프로세서 코어가 이를 공유함 ▶ 캐시 기억장치 ㆍ 캐시 적중(cache hit) ­ CPU가 원하는 데이터가 캐시에 있는 상태 ㆍ 캐시 미스(cache miss) ­ CPU가 원하는 데이터가 캐시에 없는 상태이며, 이 경우에는 주기억장치로부터 데이터를 읽어옴 ㆍ 적중률(hit ratio) ­ 캐시에 적중되는 정도 (H) ㆍ 캐시의 미스율(miss ratio) ­ (1 ­ H)  248   ㆍ 평균 기억장치 액세스 시간 (Ta) ­ Ta = H × Tc + (1
- H) × Tm 단, Tc는 캐시 액세스 시간, Tm은 주기억장치 액세스 시간 ▶ 캐시 적중률과 평균 기억장치 액세스 시간의 관계 ◼ 예제 5
-1 ­ Tc = 10ns, Tm = 100ns인 시스템에서 캐시 적중률(H)이 70%, 80%, 90%, 95% 및 99%일 때의 평균 기억장치 액세스 시간(Ta)를 구하라. ⋅ 풀이 ­ 식 (5 ­

2)를 이용하여 Ta를 구하면 아래와 같아진다. ⋅ H = 70%의 경우 : Ta = 0.7 × 10ns + 0.3 × 100ns = 37ns ⋅ H = 80%의 경우 : Ta = 0.8 × 10ns + 0.2 × 100ns = 28ns ⋅ H = 90%의 경우 : Ta = 0.9 × 10ns + 0.1 × 100ns = 19ns ⋅ H = 95%의 경우 : Ta = 0.95 × 10ns + 0.05 × 100ns = 14.5ns ⋅ H = 99%의 경우 : Ta = 0.99 × 10ns + 0.01 × 100ns = 10.9ns ※ 컴퓨터구조론, 생능출판사, 2019 ­ 캐시의 적중률이 높아질수록 평균 기억장치 액세스시간은 캐시 액세스 시간에 접근 ­ 캐시 적중률은 프로그램과 데이터의 지역성(locality)에 따라 달라짐(시간적, 공간적) ▶ 지역성(locality) ㆍ 시간적 지역성(temporal locality) ­ 최근에 액세스된 프로그램이나 데이터가 가까운 미래에 다시 액세스 될 가능성이 높음 (100번지, 100번지) ㆍ 공간적 지역성(spatial locality) ­ 기억장치 내에 인접하여 저장되어 있는 데이터들이 연속적으로 액세스 될 가능성이 높음 (100번지, 101번지) ㆍ 순차적 지역성(sequential locality) ­ 분기(branch)가 발생하지 않는 한, 명령어들은 기억장치에 저장된 순서대로 인출되어 실 행됨 ▶ 캐시 설계에 있어서의 공통적인 목표 ­ 캐시 적중률의 극대화 ­ 캐시 액세스 시간의 최소화 ­ 캐시 미스에 따른 지연 시간의 최소화 ­ 주기억장치와 캐시 간의 데이터 일관성 유지 및 그에 따른 오버헤드의 최소화  249   2. 캐시 크기 및 인출 방식   ▶ 캐시의 크기 / 인출 방식
1) 캐시의 크기(용량) ­ 용량이 커질수록 적중률이 높아지지만, 비용이 증가 ­ 용량이 커질수록 주소 해독 및 정보 인출을 위한 주변 회로가 더 복잡해지기 때문에 액세 스 시간이 다소 더 길어짐(적당한 크기를 가져야 한다)
2) 인출 방식 ㆍ 요구 인출(demand fetch) 방식 ­ 필요한 정보만 인출해 오는 방법 ㆍ 선인출(prefetch) 방식 ­ 필요한 정보 외에 앞으로 필요할 것으로 예측되는 정보도 미리 인출 ­ 지역성이 높은 경우에 효과가 큼 ▶ 주기억장치와 캐시의 조직 ㆍ 주기억장치 블록(K개의 단어들로 구성) ­ 하나의 캐시 라인(cache line)에 적재 : 주소 → 태그 주소 데이터 블록 라인번호 태그 데이터 블록(단어) 단어 단어 (a) 주기억장치 (b) 캐시 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 블록(block) ­ 주기억장치로부터 동시에 인출되는 정보들의 그룹 ⋅ 주기억장치 용량 = n 단어, 블록 = K 단어 → 블록의 수 = n/K 개 ㆍ 라인(line) ­ 캐시에서 각 블록이 저장되는 장소 ㆍ 태그(tag) ­ 라인에 적재된 블록을 구분해주는 정보 ▶ Mapping techniques ­ 각 주기억장치 블록이 어느 캐시 라인에 적재될 것인 지를 결정해 주는 방식으로서, 캐시  250   내부 조직을 결정 ⋅ 직접 사상(direct mapping) ⋅ 완전
- 연관 사상(fully
- associative mapping) ⋅ 세트
- 연관 사상(set
- associative mapping) ­ 각 주기억장치의 블록이 지정된 하나의 캐시 라인으로만 적재됨 ㆍ 주기억장치 주소 형식    ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 태그 필드(t 비트) : 태그 번호(라인에 적재되어 있는 블록의 번호) ⋅ 라인 번호(l 비트) : 캐시의 m = l 개의 라인들 중의 하나를 지정 ⋅ 단어 필드(w 비트) : 각 블록 내 w 개 단어들 중의 하나를 구분 ㆍ 주기억장치의 블록 j 가 적재될 수 있는 캐시 라인의 번호 i ­ i = j mod m 단, j : 주기억장치 블록 번호, m : 캐시 라인의 전체 수 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 라인을 공유하는 주기억장치 블록들 ­ 각 캐시 라인은 t개의 블록들에 의하여 공유(태그 필드) ­ 같은 라인을 공유하는 블록들은 서로 다른 태그를 가짐

1) 각 캐시 라인을 공유하는 주기억장치 블록들 캐시 라인 주기억장치 블록 번호들 0 0, m, …, (t ­ m) 1 1, (m +
1), …, (t ­ m +
1) ⋮ ⋮ (m
-1) (m ­

1), (2m ­
1), …, (t ­
1) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 캐시기억장치의 실패(miss) ­ 중앙처리장치가 1000번지의 워드가 필요 ⋅ 1단계에서 캐시기억장치가 1000번지의 워드를 저장하고 있는지를 검사하고 1000번지 워드가 캐시기억장치 내에 존재하지 않는다면 실패(miss) 상태가 됨 주기억장치 캐시기억장치 ※ 컴퓨터 구조와 원리2.0, 한빛아카데미, 2013  251   ­ 실패인 경우에 원하는 정보를 찾아 CPU로 전달하는 과정 ⋅ 1단계 : 주기억장치에서 필요한 정보를 획득하여 캐시기억장치에 전송(지역성) ⋅ 2단계 : 캐시기억장치는 얻어진 정보를 다시 중앙처리장치로 전송 주기억장치 캐시기억장치 ※ 컴퓨터 구조와 원리2.0, 한빛아카데미, 2013 ▶ 캐시기억장치의 적중(hit) ­ CPU가 1002번지의 워드를 필요로 하고 이것이 캐시기억장치에 존재 주기억장치 캐시기억장치 ※ 컴퓨터 구조와 원리2.0, 한빛아카데미, 2013 ⋅ 1단계 : 캐시기억장치가 1002번지의 워드를 저장하고 있는지를 검사하고, 1002번지 워드가 캐시기억장치 내에 존재한다면 적중(hit)이 됨 ⋅ 2단계 : 캐시기억장치에서 얻어진 정보를 중앙처리장치로 직접으로 전송하며, 주기억장 치를 거치는 것보다 훨씬 빠른 속도로 원하는 정보를 획득하게 됨 ­ 캐시기억장치의 동작은 기억장치 참조의 지역성(locality of reference)에 의해 가능 ⋅ 중앙처리장치의 주기억장치 참조는 제한된 영역에서만 이루어지는 현상 ⋅ 짧은 시간 동안 중앙처리장치가 접근하는 범위는 지역적으로 제한됨(공간적, 시간적)  252   사상 방식
1. 캐시기억장치의 사상 방식 중 직접 사상과 완전연관 사상 방법에 대해서 이해하고 이를 설명할 수 있다. 11주차  수업목표  
2. 캐시기억장치의 사상 방식 중 세트연관 사상 방법에 대해서 2교시  이해하고 이를 설명할 수 있다.
1. 직접 사상 세부내용 
2. 완전연관 사상
3. 세트연관 사상 1. 직접 사상   ▶ 직접 사상 캐시의 조직 캐시 기억장치 주소 데이터 태그 라인(0) 라인() 라인() (캐시 적중) (캐시 미스) 주기억장치 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 직접 사상 캐시의 동작 원리 ­ 캐시로 기억장치 주소가 보내지면, 그 중 l 비트의 라인 번호를 이용하여 캐시의 라인을 선 택 ㆍ 선택된 라인의 태그 비트들을 읽어서 주소의 태그 비트들과 비교 ­ 두 태그 값이 일치하면(캐시 적중) → 주소의 w 비트들을 이용하여 라인 내의 단어들 중에서 하나를 인출하여 CPU로 전송 ­ 태그 값이 일치하지 않는다면(캐시 미스) ⋅ 주소를 주기억장치로 보내어 한 블록을 액세스 ⋅ 인출된 블록을 지정된 캐시 라인에 적재하고, 주소의 태그 비트들을 그 라인의 태그 필드에 기록 ⋅ 만약 그 라인에 다른 블록이 이미 적재되어 있다면, 그 내용은 지워지고 새로이 인출 된 블록을 적재하고 태그도 갱신  253   ▶ 직접 사상 캐시의 장단점 ⋅ 장점 ­ 하드웨어가 간단하고, 구현 비용이 적게 듦 ⋅ 단점 ­ 각 주기억장치 블록이 적재될 수 있는 캐시 라인이 한 개 뿐이기 때문에, 그 라인을 공 유하는 다른 블록이 적재되는 경우에는 overwrite 되거나 swap
- out 됨(miss가 계속 발생) ▶ 직접 사상 캐시의 예 ­ 주기억장치 용량 = 128()바이트 ­ 주기억장치 주소 = 7비트(바이트 단위 주소 지정) ­ 블록 크기 = 4바이트 → 주기억장치는 128/4 = 32개의 블록들로 구성 ­ 캐시 용량 = 32바이트 ­ 캐시 라인 크기 = 4바이트(블록 크기와 동일) ­ 전체 캐시 라인의 수, m = 32/4 = 8개 → 기억장치 주소 형식 : 7 = 2 + 3 + 2 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 각 기억장치 블록이 공유하게 될 캐시 라인 번호 ­ i = j mod 8

1) 각 캐시 라인을 공유하는 주기억장치 블록들 캐시 라인 주기억장치 블록 번호 0 (000) 00000 01000 10000 11000 1 (001) 00001 01001 10001 11001 2 (010) 00010 01010 10010 11010 3 (011) 00011 01011 10011 11011 4 (100) 00100 01100 10100 11100 5 (101) 00101 01101 10101 11101 6 (110) 00110 01110 10110 11110 7 (111) 00111 01111 10111 11111 ※ 컴퓨터구조론, 생능출판사, 2019  254   ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 직접 사상 캐시에서의 적중 검사 예
① 0101000
② 0001101
③ 1110111
④ 1011010 ⋅ 풀이
① 캐시 미스 → 2번 라인의 데이터 필드 : ‘info’, 태그 : 01
② 캐시 적중 : 3번 라인에 적재되어 있음(‘univ’)
③ 캐시 미스 → 5번 라인의 데이터 필드 : ‘tech’, 태그 : 11
④ 캐시 적중 : 6번 라인에 적재되어 있음(‘arch’) [참고 : 단어 필드의 값이 ’10’이므로, 만약 읽기 동작이라면 ‘arch’ 중에서 세 번째 단 어인 ‘c’가 CPU로 읽혀진다.] ▶ 직접 사상의 동작 v 중앙처리장치가 00010번지 단어를 필요로 하는 경우
① 처음의 2비트 00은 태그를 나타내고, 다음 3비트 010은 캐시기억장치의 주소. 그래서 캐시기억장치의 010번지 주소만을 참조. 해당 번지가 비어 있으므로 실패(miss)한 것 으로 판단하고 주기억장치를 참조하게 됨
② 주기억장치의 주소 00010에서 필요한 단어를 획득하게 됨
③ 캐시기억장치의 해당 주소 010에 단어 데이터 5678과 태그 00을 저장함
④ 단어 데이터 5678를 CPU로 전달함  255   ㆍ 직접 사상의 동작 : miss 캐시기억장치 주기억장치 (a) 실행 전 (b) 실행 후 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 v 중앙처리장치가 10001번지 워드를 필요로 하는 경우
① 처음의 2비트 10은 태그를 표시하고, 다음 3비트 001은 캐시기억장치의 주소 캐시기 억장치의 001번지에만 접근하는데, 태그가 00으로 불일치하므로 실패(miss)
② 주기억장치 10001번지에서 단어를 획득함
③ 캐시기억장치의 001번지에 단어 데이터 7890과 태그 10을 저장, 따라서 태그를 포함 해서 00 1234가 10 7890으로 변경됨(overwrite)
④ 단어 데이터 7890이 CPU로 전달됨 ㆍ 직접 사상의 동작 : miss 캐시기억장치 주기억장치 (a) 실행 전 (b) 실행 후 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 v 중앙처리장치가 00010번지 워드를 필요로 하는 경우
① 처음의 2비트 00은 태그를 표시하고, 다음 3비트 010은 캐시기억장치의 주소를 표시 함, 캐시기억장치의 주소 010번지만 참고하는데, 태그가 00으로 일치하므로 적중(hit) 한 것으로 판단함  256  
② 캐시기억장치 010번지에서 중앙처리장치가 요구하는 단어를 획득하게 됨 ㆍ 직접 사상의 동작 : hit 캐시기억장치 주기억장치 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 2. 완전연관 사상   ▶ 완전연관 사상 ­ 주기억장치 블록이 캐시의 어떤 라인으로든 적재 가능 ­ 태그 필드 = 주기억장치 블록 번호 ㆍ 기억장치 주소 형식 ㆍ 직접 사상 캐시의 예에 완전
- 연관 사상 방식을 적용하면, ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 완전연관 사상 캐시의 조직(CAM – 동시 비교) 캐시 기억장치 주소 태그 데이터 라인(0) 라인() (캐시 적중) 라인() (캐시 미스) 주기억장치 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 완전연관 사상 캐시의 장단점 ⋅ 장점 ­ 새로운 블록이 캐시로 적재될 때 라인의 선택이 매우 자유로움  257   ­ 지역성이 높다면, 적중률이 매우 높아짐 ⋅ 단점 ­ 캐시 라인들의 태그들을 병렬로 검사하기 위하여 가격이 높은 연관 기억장치 (associative memory) 및 복잡한 주변 회로가 필요(CAM) ▶ 완전연관 사상의 예(임의 위치) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 완전연관 사상 캐시에서의 적중 검사 예 : 다 검사함
① 1011000
② 0010110
③ 0000001
④ 0111111 ⋅ 풀이
① 캐시 적중 : 현재 3번 라인에 적재되어 있음
② 캐시 미스 : 첫 번째 빈 라인인 5번 라인에 적재됨(태그 = 00101, 데이터 = ‘assm’)
③ 캐시 미스 : 라인 번호 순으로 6번 라인에 적재됨(태그 = 00000, 데이터 = ‘abcd’)
④ 캐시 적중 : 현재 1번 라인에 적재되어 있음 3. 세트연관 사상   ▶ 세트연관 사상 ­ 직접 사상과 완전
- 연관 사상의 조합 ­ 주기억장치 블록 그룹이 하나의 캐시 세트를 공유하며, 그 세트에는 두 개 이상의 라인들이 적재될 수 있음 ­ 캐시는 v 개의 세트(set)들로 나누어지며, 각 세트들은 k개의 라인들로 구성(k
- way 세트
- 연관 사상 이라고 부름)  258   ㆍ 주기억장치 블록이 적재될 수 있는 캐시 세트의 번호 i ­ i = j mod v 단, i : 캐시 세트의 번호 j : 주기억장치 블록 번호 v : 캐시 세트들의 수

1) 기억장치 주소 형식 ­ 태그 필드와 세트 필드를 합한 (t+s)비트가 주기억장치의 ts블록들 중의 하나를 지정 ­ 그 블록이 적재될 수 있는 세트 번호 : 세트 필드에 의해 지정 ­ 앞의 [예]에 2
- way 세트
- 연관 사상 방식을 적용하는 경우의 주소 형식 : (세트 수 = 8/2 = 4개) ※ 컴퓨터구조론, 생능출판사, 2019 ­ 세트 수 = 캐시 라인 수(v = m) & 세트 내 라인의 수 k = 1 → 직접 사상 ­ 세트 수 = 1 & 세트 내 라인의 수 = 캐시의 전체 라인 수(k = m) → 완전 ­ 연관 사상 ▶ 세트연관 사상의 동작 원리 ­ 기억장치 주소의 세트 필드의 s 비트들을 이용하여 캐시 세트들 중의 하나를 선택 ㆍ 주소의 태그 필드 내용과 그 세트 내의 태그들을 비교 ­ 일치하는 것이 있으면(캐시 적중) → 그 라인 내의 한 단어를 w 비트에 의해 선택하여 인출 ­ 일치하는 것이 없다면(캐시 미스) ⋅ 주기억장치를 액세스 ⋅ 세트 내 라인들 중의 한 라인에 새로운 블록을 적재(교체 알고리즘 필요) ▶ 2
-way 세트연관 사상 캐시의 조직 캐시 태그 데이터 기억장치 주소 라인(0) 세트(0) 라인(1) 라인(0) 세트() 라인(1) 라인(0) 세트() (캐시 적중) 라인(1) (캐시 미스) 주기억장치 ※ 컴퓨터구조론, 생능출판사, 2019  259   ▶ 2
-way 세트연관 사상 캐시의 예 ⋅ 예)
- 주기억장치 용량 = 128() 바이트
- 블록 크기 = 4바이트 → 주기억장치 블록 수 = 128/4 = 32개
- 캐시 크기 = 32바이트, 라인 크기 = 4바이트
- 세트당 라인 수 = 2 → 캐시 내 세트의 수 v = 8/2 = 4개

1) 각 세트를 공유하는 주기억장치 블록들 세트 번호 주기억장치 블록 번호 : 세트 당 2개 저장 0
(00) 00000 00100 01000 01100 10000 10100 11000 11100 1 (01) 00001 00101 01001 01101 10001 10101 11001 11101 2 (10) 00010 00110 01010 01110 10010 10110 11010 11110 3 (11) 00011 00111 01011 01111 10011 10111 11011 11111 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 세트연관 사상의 예 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 2
-way 세트연관 사상 캐시에서의 적중 검사
① 1011010
② 1110101
③ 1000000
④ 0001111 ⋅ 풀이
① 캐시 적중 : 현재 2번 세트의 두 번째 라인에 적재되어 있음
② 캐시 미스 → 1번 세트의 두 번째 라인에 적재
③ 캐시 미스 → 0번 세트의 첫 번째 라인에 적재(overwrite)
④ 캐시 적중 : 현재 3번 세트의 첫 번째 라인에 적재되어 있음  260   ▶ 큰 용량의 세트연관 사상 캐시 조직의 예 ­ 주기억장치의 용량은 16M()바이트임 따라서 주기억장치의 주소는 24비트이고, 바이트 단위로 주소가 지정됨 ­ 주기억장치는 4
-바이트 크기의 블록들 4M()개로 구성되어 있고, 단어의 길이는 한 바이 트임 ­ 캐시의 용량은 64K()바이트임 ­ 주기억장치의 블록 크기가 4바이트이므로, 캐시 라인의 크기도 4바이트가 되며, 결과적으로 라인 수 m = 16K()개가 됨 ­ 2
- way 세트
- 연관 사상 조직으로 가정함 따라서 세트의 수 v = 8K() 개임 ㆍ 주기억장치 주소 형식

1) 각 세트를 공유하는 주기억장치 블록들 세트 번호 주기억장치 블록 번호 0000 000000, 008000, …, ex)ex)8000 0001 000004, 008004, …, ex)ex)8004 ⋮ ⋮ ⋮ ⋮ 1ex)ex)ex) 007ex)ex)C, 00ex)ex)ex)C, …, ex)ex)ex)ex)ex)C ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 64KByte 크기의 2
-way 세트연관 캐시의 예 : 24 = 9+13+2 세트+ 태그 단어 데이터 태그 데이터 태그 데이터 세트번호 주기억장치 (16M바이트) ※ 컴퓨터구조론, 생능출판사, 2019 ◼ 예제 5
-5 ­ 프로그램 수행 중의 어느 시점에서 세트
- 연관 사상 캐시의 라인들이 그림 5
-24와 같은  261   블록들을 적재하고 있다고 하자. 이때 CPU로부터 다음과 같은 기억장치 주소들이 발생 한 경우에 ‘캐시 적중’인지 혹은 ‘캐시 미스’인지를 구분하라. 단, 주소는 2진수로 표시되 어 있다.
① 1111 1111 0111 1111 1111 1101
② 0000 0000 0000 0000 0000 0110
③ 1010 0011 1111 1111 1111 0111
④ 0000 0001 0000 0000 0000 0100 ⋅ 풀이
① 캐시 적중 : 현재 1ex)ex)ex)번 세트의 두 번째 라인에 적재되어 있다.(태그 = 1ex)E, 데이터 = ‘tech’)
② 캐시 적중 : 현재 0001번 세트의 첫 번째 라인에 적재되어 있다.(태그 = 000, 데이터 = ‘univ’)
③ 캐시 미스 : 1ex)ex)D번 세트에는 태그가 1ex)ex)인 블록만 적재되어 있다.
④ 캐시 미스 : 0001번 세트에는 태그가 000인 블록만 적재되어 있다. ※ 컴퓨터구조론, 생능출판사, 2019  262   교체 및 쓰기

1. 캐시기억장치의 교체 알고리즘과 쓰기 정책에 대해서 학습하고 이를 설명할 수 있다. 11주차  수업목표  
2. 컴퓨터 내부에서 여러 개의 캐시를 사용하는 이유에 대해서 3교시  학습하고 이를 설명할 수 있다.
1. 교체 알고리즘 세부내용 
2. 쓰기 정책
3. 다중 캐시 1. 교체 알고리즘  ▶ 교체 알고리즘 ­ 세트
-연관 사상에서 주기억장치로부터 새로운 블록이 캐시로 적재될 때, 만약 세트 내 모든 라인들이 다른 블록들로 채워져 있다면, 그들 중의 하나를 선택하여 새로운 블록으로 교체 v 교체 알고리즘이란, 캐시 적중률을 극대화할 수 있도록 교체할 블록을 선택하기 위한 알고 리즘 ㆍ 최소 최근 사용(Least Recently Used : LRU) 알고리즘 ­ 사용되지 않은 채로 가장 오래 있었던 블록을 교체하는 방식 ㆍ ex)Iex)O(ex)irst ­ In ­ ex)irst ­ Out : ex)Iex)O) 알고리즘 ­ 캐시에 적재된 지 가장 오래된 블록을 교체하는 방식 ㆍ 최소 사용 빈도(Least ex)requently Used : Lex)U) 알고리즘 ­ 참조되었던 횟수가 가장 적은 블록을 교체하는 방식 ㆍ 랜덤(Random) ­ 캐시기억장치에서 임의의 블록을 선택하여 삭제하고 새로운 블록으로 교체하는 방식그러 나 효율성을 보장하기가 어려움(그 외 : 라운드로빈) ◼ 예제 5
-6 ­ LRU 교체 알고리즘을 사용하는 세트 ­ 연관 사상 캐시로 아래와 같은 블록들이 연속적 으로 들어온다고 할 때, 각 라인에 적재되는 블록을 표시하고 적중률(H)를 구하라. 단, 각 세트의 라인 수는 (a) 2개, 혹은 (b) 4개 라고 가정한다. 0 1 2 0 2 3 7 3 1 3 2 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 교체 알고리즘(LRU 교체) ⋅ 풀이 (a) 라인 수가 2개인 경우  263   ※ 컴퓨터구조론, 생능출판사, 2019 (b) 라인 수가 4개인 경우 ▶ 블록 크기와 캐시의 수 ㆍ 블록 크기(Block size) ­ 동시에 인출되는 정보들의 블록이 커지면 한꺼번에 많은 정보를 읽어 올 수 있지만 블록 인출 시간이 길어지게 됨 ­ 블록이 커질수록 캐시기억장치에 적재할 수 있는 블록의 수가 감소하기 때문에 블록들이 더 빈번히 교체되며, 블록이 커질수록 멀리 떨어진 단어들도 같이 읽혀오기 때문에 가까 운 미래에 사용될 가능성이 낮음(지역성) ­ 일반적인 블록의 크기는 4~8단어가 적당함 ㆍ 캐시의 수(Number of Caches) ­ 일반적인 시스템은 오직 하나의 캐시기억장치를 가지고 있었음 ­ 최근에는 캐시기억장치들이 계층적 구조로 설치되거나 기능별로 분리된 다수의 캐시기억 장치를 사용하는 것이 보편화 되었음 ­ 캐시기억장치를 설계할 때에는 몇 계층으로 할 것인지를 결정하여야 하며, 통합 형태와 분리 형태 중에서 어떤 형태로 구성할 것인지를 결정해야 함 ­ 설계 과정에서 사용할 캐시의 수가 결정됨 ▶ 다양한 캐시기억장치의 구조 : 계층, 통합/분리 캐시 1개 사용 캐시 2개 사용 캐시 3개 사용 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ⋅ (a) 단계 : 가장 일반적인 구조로 한 개의 캐시기억장치를 사용함(예전) ⋅ (b) 단계 : 두 개의 캐시기억장치를 이용하여 계층적으로 구성한 구조이며, 여기서 캐 시 1은 중앙처리장치에 내장되어 있는 경우가 일반적임(on
-chip vs. off
-chip) ⋅ (c) 단계 : 캐시기억장치 3개를 이용하여 계층적 구조로 설계한 것이며, (b)와 비교해서 캐시 1에 해당하는 부분이 분리된 형태의 두 개의 캐시로 발전되었음 그래서 각 기능 에 따라서 명령어 캐시와 자료(데이터) 캐시로 분리되었지만, (b)와 마찬가지로 캐시 1 에 해당하는 명령어 캐시와 자료 캐시는 CPU에 내장되어 있는 캐시기억장치임(파이프 라인 ­ 동시 접근)  264   2. 쓰기 정책 ▶ 쓰기 정책(write policy) ­ 캐시의 블록이 변경되었을 때 그 내용을 주기억장치에 갱신하는 시기와 방법의 결정

1) 종류
① Write­through ­ 모든 쓰기 동작들이 캐시로 뿐만 아니라 주기억장치로도 동시에 수행되는 방식 ⋅ 장점 ­ 캐시에 적재된 블록의 내용과 주기억장치에 있는 그 블록의 내용이 항상 같음 ⋅ 단점 ­ 모든 쓰기 동작이 주기억장치 쓰기를 포함하므로, 쓰기 시간이 길어짐

2) 쓰기 정책에 따른 쓰기 동작의 비교 : 즉시 vs. 나중 CPU CPU 주기억장치 주기억장치 (a) Write
- through (b) Write
- back ※ 컴퓨터구조론, 생능출판사, 2019
② Write
-back ­ 캐시에서 데이터가 변경되어도 주기억장치에는 갱신되지 않는 방식 ⋅ 장점 ­ 기억장치에 대한 쓰기 동작의 횟수가 최소화되고, 쓰기 시간이 짧아짐 ⋅ 단점 ­ 캐시의 내용과 주기억장치의 해당 내용이 서로 다름 ⇨ 캐시의 데이터가 수정된 적이 있는 경우에는, 블록을 교체할 때 주기억장치에 갱신하는 동 작이 선행되어야 하며, 그를 위하여 각 캐시 라인이 상태 비트(state bit)를 가지고 있어야 함 ▶ 다중 프로세서 시스템에서의 데이터 불일치 문제 ­ 다중프로세서시스템에서의 데이터 불일치 문제(data inconsistency problem) : 주기억장치 에 있는 블록의 내용과 캐시 라인에 적재된 블록의 내용이 서로 달라지는 문제 ­ 캐시 일관성 프로토콜(cache coherence protocol) 필요 ⋅ 예) MESI 프로토콜  265   ▶ 다중 프로세서 시스템에서의 데이터 불일치 문제 : 즉시 vs. 나중 프로세서 캐시 시스템 버스 주기억장치 (a) Write ­ back 방식이 사용된 경우 프로세서 캐시 시스템 버스 주기억장치 (b) Write
- through 방식이 사용된 경우 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 컴퓨터의 기억장치 구성

1) 기억장치의 계층적으로 분류(경제학 : 적정비용의 적정속도) 넓이 : 저장 용량 둘레 : 처리시간 높이 : 가격 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013
2) 기억장치의 계층적으로 분류 ㆍ 원의 넓이 ­ 저장 용량을 나타냄 ㆍ 원의 둘레 ­ 기억장치가 데이터를 저장하거나 인출하는데 걸리는 시간 따라서 원의 둘레는 처리속도 를 나타낸다고 할 수 있음 ㆍ 원통의 높이 ­ 기억장치의 가격을 나타냄 ▶ SRAM v SRAM(Static RAM, Static Random Access Memory)은 플립플롭을 기억 소자로 구성 하여, 집적 밀도가 높아 소용량의 기억장치에 사용  266   ­ DRAM보다 처리속도가 5배 정도 빨라서 캐시 메모리(cache memory)에 주로 사용 : RS ex)/ex) ㆍ SRAM의 기억 소자(memory cell) 구조 선택 입력() 데이터 데이터 입력 출력   ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ SRAM의 동작과정 ­ 선택입력 S가 0이면 기억 소자가 선택되지 않았으므로 읽기와 쓰기 동작은 일어나지 않음 ­ S가 1일 때, 본격적인 동작  ⋅ S = 1이고  = 0이면 쓰기 동작을 수행하여서 입력 단자에 입력된 데이터가 플립 플롭에 저장되고 데이터의 출력은 없음  ⋅ S = 1이고  = 1이면 읽기 동작을 수행하여서 플립플롭에 저장되어 있던 데이터 비트를 데이터 출력 단자를 통해서 출력을 하게 됨 ⦁⦁  ⦁⦁  ⦁⦁  ⦁⦁  = 1⦁0⦁0 = 1⦁0⦁1 = 1⦁1⦁0 = 1⦁1⦁1 플립플롭 R 입력 1 × 1 × 1 = 1 1 × 1 × 0 = 0 1 × 0 × 1 = 0 1 × 0 × 0 = 0 (G 의 출력)  플립플롭 S 입력 1 × 1 × 0 = 0 1 × 1 × 1 = 1 1 × 0 × 0 = 0 1 × 0 × 1 = 0 (G 의 출력)  플립플롭 출력 0 1 Q Q Q 데이터 풀력 0 × 0 = 0 1 × 0 = 0 Q × 1 = Q Q × 1 = Q (G 의 출력)  쓰기 동작 모드 읽기 동작 모드 동작 결과 : 입력 I가 플립플롭 출력 Q로 : 데이터 출력이 과거 상태 Q를 저장되고 데이터 출력은 없다. 출력한다. ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ SRAM의 기억소자 구조 ­ SRAM의 기억소자들을 격자 구조로 배열하면 많은 비트를 저장할 수 있는 진정한 SRAM 이 됨 선택 입력() ㆍ SRAM의 기억 소자 블록 데이터 데이터 입력 출력 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013    267  
1) 격자의 배열 구조로 형성된 SRAM의 기본 구조 ­ 기억소자들이 4 x 3의 배열이므로 12비트를 저장, 워드의 길이는 3비트가 됨 ­ 4개의 워드가 존재하므로 주소는 0, 1, 2, 3의 4개가 필요 ­ 2 x 4 디코더는 2비트를 가지고 4개 중에서 하나를 선택 데이터 입력 주소 입력 데이터 출력 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ SRAM의 쓰기 동작 과정 ­ 주소 선택선을 통해 입력신호 A A = 01이 입력되면 디코더에서 주소 D 이 선택됨     ­ 그리고 제어 단은  = 0 이 되어 쓰기 동작을 수행함 ­ 따라서 주소 D 의 기억 소자 3개에 입력 데이터 101이 저장되게 됨  ­ 여기서 모든 기억 소자에 입력 값이 전달되지만, D 을 제외한 다른 주소는 쓰기 제어 입력  을 받지 못하므로 어떤 값도 저장되지 않음 데이터 입력 주소 입력 데이터 출력 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013  268   ▶ SRAM의 읽기 동작 과정 ­ 주소 선택선을 통해 들어온 입력신호 A A 는 01의 값에 해당되는 주소가 디코더에서 선택   됨  ­ 이때 제어 단은  = 1 이 되어, 선택된 각각의 기억 소자는 출력 단자를 통하여 출력 을 내보내게 됨 데이터 입력 주소 입력 데이터 출력 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 3. 다중 캐시 ▶ 다중 캐시(multiple cache) ㆍ 온­칩 캐시(on­chip cache) ­ 캐시 액세스 시간을 단축시키기 위하여 CPU 칩 내에 포함시킨 캐시(아래 그림의 L1) ㆍ 오프­칩 캐시(off­chip cache) ­ 캐시가 CPU 외부에 위치함
1) 계층적 캐시(hierarchical cache) ­ 온
- 칩 캐시를 1차(L1) 캐시로 사용하고, 칩 외부에 더 큰 용량의 2차(L2) 캐시를 설치하 는 방식 CPU 주기억장치 ※ 컴퓨터구조론, 생능출판사, 2019  269   ▶ 계층적 캐시(hierarchical cache) ­ L 는 L 의 슈퍼­세트(super
-set) : L 의 용량이 L 보다 크며, L 의 모든 내용이 L 에도 존       재 ­ 먼저 L 을 검사하고, 만약 원하는 정보가 L 에 없다면 L 를 검사하며, L 에도 없는 경우에     는 주기억장치를 액세스 ­ L 은 속도가 빠르지만, 용량이 작기 때문에 L 보다 적중률은 더 낮음   ㆍ 2
-단계 캐시 시스템의 평균 기억장치 액세스 시간  ×  × ×       만약 가 에서 미스된 액세스들에 대한 의 적중률이라면     ×  × {  }×         ◼ 예제 5
-8 ­ L ·L 캐시 및 주기억장치의 액세스 시간이 각각 2ns, 10ns 및 100ns이고, L 의 적중    률(H )이 0.7, L 의 적중률(H )은 0.9라고 할 때, 평균 기억장치 액세스 시간을 구하라.    단, 식 (5 ­

6) 및 식 (5 ­
7)을 이용하는 경우에 대하여 각각 답하라. ⋅ 풀이 ­ 먼저, 식 (5 ­
6)에서와 같이 H 가 전체 기억장치 액세스들에 대한 L 의 적중률이라면,   평균 기억장치 액세스 시간(Ta)은 아래와 같아진다. Ta = (0.7 × 2ns) + {(0.9 ­ 0.7) × 10ns} + {(1 ­ 0.9) × 100ns} = 1.4ns + 2ns + 10ns = 13.4ns 그런데 만약 H 가 L 에서 미스 된 기억장치 액세스들에 대한 L 의 적중률이라면, 평균    기억장치 액세스 시간(Ta)은 식 (5 ­
7)을 이용하여 아래와 같이 구할 수 있다. Ta = (0.7 × 2ns) + (1 ­ 0.7) × 0.9 × 10ns + {1 ­ 0.7 ­ (1 ­ 0.7) × 0.9} × 100ns = 1.4ns + 2.7ns + 3ns = 7.1ns ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 분리 캐시(split cache) ­ 캐시를 명령어 캐시와 데이터 캐시로 분리 ­ 명령어 인출 유니트와 실행 유니트 간의 캐시 액세스 충돌 제거 ­ 대부분의 고속 프로세서들에서 사용 ­ 파이프라인에 유리  270   ▶ 분리 캐시의 사례 : PowerPC 620 프로세서(제어 장치) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 계층적 분리 캐시의 사례 : 인텔 이타늄(Itanium) 프로세서 ex)rontside 버스 시스템 버스 프로세서 칩 프로세서 카트리지 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 멀티
-코어 프로세서의 캐시 구조(QuickPath – ex)ront Side Bus) ⋅ 예) 인텔 i7
- 990X 쿼드
- 코어 프로세서의 3
- 레벨 캐시 구조 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 캐시기억장치의 통합과 분리 ㆍ 통합 캐시 형태 ­ 초창기 온
-칩 캐시기억장치는 데이터와 명령어를 모두 저장하는 통합 캐시 형태임 ­ 통합 캐시는 명령어와 데이터 간의 균형을 자동적으로 유지해주기 때문에 분리 캐시보다  271   적중률이 더 높은 장점이 있음 ㆍ 분리 캐시 형태 ­ 분리 캐시는 명령어만 저장하는 명령어 캐시와 데이터만 저장하는 데이터 캐시로 분리하 여 두 개의 온
-칩 캐시를 두는 형태임 ­ 특히 여러 개의 명령어들이 동시에 실행되는 고성능 프로세서에서는 이러한 경향이 뚜렷 함 ­ 분리 캐시의 장점은 명령어 인출과 명령어 실행 간 캐시의 충돌이 발생하지 않는다는 것 임(파이프라인) ▶ 멀티 프로세서의 캐시기억장치 구조 v 최신의 컴퓨터 시스템은 여러 개의 중앙처리장치(CPU)를 장착하여 처리 성능을 향상시키 고 있는데, 이것을 멀티 프로세서 시스템이라 함

1) 시스템 버스에 온
-칩 캐시의 CPU 3개가 연결된 멀티 프로세서 시스템 중앙처리장치 캐시기억장치 시스템 버스 주기억장치 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ­ 멀티 프로세서 시스템에서는 주기억장치와 각 중앙처리장치 내의 캐시기억장치들 사이에서 데이터의 불일치 현상이 발생함 ­ 데이터의 불일치 현상은 프로그램이 올바르게 동작하지 않는 원인이 됨 ▶ 즉시 쓰기방식에서의 데이터 불일치 상태

1) 멀티 프로세서 시스템에 즉시 쓰기 정책 ­ CPU1과 CPU2는 주기억장치에서 D라는 데이터를 읽어오는데, 이렇게 되면 CPU1, CPU2, 주기억장치는 D라는 동일한 데이터를 갖게 됨 ­ CPU1이 프로그램을 실행하여 D라는 데이터를 X로 수정하게 되면 CPU1에 속한 캐시기억 장치는 데이터를 X로 변경하고 즉시 쓰기 정책에 따라 주기억장치에도 수정된 데이터인 X 를 저장하게 됨 ­ 이 경우 CPU1에 속한 캐시기억장치와 주기억장치의 데이터는 X로 수정이 되지만 CPU2에 속한 캐시기억장치는 D라는 데이터로 남아있게 되기 때문에 데이터의 불일치가 발생하게 됨 중앙처리장치 캐시기억장치 시스템 버스 주기억장치 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013  272   ▶ 나중 쓰기방식에서의 데이터 불일치 상태
1) 멀티 프로세서 시스템에 나중 쓰기 정책 ­ 주기억장치에서 D라는 데이터를 CPU1과 CPU2의 캐시가 읽어와서, CPU1, CPU2, 주기억 장치는 D라는 동일한 데이터를 갖게 됨 ­ CPU1이 프로그램을 실행하여 D라는 데이터를 X로 수정하게 되면 나중 쓰기 정책에 의해 CPU1에 속한 캐시기억장치는 수정된 데이터 X가 저장됨 ­ 주기억장치와 CPU2에 속한 캐시기억장치는 D라는 데이터로 남아있게 되기 때문에 데이터 의 불일치가 발생하게 됨 중앙처리장치 캐시기억장치 시스템 버스 주기억장치 ※ 컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ 캐시기억장치의 데이터 일관성 유지 방법
1) 공유 캐시기억장치를 사용하는 방법 ­ 가장 간단한 방법으로 다수의 프로세서가 하나의 캐시기억장치만을 공유 ­ 캐시의 데이터들이 항상 일관성 있게 유지하는 장점이 있으나 다중 프로세서가 동시에 캐 시에 접근하면 프로세서들 간의 충돌이 발생함 ­ 또한 온
-칩 캐시기억장치의 경우 CPU의 외부 활동을 줄여 실행 시간을 가속시키고 전체 시스템 성능을 높이는 원칙에 위배되는 단점을 가지게 됨(충돌 발생)

2) 공유 변수는 캐시기억장치에 저장하지 않는 방법 ­ 수정 가능한 데이터는 캐시기억장치에 저장하지 않는 방법임 ­ 수정될 데이터는 캐시에 저장하지 않고 주기억장치에 바로 저장함 ­ 캐시기억장치에 저장 가능한지 캐시기억장치에 저장 불가능 한지를 사용자가 선택하여 선 언해 주어야 하는 단점이 있음
3) 버스 감시 시스템을 사용하는 방법 ­ 감시 기능을 가진 장비를 시스템 버스 상에 추가로 설치하는 방법임 ­ 한 캐시가 데이터를 수정하면 그 정보를 다른 캐시와 주기억장치에 전달 ­ 시스템 버스에 통신량이 증가하는 단점이 있음  273   하드 디스크
1. 보조기억장치인 하드 디스크의 기본 구조에 대해서 학습하고 이를 설명할 수 있다. 12주차  수업목표  
2. 하드 디스크의 평가 요소인 디스크 액세스 시간에 대해서 1교시  학습하고 이를 설명할 수 있다.
1. 하드 디스크 구조 세부내용 
2. 디스크 액세스 시간 1. 하드 디스크 구조  ▶ 하드 디스크(hard disk) v 하드 디스크(hard disk)란, 자화될 수 있는 물질로 코팅된 플라스틱이나 금속을 이용한 원 형 평판으로 만들어진 저장장치로 자기 디스크(magnetic disk), 혹은 단순히 디스크라고 도 부름(HDD)
1) 주요 구성 요소들 ㆍ 원형 평판(circular platter) ­ 실제 정보가 저장되는 장소로서, 다수의 트랙(track)들로 구성 : 섹터(sector) ㆍ 헤드(head) ­ 전도성 코일을 통하여 표면을 자화(magnetize) 시킴으로써 데이터를 저장하는 장치 ㆍ 디스크 팔(disk arm) ­ 헤드를 이동시키는 장치 ㆍ 구동장치(actuator) ­ 원형 평판 회전 및 디스크 팔 구동을 위한 모터(motor)
2) 디스크 표면과 헤드 트랙들 sector 구동장치 디스크 팔 헤드 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 디스크 쓰기 ­ 헤드의 코일에 전류가 흐를 때 발생하는 자기장(magnetic field)을 이용하여 데이터를 저장하는 동작 ㆍ 디스크 읽기 ­ 자기장이 존재하는 위치에 헤드가 지나갈 때 코일에 유기(유도)되는 전기를 감지하여 데 이터를 인출하는 동작  274  
3) 하드 디스크의 특징 ­ 하드 디스크 드라이브(Hard disk drive, HDD), 하드 디스크(hard disk), 하드 드라이브 (hard drive), 고정 디스크(fixed disk)는 비휘발성, 순차접근이 가능한 컴퓨터의 보조 기억 장치임 : 직접접근(임의+순차) ­ 보호 케이스 안에 있는 플래터를 회전시켜, 이것에 자기 패턴으로 정보를 기록함 : 원형 평 판 ­ 여기서 이 플래터를 구동하는 장치가 스핀들 모터(motor)로 이루어진 것이 특징임 ­ 데이터는 플래터 표면에 코팅된 자성체에 기록되며, 회전하는 플래터 위에 부상하는 입출력 헤드에 의해 자기적으로 데이터를 쓰고 읽을 수 있음 ­ 하드 디스크는 플로피 디스크와 같은 자기 기록 매체이나, 플로피 디스크와 다르게 금속 재 질의 플래터에 데이터를 기록하기 때문에, 플로피디스크와 구분짓기 위해, 재질적으로 단단 하다는 뜻으로 하드라는 이름이 붙었음 ­ 일반적으로 아직까지는 개인용 컴퓨터의 운영 체제를 담는 용도로, 없어서는 안 될 저장 매 체로 많이 쓰이고 있음 : SSD로 대체되고 있으나 외장 HDD로 많이 사용됨 ­ 더 높은 데이터 전송 속도, 더 높은 스토리지 밀도, 더 나은 신뢰성, 훨씬 더 낮은 레이턴 시와 액세스 타임 등 여러 가지 특성이 우수한 반도체 기반의 기록 매체인 솔리드 스테이 트 드라이브(SSD)가 가격하락과 함께 저장 매체 시장에 서서히 진입하고는 있으나, 저장 용량당 가격에서 하드 디스크에 비해 높은 가격을 가지고 있으므로 성능적인 우위에도 불 구하고 하드 디스크는 여전히 중요한 저장 매체로 사용되고 있음 ­ 전원이 꺼지더라도 저장된 데이터는 유지되는 비휘발성 메모리의 일종임 ­ 원리적으로, 컴퓨터에 저장되는 모든 데이터는 0,1 두 디지털 신호에 의해 이루어짐 ­ 하드 디스크의 경우 이러한 디지털 신호를 원반형태의 플래터에 기록함 : 원형 평판 ­ 디지털 신호의 기록은 자기장의 밀도 변화를 이용해 기록 ­ 좀더 자세하게 말하면, 자기장의 밀도 변화를 측정하는 바늘(헤드)가 플래터 위의 일정한 간격을 지나치는 동안 자기장의 극성이 변화하면 1, 그렇지 않으면 0으로 인식함 ­ 자기장을 이용한 기계적 구조로 구성된 하드 디스크는 반도체 기반의 저장 매체(솔리드 스 테이트 드라이브)에 비해 진동, 충격, 자성 등의 외부 환경에 취약함 ­ 또한, 하드 디스크 외부는 소음 발생과 외부의 먼지 유입을 최소화하기 위해서 최대한 밀폐 적인 구조로 설계되어 있음 ­ 내부를 헬륨으로 충전하는 등 내부가 외부와 완전히 격리된 모델도 존재하지만, 일반적인 하드디스크에는 내부의 기압을 대기압과 동등하게 해주는 작은 구멍이 뚫린 씰(seal)이 있 어 외부 환경에 따라 먼지 등이 유입될 수 있기 때문에 외부 환경에 의한 수명 편차가 큼 ▶ 하드 디스크(hard disk) 
- 역사

1) 하드 디스크의 역사 ­ 최초의 하드 디스크는 1956년에 미국의 IBM에서 RAMAC(Random Access Method of Accounting and Control)이라는 이름으로 출시되었음 ­ 메인프레임과 미니컴퓨터에 탑재하기 위해 출시된 이 장치는 지름 24인치의 플래터 50장  275   으로 약 4.8 MiB의 용량을 구현하였으며 가격은 약 5만 달러였음 ­ 1980년대 초반까지는 하드디스크는 PC에 있어 특별한 기능을 하는 고가의 주변기기에 불 과하였음 ­ 하지만 1980년대 후반에 들어오면서 하드디스크는 PC에 있어 필수적인 기능이 되어 저가 의 PC에도 탑재되기 시작했음 ­ 2000년 초반 이후 디지털 가전제품의 수요가 증가함에 따라 디지털화된 영상과 음성을 저 장하기 위한 용도의 수요가 증가하였으며, 2000년대 중반부터는 내비게이션과 텔레비전에 도 하드디스크가 탑재되기 시작했음 ­ 그 이후, 하드디스크를 USB나 IEEE 1394를 이용해 외부 장치처럼 이용할 수 있는 외장 하드디스크(외장 하드) 가 등장하였음 ­ 또한, 특정 컴퓨터에 종속되지 않고, 독립적으로 네트워크상에서 공유할 수 있는 NAS라는 제품도 등장하였음 : LAN으로 연결하는 외장 HDD ▶ 디스크의 구조 ㆍ 섹터(sector) ­ 디스크에 한 번에 쓰거나 읽는 데이터 크기의 최소 단위 ㆍ 섹터간 갭(inter ­ sector gap) ­ 섹터들을 구분하기 위한 간격(gap) ㆍ 트랙간 갭(inter ­ track gap) ­ 헤드가 잘못 정렬되거나 자기장의 간섭 때문에 발생하는 오류를 방지하기 위한 트랙들 사이의 간격 ㆍ 초기 디스크의 경우 ­ 표면당 트랙의 수 = 500∼2000개 ­ 트랙당 섹터의 수 = 32개(최근 트랙 및 섹터 수가 크게 증가) ▶ 디스크 표면의 세부 구조 : 1 트랙 = n 섹터 섹터간 갭 트랙간 갭 섹터 트랙 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 등각속도(Constant Angular Velocity:CAV) 방식 ­ 디스크가 일정한 속도로 회전하는 상태에서, 트랙의 위치에 상관없이 데이터를 동일한 비율  276   로 액세스하는 방식 ⋅ 장점 ­ 구동장치 간단 ⋅ 단점 ­ 저장 공간 낭비(바깥쪽 트랙이 안쪽 트랙보다 더 길지만, 저장 밀도가 낮아서 저장되는 데이터 양은 동일)
1) CAV 방식 0번 트랙 0번 섹터 13번 트랙 7번 섹터 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 다중 영역 기록(Multiple Zone Recording:MZR) 방식 ­ 디스크 표면이 여러 개의 동심원 영역들(concentric zones) 로 나누어지며, 같은 영역에 속한 트랙들의 저장 밀도는 동일 ­ 디스크 전체적으로 저장 밀도를 거의 같도록 조정 ⋅ 바깥쪽 트랙들에 더 많은 데이터 저장 가능 ⋅ 각 트랙이 더 많은 섹터들로 분할 ⋅ 예) 15개 트랙들이 5개 영역들로 분할
- 안쪽 두 영역들: 각 트랙이 9개 혹은 11개 섹터
- 다음 영역: 세 트랙이 각각 14 혹은 15개 섹터
- 바깥쪽 두 영역 : 각 네 트랙씩, 각 트랙은 14 혹은 16개 섹터

1) MZR 방식 영역(zone) ※ 컴퓨터구조론, 생능출판사, 2019  277  
2) MZR 방식의 장단점 ⋅ 장점 ­ 디스크 전체 용량 증가 ⋅ 단점 ­ 트랙 위치에 따라 회전속도가 조정되어야 하므로 제어 회로가 더 복잡 ­ 영역에 따라 읽기 및 쓰기 시간에 미세한 차이 발생 ▶ 디스크 형식화 작업(disk formatting) ­ 디스크의 구성을 검사하고, 그에 관한 정보와 트랙의 시작점, 섹터의 시작과 끝을 구분하기 위한 제어 정보 등을 디스크상의 특정 위치에 저장하는 과정 ⋅ 예) 트랙 형식의 예
- 섹터 크기 = 600 바이트(512바이트 데이터 + 제어 정보)
- 제어 정보(ID 필드) : 섹터를 구분하는 데 필요한 식별자 또는 주소 : SYNCH 바이트, 트랙 번호, 헤드 번호, 섹터 번호, 오류 검출 코드(CRC) ▶ 트랙 형식의 예 섹터 1 섹터 2 바이트 수 바이트 수 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ CRC(Cyclic Redundancy Check) ­ 디스크로부터 데이터를 읽거나 데이터 통신 과정에서 발생하는 오류를 검출하기 위하여 순 환 2진 부호를 사용하는 방식 : 2진 나눗셈(XOR) ­ 송신 측에서 데이터를 블록 단위로 나누고, 각 블록 뒤에 2진 다항식의 특수 계산에 의해 얻어진 순환 부호를 여분으로 붙여서 저장 후 송신 ­ 수신 측에서도 동일한 계산을 수행하여 동일한 순환 부호가 얻어지는지를 확인함으로써 전 송 오류의 유무를 검사 ­ 패리티 비트를 이용하는 방법보다 정교하여 오류 검출 능력이 뛰어남 ­ 저장장치(하드 디스크, CD
-ROM, DVD) 및 각종 통신 프로토콜에서 사용 ▶ 디스크 드라이브(disk drive) ­ 디스크, 헤드가 부착된 디스크 팔, 구동장치, 디스크를 회전시키는 축(spindle), 데이터 전 송을 위한 전자 회로 등을 포함한 전체 패키지  278   ㆍ 디스크 면 수에 따른 분류 ­ 양면 디스크(double
- sided disk) ­ 단면 디스크(single
- sided disk) ㆍ 실린더(cylinder) ­ 다중 평판 디스크 드라이브에서 서로 다른 디스크 표면에 있지만 같은 반경에 위치하고 있어, 디스크 팔을 움직이지 않고도 동시에 액세스할 수 있는 트랙들의 집합 ▶ 단일
-평판 디스크 드라이브의 내부 구조 트랙 섹터 구동장치 회전축 디스크 팔 데이터 전송선 헤드 회전 구동장치 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 다중
-평판 디스크 드라이브의 내부 구조 헤드 표면 1 표면 2 구동장치 디스크 팔 표면 3 표면 4 데이터 전송선 표면 5 표면 6 표면 7 표면 8 회전 구동장치 ※ 컴퓨터구조론, 생능출판사, 2019 2. 디스크 액세스 시간  ▶ 디스크 액세스 시간 ㆍ 디스크 액세스(읽기 / 쓰기) 동작의 순서
① 헤드를 해당 트랙으로 이동
② 원하는 섹터가 헤드 아래로 회전되어 올 때까지 대기
③ 데이터를 전송

1) 디스크 액세스 시간(disk access time) ­ 디스크 액세스 시간 = 탐색 시간 + 회전 지연 시간 + 데이터 전송 시간  279   ㆍ 탐색 시간(seek time) ­
①번에 걸리는 시간 ㆍ 회전 지연 시간(rotational latency time) ­
②번에 걸리는 시간 ㆍ 데이터 전송 시간(data transfer time) ­
③번에 걸리는 시간 및 디스크 제어기(disk controller)에서 소요되는 시간 ㆍ 회전지연시간 ­ 디스크의 회전속도에 따라 결정 ⋅ 예) 회전축의 속도 = 7200 rpm(rotations per minute)인 경우,초당 120바퀴 회 전 → 한 바퀴 회전에는 1/120sec(8.33ms)
- 회전지연시간 = 0 ~ 8.33ms
- 평균 회전지연 = 4.17ms(1/2 바퀴 회전에 걸리는 시간) ㆍ 디스크 회전축 속도 ­ 5400 rpm, 7200 rpm 주로 사용 ⋅ 참고) 10000 rpm 이상의 구동장치 기술도 개발되었으나, 높은 발열량에 대한 냉각 의 어려움으로 사용 제한 ◼ 예제 6
-1 ­ 어떤 디스크의 평균 탐색 시간이 7ms, 전송률이 600[MByte/s]이고, 회전축의 속도가 5400rpm, 그리고 제어기의 지연시간은 0.1ms라고 가정한다. 섹터의 크기가 512바이 트인 경우에, 한 섹터를 읽거나 쓰는 데 걸리는 평균 액세스 시간(T )을 구하라. a ⋅ 풀이 ­ 평균 회전 지연시간 = {1/(5400/60)} × 0.5바퀴 ≒ 5.5ms T = 7ms + 5.5ms + (0.5KByte ÷ 600MByte/s) + 0.1ms ≒ 12.6ms a ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 최신 디스크들의 특성 및 성능 파라미터들 : HDD(IBM+Hitachi)

1) 디스크들의 특성 및 성능 파라미터들의 비교 Cinemastar Travelstar Ultrastar 파라미터 Z5K500 Z5K1 HC530 용량 500GBytes 1TBytes 14TBytes 회전 속도 5400rpm 5400rpm 7200rpm 회전지연(평균) 5.5ms 5.5ms 4.16ms 탐색 시간(평균) 15ms 11ms 7.5ms 저장 밀도 Gbitsin Gbitsin Gbitsin 데이터 전송률 600MBytes/s 600MBytes/s 600MBytes/s 디스크 크기 2.5〃 2.5〃 3.5〃 ※ 컴퓨터구조론, 생능출판사, 2019  280   ▶ 주기억장치
-보조기억장치 간 정보 전송 ­ 시스템 초기화(부팅) 과정에서 OS 프로그램을 주기억장치로 적재 ­ 응용 프로그램이 처음 수행될 때는 디스크로부터 주기억장치로 적재 ­ 새로이 생성되거나 수정된 데이터는 보조저장장치에 영구 저장 ­ 주기억장치 공간이 부족한 경우에는 적재되어 있는 블록을 보조저장장치로 내보내고 (swap
-out), 새로운 블록을 읽어와서 그 공간에 적재(swap
-in) ▶ SSD 출현 ­ 주기억장치와 보조저장장치 간의 속도 격차 증가 ⇨ 보조저장장치의 성능 향상 필요 ­ 기계장치가 포함된 디스크 드라이브의 성능 한계

1) SSD(Solid ­ State Drive) 출현 ­ 비휘발성 반도체 기억장치들을 이용한 대용량 보조저장장치(다수의 플래시 메모리들을 배열 로 구성한 패키지) ­ 속도 및 신뢰도 향상 : 임의 접근 ­ 디스크와는 다른 읽기/쓰기 특성을 가지기 때문에 별도 관리 필요 ­ 상대적 고가 및 낮은 내구성(데이터 갱신 횟수 제한) v 솔리드 스테이트 드라이브(solid
- state drive, SSD) 또는 솔리드 스테이트 디스크(solid state disk)는 반도체를 이용하여 정보를 저장하는 장치임 ⋅ 솔리드 스테이트 드라이브는 순수 전자식으로 작동하므로 기계식인 하드 디스크 드라이 브(HDD)의 문제인 긴 탐색 시간, 반응 시간, 기계적 지연, 실패율, 소음을 크게 줄여 줌 ⋅ 반면에 DRAM이 아닌 플래시 메모리가 적용된 SSD의 경우, 데이터 접근 시간이 아닌 연속적인 읽기와 쓰기에 대해 하드 디스크보다 속도가 낮은 경우가 대부분이었음 ⋅ 하지만 최신 기술이 적용된 SSD의 경우, 대부분 하드 디스크 드라이브 이상의 읽기와 쓰기 속도를 냄  281   RAID

1. 하드 디스크를 안전하게 사용하기 위한 RAID의 출현 배경에 대해서 학습하고 이를 설명할 수 있다. 12주차  수업목표  
2. RAID를 종류별로 학습하고 각 종류별 장단점에 대해서 설명할 2교시  수 있다.
1. 출현 배경 세부내용 
2. RAID 종류 1. 출현 배경 ▶ RAID(Redundant Array of Inexpensive Disks) ­ 한 개의 대형 디스크를 사용하는 것보다, 크기가 작은 여러 개의 디스크들을 서로 연결하여 하나의 큰 용량을 가진 디스크 배열(disk array)을 구성하면, 보다 더 저렴한 가격으로 더 큰 용량을 가진 디스크 서브시스템의 구성 가능 ㆍ 추가적인 장점 ­ 데이터 분산 저장에 의한 동시 액세스(concurrent access) 가능 ­ 병렬 데이터 채널에 의한 데이터 전송 속도 향상 ㆍ 문제점 ­ 고장 가능성 증가(MTTex) 단축) : Mean Time to ex)ailure v 복수 배열 독립 디스크(Redundant Array of Independent Disks 혹은 Redundant Array of Inexpensive Disks)는 여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술임 ⋅ 디스크 어레이(disk array)라고도 함 ⋅ 데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 레벨이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시 킬 수 있음(7 레벨 : 0 ­
6)
1) RAID의 특징 ­ 최초에 제안되었을 때는 다섯 가지의 레벨이 존재했는데, 이후에 중첩 레벨을 비롯한 여러 가지 다른 레벨들이 추가되었음 : 5에서 7개로 ­ RAID는 여러 개의 디스크를 하나로 묶어 하나의 논리적 디스크로 작동하게 하는데, 하드웨 어적인 방법과 소프트웨어적인 방법이 있음 ­ 하드웨어적인 방법은 운영 체제에 이 디스크가 하나의 디스크처럼 보이게 함 ­ 소프트웨어적인 방법은 주로 운영체제 안에서 구현되며, 사용자에게 디스크를 하나의 디스 크처럼 보이게 함 ▶ 디스크 인터리빙(disk interleaving) ­ 데이터 블록들을 여러 개의 디스크들로 이루어진 디스크 배열(disk array)에 분산 저장하는 기술  282   ­ 균등 분산 저장을 위하여 라운드
-로빈(round
-robin) 방식 사용 ㆍ 디스크 인터리빙을 이용한 분산 저장 디스크 1 디스크 2 디스크 3 디스크 4 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 디스크와 디스크 배열의 특성 비교 : RAID 전의 디스크 배열

1) 대형 디스크, 소형 디스크 및 디스크 배열의 특성 비교 모델 디스크 배열 IBM 3390 (10.5˝) IBM 0061 (3.5˝) 특성 (IBM 0061 70개) 용량 23GByte 320MByte 23GByte 크기 ft ft ft 전력 소모량 3KW 11W 1KW 데이터 전송률 15MB/sec 1.5MB/sec 120MB/sec I/O 처리률 600IOs/sec 55IOs/sec 3900IOs/sec 가격 $200,000 $2,000 $150,000 MTTex) 250000시간 50000시간 ? ※ 컴퓨터구조론, 생능출판사, 2019 * 위의 표는 RAID를 처음 제안한 U.C. Berkeley 대학의 연구팀이 제시한 것으로서, 그 당시 의 디스크들에 대한 규격 및 가격 등을 기준으로 작성되었음 ▶ 디스크 배열의 단점
1) 디스크 배열의 주요 단점 ­ MTTex)(Mean Time To ex)ailure)의 단축 ⋅ 예) MTTex) = 30000시간인 디스크 100개를 이용한 디스크 배열의 MTTex) = 30000/100 = 300 시간으로 단축 ▶ RAID 제안 ­ 디스크 배열의 결함 허용도(fault
-tolerance)를 높이기 위하여 RAID가 제안됨 ㆍ 핵심 기술 ­ 검사 디스크(check disk)들을 이용하여 오류 검출 및 복구(error detection and recovery) 기능 추가 ㆍ 디스크 결함 발생시의 복구 절차(아래의 모든 절차들이 시스템의 정상적 동작이 유지되고 있는 상태에서 진행)
① 해당 디스크 사용 중단 및 시스템으로부터 분리(디스크 용량 축소)
② 검사 디스크에 저장된 정보를 이용하여 원래의 데이터 복구  283  
③ 결함 수리 후 디스크 재설치
④ 시스템 재구성(원래의 디스크 용량 회복) 2. RAID 종류 ▶ RAID
-0

1) RAID
-0의 특징 ­ 2개 이상의 디스크를 사용하여 2개 이상의 볼륨을 구성한 구조로 여분(redundancy) 디스 크를 포함하지 않아서 오류 검출 기능은 없음 ­ 단순히 볼륨마다 디스크를 나열해 놓았기 때문에 스트라이핑(striping) 모드라고 하며, 높은 신뢰성을 요구하기 보다는 성능과 용량을 중요시하는 시스템에 사용 ­ 특정 데이터를 기록할 때는 볼륨의 수만큼 나누어서 각 볼륨 내의 같은 디스크와 같은 섹 터에 병렬로 분산 저장함 ­ 데이터 접근 요구들이 하나의 디스크에 집중되지 않고 분산되며, 검색과 데이터 전송이 병 렬로 이루어져 성능이 향상되고, 데이터의 읽기/쓰기 성능이 매우 향상됨 ­ 컴퓨터 시스템에서 초당 수천 개의 입출력 요구가 발생하는 경우 RAID 레벨 0은 여러 디 스크에 입출력 요구들을 균등하게 분배함으로써 높은 입출력 처리율을 제공할 수 있음 ­ 4개의 볼륨으로 구성되어 있고 각 볼륨은 4개의 디스크로 구성됨 ­ 각 디스크 스트립(strip)들은 각 볼륨에 순차적으로 배당되어 있어, 저장될 데이터가 라운드 로빈(round robin) 방식으로 분산 저장됨 볼륨 1 볼륨 2 볼륨 3 볼륨 4

2) RAID
-0의 단점 ­ 오류 검출 기능을 제공하지 않기 때문에 어떠한 오류도 복구하지 못함 ­ 데이터가 분할되어 있기 때문에 볼륨을 구성하는 디스크 하나만 고장이 나도 데이터를 복 구할 수 없음 ­ 빠른 속도가 필요한 시스템에서는 적절한 방법이나 데이터의 안정성이 요구는 시스템에서 는 바람직한 방법이 아님 ▶ RAID
-1 ㆍ 디스크 미러링(disk mirroring) 방식 이용 ­ 데이터 디스크에 저장된 모든 데이터들은 짝(pair)을 이루고 있는 미러 디스크의 같은 위치에 복사  284   데이터 디스크들 미러 디스크들 ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 장점 ­ 거의 완전한 결함 허용도(fault tolerance) 제공 ⋅ 단점 ­ 가격이 높음 ⋅ 주요 용도 ­ 높은 신뢰도를 요구하는 결함허용시스템에 주로 사용 ­ 시스템 소프트웨어 혹은 중요한 데이터 파일 저장에 사용 ▶ RAID
-2 ㆍ 비트 ­ 단위 인터리빙 방식 사용 ­ 데이터를 각 디스크에 비트 단위로 분산 저장 ­ 해밍 코드(Hamming code)를 이용한 오류 검출 및 정정 데이터 디스크들 검사 디스크들 ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 단점 ­ 필요한 검사 디스크들의 수가 많아서 가격이 비쌈 ⋅ 주요 용도 ­ 오류가 많이 발생하는 환경에서 사용 ㆍ 필요한 검사 디스크 수를 구하는 식 C ≥ G + C ­ 단, G : 데이터 디스크의 수 C : 필요한 검사 디스크들의 수 ⋅ 예) G = 8인 경우 : 검사 디스크 수(C) = 4, 오버헤드 = 50 % G = 16인 경우 : 검사디스크 수(C) = 5, 오버헤드 = 31 % ▶ RAID
-3 ㆍ 패리티 방식을 이용한 오류 검출 및 정정 방식 사용 ­ 패리티 비트 : p = b1 ⊕ b2 ⊕ b3 ⊕ b4 ㆍ 디스크에 결함이 발생한 경우의 데이터 복구 방법 ­ 예) b2가 저장된 디스크 결함 발생시 : b2 = p ⊕ b1 ⊕ b3 ⊕ b4  285   데이터 디스크들 패리티 디스크 ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 장점 ­ 병렬 데이터 읽기 / 쓰기 가능 → 디스크 액세스 속도 향상 ⋅ 단점 ­ 쓰기 동작 때마다 패리티 비트 갱신 필요 → 시간 지연 발생 ▶ RAID
-4 ­ 블록
- 단위 인터리빙 방식 사용 ­ 데이터 디스크들의 동일한 위치에 있는 블록들에 대한 패리티 블록을 패리티 디스크에 저 장 데이터 디스크들 패리티 디스크 ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 문제점 ­ 매 쓰기 동작을 위해 패리티 디스크를 두 번씩 액세스(총 4번) → 병목 현상 발생

1) 데이터 블록의 쓰기(갱신) 과정 ­ 두 번째 디스크에 저장된 블록 B2를 B2'로 갱신하는 경우 ­ 새로운 패리티 블록 P' = B1 ⊕ B2' ⊕ B3 ⊕ B4 ⋅ 세 번의 디스크 읽기(B1, B3 및 B4 읽기)와 두 번의 디스크 쓰기(새로운 데이터 및 패 리티 쓰기) 동작들이 필요 → 성능 저하 ⋅ 디스크 액세스 횟수의 최소화 방법 P' = B1 ⊕ B2' ⊕ B3 ⊕ B4 ⊕ (B2 ⊕ B2) = (B1 ⊕ B2 ⊕ B3 ⊕ B4) ⊕ B2 ⊕ B2’ = P ⊕ B2 ⊕ B2‘ ­ 즉, 디스크 수에 상관없이, 한 블록 갱신에 네 번의 디스크 액세스만 필요 ⋅ 원래 데이터 읽기, 원래 패리티 읽기, (새로운 패리티 계산), 새로운 데이터 쓰기, 새로 운 패리티 쓰기 ▶ RAID
-5 ­ RAID
- 4의 문제점을 보완하기 위하여 패리티 블록들을 라운드
- 로빈(round
- robin) 방 식으로 분산 저장 ⋅ 장점  286   ­ 패리티 디스크에 대한 병목 현상 해소 ­ 쓰기 동작들의 병렬 수행 가능 ⋅ 데이터 디스크들의 수가 G 개일 때, 최대 (G+1)/2 개의 쓰기 동작들의 병렬 수행 가능 ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 문제점 ­ 작은 쓰기 문제(small write problem) 존재 ⋅ 어느 한 블록만 갱신하는 '작은 쓰기(small write)'의 경우에 네 번의 디스크 액세스 가 필요하기 때문에 성능이 저하됨 ⋅ 비교 ­ 큰 쓰기(large write : 디스크 수보다 더 많은 블록들로 이루어진 파일을 한꺼번에 저장 혹은 갱신)의 경우에는 패리티 블록을 미리 계산하여, 새로운 데이터 및 패리티 블록을 한번씩만 쓰면 됨 ㆍ RAID
- 1과 RAID
- 5의 비교 ­ RAID
- 1 : 읽기와 작은 쓰기가 많은 환경에 적합 ­ RAID
- 5 : 용량과 비용을 중요시하는 응용이나 큰 쓰기 요구가 많은 환경에 적합 ­ 가격 대 성능비 측면에서 RAID
- 5가 더 우수 ▶ RAID
-6 ­ 신뢰성에 좀 더 기반을 둔 구성 임 ­ 레벨 5에서는 2개의 볼륨에서 동시에 오류가 발생할 경우 복구하기 힘들지만 레벨 6은 패 리티 정보를 하나 더 추가해서 동시에 오류가 발생해도 복구가 가능함 ­ 가로 방향과 세로 방향의 패리티 정보가 생성되고 각각 저장되어서, N개의 데이터 볼륨을 필요로 하는 경우 RAID 레벨 6은 N + 2개의 볼륨이 필요함 ㆍ RAID 레벨 6의 구조 ­ p와 q가 두 종류의 패리티 정보임 볼륨 1 볼륨 2 볼륨 3 볼륨 4 볼륨 5 볼륨 6 ⋅ 장점 ­ 아주 높은 데이터 신뢰성을 제공하는 장점이 있음 ⋅ 단점 ­ 쓰기 동작을 할 때 마다 두 개의 패리티를 갱신해야 하며, 두 종류의 패리티 정보를 저  287   장할 수 있는 추가적인 볼륨이 필요하다는 단점이 있음 ▶ RAID
-결합 ㆍ RAID 0 + 1 ­ 레이드 0 + 1은 먼저 디스크를 스트라이핑(RAID

0)하고, 디스크를 미러링(RAID
1) 함 (적어도 4개의 디스크) ­ 디스크가 6개일 경우는 3개씩 스트라이핑하고 미러링을 그 다음에 수행함 ㆍ RAID 10(RAID 1 +
0) ­ 레이드 10은 먼저 디스크를 미러링(RAID
1)하고, 그 이후 스트라이핑 함(적어도 4개의 디스크) ­ 디스크가 6개일 경우는 2개씩 미러링을 하고, 미러링된 3개를 스트라이핑 함 ㆍ RAID 50(RAID 5 +
0) ­ 패리티가 배분되는(distributed) 스트라이핑된 세트를 다시 스트리핑(RAID
0) 함(적어도 6개의 디스크) ㆍ RAID 1E ­ 미러링과 데이터 스트라이핑의 결합(적어도 3 개의 디스크) ▶ 플래시 메모리의 출현 ­ 부동 게이트로 들어가는 전자들의 수를 조정하여 각 셀에 저장되는 상태의 수를 증가 ㆍ SLC(single ­ level cell) ­ 두 가지 상태를 가짐으로써 한 비트를 저장하는 셀 ㆍ MLC(multi ­ level cell) ­ 셀의 상태를 4가지(00,01,10,11)로 구분 → 메모리 셀 당 2비트씩 저장 v 플래시 메모리의 출현 : SLC(1비트) vs. MLC(2비트) (a) SLC (b) MLC ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ TLC(triple ­ level cell) ­ 셀의 상태를 8가지(000, 001, 010, 011, 100, 101,110,111)로 구분 → 셀 당 3비트 씩 저장
1) MLC 및 TLC의 문제점 ­ 전자 수 조정을 위한 세밀한 작업 필요 ­ 데이터 구분의 어려움으로 인한 액세스 속도 저하 ­ 오류 발생 빈도 증가 ­ 수명 단축  288  
2) SLC, MLC 및 TLC의 특성 비교 특성 / 종류 SLC MLC TLC 셀 당 비트 수 1 2 3 읽기 시간 25㎲ 50㎲ 75㎲ 쓰기 시간 200 ~ 300㎲ 600 ~ 900㎲ 900 ~ 1,300㎲ 삭제 시간 1.5ms 3ms 4.5ms 재기록 가능 횟수 100,000 3,000 ~ 10,000 1,000 ※ 컴퓨터구조론, 생능출판사, 2019
3) 3D V
- NAND 플래시 제조 공정 ⋅ 1단계 ­ P
- well 부분을 원통형으로 제조 ­ 부동 게이트를 p
- well 원통 주위를 둘러싸도록 제조 ­ 제어 게이트도 부동 게이트 주위를 둘러싸도록 제조 → 3차원 구조(3D)의 셀 구성(그림 (b)) ⋅ 2단계 ­ 셀들을 수직 적층 구조로 쌓아 올림(그림 (c)) ­ 다수의 실리콘 다이(die)들을 부착시키고, 많은 수의 미세 크기 홀(hole)들을 뚫고, 셀들 을 수직 방향으로 적층(그림 (d)) ▶ 플래시 메모리의 출현 : p
-well, 부동 게이트, 제어 게이트

1) 3D V ­ NAND 플래시 메모리의 내부 구조 (a) 2차원 셀의 구조 (b) 3차원 셀의 구조 (c) 수직 24적층 구조 (d) 3D V
-NAND 플래시 구조 ※ 컴퓨터구조론, 생능출판사, 2019

2) 3D V ­ NAND 플래시의 동향 ­ 수 억 개의 홀(hole)을 뚫고 각 층마다 전극을 연결하는 에칭(etching) 기술 및 수직 셀을 만드는 게이트 패턴(gate pattern) 기술과 같은 첨단 반도체 공정기술 필요 ­ 32단, 64단, 96단의 초정밀 적층 기술 개발로 용량이 계속 증가 중  289  
3) 3D V ­ NAND 플래시의 특징 ­ 부동 게이트 공간의 확장으로, 많은 수의 전자 주입 가능 ⇨ 전자 수를 기준으로 데이터 구분이 용이해져 오류 감소 ­ 부동 게이트 내의 전자 수를 16등급으로 구분하여 4
-비트 데이터를 저장하는 QLC(quadruple
- level cell) 제조 가능 ⇨ 테라 비트(tera bit)급의 칩 출현 ▶ 플래시 메모리 v 플래시 메모리(flash memory)는 전기적으로 데이터를 지우고 다시 기록할 수 있는 비휘 발성 컴퓨터 기억 장치를 말함 ⋅ EEPROM과 다르게 여러 구역으로 구성된 블록 안에서 지우고 쓸 수 있음 ⋅ 이제는 플래시 메모리의 가격이 EEPROM 보다 훨씬 싸기 때문에, 비휘발성 고체 상태 (solid
-state) 저장 매체가 상당량 필요한 곳에서는 가장 많이 사용되는 메모리 종류가 되었음 ⋅ 대표적인 활용 예로 디지털 음악 재생기(MP3), 디지털 카메라, 휴대 전화를 들 수 있 음 ⋅ 일반적인 데이터를 저장하고 컴퓨터 사이에 데이터를 옮기는 용도로 USB 드라이브를 많이 사용하는데, 이때도 플래시 메모리가 쓰임 ⋅ 또한 게임 자료를 저장하기 위해 EEPROM 대신 플래시 메모리가 자주 사용되고 있어 게임 시장에서도 인기를 얻고 있음 : 동영상

1) 플래시 메모리의 특징 ­ 플래시 메모리는 메모리 칩 안에 정보를 유지시키는 데에 전력이 필요 없는 비휘발성 메모 리임 ­ 게다가 플래시 메모리는 읽기 속도가 빠르며(단, 개인용 컴퓨터에서 메인메모리로 쓰이는 DRAM만큼 빠르지는 않고, 순차읽기속도는 하드디스크가 더 빠를 수 있음) 하드 디스크 보다 충격에 강함 ­ 이러한 특징으로 배터리로 동작하는 장치에서 저장 장치로 많이 사용함 ­ 플래시 메모리의 또 다른 장점은 강한 압력이나 끓는 물에도 견딜 만큼, 물리적인 힘으로 거의 파괴되지 않는다는 점임  290   플래시 메모리와 SSD
1. 현재 많이 사용하고 있는 플래시 메모리에 대해서 학습하고 이를 설명할 수 있다. 12주차  수업목표  
2. 하드 디스크의 대안으로 현재 많이 사용되는 SSD에 대해서 3교시  학습하고 이를 설명할 수 있다.
1. 플래시 메모리 세부내용 
2. SSD 1. 플래시 메모리 ▶ 플래시 메모리 ­ 플래시 메모리의 출현 → 비휘발성 반도체 기억장치 분야 활성화 계기 ⋅ 높은 저장 밀도 : 한 비트 저장에 한 개의 트랜지스터 사용 [비교] EEPROM : 비트 당 두 개의 트랜지스터 사용 ⋅ 낮은 전력소모량, 높은 신뢰성, 속도 향상
1) 동작 원리 ­ 메모리 셀(기억 소자) 구현 : NMOS 트랜지스터 사용 ­ 구조적 특징 : 두 개의 게이트(일반 NMOS는 한 개) ㆍ 제어 게이트(control gate) : 일반 트랜지스터의 게이트와 동일 ㆍ 부동 게이트(floating gate) : 정보 저장의 핵심적 역할 수행 ▶ 동작 원리 : p
-well, 부동 게이트, 제어 게이트

1) 메모리 셀의 기호 및 내부 구조  드레인  GND   게이트 소스 (a) 기호 (b) 내부 구조 ※ 컴퓨터구조론, 생능출판사, 2019 ㆍ 부동 게이트 ­ 절연체인 산화막(SiO2)으로 둘러싸여 전자들이 쉽게 들어오거나 나가지 못하며, 초기에 는 비어있는(empty) 상태 = (‘1’ 저장 상태) ▶ 동작 원리
1) 프로그래밍(쓰기) 동작 ­ 제어 게이트로 고전압(예 : +12V) 인가 시, 강력한 전기장 발생으로 N
-채널의 전자들이 부  291   동 게이트로 진입(터널링 효과로 인한 터널 주입 발생) → ‘0’ 쓰기 ⋅ ‘0’ 저장 : Vg = +12V 인가 ⋅ ‘1’ 저장 : Vg = 0

2) 삭제(erase) 동작 ­ p층(p
-well)에 고전압(Vp) 인가 시, 부동 게이트에 갇힌 전자들이 N
-채널로 빠져 나옴(터 널 릴리스 현상) ⋅ 셀에 저장된 값 → 원래 값(‘1’)으로 변경

3) 읽기 동작 ­ 드레인 전압(Vd : 5V) 인가 → N
-채널을 통하여 전자 흐름 발생 ­ 게이트 전압(Vg : 5V) 인가 → 전기장 발생 ­ 저장된 데이터 = ‘1’ (부동 게이트가 빈 상태) 경우 → N
-채널 확장(그림 (a)) → 많은 전류가 흘러 트랜지스터가 ‘ON’ 상태 : ‘1’ 읽음 ­ 저장된 데이터 = ‘0’ (부동 게이트가 채워진 상태) 경우 → N
-채널 유지(그림 (b)) → 매우 적은 전류가 흘러 트랜지스터는 ‘Oex)ex)’ 상태 : ‘0’ 읽음 ▶ 메모리 셀의 읽기 동작 원리 : Vd, Vg 5V 인가 – N
-채널 확장/유지 전기장 GND   (a) 부동 게이트가 비어 있는 상태(‘1’이 저장된 상태) 전기장 GND   (b) 부동 게이트가 채워진 상태(‘0’이 저장된 상태) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 플래시 메모리의 셀 배열 조직 ㆍ NOR형 플래시 메모리 ­ 메모리 셀 배열(memory cell array)이 NMOS 트랜지스터들의 병렬 접속으로 구성(그림 (a)) : 전원(Vcc)이 비트 라인(BL)을 통하여 모든 트랜지스터들의 드레인으로 직접 공급  292   되며, 트랜지스터들의 소스는 접지(GND)로 접속 ⇨ 각 트랜지스터의 독립적 스위칭 동작 가능(셀 단위 액세스 가능) ㆍ NAND형 플래시 메모리 ­ 메모리 셀 배열이 NMOS 트랜지스터들의 직렬 접속으로 구성(그림 (b)) : 전원(Vcc)이 첫 번째 트랜지스터의 드레인으로만 접속되고, 소스가 다음 트랜지스터의 드레인으로 접 속되며, 마지막 트랜지스터의 소스만 접지 ⇨ 트랜지스터의 독립적 스위칭 동작 불가능(셀 단위 액세스 불가능) ▶ NOR형 플래시 메모리의 읽기 동작 원리 ­ 셀 배열의 트랜지스터(TR)에 ‘0’이 저장 된 상태에서 해당 단어 선(WL)으로 Vg = +5V 인 가 : (TR : Oex)ex)) → BL(비트 선) = +5V 유지 ­ 셀 배열의 어느 TR(들)에든 ‘1’이 저장 된 상태에서 Vg = +5V 인가 : (TR : ON) → BL = 0V → “NOR 연산” ­ (BL = 0V) → 감지 증폭기(sensor amp)의 스위칭 동작에 의해, 최종 출력 = ‘1’, [(BL = +5V) → ‘0’ 출력] ­ 셀(비트) 단위 읽기 가능 ▶ NOR형 플래시 메모리의 읽기 동작 원리 : 병렬 – 셀 단위 BL WL WL 메모리 셀 WL WL n WL n GND 감지 증폭기 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ NAND형 플래시 메모리의 읽기 동작 원리 ­ ‘1’ 저장 상태에서, (TR : ON)을 위한 문턱 전압(threshold voltage : Vth) =
-3V ­ ‘0’ 저장 상태에서는 Vth = +1V ­ 초기 상태 : 모든 WL(Vg) = +5V(TR = ON) ­ 어느 한 셀의 읽기 : 해당 Vg = 0V 인가 ⋅ ‘1’이 저장된 상태라면, Vg
> Vth : (TR = ON) → BL = 0V [‘1’] ⋅ ‘0’이 저장된 상태라면, Vg < Vth : (TR = Oex)ex)) → BL = +5V [‘0’] → “NAND 연산”  293   ⋅ [최종 출력]은 센서증폭기에 의해 반전 ▶ NAND형 플래시 메모리의 읽기 동작 원리 : 직렬 – 셀 단위 불가 BL WL WL WL WL n WL n GND 감지 증폭기 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ NOR형 및 NAND형 플래시의 비교 ㆍ NOR형 ­ 셀(비트) 단위 읽기 / 쓰기 가능 : 프로그램 코드 저장, 작은 데이터 수시 인출 및 변경 응용에 적합 ­ 셀 당 접속 선의 수 = 3개 → 낮은 저장 밀도(칩 당 저장용량 감소) ­ 주요 용도 : PC
- BIOS 저장장치, PDA / 스마트폰 OS 저장장치 등 ㆍ NAND형 ­ 셀(비트) 단위 읽기 / 쓰기 불가능(페이지 단위만 가능) ­ 셀 당 접속 선의 수 = (2개) → 높은 저장 밀도 : 대용량 저장장치로 적합 ­ 주요 용도 : 백업 저장장치, SSD 등 ▶ NAND형 플래시 메모리의 내부 조직 및 특성 ­ 블록(block)들로 구성되며, 각 블록은 다수의 페이지(page)들로 구성 ⋅ 페이지 크기 : 2Kbyte, 4Kbyte, 16Kbyte, 64Kbyte 등 ⋅ [비교] 디스크 : 읽기 / 쓰기 / 전송의 기본 단위인 섹터 = 0.5Kbyte ­ 읽기, 쓰기 및 전송 : 페이지 단위 ­ 삭제 : 블록 단위 ▶ 내부 조직 ⋅ 예) 1Gbit 플래시 메모리의 내부 조직
- 페이지 : x 방향으로 2048개의 셀들로 구성되고, z 방향으로 8개씩의 셀로 이루 어짐 → 16 Kbits(2 Kbyte)  294  
- 블록 : 64개의 페이지들로 구성 → 1 Mbit(128 Kbyte)
- 메모리 모듈 : 1024개의 블록들이 y 방향으로 쌓여 이루어짐 → 전체 용량 = 1 Gbit(128 Mbyte) ▶ 1Gbit NAND 플래시 메모리의 내부 조직 : 페이지, 블록, 모듈 BL BL BL BL 8비트 페이지 선택 1024 해독기 블록 페이지 레지스터 2048개 배열 (2KByte) ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 읽기 동작 ­ 페이지 선택 해독기(page select decoder)의 64개 출력들 중 활성화된 한 출력이 2048개 셀들의 게이트로 인가(페이지 선택) ­ z 방향의 8개 배열들에 대하여 동시에 수행(byte 단위) ­ 해당 페이지의 모든 데이터(2048 x 8비트)가 인출되어 페이지 레지스터(page register)로 적재된 후, 버스를 통하여 CPU로 전송 ­ 페이지 단위로 읽기 수행 → 바이트 단위 동작이 가능한 NOR형에 비해 읽기 시간이 더 길 어짐 ▶ 칩의 용량과 내부 조직 유형 ㆍ 칩의 용량 ­ {(2048 x 8비트) x 64페이지} x 1024블록 = 1Gbit = 128Mbyte ­ 오류 검출 및 정정을 위한 ECC(error correction code) 추가 시, 페이지 당 64byte ECC 정보가 데이터와 함께 저장됨 → 페이지 당 (2K+64)byte, 블록 당 (128K+4K)byte 저장 ㆍ 내부 조직 유형 ­ 블록 당 페이지 수 : 32개, 64개, 128개 등 ­ 페이지 크기 : 2Kbyte, 4Kbyte, 16Kbyte, 64Kbyte 등 ­ 액세스 및 전송의 기본 단위인 페이지의 크기가 일정하지 않고, 하드 디스크의 섹터 크 기와 다르며, 삭제는 블록 단위로만 가능  295   2. SSD ▶ SSD(Solid–State Drive) v SSD(Solid ­ state Drive)는 기계적 장치가 포함된 하드 디스크 드라이브(HDD)를 대체하 기 위해 개발된 대용량 비휘발성 반도체 저장장치임 ⋅ 구성요소 : 저장밀도가 높은 NAND형 플래시 메모리 ⋅ 다수의 플래시 메모리들을 배열로 구성하여 패키징 ⋅ 장점 ­ 높은 안정성 및 신뢰도 ⋅ 결점 ­ 저장용량 대비 가격이 HDD에 비해 다소 높음 ▶ SSD의 내부 조직 ㆍ 플래시 메모리 칩 ­ PCB 앞면과 뒷면에 각각 4개의 64층 QLC 플래시 장착 ­ 인터리빙 방식으로 데이터 분산 저장, 병렬 입출력 채널 구성 → 동시 액세스 및 병렬 데이터 전송 지원 ㆍ SSD 제어기(controller) ­ 데이터 저장과 인출, 칩 관리, 주소 변환 등과 같은 핵심적 기능 수행 ­ 펌웨어 수준의 프로그램을 수행하는 프로세서로 구현 ㆍ DRAM ­ 컴퓨터와 플래시 메모리 사이의 데이터 버퍼 ㆍ 외부 인터페이스 ­ SATA, PCIe 등을 이용한 직렬 전송 ▶ 사례 : Intel SSD 660p : 플래시, 제어기, DRAM, 인터페이스 DRAM(캐시) 3D NAND 플래시 칩 SSD 제어기 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ ex)TL(ex)lash Translation Layer) ­ 기존의 파일시스템과 OS로 하여금 SSD를 HDD와 같은 방법으로 사용할 수 있도록 지원해 주는 미들웨어(middleware) : 호환성 ­ SSD 제어기가 수행  296   호스트 컴퓨터 섹터 읽기 섹터 쓰기 페이지 읽기 블록 삭제 페이지 쓰기 SSD ※ 컴퓨터구조론, 생능출판사, 2019 ­ ex)TL은 페이지 주소와 섹터 주소 간의 매핑(mapping) 기능 외에도, SSD의 성능 향상을 위 하여 아래의 기능들을 수행 ⋅ 마모 평준화(wear leveling) ⋅ 쓰레기 수집(garbage collection) ⋅ 초과 대비 공간(over ­ provisioning ; 오버 ­ 프로비저닝) ▶ 마모 평준화(wear leveling) ㆍ 필요성 ­ 플래시 메모리의 셀 수명(재기록 반복횟수 : program / erase cycle)한계 ­ MLC 및 TLC에서 그 문제는 더욱 심각 ­ 삭제 및 쓰기 동작들이 일부 블록이나 페이지들에 집중될 경우, 전체 SSD 수명 단축 ㆍ 해결책 : 마모 평준화 ­ 모든 페이지들이 고르게 사용되도록 저장 위치 조정 ­ 각 페이지의 사용 횟수를 기록하여 쓰기 동작 시 참고 ­ 기록 횟수가 적은 페이지 우선 사용 ▶ 쓰레기 수집(garbage collection) ㆍ 필요성 ­ 삭제 동작이 블록 단위로만 가능 ­ 페이지 수정 시, 마모 평준화 정책에 따라 다른 위치에 새로운 내용을 쓰고, 원래 페이 지는 삭제 필요(페이지 단위는 삭제 불가) ㆍ 해결책 ­ 페이지 내용은 수정되었지만 삭제하지 못한 원래 페이지는 쓰레기(garbage)로 표시 ­ 쓰레기로 표시된 페이지가 많이 축적된 블록을 한꺼번에 삭제 : 쓰레기 수집(삭제 전에 유효 페이지는 다른 블록으로 미리 이동) ▶ 쓰레기 수집의 예 ⋅ 예) a. 페이지 A, B, C, D가 블록 X에 저장된 상태 b. 새로운 페이지 E, ex), G, H 저장하고, 기존 페이지들은 A′, B′, C′, D′로 수정하려  297   함 → 덧쓰기(overwrite)가 되지않으므로, 다른 위치에 저장 → 기존 페이지들은 무효 상태 : 쓰레기(garbage) c. 블록 X에 있는 유효 페이지(E, ex), G, H, A’, B’, C’, D’)들을 다른 블록 Y로 이동(복 사) 후, 블록 X 전체를 삭제 = 쓰레기 수집 과정 ▶ 쓰레기 수집의 예 : 이동(복사)

1) 쓰레기 수집 과정의 예 : A, B, C, D ※ 컴퓨터구조론, 생능출판사, 2019 ▶ TRIM 명령
1) TRIM명령이란? ­ OS가 수행하는 명령으로서, SSD의 무효 페이지들을 SSD 제어기에게 통보해줌으로써 쓰레 기 수집의 효율을 높여 SSD의 성능을 향상시켜주는 보조 기능 ­ 삭제 횟수를 최소화시켜주는 효과도 있음 ▶ 초과 대비 공간(over
-provisioning) ㆍ 필요성 ­ 마모 평준화의 효율을 높이기 위해서는(수정된 페이지와 쓰레기 페이지의 일시적 중복 저장을 위한) 추가적 저장 공간 필요 ㆍ 해결책 ­ SSD 내부에 여분의 저장 공간 제공 ㆍ 사례 ­ Intel DC 3500 SSD : 120 GByte + 8 GByte(초과 대비공간) ­ 삼성전자 840 계열의 MZ
-7TD250B SSD : 250 GByte + 6 GByte(초과 대비공간) ▶ 장점

1) SSD의 장점 ­ 임의 접근을 하기 때문에 탐색 시간이 없어 보다 빠르게 데이터를 주고 받을 수 있음 ­ 물리적인 이동이 없기 때문에 전력을 절약할 수 있으며, 소음이 없고, 발열도 낮음 ­ 물리적으로 움직이는 부분이 없어 기계적으로 접근이 실패할 가능성이 없기 때문에 높은 기계적 신뢰성이 보장됨  298   ­ 충격, 기압, 진동, 온도 변화에 강함 ­ 하드 디스크 드라이브보다 무게가 더 가벼움 ­ 크기적인 제약이 없으며, 하드 디스크와는 달리 저장장치를 구성하는 물리적인 구성요소가 단순하고, 필요에 따라 늘이고 줄이는 것이 비교적 간단하여 매우 작은 크기로 만드는 것이 가능함 ­ 전송속도의 증가가 비교적 쉬우며, HDD의 경우 데이터 전송 속도를 향상시키기 위해서는 플래터(평판)에서 물리적으로 서로 다른 위치에 있는 데이터까지 바늘이 빠르게 움직여야 하기 때문에 기계적인 장벽이 문제가 됨(물리적 구조) ­ 반면, SSD의 경우 데이터 전송 속도는 이와 같은 기계적인 장벽에서 자유롭기 때문에 논리 적인 구조에 따라 전송 속도를 비교적 쉽게 증가시킬 수 있음 ▶ 단점
1) SSD의 단점 ­ 예전에는 플래시 메모리의 단위 용량 당 가격이 하드 디스크 드라이브보다 7배 비쌌으나 지금은 그렇게 비싸지 않은 편이고, 수요가 계속적으로 증가하는 추세임 ­ 데이터를 기록하는 행위 자체가 기록 소자의 파손을 유발하므로, 하드 디스크 드라이브보다 수명이 짧음 ­ Wear leveling(균등 분배) 기술로 수명의 연장이 가능함(그러나 현실적으로는 기록 소자가 파손되기 전에 장치의 수명이 끝날 확률이 더 높음)(마모 평준화) ­ 다른 요인 때문에 데이터 손상이 있을 수 있는데, 예를 들면(특히 DRAM 기반의 솔리드 스테이트 드라이브에서) 뜻밖의 정전으로 데이터 손실이 발생할 수 있으며, 일반 하드 디스 크 드라이브에 비해 정전기에 약함 ­ 하드 디스크 드라이브처럼 바로 덮어쓰기를 할 수 없고 블록단위 삭제를 한 후 쓰기를 수 행하는데, 때문에 임의 쓰기(Random Write)에는 약한 면이 있으며 읽기와 쓰기 성능이 비 대칭적임 ­ 제조회사마다 고유의 ex)TL을 이용하여 이를 해결하고 있음(플래시 변환 계층) ­ 휴대용 컴퓨터에 솔리드 스테이트 드라이브를 장착하여 배터리 지속시간을 측정할 경우 하 드 디스크 드라이브를 장착한 휴대용 컴퓨터의 배터리 지속시간이 훨씬 길 수도 있는데, 그 이유는 풀 로드의 경우가 아닌 유휴상태에서 솔리드 스테이트 드라이브보다 하드 디스크 드라이브의 전력 소모량이 적기 때문임 ­ 즉 하드 디스크의 경우 사용하지 않을 때 전력 소모량을 0으로 만들 수 있으나, 솔리드 스 테이트 드라이브는 그것이 거의 불가능함 ­ 일부 솔리드 스테이트 드라이브는 내장된 컨트롤러 칩셋의 한계로 인해 사용 중 데이터 교 환이 일시적으로 수 초간 멈추는 현상(프리징)이 간혹 발생할 수 있음 ­ 이와 같은 프리징은 주로 데이터 입출력을 담당하는 칩 셋의 성능 부족이 원인이나 그 이 외에도 다양한 원인이 있을 수 있음  299   시스템 버스
1. 컴퓨터 내부에서 정보를 전달하기 위한 시스템 버스 및 그 조직에 대해서 학습하고 이를 설명할 수 있다. 13주차  수업목표  
2. 정보를 동시에 전달할 때 충돌을 방지하기 위한 버스 중재에 1교시  대해서 이해하고 이를 설명할 수 있다.
1. 시스템 버스 조직 세부내용 
2. 버스 중재 1. 시스템 버스 조직 ▶ 시스템 버스(system bus) ㆍ 시스템 버스 ­ 컴퓨터시스템의 구성 요소들(CPU, 기억장치, I/O 장치들)을 상호 연결해주는 중심 통로 ㆍ 시스템 버스를 이용한 컴퓨터시스템의 구성도 인터럽트 요구선 시스템 버스 ※ 컴퓨터구조론, 생능출판사, 2019 v 버스(bus)는 컴퓨터 안의 부품들 간에, 또는 컴퓨터 간에 데이터를 전송하는 통신 시스템 임 ⋅ 이러한 표현에는 관련된 모든 하드웨어 부품들(선, 광 파이버 등) 및 통신 프로토콜을 포함한 소프트웨어를 아우름(HW+SW) ⋅ 초기의 컴퓨터 버스들은 여러 연결들을 갖춘 병렬의 전기적 선들이었으나, 현재 이 용 어는 병렬 전기적 버스와 동일한 논리적 기능을 제공하는 물리적인 배치에 사용됨 ⋅ 현대의 컴퓨터 버스들은 병렬 및 비트 시리얼 연결(직렬)을 둘 다 지원하며, 이들 모두 멀티드롭(전기적 병렬) 또는 데이지 체인 토폴로지로 선을 구성하거나 USB처럼 스위치 허브에 의해 연결할 수도 있음 ▶ 시스템 버스의 조직 ㆍ 버스(bus) ­ 구성 요소들 간에 교환할 각종 정보들을 전송하는 선(line) 들로 구성 ㆍ 버스 선의 수 ­ 한 번에 전송하는 데이터 비트들의 수(데이터), 기억장치 주소 비트들의 수(주소) 및 제  300   어 신호들의 수(제어)에 따라 결정됨 ­ 소형 컴퓨터 : 50 ∼ 100 개의 신호선들 사용 ­ 중대형급 시스템 : 100 개 이상의 신호선들 사용 ▶ 기능에 따른 버스의 종류 ㆍ 데이터 버스(data bus) ­ 시스템 요소들 사이에 데이터(명령어)를 전송하는 데 사용되는 선들의 집합 : 명령어 버 스는 없음 ­ 양방향 전송(bidirectional transfer) ­ 버스 폭(선들의 수) = CPU와 기억장치 사이에 한 번에 전송되는 비트 수(워드) ㆍ 제어 버스(control bus) ­ CPU와 기억장치 및 I/O 장치 사이에 제어 신호들을 전송하는 선들의 집합(인터럽트, 버 스, 양방향) ㆍ 주소 버스(address bus) ­ CPU가 기억장치로(또는 기억장치로부터) 데이터 쓰기(또는 읽기) 동작을 할 때, 해당 기 억 장소를 지정하는 주소를 전송하기 위한 선들의 집합 ­ 단방향 전송(unidirectional transfer) : CPU → 기억장치 및 I/O 제어기 ­ 주소 버스의 비트 수에 의해 시스템에 접속될 수 있는 전체 기억장치 용량이 결정됨 ­ 직접 주소 지정할 수 있는 기억 장소의 단위 : 바이트(byte) 혹은 단어(word) ▶ 주소 버스의 폭(비트수)에 따른 기억장치 용량 예 ㆍ 주소 버스 = 16비트인 경우 ­ 주소지정 가능한 최대 기억장소들의 수 =  = 65,536(64K) 개 ­ 바이트 단위 주소지정일 경우 최대 기억장치 용량 = 64 Kbyte = 64x1 Kbyte ­ 32­비트 단어 단위 주소지정일 경우, 최대 기억장치 용량 = 256 Kbyte = 64x4 Kbyte ㆍ 주소 버스 = 30비트인 경우 ­ 최대  = 1G(≈10억) 개 ­ 바이트 단위 주소지정일 경우 최대 기억장치 용량 = 1 Gbyte = 1x1 Gbyte ­ 32
-비트 단어 단위 주소지정일 경우, 최대 기억장치 용량 = 4 Gbyte = 1x4 Gbyte ▶ 제어 버스

1) 기억장치 및 I/O 장치와의 데이터 교환을 위한 제어 신호들 ㆍ 기억장치 쓰기(memory write) 신호 ­ 버스에 실린 데이터를 주소가 지정하는 기억 장소에 저장되도록 하는 제어 신호 ㆍ 기억장치 읽기(memory read) 신호 ­ 주소가 지정하는 기억 장소의 내용을 읽어서 버스에 실리게 하는 제어 신호 ㆍ I/O 쓰기(I/O write) 신호 ­ 버스에 실린 데이터를 지정된 I/O 장치로 출력되게 하는 제어 신호  301   ㆍ I/O 읽기(I/O read) 신호 ­ 지정된 I/O 장치로부터 데이터를 읽어서 데이터 버스에 실리게 하는 제어 신호 ­ 버스 중재를 위한 제어신호들(bus request/grant)(이 신호들의 집합을 중재 버스라고도 부 름) ­ 인터럽트 메커니즘을 위한 제어신호들(interrupt request/acknowledge)(이 신호들의 집합 을 인터럽트 버스라고도 부름) ▶ 중재 버스(arbitration bus) ㆍ 버스 마스터(bus master) ­ 시스템 버스에 접속되는 요소들 중에서 버스 사용의 주체가 되는 요소들 ⋅ 예) CPU, 기억장치 모듈, I/O 제어기(I/O 모듈) 등 ㆍ 버스 중재(bus arbitration) ­ 시스템 버스에 접속된 두 개 또는 그 이상의 버스 마스터들이 동시에 버스를 사용하고자 할 때 순서대로 한 개의 마스터씩 버스를 사용할 수 있게 해주는 동작 ㆍ 중재 버스 ­ 버스 중재를 위한 신호 선들의 집합 ⋅ 버스 요구(bus request) 신호 : 버스 마스터가 버스 사용을 요구했음을 알리는 신호 ⋅ 버스 승인(bus grant) 신호 : 버스 사용을 요구한 마스터에게 사용을 허가하는 신호 ⋅ 버스 사용 중(bus busy) 신호 : 현재 버스가 사용되고 있는 중임을 나타내는 신호 ▶ 인터럽트 버스(interrupt bus)
1) 인터럽트 메커니즘을 위한 제어 신호선들의 집합 ㆍ 인터럽트 요구(interrupt request) 신호 ­ I/O 장치가 인터럽트를 요구했음을 알리는 신호 ㆍ 인터럽트 확인(interrupt acknowledge) 신호 ­ CPU가 인터럽트 요구를 인식했음을 알리는 신호
2) 그 이외의 제어 신호들 ㆍ 버스 클록(bus clock) 신호 ­ 동기식 버스에서 버스 동작들의 시작 시간을 일치시키기 위하여 제공되는 공통 클록 신 호 ㆍ 리셋(reset) 신호 ­ 모든 시스템 요소들의 동작을 초기화시키는 신호 ▶ 버스 대역폭(bus bandwidth)
1) 버스 대역폭이란? ­ 버스의 속도를 나타내는 척도로서, 단위 시간당 전송할 수 있는 데이터 양을 나타내며, 버 스 클록의 주기에 의해 결정 ⋅ 예) 버스 클록의 주기 : 50ns(클럭 주파수 : 20MHz) 데이터 버스의 폭 : 64비트(8바이트)  302   ⇨ 버스 대역폭 : 8byte / (50 × 10
-9 sec) = 160[Mbytes / sec](즉, 이 버스를 통하여 초당 1억 6천 바이트의 데이터 전송 가능) 2. 버스 중재 ▶ 버스 중재(bus arbitration) ㆍ 버스 경합(bus contention) ­ 한 개의 시스템 버스에 접속된 여러 개의 버스 마스터들이 동시에 버스 사용을 요구하는 현상 ㆍ 버스 중재(bus arbitration) ­ 버스 경합이 발생하는 경우, 어떤 기준에 따라 버스 마스터들 중에서 한 개씩만 선택하 여 순서대로 버스를 사용할 수 있게 해주는 동작 ㆍ 버스 중재기(bus arbiter) ­ 버스를 중재하는 하드웨어 모듈 ▶ 버스 중재 방식의 분류

1) 제어 신호들의 연결 구조에 따른 중재 방식의 분류 ㆍ 병렬 중재 방식(parallel arbitration scheme) ­ 각 버스 마스터들이 독립적인 버스 요구 신호를 발생하고, 별도의 버스 승인 신호를 받 음(병렬로 접속) → 버스 마스터들의 수와 같은 개수의 버스 요구 선 및 승인 신호 선 필요 ㆍ 직렬 중재 방식(serial arbitration scheme) ­ 버스 요구와 승인 신호 선이 각각 한 개씩만 존재하며, 각 신호 선을 버스 마스터들 간 에 직렬로 접속하는 방식
2) 버스 중재기의 위치에 따른 분류 ㆍ 중앙집중식 중재 방식(centralized arbitration scheme) ­ 시스템 내에 버스 중재기가 한 개만 존재하는 방식(1개) ­ 버스 마스터들이 발생하는 버스 요구 신호들은 하나의 중재기로 보내지고, 중재기는 정 해진 중재 원칙에 따라 선택한 버스 마스터에게 승인 신호를 발생 ㆍ 분산식 중재 방식(decentralized arbitration scheme) ­ 여러 개의 버스 중재기들이 존재하며(일반적으로 각 버스 마스터가 중재기를 한 개씩 가 짐)(여러 개), 버스 중재 동작이 각 마스터의 중재기에 의하여 이루어지는 방식 ▶ 병렬 중재 방식
1) 우선순위의 결정 방식에 따른 분류 ㆍ 고정
-우선순위 방식(fixed
-priority scheme) ­ 각 버스 마스터에 지정된 우선순위가 고정되어 있는 방식 ㆍ 가변
-우선순위 방식(dynamic
-priority scheme) ­ 우선순위를 변경할 수 있는 방식  303   ▶ 중앙집중식 고정–우선순위 중재 방식 ­ 모든 버스 마스터들이 하나의 버스 중재기에 접속(중앙) ­ 중재기와 가장 가까이 위치한 버스 마스터 1이 가장 높은 우선순위, 버스 마스터 4가 가장 낮은 우선순위를 가지는 것으로 가정(고정) 버스 마스터 BBUSY ※ 컴퓨터구조론, 생능출판사, 2019 ⋅ 예) ‘버스 마스터 1’이 버스를 사용 중일 때, ‘버스 마스터 3’이 버스 사용을 요구한 경 우
① ‘마스터 3’이 BREQ3 신호를 세트
② 버스 중재기가 ‘마스터 3’에게 BGNT3 신호를 세트 함으로써 버스 사용을 허가
③ ‘마스터 1’이 버스 사용을 끝내고 BBUSY 신호를 해제
④ ‘마스터 3’이 BBUSY 신호를 다시 세트하고, 버스 사용을 시작(이때 BREQ3와 BGNT3는 제거) BREQ BGNT BBUSY ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 병렬 중재기의 내부 회로도(고정
-우선순위) BREQ BGNT BREQ BGNT 버스 요구 버스 승인 신호들 BREQ BGNT 신호들 BREQ BGNT ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 분산식 고정
-우선순위 중재 방식 ­ 모든 버스 마스터들이 중재기를 한 개씩 보유(분산) ㆍ 중재 동작 ­ 각 중재기는 자신보다 더 높은 우선순위를 가진 마스터들의 버스 요구 신호들을 받아서 검사하여, 그들이 버스 사용 요구를 하지 않은 경우에만 자신의 버스 마스터로 버스 승  304   인 신호 발생 ­ 승인 신호를 받은 버스 마스터는 BBUSY 신호를 검사하여, 비활성화 상태(다른 마스터가 버스를 사용하지 않는 상태) 일 때 버스 사용을 시작

1) 분산식 중재 방식의 장단점 ⋅ 장점 ­ 중앙집중식에 비하여 중재 회로가 간단하므로 동작 속도가 빨라짐 ⋅ 단점 ­ 고장을 일으킨 중재기를 찾아내는 방법이 복잡하고, 한 중재기의 고장이 전체 시스템의 동작에 영향을 미칠 수가 있음 ▶ 분산식 고정
-우선순위 중재 방식의 구성도(1
-우선순위 가장 높음) 버스 마스터 버스 중재기 BREQ BREQ BREQ BBUSY (단, RnBREQnGn BGNTn ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 가변 우선순위 방식

1) 가변 우선순위 방식이란? ­ 시스템의 상태(또는 조건)에 따라 각 버스 마스터들의 우선순위를 계속 변화시키는 방식 ⋅ 단점 ­ 중재 회로 복잡 ⋅ 장점 ­ 모든 마스터들이 공정하게 버스를 사용할 수 있게 해줌
2) 회전 우선순위(rotating priority) 방식 ㆍ 방법 1 ­ 중재 동작이 끝날 때마다 모든 마스터들의 우선순위가 한 단계씩 낮아지고, 가장 우선순 위가 낮았던 마스터가 최상위 우선순위를 가지도록 하는 방법 ㆍ 방법 2 ­ 일단 버스 사용 승인을 받은 마스터는 최하위 우선순위를 가지며, 바로 다음에 위치한 마스터가 최상위 우선순위를 가지도록 하는 방법 → Acceptance
-dependent식 회전 우 선순위 방식  305   ▶ Acceptance
-dependent식 회전 우선순위 방식의 예 포인터 : 직전에 승인 받은 요구의 번호를 가 최저 우선순위 리키는 레지스터 최고 우선순위 (a) 마스터 3의 요구가 승인된 후 포인터 최저 우선순위 최고 우선순위 (b) 마스터 6의 요구가 승인된 후 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 가변 우선순위 방식 ㆍ 동등 우선순위 방식 ­ 모든 마스터들이 동등한 우선순위를 가지며, ex)Iex)O(ex)irst
-In ex)irst
-Out) 알고리즘 사용 ㆍ 임의 우선순위(random) 방식 ­ 각 중재 동작이 끝날 때마다 우선순위를 임의로 결정 ㆍ 최소­최근 사용(Least­Recently Used : LRU) 방식 ­ 최근 가장 오랫동안 버스를 사용하지 않은 버스 마스터에게 최상위 우선순위 할당 ⋅ 단점 : 회로가 매우 복잡 ▶ 직렬 중재 방식

1) 중앙집중식 직렬 중재 방식 ­ 하나의 버스 사용승인 신호선(BGNT)이 데이지­체인(daisy
-chain)형태로 모든 버스 마스터 들을 직렬로 연결 ­ 우선순위는 버스 승인 신호선이 연결된 순서대로 결정 ㆍ 동작 원리 ­ 한 개 또는 그 이상의 버스 마스터가 버스 사용을 요구하면 공통의 BREQ 신호가 세트 됨 ­ 버스 중재기 : 데이지 체인의 첫 번째에 접속된 마스터로 승인 신호(BGNT) 전송 ­ BGNT 신호를 받은 마스터는 만약 버스 사용을 요구한 상태라면, 버스 사용권을 가짐 ▶ 중앙집중식 직렬 중재 방식 ­ 만약 버스 사용을 요구하지 않은 상태라면, 승인 신호를 다음에 연결된 마스터로 통과 ­ 승인 신호는 버스를 요구한 마스터에게 도달할 때까지 계속 통과  306   ⇨ 버스 요구를 보낸 마스터들 중에서 중재기에 가장 가까이 위치한(우선순위가 가장 높은) 마스터에게 승인 신호가 전달되면 그 마스터가 버스 사용권을 획득 ▶ 중앙집중식 직렬 중재 방식의 구성도(데이지 체인) BBUSY BREQ BGNT BGNT BGNT 버스 중재기 버스 마스터들 ※ 컴퓨터구조론, 생능출판사, 2019 ▶ 분산식 직렬 중재 방식

1) 구성 ­ 데이지
-체인 버스 승인 신호(daisy
-chained bus grant signal : DBGNT)선으로 버스 중재 기들을 순환형(circular)으로 접속

2) 동작 원리 ­ 버스 사용권을 부여 받은 마스터가 버스 사용을 시작하는 순간에(그 마스터의 중재기는) 자 신의 우측에 위치한 마스터의 중재기로 접속된 DBGNT 신호를 세트 ­ 만약 그 마스터가 버스 사용을 신청하고 기다리던 중이었다면, 중재기는 즉시 DBGNT 신 호를 받아들여서 BGNT 신호를 발생시켜 마스터로 전송 ­ DBGNT 신호를 받은 마스터가 버스 요구를 하지 않은 상태라면, 그 신호를 우측의 다음 중재기로 통과시킴 ­ 그러한 과정은 버스를 요구한 마스터에 도달할 때까지 반복됨(DBGNT : Daisy
-chained Bus Grant signal) ▶ 분산식 직렬 중재 방식의 구성도 BBUSY DBGNT DBGNT 신호 ※ 컴퓨터구조론, 생능출판사, 2019  307   ⋅ 특징 ­ 각 마스터의 우선순위가 계속 변화(가변) ⋅ 버스 사용 승인을 받으면 다음 중재 동작에서는 최하위 우선순위를 가짐 ⋅ 버스를 사용한 마스터의 바로 우측에 위치한 마스터가 최상위 우선순위를 가짐 ⋅ 순환형 구조에서 DBGNT 신호가 연결된 순서대로 우선순위가 결정됨 ⋅ 단점 ­ 어느 한 지점에만 결함이 발생해도 전체 시스템의 동작 중단(single point of failure)  308   입출력 장치의 접속

1. 컴퓨터 내부에서 입출력을 제어하는 방법에 대해서 학습하고 이를 설명할 수 있다. 13주차  수업목표  
2. 입출력이 기억장치를 사용할 때 필요한 주소 지정 방식에 2교시  대해서 학습하고 이를 설명할 수 있다.
1. 입출력 제어 세부내용 
2. 입출력 주소지정 1. 입출력 제어 ▶ 지시장치 ㆍ 마우스(mouse) ­ 커서의 이동이나 영역을 지정할 수 있고 아이콘을 선택하고 메뉴를 실행할 수도 있는 입 력장치(3D) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 트랙볼(track ball) ­ 고정된 판 위에서 손이나 손바닥으로 회전시킬 수 있는 볼을 통하여 커서의 영역을 지 정, 단추를 이용하여 클릭 동작을 수행함 ­ 주로 그래픽 정보를 입력하는 데 사용함 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 터치패드(touch pad) ­ 패드 범위 안에서 손가락을 움직여 화면의 포인터를 이동하는 장치 ­ 노트북에서 마우스 대용으로 사용, 아이콘의 선택과 더블 클릭 동작을 수행하며, 선택을 오래 지속하면 마우스 오른쪽 버튼을 클릭했을 때의 기능과 동일한 동작을 수행 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 포인팅 스틱(pointing stick) ­ 주로 노트북에서 마우스 대용으로 사용하며, 키보드의 G, H, B 문자 키 사이에 튀어나 온 연필 지우개 같은 모양으로 마우스 커서를 이동시키는 장치  309   ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 조이 스틱(joy stick) ­ 주로 게임 및 컴퓨터 시뮬레이션에서 캐릭터와 도구의 동작을 제어하기 위해 사용하는 입력장치 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 디지타이저(digitizer) ­ 스타일러스(stylus) 펜과 이미지를 복사하는 퍽(Puck) 이라는 도구를 이용하여 그림이나 도형의 위치 관계를 부호화하여 입력하는 장치(좌표) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ 원시 데이터 입력장치 ㆍ 광학 마크 판독기(OMR, Optical Mark Reader) ­ 특별히 제작된 용지나 카드에 컴퓨터용 연필이나 사인펜을 사용하여 표시하고 광선을 비 추어 반사되는 유무에 따라 기록 여부를 판독하는 장치 OMR 카드 OMR 기기 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 광학 문자 판독기(OCR, Optical Character Reader) ­ 사용자에 의해 설계된 광학 문자를 장치를 이용해 직접 읽기 때문에 데이터 입력이 간단 한 장점을 갖음 ­ 설계된 특수 문자만을 사용 가능함(인쇄체 vs. 필기체) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013  310   ㆍ 스캐너(Scanner) ­ 반사되는 광 신호를 전기 신호로 만들고, 다시 디지털 데이터로 만드는 장치(감광)(3D scanner, 3D printer) ­ 문자 스캐너 : 상표, 서류, 마크 등의 문자 정보를 광학적으로 인식시키는 장치 ­ 바코드 : 대형 마트에서 판매하는 상품에 부착시켜 상품의 정보를 제공함(QR 코드) ­ 이미지 스캐너 : 촬영된 사진, 그려진 도면 등의 아날로그 영상을 컴퓨터에 직접 입력 시키는 장치 문자 스캐너 바코드 이미지 스캐너 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ 출력장치의 종류 ­ 처리된 결과 또는 저장 내용을 확인할 수 있는 형태로 나타내는 장치가 출력장치임 ­ 모니터의 소프트 카피와 프린터의 하드 카피로 분류 ㆍ 소프트 카피 출력 장치 ­ CRT 모니터는 브라운관을 사용하여 색 정보를 표현하므로 LCD 모니터에 비해 크기가 크며 무거움(beam, 형광물질) ­ LCD 모니터는 두 장의 유리판 사이에 액체를 넣어 색 정보를 표현하기 때문에 CRT 모 니터에 비해 가볍고 얇은 장점을 갖으며, 또한 보다 선명하고 떨림이 적은 화면을 제공 함(back light) : LED(점), OLED(면), QLED(1/4) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 하드 카피 출력 장치 ­ 도트 프린터는 프린터 헤드가 이동하면서 잉크 리본을 두드려 인쇄함(충격식) ­ 속도가 느리고 소음이 큼(3D printer ­ 개인이 제조) ­ 잉크젯 프린터는 프린터 노즐을 통해 잉크를 분사하여 인쇄하는 프린터로 저렴한 비용으 로 컬러 인쇄를 할 수 있고 고품질을 제공하는 장점이 있지만 속도가 느리다는 단점이 있음 ­ 레이저 프린터는 레이저 빔을 사용하여 토너를 종이에 묻혀 인쇄 하기 때문에 짧은 시간 에 많은 양의 문서를 인쇄 할 수 있으며, 인쇄 품질도 우수한 편임 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013  311   ▶ 입출력 겸용 장치의 종류 ­ 멀티미디어를 효과적으로 처리하기 위해 입력과 출력을 동시에 수행하는 장치 ­ 사운드 카드와 영상 카드, 복합기, 통신접속장치
1) 사운드 카드와 영상 카드 ㆍ 사운드 카드 ­ 외부에서 녹음되거나 마이크에서 입력되는 음성과 소리 신호를 디지털 데이터로 변환하 여 컴퓨터에 입력하고 저장된 소리 데이터나 CPU에서 처리된 소리 데이터를 아날로그 신호로 변환하여 출력하는 장치(ADC, DAC) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ㆍ 영상 카드 ­ 촬영된 영상이나 캠코더에서 입력되는 영상 신호를 디지털 데이터로 변환해서 컴퓨터에 입력하고 저장되거나 처리된 영상 디지털 데이터를 아날로그 신호로 변환하여 시각적으 로 확인할 수 있도록 출력하는 장치(ADC, DAC) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013
2) 통신 접속 장치 ㆍ 모뎀 ­ 컴퓨터의 디지털 데이터를 전화망에서 전송될 수 있도록 아날로그 신호로 변환해주고, 전화망을 통해서 전달되어온 아날로그 신호를 컴퓨터의 디지털 데이터 신호로 변환시켜 주는 장치(ADC, DAC) ㆍ 네트워크 인터페이스 카드 ­ 컴퓨터와 근거리 통신망(LAN)을 연결해주는 역할을 수행하는 장치로, 컴퓨터에 있는 데 이터를 네트워크에 보내고, 컴퓨터로 들어오는 데이터를 수집하는 기능을 수행함(NIC, MAC) ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ 컴퓨터에서 입력장치와 출력장치의 연결 ­ 컴퓨터의 후면 부에는 여러 가지 입력장치와 출력장치의 연결을 지원하는 단자가 존재  312   ⋅ 일반적인 경우 사운드 카드와 그래픽 카드는 주 회로기판(main, mother)의 슬롯에 별 도로 장착하여야만 연결 단자들을 확인할 수 있음(과거) ⋅ 경우에 따라 통합 형 주 회로기판을 사용하는 경우, 단자들도 주 회로기판에 포함함(현 재)
1) 개인용 컴퓨터에서 입출력 연결 단자 : 예전 ­ 현재(USB, HDMI) 비디오 시리얼 키보드 USB 네트워크 사운드 프린터 마우스 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ 입력장치와 출력장치의 동작 ­ 입출력장치(Input output device)는 중앙처리장치 또는 주기억장치와 외부의 입출력 매체 사이에 정보를 전송하는 기능을 수행 ⋅ 입출력장치들은 중앙처리장치는 물론이고 주기억장치에 비하여 동작 속도가 많이 느리 며, 정보를 처리하는 단위도 다름(블록) ⋅ 따라서, 오류가 발생할 확률은 높으나 각각의 동작에 대하여 자율성 보장이 가능함 (DMA, IOP)
1) 입력장치에서 중앙처리장치까지 전달되는 과정 ­ 입력된 데이터가 어느 장치에서 입력된 것인지를 판단하고 적절한 방법을 사용해서 표준 신호로 변환함 ⋅ 각종 입력장치를 통해서 입력되는 데이터들은 입력장치 고유의 데이터이므로 컴퓨터에 서 바로 처리가 불가능함 ⋅ 컴퓨터가 처리할 수 있는 디지털 데이터의 표준 신호로 변환 과정이 필요함 ­ 중앙처리장치에서 원하는 형태로 가공되어 주기억장치에 저장함 중앙처리장치 판별 기능 변환 및 전달 기능 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013
2) 중앙처리장치에서 데이터가 출력되는 과정 ­ 표준 신호의 중앙처리장치의 결과 신호는 출력 장치에서 표준 신호로 수신하고 그 장치의 특성에 맞게 신호를 변화시켜 표현함 표준 신호 외부 데이터 수신 변환 중앙처리장치 수신 능력 신호 변환 기능 출력장치 출력장치 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013  313  
3) 입력과 출력의 인터페이스 모듈(입출력 모듈) ­ 입출력장치는 중앙처리장치와 주기억장치에 비하여 동작 속도가 현저하게 느려서 직접적으 로 컴퓨터에 연결되지 않고 중간에 별도의 장치를 필요로 함 ­ 인터페이스 모듈을 통한 상호 연결되어 있음(입출력 모듈) 입출력 버스 ※컴퓨터 구조와 원리 2.0, 한빛아카데미, 2013 ▶ I/O 제어 – 입출력 모듈
1) I/O 장치가 시스템 버스에 직접 접속되지 못하는 이유 ­ I/O 장치들은 종류에 따라 제어 방법이 서로 다르며, 그러한 제어 회로들을 CPU 내부에 모두 포함시키는 것이 불가능하기 때문에 CPU가 그들을 직접 제어할 수가 없음 ­ I/O 장치들의 데이터 전송 속도가 CPU의 데이터 처리 속도에 비하여 훨씬 더 느리고 속도 가 서로 다르기 때문에, 고속의 시스템 버스와 I/O 장치들 사이에 직접 데이터를 교환하는 것은 불가능 ­ I/O 장치들과 CPU가 사용하는 데이터 형식의 길이가 서로 다른 경우가 많음 ⇨ 인터페이스 장치인 I/O 제어기(I/O controller)를 사용(입출력 모듈) ▶ I/O 제어기의 주요 기능(입출력 모듈) ­ I/O 장치의 제어와 타이밍 조정 ­ CPU와의 통신 담당 ­ I/O 장치와의 통신 담당 ­ 데이터 버퍼링(data buffering) 기능 수행 ­ 오류 검출 ▶ 프린터 제어기의 내부 구성도 : 입출력 모듈 데이터 버스 데이터 상태 신호 주소 버스 제어 신호 제어 신호 ※컴퓨터구조론, 생능출판사, 2019  314   ▶ 상태/제어 레지스터(status/control register) ­ 내부적으로 두 개의 레지스터로 구성되지만 주소는 하나만 지정 되는 레지스터들 ㆍ 상태 레지스터 ­ I/O 장치의 상태와 오류 검사 결과 등을 나타내는 비트들로 구성(CPU에 의한 읽기 동작 시 선택됨) ㆍ 제어 레지스터 ­ CPU가 보낸 I/O 명령 단어(I/O command word)를 저장(CPU에 의한 쓰기 동작 시 선 택됨)
1) CPU가 프린터로 데이터를 출력하는 과정
① CPU가 프린터 제어기에게 프린터의 상태를 검사하도록 요청
② 제어기는 프린터의 상태를 검사하여 준비되었는지를 가리키는 비트(RDY 비트)를 세트
③ CPU는 RDY 비트를(반복) 검사하고, 프린터가 다음 프린트를 시작할 준비가 된 상태라면 제어기로 출력 명령과 데이터를 전송(polling)(CPU → 제어기)
④ 제어기는 프린트 동작을 제어하기 위한 신호들과 데이터를 프린터로 전송(제어기 → 프린 터) * 데이터 레지스터를 큰 용량의 반도체 기억장치로 이루어진 데이터 버퍼(data buffer)로 대 체한다면, 데이터 블록 전체를 한꺼번에 전송 받아 프린트 가능 ▶ 프로그램을 이용한 I/O(programmed I/O) 
- polling ­ CPU가 반복적으로 I/O 장치의 상태를 검사하면서 I/O 동작을 처리하는 방식 ⋅ 장점 ­ 간단하며, 별도의 하드웨어가 필요하지 않음 ⋅ 단점 ­ CPU가 I/O 동작에 직접 관여해야 하므로, 그 동안에 다른 일을 하지 못함(CPU 낭비) ▶ 프로그램을 이용한 I/O의 흐름도 : polling – CPU 낭비 데이터 출력 명령 ※컴퓨터구조론, 생능출판사, 2019  315   2. 입출력 주소지정 ▶ I/O 주소지정(I/O addressing) ­ 각 I/O 장치 당 두 개씩의 주소 할당 : 데이터, 상태/제어 ⋅ 데이터 레지스터 주소, 상태 / 제어 레지스터 주소

1) I/O 주소 지정 방법
① 기억장치
- 사상 I/O(memory
- mapped I/O)
② 분리형 I/O(isolated ­ I/O) ▶ 기억장치
-사상 I/O(memory
-mapped I/O) ­ 기억장치 주소 영역의 일부분을 I/O 제어기 내의 레지스터들의 주소로 할당하는 방식 ­ 프로그래밍에서 기억장치 관련 명령어들을 I/O 장치 제어에도 사용 가능 ⋅ 예) LOAD 명령어, STORE 명령어, 등 ­ 기억장치 읽기 / 쓰기 신호를 I/O 읽기/쓰기 신호로 사용(별도의 I/O 제어 신호가 필요하지 않음) v 기억장치
-사상 I/O의 주소 공간 할당의 예 ­ 주소 비트들이 10 비트인 경우 → 전체 기억 장소들의 수 = 1024 =  ­ 0번지∼511번지(상위 512개 주소) : 기억장치에 할당 ­ 512번지∼1023번지(하위 512개 주소) : I / O 장치들에 할당 주소 전체 주소 공간 ※컴퓨터구조론, 생능출판사, 2019 v 기억장치
-사상 I/O의 예 ㆍ 기억장치
- 사상 I / O 방식을 이용한 경우의 프린터 출력 프로그램 ­ 데이터 레지스터 주소 : 512번지 ­ 상태 / 제어 레지스터 주소 : 513번지 ­ 상태 레지스터 최하위 비트(b ) : RDY 비트로 사용  ­ 제어 레지스터 최상위 비트(b ) : 프린트 시작(start) 비트로 사용  TEST : LOAD 513 ; 상태 레지스터의 내용을 읽는다. ANI 01 ; RDY 비트를 제외한 모든 비트들을 ‘0’으로 리셋 시킨다. JZ TEST ; 만약 RDY 비트가 ‘0’이라면, TEST로 점프한다.(polling) ; LOAD M[a] ; 프린트할 데이터를 기억장치 a번지로부터 읽어온다. STOR 512 ; 프린트할 데이터를 데이터 레지스터에 쓴다. LOAD 80H ; AC에 2진수 ‘10000000’을 적재한다.  316   (START 비트 ← ‘1’) STOR 513 ; 프린트 시작 명령을 보낸다. ※컴퓨터구조론, 생능출판사, 2019 ⋅ 장점 ­ 프로그래밍이 용이(사용 가능한 명령어들이 다양) ⋅ 단점 ­ 기억장치 주소 공간이 감소(절반) ▶ 분리형 I/O(isolated I/O) ­ I / O 장치 주소 공간을 기억장치 주소 공간과는 별도로 할당하는 방식 ­ I / O 제어를 위해서 별도의 I / O 명령어 사용 ⋅ 예) IN, OUT 명령어 ­ 별도의 I / O 읽기 / 쓰기 신호 필요 v 분리형 I/O의 주소 공간 할당의 예 ­ 주소 비트의 수가 10개일 때, 기억장치 주소와 I/O 주소를 각각 아래와 같이 1024(=) 개씩 할당 가능 ※컴퓨터구조론, 생능출판사, 2019 ⋅ 단점 ­ I/O 제어를 위해 I/O 명령어들만 이용할 수 있으므로, 프로그래밍이 불편 ⋅ 장점 ­ I/O 주소공간으로 인하여 기억장치 주소 공간이 줄어들지 않음 v 분리형 I/O의 예 ㆍ 분리형 I/O 방식을 이용한 경우의 프린터 출력 프로그램 ­ I/O 장치의 데이터 레지스터 주소 : 0번지 ­ 상태 / 제어 레지스터 주소 : 1번지 TEST : IN 1 ; 상태 레지스터의 내용을 읽는다. ANI 01 ; RDY 비트를 제외한 모든 비트들을 ‘0’으로 리셋 시킨다. JZ TEST ; 만약 RDY 비트가 ‘0’이라면, TEST로 점프한다.(polling) ; LOAD M[a] ; 프린트할 데이터를 기억장치 a번지로부터 읽어온다. OUT 0 ; 프린트할 데이터를 데이터 레지스터에 쓴다. ; AC에 2진수 ‘10000000’을 적재한다. LOAD 80H (START 비트 ← ‘1’) OUT 1 ; 프린트 시작 명령을 보낸다. ※컴퓨터구조론, 생능출판사, 2019  317   ▶ 폴링 방식 v 폴링(polling) 이란, 하나의 장치(또는 프로그램)가 충돌 회피 또는 동기화 처리 등을 목적 으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료 처리를 하는 방식을 말함 ⋅ 이 방식은 버스, 멀티포인트 형태와 같이 여러 개의 장치가 동일 회선을 사용하는 상황 에서 주로 사용되며, 서버의 제어 장치(또는 프로그램)는 순차적으로 각 단말 장치(또는 프로그램)에 회선을 사용하기 원하는지를 물어봄 ⋅ 폴링 방식(polling scheme)의 원리 → 버스 사용을 원하는 마스터가 있는지를 버스 중 재기가 주기적으로 검사하여 사용 승인 여부를 결정 ▶ 하드웨어 폴링 방식

1) 하드웨어 폴링 방식이란? ­ 버스 중재기와 각 버스 마스터 간에 별도의 폴링 선(polling line)이 존재 ­ 2진 코드화된 폴링 주소(binary encoded polling address) 를 이용하면, 폴링 선의 수가 log N개로 감소  ­ 공통의 BREQ 선과 BBUSY 선이 각각 한 개씩 존재 ㆍ 동작 순서 ­ 중재기는 폴링 주소를 발생하여 검사할 마스터를 지정한 다음에, 그 마스터가 버스 사용 을 원하는지 물음 ­ 지정된 마스터가 버스 사용을 원하면 BREQ 신호를 세트 ­ BREQ 신호가 세트되면, 중재기는 현재 검사 중인 마스터에게 버스 사용을 허가하고, 그 렇지 않으면(지정된 마스터가 버스 사용을 원하지 않으면) 다음 마스터들에 대한 검사를 순서대로 진행 ㆍ 우선순위 결정 방법 ­ 중재기가 마스터를 검사하는 순서에 의하여 결정되며, 검사할 마스터의 번호는 2진 카운 터(binary counter)를 이용하여 발생 ▶ 하드웨어 폴링 방식의 구성도 : BGNT 없음 버스 마스터 폴링 주소선 (개) BREQ BBUSY ※컴퓨터구조론, 생능출판사, 2019  318   ▶ 소프트웨어 폴링 방식 ㆍ 동작 원리 ­ 폴링의 순서와 과정을 버스 중재기 내의 프로세서가 관장하는 방식 ⋅ 단점 ­ 프로그램을 실행해야 하므로 하드웨어 방식에 비하여 속도가 더 느림 ⋅ 장점 ­ 우선순위(폴링 순서)의 변경이 용이  319   인터럽트와 DMA
1. 컴퓨터 내부에서 입출력 데이터를 효과적으로 전송하기 위한 인터럽트에 대해서 학습하고 이를 설명할 수 있다. 13주차  수업목표  
2. 컴퓨터 내부에서 입출력 데이터를 효과적으로 전송하기 위한 3교시  DMA에 대해서 학습하고 이를 설명할 수 있다.
1. 인터럽트 세부내용 
2. DMA 1. 인터럽트 ▶ 인터럽트를 이용한 I/O 
- interrupt ㆍ 인터럽트
- 구동 I/O(interrupt
- driven I/O) ­ 인터럽트 메커니즘을 이용함으로써, I/O 동작이 진행되는 동안에 CPU가 다른 작업을 처 리할 수 있도록 하는 방식 ㆍ 동작 순서 ­ CPU가 I/O 제어기에게 명령을 전송하고, CPU는 다른 작업 수행(2가지 : interrupt vs. DMA) ­ 제어기는 I/O 장치를 제어하여 I/O 명령을 수행 ­ I/O 명령 수행이 완료되면, 제어기는 CPU로 인터럽트 신호를 전송 ­ CPU는 인터럽트 신호를 받는 즉시 원래의 프로그램으로 복귀하여 수행을 계속 ▶ 인터럽트
-구동 I/O 방식에서의 프린터 출력 흐름도
① CPU는 데이터와 프린트 명령을 프린터 제어기로 전송하고, 다른 작업을 수행(2가지 : interrupt vs. DMA)
② 그 데이터의 프린트가 종료되면, 제어기가 CPU로 인터럽트 요구 신호를 전송
③ 프린트할 내용이 남아 있다면, CPU는 다음에 프린트할 데이터를 준비하여 위의 과정을 반 복 다른 작업 수행(CPU) 인터럽트 발생(프린트 제어기) 오류 보고 ※컴퓨터구조론, 생능출판사, 2019  320   ▶ 인터럽트
-구동 I/O의 구현 방법 : 버스 중재(bus arbitration) ­ 다중
-인터럽트(multiple interrupt) 방식 ­ 데이지
-체인(daisy
-chain) 방식 ­ 소프트웨어 폴링(software polling) 방식 ▶ 다중
-인터럽트 방식 ㆍ 다중
- 인터럽트 방식(multiple interrupt) ­ 각 I/O 제어기와 CPU 사이에 별도의 인터럽트 요구(interrupt request: INTR) 선과 인 터럽트 확인(interrupt acknowledge: INTA) 선을 접속하는 방법 주소 버스 데이터 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ 다중
-인터럽트 방식의 예 ㆍ I/O 제어기 #2가 인터럽트를 요구하는 경우의 동작 순서
① I/O 제어기 #2가 INTR2 신호를 세트
② CPU는 INTA2 신호를 세트 함으로써 그 제어기에게 인터럽트 요구를 인식하였음을 알 리고, 인터럽트를 위한 서비스를 시작
③ I/O 제어기2는 INTR2 신호를 해제(0으로 리셋)
④ CPU도 INTA2 신호를 해제 ⋅ 장점 ­ CPU가 인터럽트를 요구한 장치를 쉽게 찾아낼 수 있음 ⋅ 단점 ­ 하드웨어가 복잡하고, 접속 가능한 I/O 장치들의 수가 CPU의 인터럽트 요구 입력 핀의 수에 의해 제한됨 ▶ 데이지
-체인 방식 ㆍ 데이지
-체인 방식(daisy
-chain) ­ CPU로부터 발생되는 INTA 출력 선을 I/O 제어기들에 직렬로 접속하는 방식 ­ 인터럽트를 요구한 I/O 장치는 AIn 입력을 받는 즉시 자신의 고유(ID) 번호, 즉 인터럽 트 벡터(interrupt vector) 를 데이터 버스를 통하여 CPU로 전송(분기 번지) ⋅ 인터럽트 벡터는 해당 I/O 장치를 위한 인터럽트 서비스 루틴의 시작 주소를 결정하 는데 사용 ­ 만약 AIn 입력을 받은 I/O 장치가 인터럽트를 요구하지 않은 상태라면, 그 입력을 다음 장치로 통과(pass)시킴(AOn)  321   ▶ 데이지
-체인 방식의 구성도 주소 버스 데이터 버스 ※컴퓨터구조론, 생능출판사, 2019 ⋅ 장점 ­ 하드웨어가 간단 ⋅ 단점 ­ 우선순위가 낮은 장치들이 서비스를 받지 못하고 매우 오랫동안 기다려야 하는 경우가 발생(기아, starvation) ▶ 소프트웨어 폴링 방식 ㆍ 소프트웨어 폴링 방식(software polling) ­ CPU가 모든 I/O 제어기들에 접속된 TEST I/O 선을 이용하여 인터럽트를 요구한 장치를 검사하는 방식 ⋅ Test I/O 신호를 이용하여 각 I/O 장치의 인터럽트 플래그가 세트 되어 있는 지를 검 사(검사 순서가 우선순위를 결정) ⋅ 장점 ­ 우선순위의 변경이 용이 ⋅ 단점 ­ 처리 시간이 오래 걸림 주소 버스 데이터 버스 ※컴퓨터구조론, 생능출판사, 2019 2. DMA ▶ 직접기억장치액세스 ㆍ Direct Memory Access(DMA) ­ CPU의 개입 없이 I/O 장치와 기억장치 사이에 데이터를 전송하는 방식(사이클 스틸링 (cycle stealing)이라고도 함) ㆍ 방법  322   ­ CPU가 주기억장치를 액세스하지 않는 시간(CPU가 내부적으로 명령어를 해독하거나 ALU 연산을 수행하는 시간) 동안에 시스템 버스를 사용하여 주기억장치와 I/O 장치 간 에 데이터 전송 : CPU의 사이클을 훔침 v 직접 메모리 접근(直接
- 接近, Direct Memory Access, DMA)는 주변장치들(하드디스크, 그래픽 카드, 네트워크 카드, 사운드 카드 등)이 메모리에 직접 접근하여 읽거나 쓸 수 있 도록 하는 기능으로서, 컴퓨터 내부의 버스가 지원하는 기능 임 ⋅ 대개의 경우에 메모리의 일정 부분이 DMA에 사용될 영역으로 지정되며, DMA가 지원 되면 중앙처리장치가 데이터 전송에 관여하지 않아도 되므로 컴퓨터 성능이 좋아짐 : PIO ­ Programmed I/O ⋅ 한편, PIO는 DMA의 반대개념으로써, 장치들 사이에 전송되는 모든 데이터가 중앙처리 장치를 거쳐가는 방식임 ⋅ DMA는 PIO의 단점을 보완하기 위해 고안된 기능(polling)

1) DMA의 특징 ­ 주변장치의 데이터는 장치 컨트롤러(입출력 모듈)에 의해 로컬 버퍼로 이동함 ­ 그러나 전송할 데이터가 많은 경우, 많은 양의 데이터의 이동으로 인한 부담이 커지는데 이 러한 문제를 해결하기 위해 DMA를 이용함 ­ 장치 컨트롤러가 데이터의 한 블록을 이동시키는데 이 과정에서 DMA로 인해 CPU의 개입 이 필요 없게 됨 ­ CPU에서는 데이터 이동이 완료되었다는 단 한 번의 인터럽트만 발생함 ­ 데이터가 전송되는 동안 CPU는 다른 작업을 수행할 수 있게 되어 효율성이 높아짐 ­ DMA는 과거 IBM의 특허 기술이었음(현재는 특허권 소멸) ▶ DMA 제어기가 포함된 시스템 구성도 : 단일버스 분리식 시스템 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ DMA 처리 순서
① CPU가 DMA 제어기(DMA controller)로 아래 정보를 포함한 명령을 전송
- I/O 장치의 주소(예 : 디스크 드라이브 번호, 실린더 번호, 섹터 번호)
- 연산(쓰기 혹은 읽기) 지정자
- 데이터가 쓰여지거나 읽혀질 주기억장치 영역의 시작 주소
- 전송될 데이터 단어들의 수
② DMA 제어기는 CPU로 버스 요구(BUS REQ) 신호를 전송
③ CPU가 DMA 제어기로 버스 승인(BUS GRANT) 신호를 전송 : Cycle stealing
④ DMA 제어기가 주기억장치로부터 데이터를 읽어서, 디스크 제어기로 전송(CPU → 디스  323   크) 각 데이터에 대하여
②,
③,
④ 번을 두 번 반복(주기억장치 → DMA 제어기 & DMA 제 어기 → 디스크 제어기 → 데이터 저장) : 시스템 버스 두 번 사용
⑤ 저장할 데이터들이 남아있다면, 그 수만큼
② ~
④ 번 동작을 반복
⑥ 모든 데이터들의 저장이 완료되면, CPU로 INTR 신호를 전송 ▶ DMA 제어기의 내부 구조 : I/O 장치의 주소 주기억장치 주소 버스 I/O 장치 데이터 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ DMA의 문제점 ⋅ 문제점 ­ 각 데이터 전송 때마다 시스템 버스를 두 번씩 사용 → 버스 사용량 증가로 인한 시스 템 성능 저하 ⋅ 해결책 ­ I/O 장치들을 DMA 제어기에 접속 → DMA 제어기가 주기억장치를 액세스 할 때만 시 스템 버스 사용 ▶ DMA 제어기를 이용한 I/O 접속 방법 : 단일버스 통합형 시스템 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ I/O 버스를 이용한 DMA 구성도 : 입출력 버스 ­ I/O 버스 사용 → 한 개의 DMA 제어기가 다수의 I/O 장치들을 지원  324   시스템 버스 I/O 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ DMA의 문제점 ⋅ 문제점 ­ I/O 장치들은 종류와 속도가 다양하고 제어 방법도 복잡하기 때문에, 간단한 구조를 가 진 DMA 제어기로 지원하는 데는 한계가 있음 ­ 디스크 쓰기 혹은 읽기 동작의 경우에는 데이터 블록의 크기가 512 바이트 이상이기 때 문에 그 데이터들을 버퍼링(임시 저장)하기 위한 내부 기억장치가 필요 ⋅ 해결책 ­ I/O 프로세서(I/O processor : IOP) 사용 → I/O 채널(I/O channel) 이라고도 함 ▶ IOP

1) IOP 보드에 포함될 요소들 ­ I/O 제어 프로그램(OS의 I/O device driver 프로그램)을 실행할 수 있는 프로세서(CPU) ­ 데이터 블록을 임시 저장(버퍼링) 할 수 있는 용량의 지역 기억장치(local memory) ­ 시스템 버스 인터페이스 및 버스 마스터 회로 ­ I/O 버스 중재 회로 v 입출력 채널(I/O channel)은 입출력이 일어나는 동안 프로세서가 다른 일을 하지 못하는 문제를 극복하기 위해 개발된 것으로, 시스템의 프로세서와는 독립적으로 입출력만을 제어 하기 위한 시스템 구성요소라고 할 수 있음(PC에 많은 CPU가 존재) ⋅ 채널은 정보를 저장하거나 검색하기 위해서 주기억 장치를 직접 접근 할 수도 있음 (DMA) ⋅ 채널은 프로세서로부터 요청된 입출력 작업을 수행하고, 입출력 작업이 끝나면 완료되 었다는 사실을 인터럽트의 형식으로 프로세서에 알림
2) 입출력 채널의 특징 ­ 컴퓨터의 중앙 처리 장치는 한번에 하나씩 차례대로 업무를 처리하므로 주변 장치의 동작 이 끝나야만 비로소 작업을 계속하게 됨 ­ 따라서 중앙 처리 장치는 주변 장치의 느린 속도 때문에 충분히 성능을 발휘하지 못하게 되는데, 이런 일이 없도록 주변 장치를 별도의 장치에서 조종할 수 있게 한 것이 채널 ­ 채널은 중앙 처리 장치와 주변 장치의 동작을 분리시키고, 그 사이에서 중앙 처리 장치가 계속 쉬지 않고 다른 일을 할 수 있도록 하는 별도의 컴퓨터 같은 역할을 함  325   ­ 중앙 처리 장치에는 여러 개의 채널을 붙일 수 있으므로 처리 속도가 느린 주변 장치들은 여러 대를 하나의 채널로 제어할 수 있지만, 비교적 처리가 빠른 장치들은 각각의 채널을 붙임 : IOP로 처리(여러 개의 채널로 구성) ▶ IOP : selector, multiplexor 형태를 가짐 v 선택 채널(selector channel)은 1개의 보조 채널만 가지고 있어서 한 순간에 1개의 주변 기기만 서비스할 수 있음 v 멀티플렉서 채널(multiplexor channel)은 여러 개의 보조 채널을 가지고 있어서 한번에 여러 개의 데이터열을 인터리빙할 수 있음
1) 선택, 멀티플렉서 채널의 특징 ­ 입출력 채널을 처음 사용한 것은 IBM 709 진공관 메인프레임이었으며, 여기에서 1957년 의 모델 766 데이터 싱크로나이저(Model 766 Data Synchronizer)가 최초의 채널 컨트롤 러임 ­ 트랜지스터 형태의 후계자 IBM 7090은 2개 이상의 채널(7607)과 하나의 채널 멀티플렉 서(7606)을 갖추고 있었으며 최대 8개의 채널을 제어할 수 있었음 ­ 채널은 지원되는 동시 입출력 기능의 수와 유형에 따라 다름 ­ IBM 용어로 멀티플렉서 채널(multiplexer channel)은 수많은 동시 인터리빙 저속 명령어 (concurrent interleaved slow
-speed operation)들을 지원하며 명령어 각각이 한 번에 하 나의 장치로부터 한 바이트를 전송함 ­ 셀렉터 채널(selector channel)은 하나의 고속 명령(high
-speed operation)을 지원하며, 한 번에 하나의 데이터 블록을 전송함 ­ 블록 멀티플렉서(block multiplexer)는 수많은 동시 고속 명령을 지원함 ▶ I/O 프로세서가 사용된 시스템의 구성도 인터럽트 요구선 시스템 버스 I/O 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ 시스템 버스의 기본 동작 ㆍ 쓰기 동작(write operation) 순서
① 버스 마스터가 버스 사용권 획득 : CPU 허락 받지 않음  326  
② 버스를 통하여 주소와 데이터 및 쓰기 신호 전송 ㆍ 읽기 동작(read operation) 순서
① 버스 마스터가 버스 사용권 획득
② 주소와 읽기 신호를 보내고, 데이터가 전송되어 올 때까지 대기

1) 버스 동작의 타이밍에 따른 버스의 분류 ㆍ 동기식 버스(synchronous bus) ­ 시스템 버스에서 모든 버스 동작들이 공통의 버스 클럭을 기준으로 발생 ㆍ 비동기식 버스(asynchronous bus) ­ 버스 동작들의 발생 시간이 관련된 다른 버스 동작의 발생 여부에 따라 결정 ▶ 동기식 버스와 비동기식 버스의 시간 흐름도 : master, slave sync. 버스 클록 시작 신호 읽기 신호 주소 버스 데이터 버스 확인 버스 (a) 동기식 버스 MSYN 신호 SSYN 신호 읽기 신호 주소 버스 데이터 버스 (b) 비동기식 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ 동기식/비동기식 버스의 비교
1) 동기식 버스 ⋅ 장점 ­ 인터페이스 회로 간단 ⋅ 단점 ­ 버스 클럭의 주기가 가장 오래 걸리는 버스 동작의 소요 시간을 기준으로 결정되므로, 클럭 주기보다 더 짧은 시간이 걸리는 버스 동작의 경우에는 동작이 완료된 후에도 다음 주기가 시작될 때까지 대기(낭비)
2) 비동기식 버스 ⋅ 장점 ­ 각 버스 동작이 완료 즉시 연관된 다음 동작이 발생하기 때문에 동기식 버스에서와 같이  327   낭비되는 시간이 없음 ⋅ 단점 ­ 연속적 동작을 처리하기 위한 인터페이스 회로가 복잡
3) 동기식/비동기식 버스의 사용 ㆍ 소규모 컴퓨터 : 비동기식 버스 사용 ㆍ 일반적인 컴퓨터 시스템 : 동기식 버스 사용  328   병렬컴퓨터의 분류
1. 병렬컴퓨터에서 사용하는 병렬처리의 개념에 대해서 학습하고 이를 설명할 수 있다. 14주차  수업목표  
2. 병렬컴퓨터의 여러 가지 분류에 대해서 학습하고 이들이 1교시  가지는 특징들을 설명할 수 있다.
1. 병렬처리 개념 세부내용 
2. 병렬처리 분류 1. 병렬처리 개념 ▶ 병렬처리의 개념과 필요성 ㆍ 병렬처리(parallel processing) ­ 다수의 프로세서(CPU)들이 여러 개의 프로그램들 혹은 한 프로그램의 분할된 부분들을 분담하여 동시에 처리하는 기술(멀티코어, 부하분산) ㆍ 병렬처리를 위한 선결 조건 ­ 많은 수의 프로세서들로 하나의 시스템을 구성할 수 있도록 작고 저렴하며 고속인 프로 세서(CPU)들의 사용이 가능해야 함(ULSI) → 반도체 기술의 발전과 VLSI 집적도 향상으 로 가능해짐 ­ 한 프로그램을 여러 개의 작은 부분들로 분할하는 것이 가능해야 하며, 분할된 부분들을 병렬로 처리한 결과가 전체 프로그램을 순차적으로 처리한 경우와 동일한 결과를 얻을 수 있어야 함 : 소프트웨어적인 처리, 병행성
1) 야기되는 새로운 문제들 ㆍ 문제 분할(problem partition) ­ 병렬처리를 위하여 문제(혹은 프로그램)를 여러 개로 나누는 것 ㆍ 프로세서간 통신(interprocessor communication) ­ 분할된 부분을 나누어 처리하는 프로세서간의 데이터 교환을 위해 메커니즘 필요 : 공유 메모리, message
-passing

2) 필요한 관련 기술들 ­ 병렬 프로그램 언어와 컴파일러의 개발 ­ 상호 배타 메커니즘(mutual exclusion mechanism) 지원 ­ 공유자원들에 대한 경합(contention)을 줄이고 이용률을 극대화할 수 있는 운영체제의 개 발 ▶ 병렬처리의 단위 ㆍ 작업
-단위 병렬성(Job­level parallelism) ­ 독립적인 작업 프로그램(job program) 단위로 병렬처리 ⋅ 예) 성적관리 프로그램, 실험 데이터 처리 프로그램 ㆍ 태스크­단위 병렬성(task­level parallelism)  329   ­ 하나의 큰 작업을 기능에 따라 분할한 작은 프로그램(태스크, task) 단위로 병렬처리 ⋅ 예) 로봇 제어 프로그램 ⇨ 두뇌, 팔과 다리들의 동작을 제어하는 다수의 태스크 (task)들로 분할한 후, 병렬처리 → 프로세서들간의 정보 교환 필요 ㆍ 스레드­단위 병렬성(thread­level parallelism) ­ 동시에 처리될 수 있는 가장 작은 크기의 독립적인 단위 프로그램인 스레드 단위의 병렬 처리(가장 작은 단위) ㆍ 명령어­단위 병렬성(instruction­level parallelism) ­ 데이터 의존성이 존재하지 않는 여러 개의 명령어들을 동시에 수행하는 병렬처리 : 스레 드는 명령어들을 처리 2. 병렬처리 분류 ▶ 병렬컴퓨터의 분류 ㆍ ex)lynn의 분류(ex)lynn’s classification) ­ 구조적 특징에 따른 컴퓨터 분류 방식 ⋅ 명령어 스트림(instruction stream) : 프로세서에 의해 실행되기 위하여 순서대로 나 열된 명령어 코드들의 집합 ⋅ 데이터 스트림(data stream) : 그 명령어들을 실행하는데 필요한 순서대로 나열된 데이터들의 집합 ▶ 병렬컴퓨터의 분류 : 단일(single) vs. 복수(multiple) ㆍ 프로세서들이 처리하는 명령어와 데이터의 스트림(stream; 흐름)의 수에 따라 분류 ­ 단일 명령어 스트림
- 단일 데이터 스트림(SISD) ­ 단일 명령어 스트림
- 복수 데이터 스트림(SIMD) ­ 복수 명령어 스트림
- 단일 데이터 스트림(MISD) ­ 복수 명령어 스트림
- 복수 데이터 스트림(MIMD) ▶ SISD : PU(Processing Unit), MM(Memory Module) ­ 한번에 한 개씩의 명령어와 데이터를 순서대로 처리하는 단일프로세서 시스템 ­ 파이프라이닝(pipelining), 슈퍼스칼라(superscalar) 구조를 이용 : 병렬 수행, ■ 병렬 수행 (a) SISD 시스템 ※컴퓨터구조론, 생능출판사, 2019 ▶ SIMD ­ 배열 프로세서(array processor), vector processor ­ 여러 개의 프로세싱 유니트(PU)들로 구성되고, PU들의 동작은 모두 하나의 제어 유니트  330   (CU)에 의해 통제 ­ 모든 PU들은 하나의 명령어 스트림을 실행 ­ 데이터 스트림은 여러 개를 동시에 처리  : 제어 유니트  : 프로세싱 유니트  : 기억장치 모듈  : 공유 기억장치  : 명령어 스트림  : 데이터 스트림 (b) SIMD 시스템 ※컴퓨터구조론, 생능출판사, 2019 ▶ MISD : CU, PU, MM, SM, IS, DS ­ N개의 프로세서들이 서로 다른 명령어들을 실행하지만, 처리하는 데이터 스트림은 한 개 : 일기 예보 → 비현실적이므로 실제 구현된 경우는 없음 (c) MISD 시스템 ※컴퓨터구조론, 생능출판사, 2019 ▶ MIMD ­ N개의 프로세서들이 서로 다른 명령어들과 데이터들을 처리 : 일반 멀티 프로세서, 멀티코 어

1) 프로세서들간의 상호작용 정도에 따라 두 가지로 분류 ㆍ 밀결합 시스템(tightly ­ coupled system) ­ 공유
- 기억장치 구조(shared
- memory architecture) ­ 다중프로세서 시스템(multiprocessor system) ㆍ 소결합 시스템(loosely ­ coupled system) ­ 지역 기억장치(local memory)를 가진 독립적인 컴퓨터 모듈로 구성 ­ 프로세서간 통신은 메시지 전송(message
- passing) 방식 이용 ­ 다중컴퓨터 시스템(multiple
- computer system)  331   ▶ MIMD 조직의 구성도 : CU, PU, MM, SM, IS, DS (d) MIMD 시스템 ※컴퓨터구조론, 생능출판사, 2019 ▶ 기억장치 액세스 모델에 따른 분류 ­ 균일 기억장치 액세스(Uniform Memory Access : UMA) 모델 ­ 불균일 기억장치 액세스(Non
-uniform Memory Access : NUMA) 모델 ­ 무
-원격 기억장치 액세스(No
-Remote Memory Access : NORMA) 모델 ▶ UMA 모델 : 버스(공유, 다중), 크로스바(완전연결), MIN(중간) ­ 모든 프로세서들이 상호연결망에 의해 접속된 주기억장치를 공유함 : MIN(다단계 상호연결 망) ­ 프로세서들은 주기억장치의 어느 영역이든 액세스할 수 있으며, 그에 걸리는 시간이 동일함 프로세서 공유 기억장치 ※컴퓨터구조론, 생능출판사, 2019

1) 장단점 ⋅ 장점 ­ 하드웨어가 간단하고, 프로그래밍이 용이함 ⋅ 단점 ­ 공유 자원에 대한 경합(contention)이 높아지기 때문에 시스템 크기에 한계가 있음 ⋅ 예) 공유
-버스를 사용하는 시스템 : 프로세서 30개 이하 크로스바, MIN을 사용하는 시스템 : 프로세서 64개 이하 ▶ NUMA 모델 ­ UMA 모델의 한계를 극복하고 더 큰 규모의 시스템을 구성하기 위한 모델 : 가장 오래된? ­ 다수의 UMA 모델들이 상호연결망에 의해 접속 ­ 분산 공유
-기억장치(distributed shared
-memory) 구조  332   ­ 기억장치 액세스 시간은 기억장치의 위치에 따라 달라짐 ⋅ 지역 기억장치 액세스(local memory access) ⋅ 전역 기억장치 액세스(global memory access) ⋅ 원격 기억장치 액세스(remote memory access) ▶ NUMA 모델의 일반적인 구성도 : global(전역), local(지역), remote(원격) 모듈 1 모듈 ■ ※컴퓨터구조론, 생능출판사, 2019 ▶ NORMA 모델 ­ 프로세서가 원격 기억장치(remote memory)는 직접 액세스할 수 없는 시스템 구조 ­ 프로세서들과 기억장치들은 메시지­전송(message
-passing)을 지원하는 상호연결망으로 접 속 ­ 분산
-기억장치 시스템(distributed
-memory)으로도 부름 ­ 주요 상호연결망 : 메시(mesh : 그물망), 하이퍼큐브(hypercube : 직육면체, 상호연결함 수), 토러스(torus : 원형+메시) 등 ▶ NORMA 모델 : 메시(그물), 하이퍼큐브(직육면), 토러스(원형+메시)  ※컴퓨터구조론, 생능출판사, 2019  333   ▶ 시스템 구성 방법에 따른 분류 : SMP, MPP, CC
-NUMA ­ 대칭적 다중프로세서(Symmetric Multiprocessor : SMP) ­ 대규모 병렬프로세서(Massively Parallel Processor : MPP) ­ 캐시
-일관성 NUMA(Cache
-Coherent NUMA : CC
-NUMA) 시스템 ­ 분산 시스템(Distributed System) : cluster vs. grid ­ 클러스터 컴퓨터(Cluster Computer), Grid Computer ▶ SMP ­ 64개 이하의 프로세서들을 가지는 중대형급 시스템 ­ 완전
- 공유 구조(shared
- everything architecture) : 프로세서들이 시스템 내의 모든 자 원들을 공유 ­ 시스템 내에 하나의 OS만 존재 ㆍ 대칭적(symmetric) ­ 모든 프로세서들이 필요 시 직접 OS 코드 수행 ­ 모든 프로세서들이 자원들을 동등한 권한으로 사용

1) SMP의 특징 ­ 능력이 비슷한 프로세서들로 구성 ­ 프로세서들이 기억장치와 I/O 장치들을 공유하며, 상호연결망에 의해 접속 ­ 모든 프로세서들은 동등한 권한을 가지며, 같은 수준의 기능들을 수행 ­ 프로세서간 통신은 공유 기억장치를 이용 ­ 작업 스케줄링(Job scheduling)이 하나의 OS에 의해 통합적으로 이루어짐 ­ 공유 자원의 경합(Contention)으로 인하여 시스템 크기에 한계 ▶ SMP : 경합(Contention), 공유 기억장치(Shared Memory)
1) 공유­기억장치 다중프로세서시스템(SMP)의 기본 구성도 시스템 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ MPP ­ 무공유 구조(shared
-nothing)를 기반으로 하는 대규모 병렬처리시스템 ­ 수백 혹은 수천 개의 프로세싱 노드(processing node) 들로 구성 ­ 간단한 구조의 노드 프로세서 사용 ­ 마이크로
-커널(micro
-kernel) 수준의 노드 OS 탑재 : 최소한의 운영체제 기능만을 제공 ­ 노드들 간의 통신은 메시지 전송 방식 이용 ­ 복잡도 높은 상호연결망 이용  334   ▶ CC
-NUMA ­ 독립적인 노드들(UMA 혹은 NUMA 시스템)이 상호연결망에 의해 접속 ­ 모든 노드들이 캐시 및 주기억장치들 사이에서데이터 일관성 유지 ­ 시스템 내의 모든 기억장치들이 전역 주소 공간(global address space)을 가지는 분산 공 유­기억장치시스템(distributed shared
-memory system)으로 구성 ⋅ 주요 장점 ­ S/W 변경 없이 SMP보다 더 큰 시스템 구축 가능 ▶ CC–NUMA 시스템의 일반적인 구성도 : 디렉토리(캐시일관성) 상호연결망  : 프로세서  : 캐시  : 디렉토리  : 주기억장치 모듈  : 네트워크 인터페이스 ※컴퓨터구조론, 생능출판사, 2019 ▶ 분산 시스템 : distributed system = cluster or grid ­ 독립적인 노드(컴퓨터시스템)들이 전통적인 네트워크에 의해 접속 : 부하 분산(load balancing) ­ 노드들 간의 정보 교환 혹은 병렬처리를 수행할 때만 네트워크를 이용하여 통신 : loosely
- coupled system ㆍ 노드 ­ PC, workstation, SMP, MPP, 혹은 그들의 조합 ▶ 클러스터 컴퓨터 – 시작점(슈퍼컴퓨터는 비싸다) ­ A collection of PCs or workstations : PC들의 모음 ­ 네트워크 : 고속 LAN, 혹은 network switch(L4/L7 switch) ­ 모든 시스템 자원들을 단일 시스템 이미지(SSI : Single System Image)로 통합 : 마치 하 나인 것처럼 ⋅ 주요 장점 ­ 저렴한 비용으로 병렬처리시스템 구축 가능 ­ 결함 대체 용이 → 가용성(availability) 향상, 선형성  335   ▶ 클러스터 컴퓨터

1) 클러스터 컴퓨터의 특징 ­ 시장에서 구할 수 있는 저렴한 상용 제품 여러 대를 조합하여 더 빠르고 안정적인 시스템 을 만들고자 하는 요구가 원천이 되어 다양한 아키텍처와 구성 방법이 발전해왔음 ­ 컴퓨터 클러스터링 접근법은 일반적으로 시장에서 쉽게 가용한 제품들을 고속의 근거리 통 신망으로 연결함 ­ 컴퓨팅 노드들을 "클러스터 미들웨어"라는 소프트웨어 계층에서 관리됨 : 운영체제의 역할 을 대신, 마치 하나처럼 ­ 이 소프트웨어 계층은 노드들의 상층부에 위치하여 사용자들이 단일 시스템 이미지 개념으 로 하나의 커다란 컴퓨팅 단위로 처리할 수 있도록 함(single system image) ▶ 클러스터 컴퓨터 vs. 그리드 컴퓨터(이기종, 별도의 프로토콜)
1) 클러스터 컴퓨터의 특징 ­ 중앙 집중적인 관리 접근법은 노드들을 잘 조화된 공유 서버들로 만들어 줌 ­ 이 방식은 많은 노드들을 사용하는 P2P이나 그리드 컴퓨팅과는 다르며 분산 컴퓨팅의 특성 으로 차이점이 있음 ­ 컴퓨터 클러스터는 간단히 두 개의 개인용 컴퓨터를 연결하는 두 노드 시스템일 수도 있고 수천 대를 연결한 매우 빠른 슈퍼컴퓨터일 수도 있음 ­ 기본적인 클러스터 구성 방법은 전통적인 슈퍼컴퓨터를 비용 면에서 효율적인 제품으로 대 체하기 위해 몇 개의 개인용 컴퓨터들을 이용하여 만든 베오울프(beowulf) 방식임 : 동일 기종, 별도의 프로토콜 필요 없음 ▶ 클러스터 컴퓨터
1) 클러스터 컴퓨터의 특징 ­ 초창기 133개의 노드로 구성된 Stone Supercomputer 프로젝트는 컴퓨터 클러스터 개념 이 실현 가능하다는 것을 증명하였음 ­ 비교적 낮은 비용으로 고성능을 이루기 위해 리눅스와 병렬 가상 머신 툴킷과 메시지 전달 인터페이스 라이브러리를 사용하였음 : 리눅스 많이 사용 ­ 비록 클러스터들은 적은 수의 개인용 컴퓨터들을 단순한 네트워크로 연결되었지만 높은 수 준의 성능을 이룰 수 있었음 : 노드의 수에 완벽하게 비례하지 않음 ­ 현재 해마다 두 번(6,
11) 발표하는 TOP500에 등재된 슈퍼 컴퓨터들 가운데 상당수의 시 스템은 컴퓨터 클러스터들임  336   다중 프로세서 시스템
1. 다중 프로세서 시스템의 종류인 공유기억장치 시스템과 분산기억장치 시스템에 대해서 학습하고 이를 설명할 수 있다. 14주차  수업목표  
2. 다중 프로세서 시스템에서 발생하는 문제점을 해결하기 위한 2교시  캐시 일관성 유지 프로토콜을 이해하고 이를 설명할 수 있다.
1. 공유기억장치 시스템 세부내용 
2. 분산기억장치 시스템
3. 캐시 일관성 유지 프로토콜 1. 공유기억장치 시스템 ▶ 다중프로세서 시스템 구조(multiprocessor system architecture) ㆍ 다중프로세서 시스템 구조 ­ MIMD 조직으로서, 여러 개의 프로세서들이 비동기적으로 프로그램을 실행하는 시스템 (독립적) ㆍ 기억장치 모듈을 사용하는(소유하는) 방식에 따른 분류 ­ 공유
-기억장치 시스템(shared
-memory system) ­ 분산
-기억장치 시스템(distributed
-memory system) ▶ 공유기억장치 시스템 구조 ­ 밀결합 구조로서, 주기억장치가 어느 한 프로세서에 속해 있지 않고 모든 프로세서들에 의 해 공유(tightly
-coupled) ㆍ 상호연결 구조 ­ 버스(Bus) : 경합 ⋅ 공유­버스(shared­bus) ⋅ 다중­버스(multiple­bus) ­ 크로스바 스위치(Crossbar Switch) : 모두 연결 ­ 다단계 상호연결망 : 버스 + 크로스바(Multistage Interconnection Network : MIN) ▶ 공유기억장치 시스템 구조의 장단점 ⋅ 장점 ­ 프로세서들이 공통으로 사용하는 데이터들이 공유 기억장치에 저장되므로 별도의 프로세 서 간 데이터 교환 메커니즘이 필요하지 않음 ­ 프로그램 실행시간 동안에 각 프로세서들이 처리할 작업들을 동적으로 균등하게 할당할 수 있으므로 프로세서 이용률을 극대화할 수 있어서 시스템 효율을 높일 수 있음 ⋅ 단점 ­ 프로세서들과 기억장치들 간의 통로(버스 또는 상호연결망)상에 통신량이 많아지기 때문 에 경합(Contention)으로 인한 지연 시간이 길어질 수 있음  337   ­ 두 개 이상의 프로세서들이 공유 자원(기억장치 모듈 또는 입출력장치)을 동시에 사용하 려는 경우에 한 개 이외의 프로세서들은 대기해야 함 → 프로세서 수가 증가해도 선형적 성능 향상 불가능(고속 상호연결망과 캐시 기억장치의 사용으로 보완) ▶ 공유
-버스 구조 ­ 하드웨어가 매우 간단 ­ 버스 경합(Contention)으로 인한 지연 시간 증가 → 버스의 전송 속도를 높이거나 캐시를 사용하여 성능 저하를 보완  : 프로세서  : 기억장치  : 입출력장치 시스템 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ 다중
-버스 구조 : 버스 제어기, IOP ­ 버스 경합을 줄이기 위하여 버스의 수를 증가 ­ 계층버스 구조(hierarchical bus structure) : 용도가 다른 여러 계층의 버스들을 사용 지역 버스 시스템 버스 지역 버스 지역 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ 크로스바 스위치(crossbar switch) : 스위칭 소자 ­ 프로세서들과 기억장치들 사이의 완전 연결성(full connectivity) ­ 비용이 많이 들고 하드웨어가 복잡 스위칭 소자 ( : 프로세서,  : 기억장치 모듈)   ※컴퓨터구조론, 생능출판사, 2019  338   ▶ 다단계 상호연결망(Multistage Interconnection Network : MIN) ­ 크로스바 스위치와 버스 중간 정도의 하드웨어 복잡성을 가진 상호연결망 ⋅ 예) 오메가 네트워크(Omega network) 입력단 단계 2 단계 1 단계 0 출력단 ※컴퓨터구조론, 생능출판사, 2019 ▶ 오메가 네트워크

1) 입력단과 출력단이 각각 N개인 경우(8개) ­ 필요한 단계(stage)의 수 : s = log N (3개)  ­ 각 단계의 스위칭 소자(switching element)들의 수 : m = N/2 (4개)
2) 스위칭 소자의 접속 방식(connection mode) ㆍ 직진(straight) ­ 같은 위치의 입출력 단자들이 서로 접속 ㆍ 교차(swap) ­ 서로 다른 위치의 입출력 단자들이 접속 ㆍ 하위 방송(lower broadcast) ­ 하단의 입력 단자가 모든 출력단자들로 접속 ㆍ 상위 방송(upper broadcast) ­ 상단의 입력 단자가 모든 출력단자들로 접속 2. 분산기억장치 시스템 ▶ 분산기억장치 시스템 구조 ㆍ 분산기억장치 시스템 구조 ­ 소결합 구조(loosely
- coupled structure) ­ 각 프로세서가 자신의 지역 기억장치(local memory)를 소유 ­ 다른 프로세서들과의 통신은 메시지 전송(message
- passing) 이용 ⋅ 장점 ­ 공유자원에 대한 경합(Contention) 감소 ⋅ 단점 ­ 통신 프로토콜에 의한 지연 시간 증가 ㆍ 네트워크 지름(network diameter) ­ 네트워크 내에서 가장 멀리 떨어져 있는 노드들 간의 거리(즉, 링크의 수)  339   ▶ 선형 배열(linear array) 구조 ­ 네트워크 지름이 N
-1로서, 다른 구조들에 비하여 가장 김 ­ 버스 구조 보다 동시성이 더 높음 : (1,

2) (3,
4) … ­ 통신 시간이 노드들 간의 거리에 따라 서로 다르며, 노드의 수가 많아지면(N이 커지면) 통 신 시간이 매우 길어짐 ※컴퓨터구조론, 생능출판사, 2019 ▶ 링(ring) 구조 ㆍ 네트워크 지름 ­ 각 링크가 양방향성(bi ­ directional)이면⌊N / 2⌋ ­ 단방향성(uni
- directional)이면 N ­ 1 ㆍ 변형 구조 : 코달 원형(chordal ring) ­ 링크의 수가 증가될수록 네트워크 지름은 감소 ­ d(degree) : 각 노드가 가지는 링크의 수 ▶ 링 구조와 코달 원형 구조 : 링크의 수 증가 (a) 링 구조(d =

2) (b) 코달 링(d =
3) (c) 코달 링(d =
4) ※컴퓨터구조론, 생능출판사, 2019 ▶ 트리(tree) 구조 ­ 층(level)의 수를 k라고 할 때 N = (k
-

1)개의 노드들 접속 ­ 네트워크 지름 = 2(k
-

1), k가 4라면? ­ 시스템 요소들의 수가 증가함에 따라 성능이 선형적으로 향상 ※컴퓨터구조론, 생능출판사, 2019  340   ▶ 팻 트리(fat tree) 구조 : CM
-5(커넥션 머신, MIT, 폰노이만 대안) ­ 상위 층으로 올라갈수록 노드 간의 통신 채널 수 증가 ­ 트리 구조에서 상위 층으로 올라갈수록 통신량이 많아져서 채널이 병목(Bottleneck)이 되 는 문제점을 해결 ­ Thinking Machine 사의 CM
- 5시스템에서 실제 사용 ※컴퓨터구조론, 생능출판사, 2019 ▶ 메시 구조(mesh network) ­ Illiac IV(최초의 대규모 병렬 컴퓨터), MPP(대규모 병렬 컴퓨터), DAP(분산 배열 프로세 서), CM ­ 2(MIT, 폰노이만 대안) 및 Intel Paragon(대규모 병렬 컴퓨터)에서 사용 ※컴퓨터구조론, 생능출판사, 2019 ▶ 토러스 네트워크(torus network) ­ 원형 구조와 메쉬 구조가 혼합된 구조로 확장이 용이 ­ N × N 토러스의 경우에 네트워크 지름은 2⌊N / 2⌋, N = 4? ※컴퓨터구조론, 생능출판사, 2019  341   ▶ 하이퍼큐브 네트워크(hypercube network) : 1bit만 차이 남 ㆍ 상호연결 함수(interconnection function) ­ Cb b b b b b b b b′ b i m m⋯ i i i⋯   m i ⋯  ⋯ 단, mlog N, N : 전체 노드 수, 0 ≤ i ≤ m        ′             ′            ′         ※컴퓨터구조론, 생능출판사, 2019 ▶ 하이퍼큐브에서의 자동 경로설정(self
-routing) 방법

1) E­큐브 라우팅(E­cube routing)
① 두 노드의 번호를 나타내는 2진수 비트들 간에 exclusive
-OR 연산을 수행하여 방향 단어 (direction word)를 구함
② 방향 단어의 LSB(맨오른쪽)부터 검사하여, 비트값이 1이면 x 방향으로 이동(move)하고, 0 이면 이동하지 않음
③ MSB까지의 모든 비트들에 대하여
②번을 차례대로 반복하면서, 대응되는 차원의 방향으 로 이동할지를 결정 ⋅ 예) 6번 노드 → 13번 노드로 패킷 전송 ㆍ 방향 단어 : 0110 XOR 1101 = 1011 ­ b = 1 ⇒ x 방향으로 이동  ­ b = 1 ⇒ y 방향으로 이동  ­ b = 0 ⇒ z 방향으로의 이동은 없음  ­ b = 1 ⇒ 4차원 방향으로 이동  ※컴퓨터구조론, 생능출판사, 2019  342   3. 캐시 일관성 유지 프로토콜 ▶ 캐시 일관성 유지 프로토콜

1) 필요성 ­ 단일
-버스 공유
-기억장치 다중프로세서시스템에서는 버스 경합(Contention)을 줄이기 위하 여 각 프로세서가 캐시를 보유 ­ 데이터 처리과정에서 주기억장치에 저장된 공유 데이터(shared data)가 여러 캐시에 적재 되는 상태 발생 ­ 각 프로세서가 공유 데이터를 변경하는 경우에 주기억장치와 각 캐시에 적재된 해당 데이 터가 서로 다른 값을 가지는 상황 발생 ⇨ 캐시 일관성 유지 프로토콜(cache coherence protocol) 필요 ­ 디렉터리 기반 일관성 구조는 캐시 블록의 공유 상태, 노드 등을 기록하는 저장 공간인 디 렉터리를 이용하여 관리하는 구조 ­ 스누핑(snooping)은 주소 버스를 항상 감시하여 캐시 상의 메모리에 대한 접근이 있는지를 감시하는 구조 ­ 다른 캐시에서 쓰기가 발생하면 캐시 컨트롤러에 의해서 자신의 캐시 위에 있는 복사본을 무효화 시킴

2) 디렉터리와 스누핑 ­ 디렉터리와 스누핑은 연구가 활발히 되고 있으며 또한 장단점이 이미 잘 알려져 있음 ­ 스누핑의 경우 각 노드의 대역폭이 충분히 크다면 좋은 성능을 기대할 수 있음 ­ 그러나 성능 확장성(Scalability)이 좋지 않음 ­ 왜냐하면 메모리 요청(Request)에 대해 다른 모든 노드에 브로드캐스트 해야 하기 때문이 며 노드의 수가 증가하면 더 많은 브로드캐스트가 발생하게 되고 이 때문에 버스의 대역폭 도 더 늘어나야만 함 ­ 이에 반해 디렉터리 기반 구조는 어떤 노드에서 해당 캐시 블록의 복사본을 가지고 있는지 를 알고 있기 때문에 특정 노드에만 요청을 하게 됨 ­ 따라서 브로드캐스트가 불필요하게 되어 대역폭이 상대적으로 작아도 됨 ­ 이 때문에 64개 이상의 프로세서를 가지는 대규모 시스템에서는 디렉터리 기반의 캐시 일 관성 프로토콜을 사용하는 경우가 많음 ▶ 캐시 쓰기 정책에 따른 데이터 불일치 문제 : 즉시 쓰기 ㆍ Write
- through 정책 사용시 ­ P1과 P2가 공유 데이터 X를 캐시에 적재하고 있는 상태에서 P1이 그 데이터와 주기억 장치를 X’으로 변경한 경우 프로세서 캐시 시스템 버스 ※컴퓨터구조론, 생능출판사, 2019 주기억장치  343   ▶ 캐시 쓰기 정책에 따른 데이터 불일치 문제 : 나중 쓰기 ㆍ Write
- back 정책 사용시 ­ P1과 P2가 공유 데이터 X를 캐시에 적재하고 있는 상태에서 P1이 그 데이터를 X’으로 변경한 경우(나중 쓰기) 프로세서 캐시 시스템 버스 주기억장치 ※컴퓨터구조론, 생능출판사, 2019 ▶ 캐시 쓰기 정책에 따른 데이터 불일치 문제

1) 버스 감시(bus snooping)을 이용하는 방법 ­ 프로세서가 어떤 캐시 라인을 수정하는 경우에 그 사실을 방송(broadcasting) 하는 동작과 버스 상의 상황을 감시(snooping)하는 하드웨어를 구현 ⇨ 스누프 제어기(snoop controller) 설치 ▶ 캐시 쓰기 정책에 따른 데이터 불일치 문제 : broadcasting, snooping
1) 버스 감시(bus snooping)을 이용하는 방법 프로세서 모듈 내부 버스 시스템 버스 ※컴퓨터구조론, 생능출판사, 2019 ▶ Write
-through 일관성 유지 프로토콜 : 즉시 쓰기 ­ 프로세서가 캐시의 데이터를 수정할 때, 동시에 주기억장치에도 갱신 ㆍ 스누프 제어기의 동작 ­ 주기억장치에 대한 쓰기 동작의 주소가 자신의 캐시에 있는지 검사 ­ 만약 존재한다면, 그 블록을 무효화(invalidate)시킴 → 프로세서가 무효화된 블록을 액 세스하는 경우에는 캐시 미스로 처리 ㆍ 캐시 데이터의 상태  344   ­ 유효(V : Valid) 상태 : 캐시의 내용 ＝ 주기억장치의 내용 ­ 무효(I : Invalid) 상태 : 캐시의 내용 ≠ 주기억장치의 내용 (a) 두 캐시들이 모두 유효한 를 (b) P  이 를 로 변경하였고, 그에 따라 지니고 있는 상태 주기억장치도 갱신되었으며, P 의 캐시에 있  는 는 무효(I) 상태가 됨 (c) P 가 를 엑세스하면 캐시 미스가 발생하여 주기억장치로부터  ′가 읽혀오고, 데이터의 상태는 유효(V)로 변경됨 ※컴퓨터구조론, 생능출판사, 2019 ▶ Write
-back 일관성 유지와 MESI 프로토콜 : 나중 쓰기 ­ 프로세서가 캐시의 데이터를 변경해도 주기억장치의 내용은 갱신되지 않음 ⇨ 다른 스누피 제어기들이 시스템 버스를 감시해도 변경 사실을 알 수 없음 ⋅ 해결책 ­ 변경된 캐시의 스누피 제어기가 변경 사실을 다른 스누피 제어기들에게 통보 : broadcasting ㆍ 무효화 신호(invalidate signal) ­ 데이터의 변경 사실을 알려주기 위한 신호 ㆍ 무효화 사이클(invalidate cycle) ­ 무효화 신호가 전송되는 버스 사이클 ­ MESI 프로토콜은 캐시 메모리의 일관성을 유지하기 위해서 별도의 플래그(flag)를 할당한 후 플래그의 상태를 통해 데이터의 유효성 여부를 판단하는 프로토콜임 ­ 멀티프로세서 시스템에서 캐시 메모리의 일관성을 유지하기 위해 메모리가 가질 수 있는 4 가지 상태를 정의

1) MESI 프로토콜에서 캐시 데이터의 상태 ㆍ 수정(M : Modified) 상태 ­ 데이터가 수정(변경)된 상태 ㆍ 배타(E : Exclusive) 상태  345   ­ 유일한 복사본이고, 주기억장치의 내용과 동일한 상태 ㆍ 공유(S : Shared) 상태 ­ 데이터가 두 개 이상의 프로세서 캐시에 적재되어 있는 상태 ㆍ 무효(I : Invalid) 상태 ­ 데이터가 다른 프로세서에 의해 수정되어 무효가 된 상태 ▶ Write
-back 일관성 유지와 MESI 프로토콜

1) MESI 프로토콜의 상태 전이도(E
-배타, I
-무효, S
-공유, M
-수정) ※컴퓨터구조론, 생능출판사, 2019 ㆍ 실선 : 프로세서의 동작에 의한 상태 전이 ㆍ 점선 : 다른 캐시에서의 변화에 의한 상태 전이  346   GPU

1. GPU에서 사용하는 CUDA 모델에 대해서 학습하고 이를 14주차  수업목표   설명할 수 있다. 3교시 
2. GPU의 내부 구조에 대해서 학습하고 이를 설명할 수 있다.
1. CUDA 모델 세부내용 
2. 내부 구조 1. CUDA 모델 ▶ 그래픽처리유니트(GPU) : 엔비디아 ㆍ NVIDIA사의 GPU ­ 1999년에 최초 개발된 실시간 그래픽처리용 보조프로세서
1) 다양한 데이터 병렬 응용을 위한 범용 GPU로 발전된 계기 ㆍ 통합된 그래픽 및 계산 구조(unified graphic and compute architecture) ­ 그래픽 응용뿐 아니라 일반적인 계산에도 적합한 통합적인 하드웨어 구조 ㆍ CUDA(Compute Unified Device Architecture) 프로그래밍 모델 ­ 일반적인 프로그래밍 언어들을 이용하여 GPU를 위한 프로그램을 쉽게 작성할 수 있게 해주는 프로그래머
-친화적 병렬컴퓨팅 플랫폼(programmer
-friendly parallel computing platform)으로서, NVIDIA사에 의해 개발된 프로그래밍 모델 ▶ CUDA 프로그램을 처리하는 컴퓨팅시스템 모델

1) 구성 요소들 ㆍ 호스트(host) ­ 일반적 CPU, PC 혹은 SMP(다중 프로세서 시스템)로서 순차적 프로그램 처리 ㆍ 디바이스(device) ­ GPU와 같은 병렬프로세서(SIMD) ㆍ GPU의 내부 구성(그림 8
-31) ­ 다수의 스트리밍 다중프로세서들(streaming multiprocessor: SM) : 동영상 처리를 위 해 H/W, S/W의 병렬 수행을 간소화 ­ 각 SM 내에는 실제 프로그램 코드를 수행하는 다수의 스트리밍 프로세서들(streaming processor) v 그림 8
-31 : 간략화된 GPU 구성도 ­ 5 SMs : streaming multiprocessor ­ 16 SPs/SM : streaming processor v G80(초기의 NVIDIA GPU 제품) ­ 16 SMs : 동영상 처리를 위해 H/W, S/W의 병렬 수행을 간소화 ­ 128 SPs/SM v 최근 고성능 GPU  347   ­ 수천 혹은 수만 개의 SP들 포함 ▶ CUDA 프로그램을 처리하는 컴퓨팅시스템 모델 : 호스트, GPU, SM

1) 전형적인 GPU의 간략화된 내부 구성도 [그림 8
-31] ※컴퓨터구조론, 생능출판사, 2019 ▶ CUDA 프로그래밍 모델

1) CUDA 프로그램 ­ 호스트 코드(host code)와 디바이스 코드(device code)로 구성 ㆍ 호스트 코드 ­ ANSI C 기반의 순차적 프로그램 ㆍ 디바이스 코드 ­ ANSI C 코드와 커널 함수(kernel function) 로 구성 ㆍ 커널 함수 ­ 병렬 함수 및 데이터 구조를 명시하는 키워드들을 확장한 형태로 작성된 코드로서, 디바 이스가 실행하는 부분(병렬처리 가능 부분) ㆍ 스레드(thread) ­ 커널 함수의 한 인스턴스(instance)로서, GPU의 SP(CUDA 코어)에 의해 실행 ▶ CUDA 프로그래밍 실행 모델 : 그리드(병렬 수행 스레드 전체)
1) CUDA 프로그램 실행 모델(nBlk : 블록 수, nTid : 스레드 수) 순차적 코드(호스트) block 그리드 0 병렬 커널(디바이스) KernelA <<< nBIk. nTid
>>> (args); 순차적 코드(호스트) 그리드 1 병렬 커널(디바이스) KernelA <<< nBIk. nTid
>>> (args); ※컴퓨터구조론, 생능출판사, 2019  348   ▶ CUDA 프로그래밍 실행 모델 ㆍ 그리드(grid) ­ 하나의 병렬 커널에 의해 생성되는 스레드 전체 ㆍ 블록(block) ­ 그리드 내의 스레드들을 적절한 수의 스레드들로 분할한 단위 → 하나의 스트리밍 프로 세서(SM)에게 할당 ㆍ 커널 코드 선언 지정자 : __global__ ­ 커널에 의해 생성될 블록의 수(nBlk)와 스레드의 수(nTid)는 실행 구문인 <<< …
>>> 내부에서 지정 ◼ 예제 8
-1 ­ 크기가 N인 두 개의 벡터 A와 B를 더하고, 그 결과를 벡터 C에 저장하는 CUDA 프로 그램을 작성하라. ※컴퓨터구조론, 생능출판사, 2019 ㆍ CUDA 프로그래밍 실행 모델 : 커널 코드 지정(__global__) ⋅ 풀이 // Kernel definition __global__ void VecAdd(float* A, float* B, float* C) { int i = threadldx.x; // thread id C[i] = A[i] + B[i]; } int main() { … // Kernel invocation with N threads (1 block) VecAdd <<< 1, N
>>> (A, B, C); // VecAdd 호출 … } ※컴퓨터구조론, 생능출판사, 2019 ㆍ [예제 8
-1] 프로그램이 실행되면, ­ N개의 스레드들이 생성되어 각 CUDA 코어(SP)에서 실행 ­ 각자의 인덱스(ID)에 따라 서로 다른 데이터에 대하여 함수 VecAdd( )가 수행되는데 즉, N개의 스레드들(C[1]=A[1]+B[1], C[2]=A[2]+B[2], … )이 각 코어에 의해 병렬로 처리됨 ㆍ 스레드 ID ­ 커널 함수 내의 내장 변수(built
- in variable)인 threadIdx로 액세스 되며, 자신에 할 당되는 스레드 및 데이터 기억장치 주소를 계산에 사용한다.  349   ▶ 그리드, 블록 및 스레드 간의 관계 : grid > block > thread ※컴퓨터구조론, 생능출판사, 2019 ▶ CUDA 프로그램 실행 과정 : 호스트(CPU), 디바이스(GPU)
① 호스트가 순차적 코드를 실행함
② 커널 함수가 호출되면, 병렬 커널 코드가 디바이스로 보내짐
③ 디바이스에서 커널이 그리드(다수의 블록 및 스레드들 포함)를 생성하여 SM들에게 할당하 며, SM 내의 SP들이 한 스레드씩을 담당하여 실행함
④ 모든 스레드들의 실행이 완료되면 그리드가 종료되고, 결과값들이 호스트로 전송됨
⑤ 호스트는 다음 순차적 코드를 실행하며, 또다른 커널을 만난다면
②~
④번 과정을 반복함 ▶ GPU 기억장치 계층 ㆍ 지역 기억장치(local memory) ­ 각 스레드가 사용하며, 주로 레지스터 세트로 구현 ㆍ 공유 기억장치(shared memory) ­ 같은 블록에 포함된 스레드들이 공동으로 사용 ㆍ 전역 기억장치(global memory) ­ 모든 응용 프로그램들이 생성한 그리드들이 공유하는 기억장치로서, 호스트와 GPU간의 데이터 교환에도 사용됨 ▶ GPU 기억장치 계층 : 스레드(지역), 블록간(공유), 그리드간(전역) 스레드 스레드 블록 그리드 0 ※컴퓨터구조론, 생능출판사, 2019 그리드 1  350   ▶ CUDA 실행을 위한 기억장치 구조 : 지역, 공유, 전역 ※컴퓨터구조론, 생능출판사, 2019 ▶ 호스트
-디바이스 간 정보 전송을 위한 함수들 : CPU
-GPU ­ 기억 장소 할당 : cudaMalloc((void**)&Md, size); ­ 데이터 전송(호스트 → 디바이스) : cudaMemcpy(Md, M, size, cudaMemcpyHostToDevice); ­ 데이터 전송(디바이스 → 호스트) : cudaMemcpy(Md, M, size, cudaMemcpyDeviceToHost); ­ 기억 장소 해제 : cudaex)ree(Md); 2. 내부 구조 ▶ GPU의 내부 구조 ㆍ 최초 GPU ­ NVIDIA Geex)orce 8800 GTX ㆍ 그 이후 제품들 ­ Telsa, ex)ermi, Kepler, Maxwell 등 ㆍ 구조분석 사례 : ex)ermi 구조 ­ 16 SMs ­ 32 CUDA 코어(SP)/SM ­ 전체 CUDA 코어 수(SP) = (16 SM) x (32 코어) = 512개

1) NVIDIA ex)ermi GPU의 전체적인 구조(DRAM, I/ex), L2, Thread) ※컴퓨터구조론, 생능출판사, 2019  351   ▶ ex)ermi GPU의 각 SM 내부 구성요소들 ­ GPU 프로세서 코어들(32개의 CUDA 코어들) : SP ­ 2개씩의 왑 스케줄러(warp scheduler) 및 디스패치 포트(dispatch port) : 왑 단위의 스 레드 할당(block?) ­ 16개의 적재 / 저장 유니트(load / store unit) : 캐시 및 DRAM 액세스 ­ 4개의 Sex)U(special function unit) : 초월 함수 계산(유한한 대수 함수와 대조) ­ 32K개의 32
- 비트 레지스터들 ­ 공유 기억장치 및 L1 캐시(전체 64KB) ㆍ 왑(warp) ­ SM이 한 번에 수행할 수 있는 32개의 스레드 묶음 ▶ 단일 SM의 내부 구조 : 왑 스케줄러, 디스패치 유니트, Sex)U, ex)PU ※컴퓨터구조론, 생능출판사, 2019 ▶ NVIDIA GPU들 간의 특징 비교 GPU G80 ex)ermi Kepler 트랜지스터 6.81억개 30억개 71억개 CUDA 코어 128개 512개 2,880개 Sex)U 2 4 32 왑 스케줄러(SM당) 1 2 4 공유 기억장치(SM당) 16KByte 48KByte(조정가능) 96KByte(조정가능) L1 캐시(SM당) 없음 16KByte(조정가능) 32KByte(조정가능) L2 캐시 없음 768KByte 1,536KByte ECC 없음 있음 있음 ※컴퓨터구조론, 생능출판사, 2019  352   ▶
① 데이터를 처음 읽는 경우 ­ P 이 주기억장치로부터 X를 처음 인출 : 읽기 미스(read miss)  ⇨ 주기억장치로부터 X를 읽어온 후, 상태를 ‘배타(E)’로 세트 ※컴퓨터구조론, 생능출판사, 2019 ▶
② 캐시에 적재된 데이터의 변경 ­ P 이 X를 새로운 값(X´)으로 변경 : 쓰기 적중(write hit)  ⇨ X´로 수정한 후, 상태를 ‘수정(M)’으로 세트 ※컴퓨터구조론, 생능출판사, 2019 ▶
③ 데이터가 공유되는 경우 ­ P1이 X를 가진 상태에서, P2도 X를 읽는 경우 ⇨ 읽기 미스(read miss) → 주기억장치로부터 읽음 → P1의 스누피 제어기가 그 버스 동 작을 확인하고, X의 상태를 ‘S’로 변경하며, P2로 공유 사실을 알림 → P2가 X의 상태 를 ‘공유(S)’로 세트 ※컴퓨터구조론, 생능출판사, 2019 ▶
④ 데이터가 공유되는 경우 ­ 앞의 결과와 같이 두 프로세서들이 X를 가진 상태에서 다른 프로세서(P3)가 X를 읽는다면, 같은 동작이 발생하며 데이터 상태는 ‘공유(S)’로 세트  353   ▶
⑤ 데이터가 공유되는 경우 ­
②의 결과 상태(수정)에서, 만약 P2가 X를 액세스 한다면, 캐시 미스 발생 → 주기억장치 읽기 동작 ⋅ P1의 스누피 제어기가 그 동작을 중단시키고, 자신의 데이터(X’)를 P2로 전송(캐시간 전송(cache
-to
-cache transfer))하며, X’를 주기억장치에도 갱신 ⋅ 캐시 데이터의 상태는 모두 ‘공유(S)’로 세트 ※컴퓨터구조론, 생능출판사, 2019

1) 캐시간 전송이 지원되지 않는 시스템의 경우 ­ P1의 스누프 제어기가 P2의 읽기 동작을 중단시키고, P2에게 ‘재시도(retry)’를 요구한 후, ⋅ P1이 X’를 주기억장치에 갱신하면, ⋅ P2가 읽기를 재시도하여 X’를 읽어감 ▶
⑥ 공유 상태의 데이터가 변경되는 경우 ­
③의 결과 상태(공유)에서, P2가 X를 새로운 값으로 갱신하는 경우 ⋅ P2가 버스를 통하여 무효화 신호(invalidate signal)를 방송 ⋅ X를 가진 캐쉬들은 X의 상태를 ‘무효(I)’로 변경하고, 확인 신호 전송 → P2가 배타적 소유권 획득 ⋅ P2가 X를 새로운 값(X’)으로 갱신하고, 상태를 ‘수정(M)’으로 변경 무효화 신호 ※컴퓨터구조론, 생능출판사, 2019 ▶
⑦ ‘M’ 상태의 데이터를 다시 변경하는 경우 ­
⑥의 결과 상태(변경)에서, P2가 X´을 다시 X˝로 변경하면 쓰기 적중(write hit) → 데이터 만 변경되고, 상태는 불변  354   ※컴퓨터구조론, 생능출판사, 2019 ▶
⑧ I 상태의 데이터를 변경하는 경우 ­
⑦의 결과 상태(재변경)에서, P 이 X를 수정하기 위하여 읽으려 한다면, 쓰기 미스(write  miss) 발생 ⋅ 주기억장치 읽기 동작 시작 : 수정을 위한 읽기(read with intention to modify : RWITM) ⋅ P 가 X″를 P1으로 보내주고, 데이터의 상태를 ‘무효(I)’로 변경  ⋅ P 은 X″를 X″′로 수정하고, 상태를 ‘수정(M)’으로 세트  * 캐시간 전송이 지원되지 않는 시스템의 경우 : ‘retry’ 요구(주기억장치 갱신) ▶
⑧ I 상태의 데이터를 변경하는 경우 : 무효화 신호 P P   M X’’’ I X’’ X ※컴퓨터구조론, 생능출판사, 2019 ▶
⑨ 프로세서가 새로운 데이터를 읽어와서 수정하는 경우 ­ P1만 X를 가지고 있는 상태(
①의 결과)에서 P2가 X를 수정하는 경우 : 수정을 위한 읽기 (RWITM) ⋅ 쓰기 미스(write miss)가 발생하면, P2가 RWITM 시작 ⋅ P1이 X를 P2로 보내주고, 상태를 ‘무효(I)’로 변경 ⋅ P2는 X를 X’로 수정하고, 상태를 ‘수정(M)’으로 세트 무효화 신호 ※컴퓨터구조론, 생능출판사, 2019  355 
